function hee(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in e)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(e, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Yu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Uf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ED = { exports: {} }, Hb = {}, CD = { exports: {} }, Un = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jj;
function vee() {
  if (jj)
    return Un;
  jj = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), b = Symbol.iterator;
  function x(V) {
    return V === null || typeof V != "object" ? null : (V = b && V[b] || V["@@iterator"], typeof V == "function" ? V : null);
  }
  var E = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, O = Object.assign, _ = {};
  function P(V, ee, he) {
    this.props = V, this.context = ee, this.refs = _, this.updater = he || E;
  }
  P.prototype.isReactComponent = {}, P.prototype.setState = function(V, ee) {
    if (typeof V != "object" && typeof V != "function" && V != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, V, ee, "setState");
  }, P.prototype.forceUpdate = function(V) {
    this.updater.enqueueForceUpdate(this, V, "forceUpdate");
  };
  function M() {
  }
  M.prototype = P.prototype;
  function D(V, ee, he) {
    this.props = V, this.context = ee, this.refs = _, this.updater = he || E;
  }
  var N = D.prototype = new M();
  N.constructor = D, O(N, P.prototype), N.isPureReactComponent = !0;
  var I = Array.isArray, R = Object.prototype.hasOwnProperty, j = { current: null }, U = { key: !0, ref: !0, __self: !0, __source: !0 };
  function q(V, ee, he) {
    var ue, fe = {}, Ce = null, Se = null;
    if (ee != null)
      for (ue in ee.ref !== void 0 && (Se = ee.ref), ee.key !== void 0 && (Ce = "" + ee.key), ee)
        R.call(ee, ue) && !U.hasOwnProperty(ue) && (fe[ue] = ee[ue]);
    var Te = arguments.length - 2;
    if (Te === 1)
      fe.children = he;
    else if (1 < Te) {
      for (var pe = Array(Te), ye = 0; ye < Te; ye++)
        pe[ye] = arguments[ye + 2];
      fe.children = pe;
    }
    if (V && V.defaultProps)
      for (ue in Te = V.defaultProps, Te)
        fe[ue] === void 0 && (fe[ue] = Te[ue]);
    return { $$typeof: e, type: V, key: Ce, ref: Se, props: fe, _owner: j.current };
  }
  function J(V, ee) {
    return { $$typeof: e, type: V.type, key: ee, ref: V.ref, props: V.props, _owner: V._owner };
  }
  function H(V) {
    return typeof V == "object" && V !== null && V.$$typeof === e;
  }
  function Z(V) {
    var ee = { "=": "=0", ":": "=2" };
    return "$" + V.replace(/[=:]/g, function(he) {
      return ee[he];
    });
  }
  var re = /\/+/g;
  function Y(V, ee) {
    return typeof V == "object" && V !== null && V.key != null ? Z("" + V.key) : ee.toString(36);
  }
  function K(V, ee, he, ue, fe) {
    var Ce = typeof V;
    (Ce === "undefined" || Ce === "boolean") && (V = null);
    var Se = !1;
    if (V === null)
      Se = !0;
    else
      switch (Ce) {
        case "string":
        case "number":
          Se = !0;
          break;
        case "object":
          switch (V.$$typeof) {
            case e:
            case t:
              Se = !0;
          }
      }
    if (Se)
      return Se = V, fe = fe(Se), V = ue === "" ? "." + Y(Se, 0) : ue, I(fe) ? (he = "", V != null && (he = V.replace(re, "$&/") + "/"), K(fe, ee, he, "", function(ye) {
        return ye;
      })) : fe != null && (H(fe) && (fe = J(fe, he + (!fe.key || Se && Se.key === fe.key ? "" : ("" + fe.key).replace(re, "$&/") + "/") + V)), ee.push(fe)), 1;
    if (Se = 0, ue = ue === "" ? "." : ue + ":", I(V))
      for (var Te = 0; Te < V.length; Te++) {
        Ce = V[Te];
        var pe = ue + Y(Ce, Te);
        Se += K(Ce, ee, he, pe, fe);
      }
    else if (pe = x(V), typeof pe == "function")
      for (V = pe.call(V), Te = 0; !(Ce = V.next()).done; )
        Ce = Ce.value, pe = ue + Y(Ce, Te++), Se += K(Ce, ee, he, pe, fe);
    else if (Ce === "object")
      throw ee = String(V), Error("Objects are not valid as a React child (found: " + (ee === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : ee) + "). If you meant to render a collection of children, use an array instead.");
    return Se;
  }
  function Q(V, ee, he) {
    if (V == null)
      return V;
    var ue = [], fe = 0;
    return K(V, ue, "", "", function(Ce) {
      return ee.call(he, Ce, fe++);
    }), ue;
  }
  function te(V) {
    if (V._status === -1) {
      var ee = V._result;
      ee = ee(), ee.then(function(he) {
        (V._status === 0 || V._status === -1) && (V._status = 1, V._result = he);
      }, function(he) {
        (V._status === 0 || V._status === -1) && (V._status = 2, V._result = he);
      }), V._status === -1 && (V._status = 0, V._result = ee);
    }
    if (V._status === 1)
      return V._result.default;
    throw V._result;
  }
  var ne = { current: null }, ae = { transition: null }, se = { ReactCurrentDispatcher: ne, ReactCurrentBatchConfig: ae, ReactCurrentOwner: j };
  return Un.Children = { map: Q, forEach: function(V, ee, he) {
    Q(V, function() {
      ee.apply(this, arguments);
    }, he);
  }, count: function(V) {
    var ee = 0;
    return Q(V, function() {
      ee++;
    }), ee;
  }, toArray: function(V) {
    return Q(V, function(ee) {
      return ee;
    }) || [];
  }, only: function(V) {
    if (!H(V))
      throw Error("React.Children.only expected to receive a single React element child.");
    return V;
  } }, Un.Component = P, Un.Fragment = n, Un.Profiler = a, Un.PureComponent = D, Un.StrictMode = r, Un.Suspense = m, Un.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = se, Un.cloneElement = function(V, ee, he) {
    if (V == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + V + ".");
    var ue = O({}, V.props), fe = V.key, Ce = V.ref, Se = V._owner;
    if (ee != null) {
      if (ee.ref !== void 0 && (Ce = ee.ref, Se = j.current), ee.key !== void 0 && (fe = "" + ee.key), V.type && V.type.defaultProps)
        var Te = V.type.defaultProps;
      for (pe in ee)
        R.call(ee, pe) && !U.hasOwnProperty(pe) && (ue[pe] = ee[pe] === void 0 && Te !== void 0 ? Te[pe] : ee[pe]);
    }
    var pe = arguments.length - 2;
    if (pe === 1)
      ue.children = he;
    else if (1 < pe) {
      Te = Array(pe);
      for (var ye = 0; ye < pe; ye++)
        Te[ye] = arguments[ye + 2];
      ue.children = Te;
    }
    return { $$typeof: e, type: V.type, key: fe, ref: Ce, props: ue, _owner: Se };
  }, Un.createContext = function(V) {
    return V = { $$typeof: l, _currentValue: V, _currentValue2: V, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, V.Provider = { $$typeof: s, _context: V }, V.Consumer = V;
  }, Un.createElement = q, Un.createFactory = function(V) {
    var ee = q.bind(null, V);
    return ee.type = V, ee;
  }, Un.createRef = function() {
    return { current: null };
  }, Un.forwardRef = function(V) {
    return { $$typeof: p, render: V };
  }, Un.isValidElement = H, Un.lazy = function(V) {
    return { $$typeof: g, _payload: { _status: -1, _result: V }, _init: te };
  }, Un.memo = function(V, ee) {
    return { $$typeof: h, type: V, compare: ee === void 0 ? null : ee };
  }, Un.startTransition = function(V) {
    var ee = ae.transition;
    ae.transition = {};
    try {
      V();
    } finally {
      ae.transition = ee;
    }
  }, Un.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Un.useCallback = function(V, ee) {
    return ne.current.useCallback(V, ee);
  }, Un.useContext = function(V) {
    return ne.current.useContext(V);
  }, Un.useDebugValue = function() {
  }, Un.useDeferredValue = function(V) {
    return ne.current.useDeferredValue(V);
  }, Un.useEffect = function(V, ee) {
    return ne.current.useEffect(V, ee);
  }, Un.useId = function() {
    return ne.current.useId();
  }, Un.useImperativeHandle = function(V, ee, he) {
    return ne.current.useImperativeHandle(V, ee, he);
  }, Un.useInsertionEffect = function(V, ee) {
    return ne.current.useInsertionEffect(V, ee);
  }, Un.useLayoutEffect = function(V, ee) {
    return ne.current.useLayoutEffect(V, ee);
  }, Un.useMemo = function(V, ee) {
    return ne.current.useMemo(V, ee);
  }, Un.useReducer = function(V, ee, he) {
    return ne.current.useReducer(V, ee, he);
  }, Un.useRef = function(V) {
    return ne.current.useRef(V);
  }, Un.useState = function(V) {
    return ne.current.useState(V);
  }, Un.useSyncExternalStore = function(V, ee, he) {
    return ne.current.useSyncExternalStore(V, ee, he);
  }, Un.useTransition = function() {
    return ne.current.useTransition();
  }, Un.version = "18.2.0", Un;
}
var y0 = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
y0.exports;
var Lj;
function yee() {
  return Lj || (Lj = 1, function(e, t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.2.0", r = Symbol.for("react.element"), a = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), h = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), x = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), O = Symbol.for("react.lazy"), _ = Symbol.for("react.offscreen"), P = Symbol.iterator, M = "@@iterator";
      function D(G) {
        if (G === null || typeof G != "object")
          return null;
        var xe = P && G[P] || G[M];
        return typeof xe == "function" ? xe : null;
      }
      var N = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, I = {
        transition: null
      }, R = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, j = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, U = {}, q = null;
      function J(G) {
        q = G;
      }
      U.setExtraStackFrame = function(G) {
        q = G;
      }, U.getCurrentStack = null, U.getStackAddendum = function() {
        var G = "";
        q && (G += q);
        var xe = U.getCurrentStack;
        return xe && (G += xe() || ""), G;
      };
      var H = !1, Z = !1, re = !1, Y = !1, K = !1, Q = {
        ReactCurrentDispatcher: N,
        ReactCurrentBatchConfig: I,
        ReactCurrentOwner: j
      };
      Q.ReactDebugCurrentFrame = U, Q.ReactCurrentActQueue = R;
      function te(G) {
        {
          for (var xe = arguments.length, He = new Array(xe > 1 ? xe - 1 : 0), Xe = 1; Xe < xe; Xe++)
            He[Xe - 1] = arguments[Xe];
          ae("warn", G, He);
        }
      }
      function ne(G) {
        {
          for (var xe = arguments.length, He = new Array(xe > 1 ? xe - 1 : 0), Xe = 1; Xe < xe; Xe++)
            He[Xe - 1] = arguments[Xe];
          ae("error", G, He);
        }
      }
      function ae(G, xe, He) {
        {
          var Xe = Q.ReactDebugCurrentFrame, yt = Xe.getStackAddendum();
          yt !== "" && (xe += "%s", He = He.concat([yt]));
          var sn = He.map(function(Ot) {
            return String(Ot);
          });
          sn.unshift("Warning: " + xe), Function.prototype.apply.call(console[G], console, sn);
        }
      }
      var se = {};
      function V(G, xe) {
        {
          var He = G.constructor, Xe = He && (He.displayName || He.name) || "ReactClass", yt = Xe + "." + xe;
          if (se[yt])
            return;
          ne("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", xe, Xe), se[yt] = !0;
        }
      }
      var ee = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(G) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(G, xe, He) {
          V(G, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(G, xe, He, Xe) {
          V(G, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(G, xe, He, Xe) {
          V(G, "setState");
        }
      }, he = Object.assign, ue = {};
      Object.freeze(ue);
      function fe(G, xe, He) {
        this.props = G, this.context = xe, this.refs = ue, this.updater = He || ee;
      }
      fe.prototype.isReactComponent = {}, fe.prototype.setState = function(G, xe) {
        if (typeof G != "object" && typeof G != "function" && G != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, G, xe, "setState");
      }, fe.prototype.forceUpdate = function(G) {
        this.updater.enqueueForceUpdate(this, G, "forceUpdate");
      };
      {
        var Ce = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Se = function(G, xe) {
          Object.defineProperty(fe.prototype, G, {
            get: function() {
              te("%s(...) is deprecated in plain JavaScript React classes. %s", xe[0], xe[1]);
            }
          });
        };
        for (var Te in Ce)
          Ce.hasOwnProperty(Te) && Se(Te, Ce[Te]);
      }
      function pe() {
      }
      pe.prototype = fe.prototype;
      function ye(G, xe, He) {
        this.props = G, this.context = xe, this.refs = ue, this.updater = He || ee;
      }
      var Oe = ye.prototype = new pe();
      Oe.constructor = ye, he(Oe, fe.prototype), Oe.isPureReactComponent = !0;
      function Fe() {
        var G = {
          current: null
        };
        return Object.seal(G), G;
      }
      var me = Array.isArray;
      function Pe(G) {
        return me(G);
      }
      function Ee(G) {
        {
          var xe = typeof Symbol == "function" && Symbol.toStringTag, He = xe && G[Symbol.toStringTag] || G.constructor.name || "Object";
          return He;
        }
      }
      function Ke(G) {
        try {
          return oe(G), !1;
        } catch {
          return !0;
        }
      }
      function oe(G) {
        return "" + G;
      }
      function de(G) {
        if (Ke(G))
          return ne("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ee(G)), oe(G);
      }
      function we(G, xe, He) {
        var Xe = G.displayName;
        if (Xe)
          return Xe;
        var yt = xe.displayName || xe.name || "";
        return yt !== "" ? He + "(" + yt + ")" : He;
      }
      function Me(G) {
        return G.displayName || "Context";
      }
      function Ae(G) {
        if (G == null)
          return null;
        if (typeof G.tag == "number" && ne("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof G == "function")
          return G.displayName || G.name || null;
        if (typeof G == "string")
          return G;
        switch (G) {
          case s:
            return "Fragment";
          case a:
            return "Portal";
          case p:
            return "Profiler";
          case l:
            return "StrictMode";
          case b:
            return "Suspense";
          case x:
            return "SuspenseList";
        }
        if (typeof G == "object")
          switch (G.$$typeof) {
            case h:
              var xe = G;
              return Me(xe) + ".Consumer";
            case m:
              var He = G;
              return Me(He._context) + ".Provider";
            case g:
              return we(G, G.render, "ForwardRef");
            case E:
              var Xe = G.displayName || null;
              return Xe !== null ? Xe : Ae(G.type) || "Memo";
            case O: {
              var yt = G, sn = yt._payload, Ot = yt._init;
              try {
                return Ae(Ot(sn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var je = Object.prototype.hasOwnProperty, qe = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, ot, et, ct;
      ct = {};
      function Qt(G) {
        if (je.call(G, "ref")) {
          var xe = Object.getOwnPropertyDescriptor(G, "ref").get;
          if (xe && xe.isReactWarning)
            return !1;
        }
        return G.ref !== void 0;
      }
      function Ht(G) {
        if (je.call(G, "key")) {
          var xe = Object.getOwnPropertyDescriptor(G, "key").get;
          if (xe && xe.isReactWarning)
            return !1;
        }
        return G.key !== void 0;
      }
      function kt(G, xe) {
        var He = function() {
          ot || (ot = !0, ne("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", xe));
        };
        He.isReactWarning = !0, Object.defineProperty(G, "key", {
          get: He,
          configurable: !0
        });
      }
      function St(G, xe) {
        var He = function() {
          et || (et = !0, ne("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", xe));
        };
        He.isReactWarning = !0, Object.defineProperty(G, "ref", {
          get: He,
          configurable: !0
        });
      }
      function cn(G) {
        if (typeof G.ref == "string" && j.current && G.__self && j.current.stateNode !== G.__self) {
          var xe = Ae(j.current.type);
          ct[xe] || (ne('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', xe, G.ref), ct[xe] = !0);
        }
      }
      var Ne = function(G, xe, He, Xe, yt, sn, Ot) {
        var on = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: G,
          key: xe,
          ref: He,
          props: Ot,
          // Record the component responsible for creating this element.
          _owner: sn
        };
        return on._store = {}, Object.defineProperty(on._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(on, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Xe
        }), Object.defineProperty(on, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: yt
        }), Object.freeze && (Object.freeze(on.props), Object.freeze(on)), on;
      };
      function Ie(G, xe, He) {
        var Xe, yt = {}, sn = null, Ot = null, on = null, Rn = null;
        if (xe != null) {
          Qt(xe) && (Ot = xe.ref, cn(xe)), Ht(xe) && (de(xe.key), sn = "" + xe.key), on = xe.__self === void 0 ? null : xe.__self, Rn = xe.__source === void 0 ? null : xe.__source;
          for (Xe in xe)
            je.call(xe, Xe) && !qe.hasOwnProperty(Xe) && (yt[Xe] = xe[Xe]);
        }
        var Gn = arguments.length - 2;
        if (Gn === 1)
          yt.children = He;
        else if (Gn > 1) {
          for (var $r = Array(Gn), yr = 0; yr < Gn; yr++)
            $r[yr] = arguments[yr + 2];
          Object.freeze && Object.freeze($r), yt.children = $r;
        }
        if (G && G.defaultProps) {
          var Mr = G.defaultProps;
          for (Xe in Mr)
            yt[Xe] === void 0 && (yt[Xe] = Mr[Xe]);
        }
        if (sn || Ot) {
          var Ar = typeof G == "function" ? G.displayName || G.name || "Unknown" : G;
          sn && kt(yt, Ar), Ot && St(yt, Ar);
        }
        return Ne(G, sn, Ot, on, Rn, j.current, yt);
      }
      function Je(G, xe) {
        var He = Ne(G.type, xe, G.ref, G._self, G._source, G._owner, G.props);
        return He;
      }
      function pt(G, xe, He) {
        if (G == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + G + ".");
        var Xe, yt = he({}, G.props), sn = G.key, Ot = G.ref, on = G._self, Rn = G._source, Gn = G._owner;
        if (xe != null) {
          Qt(xe) && (Ot = xe.ref, Gn = j.current), Ht(xe) && (de(xe.key), sn = "" + xe.key);
          var $r;
          G.type && G.type.defaultProps && ($r = G.type.defaultProps);
          for (Xe in xe)
            je.call(xe, Xe) && !qe.hasOwnProperty(Xe) && (xe[Xe] === void 0 && $r !== void 0 ? yt[Xe] = $r[Xe] : yt[Xe] = xe[Xe]);
        }
        var yr = arguments.length - 2;
        if (yr === 1)
          yt.children = He;
        else if (yr > 1) {
          for (var Mr = Array(yr), Ar = 0; Ar < yr; Ar++)
            Mr[Ar] = arguments[Ar + 2];
          yt.children = Mr;
        }
        return Ne(G.type, sn, Ot, on, Rn, Gn, yt);
      }
      function ht(G) {
        return typeof G == "object" && G !== null && G.$$typeof === r;
      }
      var vt = ".", Nt = ":";
      function Tn(G) {
        var xe = /[=:]/g, He = {
          "=": "=0",
          ":": "=2"
        }, Xe = G.replace(xe, function(yt) {
          return He[yt];
        });
        return "$" + Xe;
      }
      var bt = !1, Pn = /\/+/g;
      function wn(G) {
        return G.replace(Pn, "$&/");
      }
      function Cn(G, xe) {
        return typeof G == "object" && G !== null && G.key != null ? (de(G.key), Tn("" + G.key)) : xe.toString(36);
      }
      function ar(G, xe, He, Xe, yt) {
        var sn = typeof G;
        (sn === "undefined" || sn === "boolean") && (G = null);
        var Ot = !1;
        if (G === null)
          Ot = !0;
        else
          switch (sn) {
            case "string":
            case "number":
              Ot = !0;
              break;
            case "object":
              switch (G.$$typeof) {
                case r:
                case a:
                  Ot = !0;
              }
          }
        if (Ot) {
          var on = G, Rn = yt(on), Gn = Xe === "" ? vt + Cn(on, 0) : Xe;
          if (Pe(Rn)) {
            var $r = "";
            Gn != null && ($r = wn(Gn) + "/"), ar(Rn, xe, $r, "", function(Ly) {
              return Ly;
            });
          } else
            Rn != null && (ht(Rn) && (Rn.key && (!on || on.key !== Rn.key) && de(Rn.key), Rn = Je(
              Rn,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              He + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Rn.key && (!on || on.key !== Rn.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                wn("" + Rn.key) + "/"
              ) : "") + Gn
            )), xe.push(Rn));
          return 1;
        }
        var yr, Mr, Ar = 0, jn = Xe === "" ? vt : Xe + Nt;
        if (Pe(G))
          for (var dl = 0; dl < G.length; dl++)
            yr = G[dl], Mr = jn + Cn(yr, dl), Ar += ar(yr, xe, He, Mr, yt);
        else {
          var Td = D(G);
          if (typeof Td == "function") {
            var ep = G;
            Td === ep.entries && (bt || te("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), bt = !0);
            for (var jy = Td.call(ep), is, tp = 0; !(is = jy.next()).done; )
              yr = is.value, Mr = jn + Cn(yr, tp++), Ar += ar(yr, xe, He, Mr, yt);
          } else if (sn === "object") {
            var np = String(G);
            throw new Error("Objects are not valid as a React child (found: " + (np === "[object Object]" ? "object with keys {" + Object.keys(G).join(", ") + "}" : np) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Ar;
      }
      function ir(G, xe, He) {
        if (G == null)
          return G;
        var Xe = [], yt = 0;
        return ar(G, Xe, "", "", function(sn) {
          return xe.call(He, sn, yt++);
        }), Xe;
      }
      function go(G) {
        var xe = 0;
        return ir(G, function() {
          xe++;
        }), xe;
      }
      function Kr(G, xe, He) {
        ir(G, function() {
          xe.apply(this, arguments);
        }, He);
      }
      function xr(G) {
        return ir(G, function(xe) {
          return xe;
        }) || [];
      }
      function Ln(G) {
        if (!ht(G))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return G;
      }
      function Dn(G) {
        var xe = {
          $$typeof: h,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: G,
          _currentValue2: G,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        xe.Provider = {
          $$typeof: m,
          _context: xe
        };
        var He = !1, Xe = !1, yt = !1;
        {
          var sn = {
            $$typeof: h,
            _context: xe
          };
          Object.defineProperties(sn, {
            Provider: {
              get: function() {
                return Xe || (Xe = !0, ne("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), xe.Provider;
              },
              set: function(Ot) {
                xe.Provider = Ot;
              }
            },
            _currentValue: {
              get: function() {
                return xe._currentValue;
              },
              set: function(Ot) {
                xe._currentValue = Ot;
              }
            },
            _currentValue2: {
              get: function() {
                return xe._currentValue2;
              },
              set: function(Ot) {
                xe._currentValue2 = Ot;
              }
            },
            _threadCount: {
              get: function() {
                return xe._threadCount;
              },
              set: function(Ot) {
                xe._threadCount = Ot;
              }
            },
            Consumer: {
              get: function() {
                return He || (He = !0, ne("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), xe.Consumer;
              }
            },
            displayName: {
              get: function() {
                return xe.displayName;
              },
              set: function(Ot) {
                yt || (te("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ot), yt = !0);
              }
            }
          }), xe.Consumer = sn;
        }
        return xe._currentRenderer = null, xe._currentRenderer2 = null, xe;
      }
      var Yn = -1, Jr = 0, dr = 1, Dr = 2;
      function Fr(G) {
        if (G._status === Yn) {
          var xe = G._result, He = xe();
          if (He.then(function(sn) {
            if (G._status === Jr || G._status === Yn) {
              var Ot = G;
              Ot._status = dr, Ot._result = sn;
            }
          }, function(sn) {
            if (G._status === Jr || G._status === Yn) {
              var Ot = G;
              Ot._status = Dr, Ot._result = sn;
            }
          }), G._status === Yn) {
            var Xe = G;
            Xe._status = Jr, Xe._result = He;
          }
        }
        if (G._status === dr) {
          var yt = G._result;
          return yt === void 0 && ne(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, yt), "default" in yt || ne(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, yt), yt.default;
        } else
          throw G._result;
      }
      function zr(G) {
        var xe = {
          // We use these fields to store the result.
          _status: Yn,
          _result: G
        }, He = {
          $$typeof: O,
          _payload: xe,
          _init: Fr
        };
        {
          var Xe, yt;
          Object.defineProperties(He, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Xe;
              },
              set: function(sn) {
                ne("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Xe = sn, Object.defineProperty(He, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return yt;
              },
              set: function(sn) {
                ne("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), yt = sn, Object.defineProperty(He, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return He;
      }
      function Vr(G) {
        G != null && G.$$typeof === E ? ne("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof G != "function" ? ne("forwardRef requires a render function but was given %s.", G === null ? "null" : typeof G) : G.length !== 0 && G.length !== 2 && ne("forwardRef render functions accept exactly two parameters: props and ref. %s", G.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), G != null && (G.defaultProps != null || G.propTypes != null) && ne("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var xe = {
          $$typeof: g,
          render: G
        };
        {
          var He;
          Object.defineProperty(xe, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return He;
            },
            set: function(Xe) {
              He = Xe, !G.name && !G.displayName && (G.displayName = Xe);
            }
          });
        }
        return xe;
      }
      var be;
      be = Symbol.for("react.module.reference");
      function at(G) {
        return !!(typeof G == "string" || typeof G == "function" || G === s || G === p || K || G === l || G === b || G === x || Y || G === _ || H || Z || re || typeof G == "object" && G !== null && (G.$$typeof === O || G.$$typeof === E || G.$$typeof === m || G.$$typeof === h || G.$$typeof === g || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        G.$$typeof === be || G.getModuleId !== void 0));
      }
      function wt(G, xe) {
        at(G) || ne("memo: The first argument must be a component. Instead received: %s", G === null ? "null" : typeof G);
        var He = {
          $$typeof: E,
          type: G,
          compare: xe === void 0 ? null : xe
        };
        {
          var Xe;
          Object.defineProperty(He, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Xe;
            },
            set: function(yt) {
              Xe = yt, !G.name && !G.displayName && (G.displayName = yt);
            }
          });
        }
        return He;
      }
      function Tt() {
        var G = N.current;
        return G === null && ne(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), G;
      }
      function it(G) {
        var xe = Tt();
        if (G._context !== void 0) {
          var He = G._context;
          He.Consumer === G ? ne("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : He.Provider === G && ne("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return xe.useContext(G);
      }
      function nt(G) {
        var xe = Tt();
        return xe.useState(G);
      }
      function ge(G, xe, He) {
        var Xe = Tt();
        return Xe.useReducer(G, xe, He);
      }
      function $e(G) {
        var xe = Tt();
        return xe.useRef(G);
      }
      function dt(G, xe) {
        var He = Tt();
        return He.useEffect(G, xe);
      }
      function Ft(G, xe) {
        var He = Tt();
        return He.useInsertionEffect(G, xe);
      }
      function fn(G, xe) {
        var He = Tt();
        return He.useLayoutEffect(G, xe);
      }
      function er(G, xe) {
        var He = Tt();
        return He.useCallback(G, xe);
      }
      function In(G, xe) {
        var He = Tt();
        return He.useMemo(G, xe);
      }
      function An(G, xe, He) {
        var Xe = Tt();
        return Xe.useImperativeHandle(G, xe, He);
      }
      function _n(G, xe) {
        {
          var He = Tt();
          return He.useDebugValue(G, xe);
        }
      }
      function rs() {
        var G = Tt();
        return G.useTransition();
      }
      function $a(G) {
        var xe = Tt();
        return xe.useDeferredValue(G);
      }
      function On() {
        var G = Tt();
        return G.useId();
      }
      function Si(G, xe, He) {
        var Xe = Tt();
        return Xe.useSyncExternalStore(G, xe, He);
      }
      var Ts = 0, Zl, ri, zt, Kn, Ur, Ma, oi;
      function Na() {
      }
      Na.__reactDisabledLog = !0;
      function Ei() {
        {
          if (Ts === 0) {
            Zl = console.log, ri = console.info, zt = console.warn, Kn = console.error, Ur = console.group, Ma = console.groupCollapsed, oi = console.groupEnd;
            var G = {
              configurable: !0,
              enumerable: !0,
              value: Na,
              writable: !0
            };
            Object.defineProperties(console, {
              info: G,
              log: G,
              warn: G,
              error: G,
              group: G,
              groupCollapsed: G,
              groupEnd: G
            });
          }
          Ts++;
        }
      }
      function la() {
        {
          if (Ts--, Ts === 0) {
            var G = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: he({}, G, {
                value: Zl
              }),
              info: he({}, G, {
                value: ri
              }),
              warn: he({}, G, {
                value: zt
              }),
              error: he({}, G, {
                value: Kn
              }),
              group: he({}, G, {
                value: Ur
              }),
              groupCollapsed: he({}, G, {
                value: Ma
              }),
              groupEnd: he({}, G, {
                value: oi
              })
            });
          }
          Ts < 0 && ne("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var os = Q.ReactCurrentDispatcher, ya;
      function Jl(G, xe, He) {
        {
          if (ya === void 0)
            try {
              throw Error();
            } catch (yt) {
              var Xe = yt.stack.trim().match(/\n( *(at )?)/);
              ya = Xe && Xe[1] || "";
            }
          return `
` + ya + G;
        }
      }
      var eu = !1, tu;
      {
        var yd = typeof WeakMap == "function" ? WeakMap : Map;
        tu = new yd();
      }
      function gd(G, xe) {
        if (!G || eu)
          return "";
        {
          var He = tu.get(G);
          if (He !== void 0)
            return He;
        }
        var Xe;
        eu = !0;
        var yt = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var sn;
        sn = os.current, os.current = null, Ei();
        try {
          if (xe) {
            var Ot = function() {
              throw Error();
            };
            if (Object.defineProperty(Ot.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ot, []);
              } catch (jn) {
                Xe = jn;
              }
              Reflect.construct(G, [], Ot);
            } else {
              try {
                Ot.call();
              } catch (jn) {
                Xe = jn;
              }
              G.call(Ot.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (jn) {
              Xe = jn;
            }
            G();
          }
        } catch (jn) {
          if (jn && Xe && typeof jn.stack == "string") {
            for (var on = jn.stack.split(`
`), Rn = Xe.stack.split(`
`), Gn = on.length - 1, $r = Rn.length - 1; Gn >= 1 && $r >= 0 && on[Gn] !== Rn[$r]; )
              $r--;
            for (; Gn >= 1 && $r >= 0; Gn--, $r--)
              if (on[Gn] !== Rn[$r]) {
                if (Gn !== 1 || $r !== 1)
                  do
                    if (Gn--, $r--, $r < 0 || on[Gn] !== Rn[$r]) {
                      var yr = `
` + on[Gn].replace(" at new ", " at ");
                      return G.displayName && yr.includes("<anonymous>") && (yr = yr.replace("<anonymous>", G.displayName)), typeof G == "function" && tu.set(G, yr), yr;
                    }
                  while (Gn >= 1 && $r >= 0);
                break;
              }
          }
        } finally {
          eu = !1, os.current = sn, la(), Error.prepareStackTrace = yt;
        }
        var Mr = G ? G.displayName || G.name : "", Ar = Mr ? Jl(Mr) : "";
        return typeof G == "function" && tu.set(G, Ar), Ar;
      }
      function ul(G, xe, He) {
        return gd(G, !1);
      }
      function Ay(G) {
        var xe = G.prototype;
        return !!(xe && xe.isReactComponent);
      }
      function _s(G, xe, He) {
        if (G == null)
          return "";
        if (typeof G == "function")
          return gd(G, Ay(G));
        if (typeof G == "string")
          return Jl(G);
        switch (G) {
          case b:
            return Jl("Suspense");
          case x:
            return Jl("SuspenseList");
        }
        if (typeof G == "object")
          switch (G.$$typeof) {
            case g:
              return ul(G.render);
            case E:
              return _s(G.type, xe, He);
            case O: {
              var Xe = G, yt = Xe._payload, sn = Xe._init;
              try {
                return _s(sn(yt), xe, He);
              } catch {
              }
            }
          }
        return "";
      }
      var tr = {}, bd = Q.ReactDebugCurrentFrame;
      function lc(G) {
        if (G) {
          var xe = G._owner, He = _s(G.type, G._source, xe ? xe.type : null);
          bd.setExtraStackFrame(He);
        } else
          bd.setExtraStackFrame(null);
      }
      function wd(G, xe, He, Xe, yt) {
        {
          var sn = Function.call.bind(je);
          for (var Ot in G)
            if (sn(G, Ot)) {
              var on = void 0;
              try {
                if (typeof G[Ot] != "function") {
                  var Rn = Error((Xe || "React class") + ": " + He + " type `" + Ot + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof G[Ot] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Rn.name = "Invariant Violation", Rn;
                }
                on = G[Ot](xe, Ot, Xe, He, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Gn) {
                on = Gn;
              }
              on && !(on instanceof Error) && (lc(yt), ne("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Xe || "React class", He, Ot, typeof on), lc(null)), on instanceof Error && !(on.message in tr) && (tr[on.message] = !0, lc(yt), ne("Failed %s type: %s", He, on.message), lc(null));
            }
        }
      }
      function qn(G) {
        if (G) {
          var xe = G._owner, He = _s(G.type, G._source, xe ? xe.type : null);
          J(He);
        } else
          J(null);
      }
      var xd;
      xd = !1;
      function Sd() {
        if (j.current) {
          var G = Ae(j.current.type);
          if (G)
            return `

Check the render method of \`` + G + "`.";
        }
        return "";
      }
      function gn(G) {
        if (G !== void 0) {
          var xe = G.fileName.replace(/^.*[\\\/]/, ""), He = G.lineNumber;
          return `

Check your code at ` + xe + ":" + He + ".";
        }
        return "";
      }
      function uc(G) {
        return G != null ? gn(G.__source) : "";
      }
      var eo = {};
      function Ia(G) {
        var xe = Sd();
        if (!xe) {
          var He = typeof G == "string" ? G : G.displayName || G.name;
          He && (xe = `

Check the top-level render call using <` + He + ">.");
        }
        return xe;
      }
      function ga(G, xe) {
        if (!(!G._store || G._store.validated || G.key != null)) {
          G._store.validated = !0;
          var He = Ia(xe);
          if (!eo[He]) {
            eo[He] = !0;
            var Xe = "";
            G && G._owner && G._owner !== j.current && (Xe = " It was passed a child from " + Ae(G._owner.type) + "."), qn(G), ne('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', He, Xe), qn(null);
          }
        }
      }
      function nu(G, xe) {
        if (typeof G == "object") {
          if (Pe(G))
            for (var He = 0; He < G.length; He++) {
              var Xe = G[He];
              ht(Xe) && ga(Xe, xe);
            }
          else if (ht(G))
            G._store && (G._store.validated = !0);
          else if (G) {
            var yt = D(G);
            if (typeof yt == "function" && yt !== G.entries)
              for (var sn = yt.call(G), Ot; !(Ot = sn.next()).done; )
                ht(Ot.value) && ga(Ot.value, xe);
          }
        }
      }
      function io(G) {
        {
          var xe = G.type;
          if (xe == null || typeof xe == "string")
            return;
          var He;
          if (typeof xe == "function")
            He = xe.propTypes;
          else if (typeof xe == "object" && (xe.$$typeof === g || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          xe.$$typeof === E))
            He = xe.propTypes;
          else
            return;
          if (He) {
            var Xe = Ae(xe);
            wd(He, G.props, "prop", Xe, G);
          } else if (xe.PropTypes !== void 0 && !xd) {
            xd = !0;
            var yt = Ae(xe);
            ne("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", yt || "Unknown");
          }
          typeof xe.getDefaultProps == "function" && !xe.getDefaultProps.isReactClassApproved && ne("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function fr(G) {
        {
          for (var xe = Object.keys(G.props), He = 0; He < xe.length; He++) {
            var Xe = xe[He];
            if (Xe !== "children" && Xe !== "key") {
              qn(G), ne("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Xe), qn(null);
              break;
            }
          }
          G.ref !== null && (qn(G), ne("Invalid attribute `ref` supplied to `React.Fragment`."), qn(null));
        }
      }
      function Fm(G, xe, He) {
        var Xe = at(G);
        if (!Xe) {
          var yt = "";
          (G === void 0 || typeof G == "object" && G !== null && Object.keys(G).length === 0) && (yt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sn = uc(xe);
          sn ? yt += sn : yt += Sd();
          var Ot;
          G === null ? Ot = "null" : Pe(G) ? Ot = "array" : G !== void 0 && G.$$typeof === r ? (Ot = "<" + (Ae(G.type) || "Unknown") + " />", yt = " Did you accidentally export a JSX literal instead of a component?") : Ot = typeof G, ne("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ot, yt);
        }
        var on = Ie.apply(this, arguments);
        if (on == null)
          return on;
        if (Xe)
          for (var Rn = 2; Rn < arguments.length; Rn++)
            nu(arguments[Rn], G);
        return G === s ? fr(on) : io(on), on;
      }
      var Aa = !1;
      function jo(G) {
        var xe = Fm.bind(null, G);
        return xe.type = G, Aa || (Aa = !0, te("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(xe, "type", {
          enumerable: !1,
          get: function() {
            return te("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: G
            }), G;
          }
        }), xe;
      }
      function Os(G, xe, He) {
        for (var Xe = pt.apply(this, arguments), yt = 2; yt < arguments.length; yt++)
          nu(arguments[yt], Xe.type);
        return io(Xe), Xe;
      }
      function zm(G, xe) {
        var He = I.transition;
        I.transition = {};
        var Xe = I.transition;
        I.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          G();
        } finally {
          if (I.transition = He, He === null && Xe._updatedFibers) {
            var yt = Xe._updatedFibers.size;
            yt > 10 && te("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Xe._updatedFibers.clear();
          }
        }
      }
      var cl = !1, ru = null;
      function Vm(G) {
        if (ru === null)
          try {
            var xe = ("require" + Math.random()).slice(0, 7), He = e && e[xe];
            ru = He.call(e, "timers").setImmediate;
          } catch {
            ru = function(yt) {
              cl === !1 && (cl = !0, typeof MessageChannel > "u" && ne("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var sn = new MessageChannel();
              sn.port1.onmessage = yt, sn.port2.postMessage(void 0);
            };
          }
        return ru(G);
      }
      var Ci = 0, ou = !1;
      function au(G) {
        {
          var xe = Ci;
          Ci++, R.current === null && (R.current = []);
          var He = R.isBatchingLegacy, Xe;
          try {
            if (R.isBatchingLegacy = !0, Xe = G(), !He && R.didScheduleLegacyUpdate) {
              var yt = R.current;
              yt !== null && (R.didScheduleLegacyUpdate = !1, su(yt));
            }
          } catch (Mr) {
            throw Ti(xe), Mr;
          } finally {
            R.isBatchingLegacy = He;
          }
          if (Xe !== null && typeof Xe == "object" && typeof Xe.then == "function") {
            var sn = Xe, Ot = !1, on = {
              then: function(Mr, Ar) {
                Ot = !0, sn.then(function(jn) {
                  Ti(xe), Ci === 0 ? Ed(jn, Mr, Ar) : Mr(jn);
                }, function(jn) {
                  Ti(xe), Ar(jn);
                });
              }
            };
            return !ou && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ot || (ou = !0, ne("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), on;
          } else {
            var Rn = Xe;
            if (Ti(xe), Ci === 0) {
              var Gn = R.current;
              Gn !== null && (su(Gn), R.current = null);
              var $r = {
                then: function(Mr, Ar) {
                  R.current === null ? (R.current = [], Ed(Rn, Mr, Ar)) : Mr(Rn);
                }
              };
              return $r;
            } else {
              var yr = {
                then: function(Mr, Ar) {
                  Mr(Rn);
                }
              };
              return yr;
            }
          }
        }
      }
      function Ti(G) {
        G !== Ci - 1 && ne("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Ci = G;
      }
      function Ed(G, xe, He) {
        {
          var Xe = R.current;
          if (Xe !== null)
            try {
              su(Xe), Vm(function() {
                Xe.length === 0 ? (R.current = null, xe(G)) : Ed(G, xe, He);
              });
            } catch (yt) {
              He(yt);
            }
          else
            xe(G);
        }
      }
      var iu = !1;
      function su(G) {
        if (!iu) {
          iu = !0;
          var xe = 0;
          try {
            for (; xe < G.length; xe++) {
              var He = G[xe];
              do
                He = He(!0);
              while (He !== null);
            }
            G.length = 0;
          } catch (Xe) {
            throw G = G.slice(xe + 1), Xe;
          } finally {
            iu = !1;
          }
        }
      }
      var cc = Fm, Cd = Os, Jf = jo, as = {
        map: ir,
        forEach: Kr,
        count: go,
        toArray: xr,
        only: Ln
      };
      t.Children = as, t.Component = fe, t.Fragment = s, t.Profiler = p, t.PureComponent = ye, t.StrictMode = l, t.Suspense = b, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Q, t.cloneElement = Cd, t.createContext = Dn, t.createElement = cc, t.createFactory = Jf, t.createRef = Fe, t.forwardRef = Vr, t.isValidElement = ht, t.lazy = zr, t.memo = wt, t.startTransition = zm, t.unstable_act = au, t.useCallback = er, t.useContext = it, t.useDebugValue = _n, t.useDeferredValue = $a, t.useEffect = dt, t.useId = On, t.useImperativeHandle = An, t.useInsertionEffect = Ft, t.useLayoutEffect = fn, t.useMemo = In, t.useReducer = ge, t.useRef = $e, t.useState = nt, t.useSyncExternalStore = Si, t.useTransition = rs, t.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(y0, y0.exports)), y0.exports;
}
process.env.NODE_ENV === "production" ? CD.exports = vee() : CD.exports = yee();
var C = CD.exports;
const le = /* @__PURE__ */ Uf(C), iy = /* @__PURE__ */ hee({
  __proto__: null,
  default: le
}, [C]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fj;
function gee() {
  if (Fj)
    return Hb;
  Fj = 1;
  var e = C, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(p, m, h) {
    var g, b = {}, x = null, E = null;
    h !== void 0 && (x = "" + h), m.key !== void 0 && (x = "" + m.key), m.ref !== void 0 && (E = m.ref);
    for (g in m)
      r.call(m, g) && !s.hasOwnProperty(g) && (b[g] = m[g]);
    if (p && p.defaultProps)
      for (g in m = p.defaultProps, m)
        b[g] === void 0 && (b[g] = m[g]);
    return { $$typeof: t, type: p, key: x, ref: E, props: b, _owner: a.current };
  }
  return Hb.Fragment = n, Hb.jsx = l, Hb.jsxs = l, Hb;
}
var Wb = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zj;
function bee() {
  return zj || (zj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = C, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), p = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), O = Symbol.iterator, _ = "@@iterator";
    function P(be) {
      if (be === null || typeof be != "object")
        return null;
      var at = O && be[O] || be[_];
      return typeof at == "function" ? at : null;
    }
    var M = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function D(be) {
      {
        for (var at = arguments.length, wt = new Array(at > 1 ? at - 1 : 0), Tt = 1; Tt < at; Tt++)
          wt[Tt - 1] = arguments[Tt];
        N("error", be, wt);
      }
    }
    function N(be, at, wt) {
      {
        var Tt = M.ReactDebugCurrentFrame, it = Tt.getStackAddendum();
        it !== "" && (at += "%s", wt = wt.concat([it]));
        var nt = wt.map(function(ge) {
          return String(ge);
        });
        nt.unshift("Warning: " + at), Function.prototype.apply.call(console[be], console, nt);
      }
    }
    var I = !1, R = !1, j = !1, U = !1, q = !1, J;
    J = Symbol.for("react.module.reference");
    function H(be) {
      return !!(typeof be == "string" || typeof be == "function" || be === r || be === s || q || be === a || be === h || be === g || U || be === E || I || R || j || typeof be == "object" && be !== null && (be.$$typeof === x || be.$$typeof === b || be.$$typeof === l || be.$$typeof === p || be.$$typeof === m || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      be.$$typeof === J || be.getModuleId !== void 0));
    }
    function Z(be, at, wt) {
      var Tt = be.displayName;
      if (Tt)
        return Tt;
      var it = at.displayName || at.name || "";
      return it !== "" ? wt + "(" + it + ")" : wt;
    }
    function re(be) {
      return be.displayName || "Context";
    }
    function Y(be) {
      if (be == null)
        return null;
      if (typeof be.tag == "number" && D("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof be == "function")
        return be.displayName || be.name || null;
      if (typeof be == "string")
        return be;
      switch (be) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case a:
          return "StrictMode";
        case h:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof be == "object")
        switch (be.$$typeof) {
          case p:
            var at = be;
            return re(at) + ".Consumer";
          case l:
            var wt = be;
            return re(wt._context) + ".Provider";
          case m:
            return Z(be, be.render, "ForwardRef");
          case b:
            var Tt = be.displayName || null;
            return Tt !== null ? Tt : Y(be.type) || "Memo";
          case x: {
            var it = be, nt = it._payload, ge = it._init;
            try {
              return Y(ge(nt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var K = Object.assign, Q = 0, te, ne, ae, se, V, ee, he;
    function ue() {
    }
    ue.__reactDisabledLog = !0;
    function fe() {
      {
        if (Q === 0) {
          te = console.log, ne = console.info, ae = console.warn, se = console.error, V = console.group, ee = console.groupCollapsed, he = console.groupEnd;
          var be = {
            configurable: !0,
            enumerable: !0,
            value: ue,
            writable: !0
          };
          Object.defineProperties(console, {
            info: be,
            log: be,
            warn: be,
            error: be,
            group: be,
            groupCollapsed: be,
            groupEnd: be
          });
        }
        Q++;
      }
    }
    function Ce() {
      {
        if (Q--, Q === 0) {
          var be = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: K({}, be, {
              value: te
            }),
            info: K({}, be, {
              value: ne
            }),
            warn: K({}, be, {
              value: ae
            }),
            error: K({}, be, {
              value: se
            }),
            group: K({}, be, {
              value: V
            }),
            groupCollapsed: K({}, be, {
              value: ee
            }),
            groupEnd: K({}, be, {
              value: he
            })
          });
        }
        Q < 0 && D("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Se = M.ReactCurrentDispatcher, Te;
    function pe(be, at, wt) {
      {
        if (Te === void 0)
          try {
            throw Error();
          } catch (it) {
            var Tt = it.stack.trim().match(/\n( *(at )?)/);
            Te = Tt && Tt[1] || "";
          }
        return `
` + Te + be;
      }
    }
    var ye = !1, Oe;
    {
      var Fe = typeof WeakMap == "function" ? WeakMap : Map;
      Oe = new Fe();
    }
    function me(be, at) {
      if (!be || ye)
        return "";
      {
        var wt = Oe.get(be);
        if (wt !== void 0)
          return wt;
      }
      var Tt;
      ye = !0;
      var it = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var nt;
      nt = Se.current, Se.current = null, fe();
      try {
        if (at) {
          var ge = function() {
            throw Error();
          };
          if (Object.defineProperty(ge.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ge, []);
            } catch (_n) {
              Tt = _n;
            }
            Reflect.construct(be, [], ge);
          } else {
            try {
              ge.call();
            } catch (_n) {
              Tt = _n;
            }
            be.call(ge.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_n) {
            Tt = _n;
          }
          be();
        }
      } catch (_n) {
        if (_n && Tt && typeof _n.stack == "string") {
          for (var $e = _n.stack.split(`
`), dt = Tt.stack.split(`
`), Ft = $e.length - 1, fn = dt.length - 1; Ft >= 1 && fn >= 0 && $e[Ft] !== dt[fn]; )
            fn--;
          for (; Ft >= 1 && fn >= 0; Ft--, fn--)
            if ($e[Ft] !== dt[fn]) {
              if (Ft !== 1 || fn !== 1)
                do
                  if (Ft--, fn--, fn < 0 || $e[Ft] !== dt[fn]) {
                    var er = `
` + $e[Ft].replace(" at new ", " at ");
                    return be.displayName && er.includes("<anonymous>") && (er = er.replace("<anonymous>", be.displayName)), typeof be == "function" && Oe.set(be, er), er;
                  }
                while (Ft >= 1 && fn >= 0);
              break;
            }
        }
      } finally {
        ye = !1, Se.current = nt, Ce(), Error.prepareStackTrace = it;
      }
      var In = be ? be.displayName || be.name : "", An = In ? pe(In) : "";
      return typeof be == "function" && Oe.set(be, An), An;
    }
    function Pe(be, at, wt) {
      return me(be, !1);
    }
    function Ee(be) {
      var at = be.prototype;
      return !!(at && at.isReactComponent);
    }
    function Ke(be, at, wt) {
      if (be == null)
        return "";
      if (typeof be == "function")
        return me(be, Ee(be));
      if (typeof be == "string")
        return pe(be);
      switch (be) {
        case h:
          return pe("Suspense");
        case g:
          return pe("SuspenseList");
      }
      if (typeof be == "object")
        switch (be.$$typeof) {
          case m:
            return Pe(be.render);
          case b:
            return Ke(be.type, at, wt);
          case x: {
            var Tt = be, it = Tt._payload, nt = Tt._init;
            try {
              return Ke(nt(it), at, wt);
            } catch {
            }
          }
        }
      return "";
    }
    var oe = Object.prototype.hasOwnProperty, de = {}, we = M.ReactDebugCurrentFrame;
    function Me(be) {
      if (be) {
        var at = be._owner, wt = Ke(be.type, be._source, at ? at.type : null);
        we.setExtraStackFrame(wt);
      } else
        we.setExtraStackFrame(null);
    }
    function Ae(be, at, wt, Tt, it) {
      {
        var nt = Function.call.bind(oe);
        for (var ge in be)
          if (nt(be, ge)) {
            var $e = void 0;
            try {
              if (typeof be[ge] != "function") {
                var dt = Error((Tt || "React class") + ": " + wt + " type `" + ge + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof be[ge] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw dt.name = "Invariant Violation", dt;
              }
              $e = be[ge](at, ge, Tt, wt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ft) {
              $e = Ft;
            }
            $e && !($e instanceof Error) && (Me(it), D("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Tt || "React class", wt, ge, typeof $e), Me(null)), $e instanceof Error && !($e.message in de) && (de[$e.message] = !0, Me(it), D("Failed %s type: %s", wt, $e.message), Me(null));
          }
      }
    }
    var je = Array.isArray;
    function qe(be) {
      return je(be);
    }
    function ot(be) {
      {
        var at = typeof Symbol == "function" && Symbol.toStringTag, wt = at && be[Symbol.toStringTag] || be.constructor.name || "Object";
        return wt;
      }
    }
    function et(be) {
      try {
        return ct(be), !1;
      } catch {
        return !0;
      }
    }
    function ct(be) {
      return "" + be;
    }
    function Qt(be) {
      if (et(be))
        return D("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ot(be)), ct(be);
    }
    var Ht = M.ReactCurrentOwner, kt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, St, cn, Ne;
    Ne = {};
    function Ie(be) {
      if (oe.call(be, "ref")) {
        var at = Object.getOwnPropertyDescriptor(be, "ref").get;
        if (at && at.isReactWarning)
          return !1;
      }
      return be.ref !== void 0;
    }
    function Je(be) {
      if (oe.call(be, "key")) {
        var at = Object.getOwnPropertyDescriptor(be, "key").get;
        if (at && at.isReactWarning)
          return !1;
      }
      return be.key !== void 0;
    }
    function pt(be, at) {
      if (typeof be.ref == "string" && Ht.current && at && Ht.current.stateNode !== at) {
        var wt = Y(Ht.current.type);
        Ne[wt] || (D('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Y(Ht.current.type), be.ref), Ne[wt] = !0);
      }
    }
    function ht(be, at) {
      {
        var wt = function() {
          St || (St = !0, D("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", at));
        };
        wt.isReactWarning = !0, Object.defineProperty(be, "key", {
          get: wt,
          configurable: !0
        });
      }
    }
    function vt(be, at) {
      {
        var wt = function() {
          cn || (cn = !0, D("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", at));
        };
        wt.isReactWarning = !0, Object.defineProperty(be, "ref", {
          get: wt,
          configurable: !0
        });
      }
    }
    var Nt = function(be, at, wt, Tt, it, nt, ge) {
      var $e = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: be,
        key: at,
        ref: wt,
        props: ge,
        // Record the component responsible for creating this element.
        _owner: nt
      };
      return $e._store = {}, Object.defineProperty($e._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty($e, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Tt
      }), Object.defineProperty($e, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: it
      }), Object.freeze && (Object.freeze($e.props), Object.freeze($e)), $e;
    };
    function Tn(be, at, wt, Tt, it) {
      {
        var nt, ge = {}, $e = null, dt = null;
        wt !== void 0 && (Qt(wt), $e = "" + wt), Je(at) && (Qt(at.key), $e = "" + at.key), Ie(at) && (dt = at.ref, pt(at, it));
        for (nt in at)
          oe.call(at, nt) && !kt.hasOwnProperty(nt) && (ge[nt] = at[nt]);
        if (be && be.defaultProps) {
          var Ft = be.defaultProps;
          for (nt in Ft)
            ge[nt] === void 0 && (ge[nt] = Ft[nt]);
        }
        if ($e || dt) {
          var fn = typeof be == "function" ? be.displayName || be.name || "Unknown" : be;
          $e && ht(ge, fn), dt && vt(ge, fn);
        }
        return Nt(be, $e, dt, it, Tt, Ht.current, ge);
      }
    }
    var bt = M.ReactCurrentOwner, Pn = M.ReactDebugCurrentFrame;
    function wn(be) {
      if (be) {
        var at = be._owner, wt = Ke(be.type, be._source, at ? at.type : null);
        Pn.setExtraStackFrame(wt);
      } else
        Pn.setExtraStackFrame(null);
    }
    var Cn;
    Cn = !1;
    function ar(be) {
      return typeof be == "object" && be !== null && be.$$typeof === t;
    }
    function ir() {
      {
        if (bt.current) {
          var be = Y(bt.current.type);
          if (be)
            return `

Check the render method of \`` + be + "`.";
        }
        return "";
      }
    }
    function go(be) {
      {
        if (be !== void 0) {
          var at = be.fileName.replace(/^.*[\\\/]/, ""), wt = be.lineNumber;
          return `

Check your code at ` + at + ":" + wt + ".";
        }
        return "";
      }
    }
    var Kr = {};
    function xr(be) {
      {
        var at = ir();
        if (!at) {
          var wt = typeof be == "string" ? be : be.displayName || be.name;
          wt && (at = `

Check the top-level render call using <` + wt + ">.");
        }
        return at;
      }
    }
    function Ln(be, at) {
      {
        if (!be._store || be._store.validated || be.key != null)
          return;
        be._store.validated = !0;
        var wt = xr(at);
        if (Kr[wt])
          return;
        Kr[wt] = !0;
        var Tt = "";
        be && be._owner && be._owner !== bt.current && (Tt = " It was passed a child from " + Y(be._owner.type) + "."), wn(be), D('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', wt, Tt), wn(null);
      }
    }
    function Dn(be, at) {
      {
        if (typeof be != "object")
          return;
        if (qe(be))
          for (var wt = 0; wt < be.length; wt++) {
            var Tt = be[wt];
            ar(Tt) && Ln(Tt, at);
          }
        else if (ar(be))
          be._store && (be._store.validated = !0);
        else if (be) {
          var it = P(be);
          if (typeof it == "function" && it !== be.entries)
            for (var nt = it.call(be), ge; !(ge = nt.next()).done; )
              ar(ge.value) && Ln(ge.value, at);
        }
      }
    }
    function Yn(be) {
      {
        var at = be.type;
        if (at == null || typeof at == "string")
          return;
        var wt;
        if (typeof at == "function")
          wt = at.propTypes;
        else if (typeof at == "object" && (at.$$typeof === m || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        at.$$typeof === b))
          wt = at.propTypes;
        else
          return;
        if (wt) {
          var Tt = Y(at);
          Ae(wt, be.props, "prop", Tt, be);
        } else if (at.PropTypes !== void 0 && !Cn) {
          Cn = !0;
          var it = Y(at);
          D("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", it || "Unknown");
        }
        typeof at.getDefaultProps == "function" && !at.getDefaultProps.isReactClassApproved && D("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Jr(be) {
      {
        for (var at = Object.keys(be.props), wt = 0; wt < at.length; wt++) {
          var Tt = at[wt];
          if (Tt !== "children" && Tt !== "key") {
            wn(be), D("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Tt), wn(null);
            break;
          }
        }
        be.ref !== null && (wn(be), D("Invalid attribute `ref` supplied to `React.Fragment`."), wn(null));
      }
    }
    function dr(be, at, wt, Tt, it, nt) {
      {
        var ge = H(be);
        if (!ge) {
          var $e = "";
          (be === void 0 || typeof be == "object" && be !== null && Object.keys(be).length === 0) && ($e += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var dt = go(it);
          dt ? $e += dt : $e += ir();
          var Ft;
          be === null ? Ft = "null" : qe(be) ? Ft = "array" : be !== void 0 && be.$$typeof === t ? (Ft = "<" + (Y(be.type) || "Unknown") + " />", $e = " Did you accidentally export a JSX literal instead of a component?") : Ft = typeof be, D("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ft, $e);
        }
        var fn = Tn(be, at, wt, it, nt);
        if (fn == null)
          return fn;
        if (ge) {
          var er = at.children;
          if (er !== void 0)
            if (Tt)
              if (qe(er)) {
                for (var In = 0; In < er.length; In++)
                  Dn(er[In], be);
                Object.freeze && Object.freeze(er);
              } else
                D("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Dn(er, be);
        }
        return be === r ? Jr(fn) : Yn(fn), fn;
      }
    }
    function Dr(be, at, wt) {
      return dr(be, at, wt, !0);
    }
    function Fr(be, at, wt) {
      return dr(be, at, wt, !1);
    }
    var zr = Fr, Vr = Dr;
    Wb.Fragment = r, Wb.jsx = zr, Wb.jsxs = Vr;
  }()), Wb;
}
process.env.NODE_ENV === "production" ? ED.exports = gee() : ED.exports = bee();
var L = ED.exports;
function cd(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...r) {
    return e(...r) || t(...r);
  };
}
function um(e) {
  return e !== null && typeof e == "object" && e.constructor === Object;
}
function d3(e) {
  if (!um(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = d3(e[n]);
  }), t;
}
function Ks(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return um(e) && um(t) && Object.keys(t).forEach((a) => {
    a !== "__proto__" && (um(t[a]) && a in e && um(e[a]) ? r[a] = Ks(e[a], t[a], n) : n.clone ? r[a] = um(t[a]) ? d3(t[a]) : t[a] : r[a] = t[a]);
  }), r;
}
var TD = { exports: {} }, c1 = { exports: {} }, Cr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vj;
function wee() {
  if (Vj)
    return Cr;
  Vj = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, p = e ? Symbol.for("react.context") : 60110, m = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, x = e ? Symbol.for("react.suspense_list") : 60120, E = e ? Symbol.for("react.memo") : 60115, O = e ? Symbol.for("react.lazy") : 60116, _ = e ? Symbol.for("react.block") : 60121, P = e ? Symbol.for("react.fundamental") : 60117, M = e ? Symbol.for("react.responder") : 60118, D = e ? Symbol.for("react.scope") : 60119;
  function N(R) {
    if (typeof R == "object" && R !== null) {
      var j = R.$$typeof;
      switch (j) {
        case t:
          switch (R = R.type, R) {
            case m:
            case h:
            case r:
            case s:
            case a:
            case b:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case p:
                case g:
                case O:
                case E:
                case l:
                  return R;
                default:
                  return j;
              }
          }
        case n:
          return j;
      }
    }
  }
  function I(R) {
    return N(R) === h;
  }
  return Cr.AsyncMode = m, Cr.ConcurrentMode = h, Cr.ContextConsumer = p, Cr.ContextProvider = l, Cr.Element = t, Cr.ForwardRef = g, Cr.Fragment = r, Cr.Lazy = O, Cr.Memo = E, Cr.Portal = n, Cr.Profiler = s, Cr.StrictMode = a, Cr.Suspense = b, Cr.isAsyncMode = function(R) {
    return I(R) || N(R) === m;
  }, Cr.isConcurrentMode = I, Cr.isContextConsumer = function(R) {
    return N(R) === p;
  }, Cr.isContextProvider = function(R) {
    return N(R) === l;
  }, Cr.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, Cr.isForwardRef = function(R) {
    return N(R) === g;
  }, Cr.isFragment = function(R) {
    return N(R) === r;
  }, Cr.isLazy = function(R) {
    return N(R) === O;
  }, Cr.isMemo = function(R) {
    return N(R) === E;
  }, Cr.isPortal = function(R) {
    return N(R) === n;
  }, Cr.isProfiler = function(R) {
    return N(R) === s;
  }, Cr.isStrictMode = function(R) {
    return N(R) === a;
  }, Cr.isSuspense = function(R) {
    return N(R) === b;
  }, Cr.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === h || R === s || R === a || R === b || R === x || typeof R == "object" && R !== null && (R.$$typeof === O || R.$$typeof === E || R.$$typeof === l || R.$$typeof === p || R.$$typeof === g || R.$$typeof === P || R.$$typeof === M || R.$$typeof === D || R.$$typeof === _);
  }, Cr.typeOf = N, Cr;
}
var Tr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uj;
function xee() {
  return Uj || (Uj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, p = e ? Symbol.for("react.context") : 60110, m = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, x = e ? Symbol.for("react.suspense_list") : 60120, E = e ? Symbol.for("react.memo") : 60115, O = e ? Symbol.for("react.lazy") : 60116, _ = e ? Symbol.for("react.block") : 60121, P = e ? Symbol.for("react.fundamental") : 60117, M = e ? Symbol.for("react.responder") : 60118, D = e ? Symbol.for("react.scope") : 60119;
    function N(me) {
      return typeof me == "string" || typeof me == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      me === r || me === h || me === s || me === a || me === b || me === x || typeof me == "object" && me !== null && (me.$$typeof === O || me.$$typeof === E || me.$$typeof === l || me.$$typeof === p || me.$$typeof === g || me.$$typeof === P || me.$$typeof === M || me.$$typeof === D || me.$$typeof === _);
    }
    function I(me) {
      if (typeof me == "object" && me !== null) {
        var Pe = me.$$typeof;
        switch (Pe) {
          case t:
            var Ee = me.type;
            switch (Ee) {
              case m:
              case h:
              case r:
              case s:
              case a:
              case b:
                return Ee;
              default:
                var Ke = Ee && Ee.$$typeof;
                switch (Ke) {
                  case p:
                  case g:
                  case O:
                  case E:
                  case l:
                    return Ke;
                  default:
                    return Pe;
                }
            }
          case n:
            return Pe;
        }
      }
    }
    var R = m, j = h, U = p, q = l, J = t, H = g, Z = r, re = O, Y = E, K = n, Q = s, te = a, ne = b, ae = !1;
    function se(me) {
      return ae || (ae = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), V(me) || I(me) === m;
    }
    function V(me) {
      return I(me) === h;
    }
    function ee(me) {
      return I(me) === p;
    }
    function he(me) {
      return I(me) === l;
    }
    function ue(me) {
      return typeof me == "object" && me !== null && me.$$typeof === t;
    }
    function fe(me) {
      return I(me) === g;
    }
    function Ce(me) {
      return I(me) === r;
    }
    function Se(me) {
      return I(me) === O;
    }
    function Te(me) {
      return I(me) === E;
    }
    function pe(me) {
      return I(me) === n;
    }
    function ye(me) {
      return I(me) === s;
    }
    function Oe(me) {
      return I(me) === a;
    }
    function Fe(me) {
      return I(me) === b;
    }
    Tr.AsyncMode = R, Tr.ConcurrentMode = j, Tr.ContextConsumer = U, Tr.ContextProvider = q, Tr.Element = J, Tr.ForwardRef = H, Tr.Fragment = Z, Tr.Lazy = re, Tr.Memo = Y, Tr.Portal = K, Tr.Profiler = Q, Tr.StrictMode = te, Tr.Suspense = ne, Tr.isAsyncMode = se, Tr.isConcurrentMode = V, Tr.isContextConsumer = ee, Tr.isContextProvider = he, Tr.isElement = ue, Tr.isForwardRef = fe, Tr.isFragment = Ce, Tr.isLazy = Se, Tr.isMemo = Te, Tr.isPortal = pe, Tr.isProfiler = ye, Tr.isStrictMode = Oe, Tr.isSuspense = Fe, Tr.isValidElementType = N, Tr.typeOf = I;
  }()), Tr;
}
var Bj;
function f3() {
  return Bj || (Bj = 1, process.env.NODE_ENV === "production" ? c1.exports = wee() : c1.exports = xee()), c1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var rk, Hj;
function See() {
  if (Hj)
    return rk;
  Hj = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function a() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var l = {}, p = 0; p < 10; p++)
        l["_" + String.fromCharCode(p)] = p;
      var m = Object.getOwnPropertyNames(l).map(function(g) {
        return l[g];
      });
      if (m.join("") !== "0123456789")
        return !1;
      var h = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(g) {
        h[g] = g;
      }), Object.keys(Object.assign({}, h)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return rk = a() ? Object.assign : function(s, l) {
    for (var p, m = r(s), h, g = 1; g < arguments.length; g++) {
      p = Object(arguments[g]);
      for (var b in p)
        t.call(p, b) && (m[b] = p[b]);
      if (e) {
        h = e(p);
        for (var x = 0; x < h.length; x++)
          n.call(p, h[x]) && (m[h[x]] = p[h[x]]);
      }
    }
    return m;
  }, rk;
}
var ok, Wj;
function L$() {
  if (Wj)
    return ok;
  Wj = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ok = e, ok;
}
var ak, Yj;
function p3() {
  return Yj || (Yj = 1, ak = Function.call.bind(Object.prototype.hasOwnProperty)), ak;
}
var ik, qj;
function Eee() {
  if (qj)
    return ik;
  qj = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = L$(), n = {}, r = p3();
    e = function(s) {
      var l = "Warning: " + s;
      typeof console < "u" && console.error(l);
      try {
        throw new Error(l);
      } catch {
      }
    };
  }
  function a(s, l, p, m, h) {
    if (process.env.NODE_ENV !== "production") {
      for (var g in s)
        if (r(s, g)) {
          var b;
          try {
            if (typeof s[g] != "function") {
              var x = Error(
                (m || "React class") + ": " + p + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw x.name = "Invariant Violation", x;
            }
            b = s[g](l, g, m, p, null, t);
          } catch (O) {
            b = O;
          }
          if (b && !(b instanceof Error) && e(
            (m || "React class") + ": type specification of " + p + " `" + g + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof b + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), b instanceof Error && !(b.message in n)) {
            n[b.message] = !0;
            var E = h ? h() : "";
            e(
              "Failed " + p + " type: " + b.message + (E ?? "")
            );
          }
        }
    }
  }
  return a.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ik = a, ik;
}
var sk, Gj;
function Cee() {
  if (Gj)
    return sk;
  Gj = 1;
  var e = f3(), t = See(), n = L$(), r = p3(), a = Eee(), s = function() {
  };
  process.env.NODE_ENV !== "production" && (s = function(p) {
    var m = "Warning: " + p;
    typeof console < "u" && console.error(m);
    try {
      throw new Error(m);
    } catch {
    }
  });
  function l() {
    return null;
  }
  return sk = function(p, m) {
    var h = typeof Symbol == "function" && Symbol.iterator, g = "@@iterator";
    function b(V) {
      var ee = V && (h && V[h] || V[g]);
      if (typeof ee == "function")
        return ee;
    }
    var x = "<<anonymous>>", E = {
      array: M("array"),
      bigint: M("bigint"),
      bool: M("boolean"),
      func: M("function"),
      number: M("number"),
      object: M("object"),
      string: M("string"),
      symbol: M("symbol"),
      any: D(),
      arrayOf: N,
      element: I(),
      elementType: R(),
      instanceOf: j,
      node: H(),
      objectOf: q,
      oneOf: U,
      oneOfType: J,
      shape: re,
      exact: Y
    };
    function O(V, ee) {
      return V === ee ? V !== 0 || 1 / V === 1 / ee : V !== V && ee !== ee;
    }
    function _(V, ee) {
      this.message = V, this.data = ee && typeof ee == "object" ? ee : {}, this.stack = "";
    }
    _.prototype = Error.prototype;
    function P(V) {
      if (process.env.NODE_ENV !== "production")
        var ee = {}, he = 0;
      function ue(Ce, Se, Te, pe, ye, Oe, Fe) {
        if (pe = pe || x, Oe = Oe || Te, Fe !== n) {
          if (m) {
            var me = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw me.name = "Invariant Violation", me;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Pe = pe + ":" + Te;
            !ee[Pe] && // Avoid spamming the console because they are often not actionable except for lib authors
            he < 3 && (s(
              "You are manually calling a React.PropTypes validation function for the `" + Oe + "` prop on `" + pe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), ee[Pe] = !0, he++);
          }
        }
        return Se[Te] == null ? Ce ? Se[Te] === null ? new _("The " + ye + " `" + Oe + "` is marked as required " + ("in `" + pe + "`, but its value is `null`.")) : new _("The " + ye + " `" + Oe + "` is marked as required in " + ("`" + pe + "`, but its value is `undefined`.")) : null : V(Se, Te, pe, ye, Oe);
      }
      var fe = ue.bind(null, !1);
      return fe.isRequired = ue.bind(null, !0), fe;
    }
    function M(V) {
      function ee(he, ue, fe, Ce, Se, Te) {
        var pe = he[ue], ye = te(pe);
        if (ye !== V) {
          var Oe = ne(pe);
          return new _(
            "Invalid " + Ce + " `" + Se + "` of type " + ("`" + Oe + "` supplied to `" + fe + "`, expected ") + ("`" + V + "`."),
            { expectedType: V }
          );
        }
        return null;
      }
      return P(ee);
    }
    function D() {
      return P(l);
    }
    function N(V) {
      function ee(he, ue, fe, Ce, Se) {
        if (typeof V != "function")
          return new _("Property `" + Se + "` of component `" + fe + "` has invalid PropType notation inside arrayOf.");
        var Te = he[ue];
        if (!Array.isArray(Te)) {
          var pe = te(Te);
          return new _("Invalid " + Ce + " `" + Se + "` of type " + ("`" + pe + "` supplied to `" + fe + "`, expected an array."));
        }
        for (var ye = 0; ye < Te.length; ye++) {
          var Oe = V(Te, ye, fe, Ce, Se + "[" + ye + "]", n);
          if (Oe instanceof Error)
            return Oe;
        }
        return null;
      }
      return P(ee);
    }
    function I() {
      function V(ee, he, ue, fe, Ce) {
        var Se = ee[he];
        if (!p(Se)) {
          var Te = te(Se);
          return new _("Invalid " + fe + " `" + Ce + "` of type " + ("`" + Te + "` supplied to `" + ue + "`, expected a single ReactElement."));
        }
        return null;
      }
      return P(V);
    }
    function R() {
      function V(ee, he, ue, fe, Ce) {
        var Se = ee[he];
        if (!e.isValidElementType(Se)) {
          var Te = te(Se);
          return new _("Invalid " + fe + " `" + Ce + "` of type " + ("`" + Te + "` supplied to `" + ue + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return P(V);
    }
    function j(V) {
      function ee(he, ue, fe, Ce, Se) {
        if (!(he[ue] instanceof V)) {
          var Te = V.name || x, pe = se(he[ue]);
          return new _("Invalid " + Ce + " `" + Se + "` of type " + ("`" + pe + "` supplied to `" + fe + "`, expected ") + ("instance of `" + Te + "`."));
        }
        return null;
      }
      return P(ee);
    }
    function U(V) {
      if (!Array.isArray(V))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? s(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : s("Invalid argument supplied to oneOf, expected an array.")), l;
      function ee(he, ue, fe, Ce, Se) {
        for (var Te = he[ue], pe = 0; pe < V.length; pe++)
          if (O(Te, V[pe]))
            return null;
        var ye = JSON.stringify(V, function(Fe, me) {
          var Pe = ne(me);
          return Pe === "symbol" ? String(me) : me;
        });
        return new _("Invalid " + Ce + " `" + Se + "` of value `" + String(Te) + "` " + ("supplied to `" + fe + "`, expected one of " + ye + "."));
      }
      return P(ee);
    }
    function q(V) {
      function ee(he, ue, fe, Ce, Se) {
        if (typeof V != "function")
          return new _("Property `" + Se + "` of component `" + fe + "` has invalid PropType notation inside objectOf.");
        var Te = he[ue], pe = te(Te);
        if (pe !== "object")
          return new _("Invalid " + Ce + " `" + Se + "` of type " + ("`" + pe + "` supplied to `" + fe + "`, expected an object."));
        for (var ye in Te)
          if (r(Te, ye)) {
            var Oe = V(Te, ye, fe, Ce, Se + "." + ye, n);
            if (Oe instanceof Error)
              return Oe;
          }
        return null;
      }
      return P(ee);
    }
    function J(V) {
      if (!Array.isArray(V))
        return process.env.NODE_ENV !== "production" && s("Invalid argument supplied to oneOfType, expected an instance of array."), l;
      for (var ee = 0; ee < V.length; ee++) {
        var he = V[ee];
        if (typeof he != "function")
          return s(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ae(he) + " at index " + ee + "."
          ), l;
      }
      function ue(fe, Ce, Se, Te, pe) {
        for (var ye = [], Oe = 0; Oe < V.length; Oe++) {
          var Fe = V[Oe], me = Fe(fe, Ce, Se, Te, pe, n);
          if (me == null)
            return null;
          me.data && r(me.data, "expectedType") && ye.push(me.data.expectedType);
        }
        var Pe = ye.length > 0 ? ", expected one of type [" + ye.join(", ") + "]" : "";
        return new _("Invalid " + Te + " `" + pe + "` supplied to " + ("`" + Se + "`" + Pe + "."));
      }
      return P(ue);
    }
    function H() {
      function V(ee, he, ue, fe, Ce) {
        return K(ee[he]) ? null : new _("Invalid " + fe + " `" + Ce + "` supplied to " + ("`" + ue + "`, expected a ReactNode."));
      }
      return P(V);
    }
    function Z(V, ee, he, ue, fe) {
      return new _(
        (V || "React class") + ": " + ee + " type `" + he + "." + ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + fe + "`."
      );
    }
    function re(V) {
      function ee(he, ue, fe, Ce, Se) {
        var Te = he[ue], pe = te(Te);
        if (pe !== "object")
          return new _("Invalid " + Ce + " `" + Se + "` of type `" + pe + "` " + ("supplied to `" + fe + "`, expected `object`."));
        for (var ye in V) {
          var Oe = V[ye];
          if (typeof Oe != "function")
            return Z(fe, Ce, Se, ye, ne(Oe));
          var Fe = Oe(Te, ye, fe, Ce, Se + "." + ye, n);
          if (Fe)
            return Fe;
        }
        return null;
      }
      return P(ee);
    }
    function Y(V) {
      function ee(he, ue, fe, Ce, Se) {
        var Te = he[ue], pe = te(Te);
        if (pe !== "object")
          return new _("Invalid " + Ce + " `" + Se + "` of type `" + pe + "` " + ("supplied to `" + fe + "`, expected `object`."));
        var ye = t({}, he[ue], V);
        for (var Oe in ye) {
          var Fe = V[Oe];
          if (r(V, Oe) && typeof Fe != "function")
            return Z(fe, Ce, Se, Oe, ne(Fe));
          if (!Fe)
            return new _(
              "Invalid " + Ce + " `" + Se + "` key `" + Oe + "` supplied to `" + fe + "`.\nBad object: " + JSON.stringify(he[ue], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(V), null, "  ")
            );
          var me = Fe(Te, Oe, fe, Ce, Se + "." + Oe, n);
          if (me)
            return me;
        }
        return null;
      }
      return P(ee);
    }
    function K(V) {
      switch (typeof V) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !V;
        case "object":
          if (Array.isArray(V))
            return V.every(K);
          if (V === null || p(V))
            return !0;
          var ee = b(V);
          if (ee) {
            var he = ee.call(V), ue;
            if (ee !== V.entries) {
              for (; !(ue = he.next()).done; )
                if (!K(ue.value))
                  return !1;
            } else
              for (; !(ue = he.next()).done; ) {
                var fe = ue.value;
                if (fe && !K(fe[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Q(V, ee) {
      return V === "symbol" ? !0 : ee ? ee["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && ee instanceof Symbol : !1;
    }
    function te(V) {
      var ee = typeof V;
      return Array.isArray(V) ? "array" : V instanceof RegExp ? "object" : Q(ee, V) ? "symbol" : ee;
    }
    function ne(V) {
      if (typeof V > "u" || V === null)
        return "" + V;
      var ee = te(V);
      if (ee === "object") {
        if (V instanceof Date)
          return "date";
        if (V instanceof RegExp)
          return "regexp";
      }
      return ee;
    }
    function ae(V) {
      var ee = ne(V);
      switch (ee) {
        case "array":
        case "object":
          return "an " + ee;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + ee;
        default:
          return ee;
      }
    }
    function se(V) {
      return !V.constructor || !V.constructor.name ? x : V.constructor.name;
    }
    return E.checkPropTypes = a, E.resetWarningCache = a.resetWarningCache, E.PropTypes = E, E;
  }, sk;
}
var lk, Kj;
function Tee() {
  if (Kj)
    return lk;
  Kj = 1;
  var e = L$();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, lk = function() {
    function r(l, p, m, h, g, b) {
      if (b !== e) {
        var x = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw x.name = "Invariant Violation", x;
      }
    }
    r.isRequired = r;
    function a() {
      return r;
    }
    var s = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: a,
      element: r,
      elementType: r,
      instanceOf: a,
      node: r,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return s.PropTypes = s, s;
  }, lk;
}
if (process.env.NODE_ENV !== "production") {
  var _ee = f3(), Oee = !0;
  TD.exports = Cee()(_ee.isElement, Oee);
} else
  TD.exports = Tee()();
var Pee = TD.exports;
const c = /* @__PURE__ */ Uf(Pee);
function Ree(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function m3(e, t, n, r, a) {
  const s = e[t], l = a || t;
  if (s == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let p;
  const m = s.type;
  return typeof m == "function" && !Ree(m) && (p = "Did you accidentally use a plain function component for an element instead?"), p !== void 0 ? new Error(`Invalid ${r} \`${l}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${p} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const h3 = cd(c.element, m3);
h3.isRequired = cd(c.element.isRequired, m3);
const rw = h3;
function kee(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function Dee(e, t, n, r, a) {
  const s = e[t], l = a || t;
  if (s == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let p;
  return typeof s == "function" && !kee(s) && (p = "Did you accidentally provide a plain function component instead?"), p !== void 0 ? new Error(`Invalid ${r} \`${l}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${p} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const cT = cd(c.elementType, Dee), $ee = "exact-prop: ​";
function dT(e) {
  return process.env.NODE_ENV === "production" ? e : {
    ...e,
    [$ee]: (t) => {
      const n = Object.keys(t).filter((r) => !e.hasOwnProperty(r));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((r) => `\`${r}\``).join(", ")}. Please remove them.`) : null;
    }
  };
}
function jf(e) {
  let t = "https://mui.com/production-error/?code=" + e;
  for (let n = 1; n < arguments.length; n += 1)
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified MUI error #" + e + "; visit " + t + " for the full message.";
}
var _D = { exports: {} }, _r = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xj;
function Mee() {
  if (Xj)
    return _r;
  Xj = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), p = Symbol.for("react.server_context"), m = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), O;
  O = Symbol.for("react.module.reference");
  function _(P) {
    if (typeof P == "object" && P !== null) {
      var M = P.$$typeof;
      switch (M) {
        case e:
          switch (P = P.type, P) {
            case n:
            case a:
            case r:
            case h:
            case g:
              return P;
            default:
              switch (P = P && P.$$typeof, P) {
                case p:
                case l:
                case m:
                case x:
                case b:
                case s:
                  return P;
                default:
                  return M;
              }
          }
        case t:
          return M;
      }
    }
  }
  return _r.ContextConsumer = l, _r.ContextProvider = s, _r.Element = e, _r.ForwardRef = m, _r.Fragment = n, _r.Lazy = x, _r.Memo = b, _r.Portal = t, _r.Profiler = a, _r.StrictMode = r, _r.Suspense = h, _r.SuspenseList = g, _r.isAsyncMode = function() {
    return !1;
  }, _r.isConcurrentMode = function() {
    return !1;
  }, _r.isContextConsumer = function(P) {
    return _(P) === l;
  }, _r.isContextProvider = function(P) {
    return _(P) === s;
  }, _r.isElement = function(P) {
    return typeof P == "object" && P !== null && P.$$typeof === e;
  }, _r.isForwardRef = function(P) {
    return _(P) === m;
  }, _r.isFragment = function(P) {
    return _(P) === n;
  }, _r.isLazy = function(P) {
    return _(P) === x;
  }, _r.isMemo = function(P) {
    return _(P) === b;
  }, _r.isPortal = function(P) {
    return _(P) === t;
  }, _r.isProfiler = function(P) {
    return _(P) === a;
  }, _r.isStrictMode = function(P) {
    return _(P) === r;
  }, _r.isSuspense = function(P) {
    return _(P) === h;
  }, _r.isSuspenseList = function(P) {
    return _(P) === g;
  }, _r.isValidElementType = function(P) {
    return typeof P == "string" || typeof P == "function" || P === n || P === a || P === r || P === h || P === g || P === E || typeof P == "object" && P !== null && (P.$$typeof === x || P.$$typeof === b || P.$$typeof === s || P.$$typeof === l || P.$$typeof === m || P.$$typeof === O || P.getModuleId !== void 0);
  }, _r.typeOf = _, _r;
}
var Or = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qj;
function Nee() {
  return Qj || (Qj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), p = Symbol.for("react.server_context"), m = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), b = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), O = !1, _ = !1, P = !1, M = !1, D = !1, N;
    N = Symbol.for("react.module.reference");
    function I(Ee) {
      return !!(typeof Ee == "string" || typeof Ee == "function" || Ee === n || Ee === a || D || Ee === r || Ee === h || Ee === g || M || Ee === E || O || _ || P || typeof Ee == "object" && Ee !== null && (Ee.$$typeof === x || Ee.$$typeof === b || Ee.$$typeof === s || Ee.$$typeof === l || Ee.$$typeof === m || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ee.$$typeof === N || Ee.getModuleId !== void 0));
    }
    function R(Ee) {
      if (typeof Ee == "object" && Ee !== null) {
        var Ke = Ee.$$typeof;
        switch (Ke) {
          case e:
            var oe = Ee.type;
            switch (oe) {
              case n:
              case a:
              case r:
              case h:
              case g:
                return oe;
              default:
                var de = oe && oe.$$typeof;
                switch (de) {
                  case p:
                  case l:
                  case m:
                  case x:
                  case b:
                  case s:
                    return de;
                  default:
                    return Ke;
                }
            }
          case t:
            return Ke;
        }
      }
    }
    var j = l, U = s, q = e, J = m, H = n, Z = x, re = b, Y = t, K = a, Q = r, te = h, ne = g, ae = !1, se = !1;
    function V(Ee) {
      return ae || (ae = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ee(Ee) {
      return se || (se = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function he(Ee) {
      return R(Ee) === l;
    }
    function ue(Ee) {
      return R(Ee) === s;
    }
    function fe(Ee) {
      return typeof Ee == "object" && Ee !== null && Ee.$$typeof === e;
    }
    function Ce(Ee) {
      return R(Ee) === m;
    }
    function Se(Ee) {
      return R(Ee) === n;
    }
    function Te(Ee) {
      return R(Ee) === x;
    }
    function pe(Ee) {
      return R(Ee) === b;
    }
    function ye(Ee) {
      return R(Ee) === t;
    }
    function Oe(Ee) {
      return R(Ee) === a;
    }
    function Fe(Ee) {
      return R(Ee) === r;
    }
    function me(Ee) {
      return R(Ee) === h;
    }
    function Pe(Ee) {
      return R(Ee) === g;
    }
    Or.ContextConsumer = j, Or.ContextProvider = U, Or.Element = q, Or.ForwardRef = J, Or.Fragment = H, Or.Lazy = Z, Or.Memo = re, Or.Portal = Y, Or.Profiler = K, Or.StrictMode = Q, Or.Suspense = te, Or.SuspenseList = ne, Or.isAsyncMode = V, Or.isConcurrentMode = ee, Or.isContextConsumer = he, Or.isContextProvider = ue, Or.isElement = fe, Or.isForwardRef = Ce, Or.isFragment = Se, Or.isLazy = Te, Or.isMemo = pe, Or.isPortal = ye, Or.isProfiler = Oe, Or.isStrictMode = Fe, Or.isSuspense = me, Or.isSuspenseList = Pe, Or.isValidElementType = I, Or.typeOf = R;
  }()), Or;
}
process.env.NODE_ENV === "production" ? _D.exports = Mee() : _D.exports = Nee();
var sy = _D.exports;
const Iee = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function Aee(e) {
  const t = `${e}`.match(Iee);
  return t && t[1] || "";
}
function v3(e, t = "") {
  return e.displayName || e.name || Aee(e) || t;
}
function Zj(e, t, n) {
  const r = v3(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n);
}
function jee(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return v3(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case sy.ForwardRef:
          return Zj(e, e.render, "ForwardRef");
        case sy.Memo:
          return Zj(e, e.type, "memo");
        default:
          return;
      }
  }
}
function Zu(e, t, n, r, a) {
  if (process.env.NODE_ENV === "production")
    return null;
  const s = e[t], l = a || t;
  return s == null ? null : s && s.nodeType !== 1 ? new Error(`Invalid ${r} \`${l}\` supplied to \`${n}\`. Expected an HTMLElement.`) : null;
}
const Lee = c.oneOfType([c.func, c.object]), il = Lee;
function xt(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : jf(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Jj(...e) {
  return e.reduce((t, n) => n == null ? t : function(...a) {
    t.apply(this, a), n.apply(this, a);
  }, () => {
  });
}
function ly(e, t = 166) {
  let n;
  function r(...a) {
    const s = () => {
      e.apply(this, a);
    };
    clearTimeout(n), n = setTimeout(s, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function E0(e, t) {
  return /* @__PURE__ */ C.isValidElement(e) && t.indexOf(e.type.muiName) !== -1;
}
function aa(e) {
  return e && e.ownerDocument || document;
}
function rd(e) {
  return aa(e).defaultView || window;
}
function Fee(e, t) {
  if (process.env.NODE_ENV === "production")
    return () => null;
  const n = t ? {
    ...t.propTypes
  } : null;
  return (a) => (s, l, p, m, h, ...g) => {
    const b = h || l, x = n == null ? void 0 : n[b];
    if (x) {
      const E = x(s, l, p, m, h, ...g);
      if (E)
        return E;
    }
    return typeof s[l] < "u" && !s[a] ? new Error(`The prop \`${b}\` of \`${e}\` can only be used together with the \`${a}\` prop.`) : null;
  };
}
function OD(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
const zee = typeof window < "u" ? C.useLayoutEffect : C.useEffect, ei = zee;
let eL = 0;
function Vee(e) {
  const [t, n] = C.useState(e), r = e || t;
  return C.useEffect(() => {
    t == null && (eL += 1, n(`mui-${eL}`));
  }, [t]), r;
}
const tL = iy["useId".toString()];
function uy(e) {
  if (tL !== void 0) {
    const t = tL();
    return e ?? t;
  }
  return Vee(e);
}
function y3(e, t, n, r, a) {
  if (process.env.NODE_ENV === "production")
    return null;
  const s = a || t;
  return typeof e[t] < "u" ? new Error(`The prop \`${s}\` is not supported. Please remove it.`) : null;
}
function tl({
  controlled: e,
  default: t,
  name: n,
  state: r = "value"
}) {
  const {
    current: a
  } = C.useRef(e !== void 0), [s, l] = C.useState(t), p = a ? e : s;
  if (process.env.NODE_ENV !== "production") {
    C.useEffect(() => {
      a !== (e !== void 0) && console.error([`MUI: A component is changing the ${a ? "" : "un"}controlled ${r} state of ${n} to be ${a ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${n} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [r, n, e]);
    const {
      current: h
    } = C.useRef(t);
    C.useEffect(() => {
      !a && h !== t && console.error([`MUI: A component is changing the default ${r} state of an uncontrolled ${n} after being initialized. To suppress this warning opt to use a controlled ${n}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const m = C.useCallback((h) => {
    a || l(h);
  }, []);
  return [p, m];
}
function Zr(e) {
  const t = C.useRef(e);
  return ei(() => {
    t.current = e;
  }), C.useCallback((...n) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...n)
  ), []);
}
function yo(...e) {
  return C.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      OD(n, t);
    });
  }, e);
}
let fT = !0, PD = !1, nL;
const Uee = {
  text: !0,
  search: !0,
  url: !0,
  tel: !0,
  email: !0,
  password: !0,
  number: !0,
  date: !0,
  month: !0,
  week: !0,
  time: !0,
  datetime: !0,
  "datetime-local": !0
};
function Bee(e) {
  const {
    type: t,
    tagName: n
  } = e;
  return !!(n === "INPUT" && Uee[t] && !e.readOnly || n === "TEXTAREA" && !e.readOnly || e.isContentEditable);
}
function Hee(e) {
  e.metaKey || e.altKey || e.ctrlKey || (fT = !0);
}
function uk() {
  fT = !1;
}
function Wee() {
  this.visibilityState === "hidden" && PD && (fT = !0);
}
function Yee(e) {
  e.addEventListener("keydown", Hee, !0), e.addEventListener("mousedown", uk, !0), e.addEventListener("pointerdown", uk, !0), e.addEventListener("touchstart", uk, !0), e.addEventListener("visibilitychange", Wee, !0);
}
function qee(e) {
  const {
    target: t
  } = e;
  try {
    return t.matches(":focus-visible");
  } catch {
  }
  return fT || Bee(t);
}
function Gee() {
  const e = C.useCallback((a) => {
    a != null && Yee(a.ownerDocument);
  }, []), t = C.useRef(!1);
  function n() {
    return t.current ? (PD = !0, window.clearTimeout(nL), nL = window.setTimeout(() => {
      PD = !1;
    }, 100), t.current = !1, !0) : !1;
  }
  function r(a) {
    return qee(a) ? (t.current = !0, !0) : !1;
  }
  return {
    isFocusVisibleRef: t,
    onFocus: r,
    onBlur: n,
    ref: e
  };
}
function g3(e) {
  const t = e.documentElement.clientWidth;
  return Math.abs(window.innerWidth - t);
}
let Cv;
function b3() {
  if (Cv)
    return Cv;
  const e = document.createElement("div"), t = document.createElement("div");
  return t.style.width = "10px", t.style.height = "1px", e.appendChild(t), e.dir = "rtl", e.style.fontSize = "14px", e.style.width = "4px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.overflow = "scroll", document.body.appendChild(e), Cv = "reverse", e.scrollLeft > 0 ? Cv = "default" : (e.scrollLeft = 1, e.scrollLeft === 0 && (Cv = "negative")), document.body.removeChild(e), Cv;
}
function rL(e, t) {
  const n = e.scrollLeft;
  if (t !== "rtl")
    return n;
  switch (b3()) {
    case "negative":
      return e.scrollWidth - e.clientWidth + n;
    case "reverse":
      return e.scrollWidth - e.clientWidth - n;
    default:
      return n;
  }
}
function Kee(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function Xee(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
const Qee = Number.isInteger || Xee;
function w3(e, t, n, r) {
  const a = e[t];
  if (a == null || !Qee(a)) {
    const s = Kee(a);
    return new RangeError(`Invalid ${r} \`${t}\` of type \`${s}\` supplied to \`${n}\`, expected \`integer\`.`);
  }
  return null;
}
function x3(e, t, ...n) {
  return e[t] === void 0 ? null : w3(e, t, ...n);
}
function RD() {
  return null;
}
x3.isRequired = w3;
RD.isRequired = RD;
const C0 = process.env.NODE_ENV === "production" ? RD : x3;
function F$(e, t) {
  const n = {
    ...t
  };
  return Object.keys(e).forEach((r) => {
    if (r.toString().match(/^(components|slots)$/))
      n[r] = {
        ...e[r],
        ...n[r]
      };
    else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
      const a = e[r] || {}, s = t[r];
      n[r] = {}, !s || !Object.keys(s) ? n[r] = a : !a || !Object.keys(a) ? n[r] = s : (n[r] = {
        ...s
      }, Object.keys(a).forEach((l) => {
        n[r][l] = F$(a[l], s[l]);
      }));
    } else
      n[r] === void 0 && (n[r] = e[r]);
  }), n;
}
function Kt(e, t, n = void 0) {
  const r = {};
  return Object.keys(e).forEach(
    // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (a) => {
      r[a] = e[a].reduce((s, l) => {
        if (l) {
          const p = t(l);
          p !== "" && s.push(p), n && n[l] && s.push(n[l]);
        }
        return s;
      }, []).join(" ");
    }
  ), r;
}
const oL = (e) => e, Zee = () => {
  let e = oL;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = oL;
    }
  };
}, Jee = Zee(), ete = Jee, tte = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  readOnly: "readOnly",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function Xt(e, t, n = "Mui") {
  const r = tte[t];
  return r ? `${n}-${r}` : `${ete.generate(e)}-${t}`;
}
function Bt(e, t, n = "Mui") {
  const r = {};
  return t.forEach((a) => {
    r[a] = Xt(e, a, n);
  }), r;
}
const cy = "$$material";
function B() {
  return B = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, B.apply(this, arguments);
}
function st(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
function S3(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var nte = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, rte = /* @__PURE__ */ S3(
  function(e) {
    return nte.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function ote(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function ate(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var ite = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(a) {
      var s;
      r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(a, s), r.tags.push(a);
    }, this.isSpeedy = n.speedy === void 0 ? process.env.NODE_ENV === "production" : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(ate(this));
    var a = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var s = r.charCodeAt(0) === 64 && r.charCodeAt(1) === 105;
      s && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + r + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !s;
    }
    if (this.isSpeedy) {
      var l = ote(a);
      try {
        l.insertRule(r, l.cssRules.length);
      } catch (p) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(r) && console.error('There was a problem inserting the following rule: "' + r + '"', p);
      }
    } else
      a.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      return r.parentNode && r.parentNode.removeChild(r);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, e;
}(), Qa = "-ms-", dE = "-moz-", gr = "-webkit-", z$ = "comm", V$ = "rule", U$ = "decl", ste = "@import", E3 = "@keyframes", lte = "@layer", ute = Math.abs, pT = String.fromCharCode, cte = Object.assign;
function dte(e, t) {
  return Ra(e, 0) ^ 45 ? (((t << 2 ^ Ra(e, 0)) << 2 ^ Ra(e, 1)) << 2 ^ Ra(e, 2)) << 2 ^ Ra(e, 3) : 0;
}
function C3(e) {
  return e.trim();
}
function fte(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function br(e, t, n) {
  return e.replace(t, n);
}
function kD(e, t) {
  return e.indexOf(t);
}
function Ra(e, t) {
  return e.charCodeAt(t) | 0;
}
function F0(e, t, n) {
  return e.slice(t, n);
}
function Fu(e) {
  return e.length;
}
function B$(e) {
  return e.length;
}
function d1(e, t) {
  return t.push(e), e;
}
function pte(e, t) {
  return e.map(t).join("");
}
var mT = 1, dy = 1, T3 = 0, Zi = 0, Wo = 0, Ty = "";
function hT(e, t, n, r, a, s, l) {
  return { value: e, root: t, parent: n, type: r, props: a, children: s, line: mT, column: dy, length: l, return: "" };
}
function Yb(e, t) {
  return cte(hT("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function mte() {
  return Wo;
}
function hte() {
  return Wo = Zi > 0 ? Ra(Ty, --Zi) : 0, dy--, Wo === 10 && (dy = 1, mT--), Wo;
}
function ws() {
  return Wo = Zi < T3 ? Ra(Ty, Zi++) : 0, dy++, Wo === 10 && (dy = 1, mT++), Wo;
}
function Ku() {
  return Ra(Ty, Zi);
}
function X1() {
  return Zi;
}
function ow(e, t) {
  return F0(Ty, e, t);
}
function z0(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function _3(e) {
  return mT = dy = 1, T3 = Fu(Ty = e), Zi = 0, [];
}
function O3(e) {
  return Ty = "", e;
}
function Q1(e) {
  return C3(ow(Zi - 1, DD(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function vte(e) {
  for (; (Wo = Ku()) && Wo < 33; )
    ws();
  return z0(e) > 2 || z0(Wo) > 3 ? "" : " ";
}
function yte(e, t) {
  for (; --t && ws() && !(Wo < 48 || Wo > 102 || Wo > 57 && Wo < 65 || Wo > 70 && Wo < 97); )
    ;
  return ow(e, X1() + (t < 6 && Ku() == 32 && ws() == 32));
}
function DD(e) {
  for (; ws(); )
    switch (Wo) {
      case e:
        return Zi;
      case 34:
      case 39:
        e !== 34 && e !== 39 && DD(Wo);
        break;
      case 40:
        e === 41 && DD(e);
        break;
      case 92:
        ws();
        break;
    }
  return Zi;
}
function gte(e, t) {
  for (; ws() && e + Wo !== 47 + 10; )
    if (e + Wo === 42 + 42 && Ku() === 47)
      break;
  return "/*" + ow(t, Zi - 1) + "*" + pT(e === 47 ? e : ws());
}
function bte(e) {
  for (; !z0(Ku()); )
    ws();
  return ow(e, Zi);
}
function wte(e) {
  return O3(Z1("", null, null, null, [""], e = _3(e), 0, [0], e));
}
function Z1(e, t, n, r, a, s, l, p, m) {
  for (var h = 0, g = 0, b = l, x = 0, E = 0, O = 0, _ = 1, P = 1, M = 1, D = 0, N = "", I = a, R = s, j = r, U = N; P; )
    switch (O = D, D = ws()) {
      case 40:
        if (O != 108 && Ra(U, b - 1) == 58) {
          kD(U += br(Q1(D), "&", "&\f"), "&\f") != -1 && (M = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        U += Q1(D);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        U += vte(O);
        break;
      case 92:
        U += yte(X1() - 1, 7);
        continue;
      case 47:
        switch (Ku()) {
          case 42:
          case 47:
            d1(xte(gte(ws(), X1()), t, n), m);
            break;
          default:
            U += "/";
        }
        break;
      case 123 * _:
        p[h++] = Fu(U) * M;
      case 125 * _:
      case 59:
      case 0:
        switch (D) {
          case 0:
          case 125:
            P = 0;
          case 59 + g:
            M == -1 && (U = br(U, /\f/g, "")), E > 0 && Fu(U) - b && d1(E > 32 ? iL(U + ";", r, n, b - 1) : iL(br(U, " ", "") + ";", r, n, b - 2), m);
            break;
          case 59:
            U += ";";
          default:
            if (d1(j = aL(U, t, n, h, g, a, p, N, I = [], R = [], b), s), D === 123)
              if (g === 0)
                Z1(U, t, j, j, I, s, b, p, R);
              else
                switch (x === 99 && Ra(U, 3) === 110 ? 100 : x) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Z1(e, j, j, r && d1(aL(e, j, j, 0, 0, a, p, N, a, I = [], b), R), a, R, b, p, r ? I : R);
                    break;
                  default:
                    Z1(U, j, j, j, [""], R, 0, p, R);
                }
        }
        h = g = E = 0, _ = M = 1, N = U = "", b = l;
        break;
      case 58:
        b = 1 + Fu(U), E = O;
      default:
        if (_ < 1) {
          if (D == 123)
            --_;
          else if (D == 125 && _++ == 0 && hte() == 125)
            continue;
        }
        switch (U += pT(D), D * _) {
          case 38:
            M = g > 0 ? 1 : (U += "\f", -1);
            break;
          case 44:
            p[h++] = (Fu(U) - 1) * M, M = 1;
            break;
          case 64:
            Ku() === 45 && (U += Q1(ws())), x = Ku(), g = b = Fu(N = U += bte(X1())), D++;
            break;
          case 45:
            O === 45 && Fu(U) == 2 && (_ = 0);
        }
    }
  return s;
}
function aL(e, t, n, r, a, s, l, p, m, h, g) {
  for (var b = a - 1, x = a === 0 ? s : [""], E = B$(x), O = 0, _ = 0, P = 0; O < r; ++O)
    for (var M = 0, D = F0(e, b + 1, b = ute(_ = l[O])), N = e; M < E; ++M)
      (N = C3(_ > 0 ? x[M] + " " + D : br(D, /&\f/g, x[M]))) && (m[P++] = N);
  return hT(e, t, n, a === 0 ? V$ : p, m, h, g);
}
function xte(e, t, n) {
  return hT(e, t, n, z$, pT(mte()), F0(e, 2, -2), 0);
}
function iL(e, t, n, r) {
  return hT(e, t, n, U$, F0(e, 0, r), F0(e, r + 1, -1), r);
}
function Zv(e, t) {
  for (var n = "", r = B$(e), a = 0; a < r; a++)
    n += t(e[a], a, e, t) || "";
  return n;
}
function Ste(e, t, n, r) {
  switch (e.type) {
    case lte:
      if (e.children.length)
        break;
    case ste:
    case U$:
      return e.return = e.return || e.value;
    case z$:
      return "";
    case E3:
      return e.return = e.value + "{" + Zv(e.children, r) + "}";
    case V$:
      e.value = e.props.join(",");
  }
  return Fu(n = Zv(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Ete(e) {
  var t = B$(e);
  return function(n, r, a, s) {
    for (var l = "", p = 0; p < t; p++)
      l += e[p](n, r, a, s) || "";
    return l;
  };
}
function Cte(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
var sL = function(t) {
  var n = /* @__PURE__ */ new WeakMap();
  return function(r) {
    if (n.has(r))
      return n.get(r);
    var a = t(r);
    return n.set(r, a), a;
  };
}, Tte = function(t, n, r) {
  for (var a = 0, s = 0; a = s, s = Ku(), a === 38 && s === 12 && (n[r] = 1), !z0(s); )
    ws();
  return ow(t, Zi);
}, _te = function(t, n) {
  var r = -1, a = 44;
  do
    switch (z0(a)) {
      case 0:
        a === 38 && Ku() === 12 && (n[r] = 1), t[r] += Tte(Zi - 1, n, r);
        break;
      case 2:
        t[r] += Q1(a);
        break;
      case 4:
        if (a === 44) {
          t[++r] = Ku() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += pT(a);
    }
  while (a = ws());
  return t;
}, Ote = function(t, n) {
  return O3(_te(_3(t), n));
}, lL = /* @__PURE__ */ new WeakMap(), Pte = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, a = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r)
        return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !lL.get(r)) && !a) {
      lL.set(t, !0);
      for (var s = [], l = Ote(n, s), p = r.props, m = 0, h = 0; m < l.length; m++)
        for (var g = 0; g < p.length; g++, h++)
          t.props[h] = s[m] ? l[m].replace(/&\f/g, p[g]) : p[g] + " " + l[m];
    }
  }
}, Rte = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
}, kte = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", Dte = function(t) {
  return t.type === "comm" && t.children.indexOf(kte) > -1;
}, $te = function(t) {
  return function(n, r, a) {
    if (!(n.type !== "rule" || t.compat)) {
      var s = n.value.match(/(:first|:nth|:nth-last)-child/g);
      if (s) {
        for (var l = !!n.parent, p = l ? n.parent.children : (
          // global rule at the root level
          a
        ), m = p.length - 1; m >= 0; m--) {
          var h = p[m];
          if (h.line < n.line)
            break;
          if (h.column < n.column) {
            if (Dte(h))
              return;
            break;
          }
        }
        s.forEach(function(g) {
          console.error('The pseudo class "' + g + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + g.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, P3 = function(t) {
  return t.type.charCodeAt(1) === 105 && t.type.charCodeAt(0) === 64;
}, Mte = function(t, n) {
  for (var r = t - 1; r >= 0; r--)
    if (!P3(n[r]))
      return !0;
  return !1;
}, uL = function(t) {
  t.type = "", t.value = "", t.return = "", t.children = "", t.props = "";
}, Nte = function(t, n, r) {
  P3(t) && (t.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), uL(t)) : Mte(n, r) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), uL(t)));
};
function R3(e, t) {
  switch (dte(e, t)) {
    case 5103:
      return gr + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return gr + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return gr + e + dE + e + Qa + e + e;
    case 6828:
    case 4268:
      return gr + e + Qa + e + e;
    case 6165:
      return gr + e + Qa + "flex-" + e + e;
    case 5187:
      return gr + e + br(e, /(\w+).+(:[^]+)/, gr + "box-$1$2" + Qa + "flex-$1$2") + e;
    case 5443:
      return gr + e + Qa + "flex-item-" + br(e, /flex-|-self/, "") + e;
    case 4675:
      return gr + e + Qa + "flex-line-pack" + br(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return gr + e + Qa + br(e, "shrink", "negative") + e;
    case 5292:
      return gr + e + Qa + br(e, "basis", "preferred-size") + e;
    case 6060:
      return gr + "box-" + br(e, "-grow", "") + gr + e + Qa + br(e, "grow", "positive") + e;
    case 4554:
      return gr + br(e, /([^-])(transform)/g, "$1" + gr + "$2") + e;
    case 6187:
      return br(br(br(e, /(zoom-|grab)/, gr + "$1"), /(image-set)/, gr + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return br(e, /(image-set\([^]*)/, gr + "$1$`$1");
    case 4968:
      return br(br(e, /(.+:)(flex-)?(.*)/, gr + "box-pack:$3" + Qa + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + gr + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return br(e, /(.+)-inline(.+)/, gr + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Fu(e) - 1 - t > 6)
        switch (Ra(e, t + 1)) {
          case 109:
            if (Ra(e, t + 4) !== 45)
              break;
          case 102:
            return br(e, /(.+:)(.+)-([^]+)/, "$1" + gr + "$2-$3$1" + dE + (Ra(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~kD(e, "stretch") ? R3(br(e, "stretch", "fill-available"), t) + e : e;
        }
      break;
    case 4949:
      if (Ra(e, t + 1) !== 115)
        break;
    case 6444:
      switch (Ra(e, Fu(e) - 3 - (~kD(e, "!important") && 10))) {
        case 107:
          return br(e, ":", ":" + gr) + e;
        case 101:
          return br(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + gr + (Ra(e, 14) === 45 ? "inline-" : "") + "box$3$1" + gr + "$2$3$1" + Qa + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (Ra(e, t + 11)) {
        case 114:
          return gr + e + Qa + br(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return gr + e + Qa + br(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return gr + e + Qa + br(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return gr + e + Qa + e + e;
  }
  return e;
}
var Ite = function(t, n, r, a) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case U$:
        t.return = R3(t.value, t.length);
        break;
      case E3:
        return Zv([Yb(t, {
          value: br(t.value, "@", "@" + gr)
        })], a);
      case V$:
        if (t.length)
          return pte(t.props, function(s) {
            switch (fte(s, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return Zv([Yb(t, {
                  props: [br(s, /:(read-\w+)/, ":" + dE + "$1")]
                })], a);
              case "::placeholder":
                return Zv([Yb(t, {
                  props: [br(s, /:(plac\w+)/, ":" + gr + "input-$1")]
                }), Yb(t, {
                  props: [br(s, /:(plac\w+)/, ":" + dE + "$1")]
                }), Yb(t, {
                  props: [br(s, /:(plac\w+)/, Qa + "input-$1")]
                })], a);
            }
            return "";
          });
    }
}, Ate = [Ite], k3 = function(t) {
  var n = t.key;
  if (process.env.NODE_ENV !== "production" && !n)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(_) {
      var P = _.getAttribute("data-emotion");
      P.indexOf(" ") !== -1 && (document.head.appendChild(_), _.setAttribute("data-s", ""));
    });
  }
  var a = t.stylisPlugins || Ate;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(n))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + n + '" was passed');
  var s = {}, l, p = [];
  l = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(_) {
      for (var P = _.getAttribute("data-emotion").split(" "), M = 1; M < P.length; M++)
        s[P[M]] = !0;
      p.push(_);
    }
  );
  var m, h = [Pte, Rte];
  process.env.NODE_ENV !== "production" && h.push($te({
    get compat() {
      return O.compat;
    }
  }), Nte);
  {
    var g, b = [Ste, process.env.NODE_ENV !== "production" ? function(_) {
      _.root || (_.return ? g.insert(_.return) : _.value && _.type !== z$ && g.insert(_.value + "{}"));
    } : Cte(function(_) {
      g.insert(_);
    })], x = Ete(h.concat(a, b)), E = function(P) {
      return Zv(wte(P), x);
    };
    m = function(P, M, D, N) {
      g = D, process.env.NODE_ENV !== "production" && M.map !== void 0 && (g = {
        insert: function(R) {
          D.insert(R + M.map);
        }
      }), E(P ? P + "{" + M.styles + "}" : M.styles), N && (O.inserted[M.name] = !0);
    };
  }
  var O = {
    key: n,
    sheet: new ite({
      key: n,
      container: l,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: s,
    registered: {},
    insert: m
  };
  return O.sheet.hydrate(p), O;
}, $D = { exports: {} }, Pr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cL;
function jte() {
  if (cL)
    return Pr;
  cL = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, p = e ? Symbol.for("react.context") : 60110, m = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, x = e ? Symbol.for("react.suspense_list") : 60120, E = e ? Symbol.for("react.memo") : 60115, O = e ? Symbol.for("react.lazy") : 60116, _ = e ? Symbol.for("react.block") : 60121, P = e ? Symbol.for("react.fundamental") : 60117, M = e ? Symbol.for("react.responder") : 60118, D = e ? Symbol.for("react.scope") : 60119;
  function N(R) {
    if (typeof R == "object" && R !== null) {
      var j = R.$$typeof;
      switch (j) {
        case t:
          switch (R = R.type, R) {
            case m:
            case h:
            case r:
            case s:
            case a:
            case b:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case p:
                case g:
                case O:
                case E:
                case l:
                  return R;
                default:
                  return j;
              }
          }
        case n:
          return j;
      }
    }
  }
  function I(R) {
    return N(R) === h;
  }
  return Pr.AsyncMode = m, Pr.ConcurrentMode = h, Pr.ContextConsumer = p, Pr.ContextProvider = l, Pr.Element = t, Pr.ForwardRef = g, Pr.Fragment = r, Pr.Lazy = O, Pr.Memo = E, Pr.Portal = n, Pr.Profiler = s, Pr.StrictMode = a, Pr.Suspense = b, Pr.isAsyncMode = function(R) {
    return I(R) || N(R) === m;
  }, Pr.isConcurrentMode = I, Pr.isContextConsumer = function(R) {
    return N(R) === p;
  }, Pr.isContextProvider = function(R) {
    return N(R) === l;
  }, Pr.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, Pr.isForwardRef = function(R) {
    return N(R) === g;
  }, Pr.isFragment = function(R) {
    return N(R) === r;
  }, Pr.isLazy = function(R) {
    return N(R) === O;
  }, Pr.isMemo = function(R) {
    return N(R) === E;
  }, Pr.isPortal = function(R) {
    return N(R) === n;
  }, Pr.isProfiler = function(R) {
    return N(R) === s;
  }, Pr.isStrictMode = function(R) {
    return N(R) === a;
  }, Pr.isSuspense = function(R) {
    return N(R) === b;
  }, Pr.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === h || R === s || R === a || R === b || R === x || typeof R == "object" && R !== null && (R.$$typeof === O || R.$$typeof === E || R.$$typeof === l || R.$$typeof === p || R.$$typeof === g || R.$$typeof === P || R.$$typeof === M || R.$$typeof === D || R.$$typeof === _);
  }, Pr.typeOf = N, Pr;
}
var Rr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dL;
function Lte() {
  return dL || (dL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, a = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, p = e ? Symbol.for("react.context") : 60110, m = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, b = e ? Symbol.for("react.suspense") : 60113, x = e ? Symbol.for("react.suspense_list") : 60120, E = e ? Symbol.for("react.memo") : 60115, O = e ? Symbol.for("react.lazy") : 60116, _ = e ? Symbol.for("react.block") : 60121, P = e ? Symbol.for("react.fundamental") : 60117, M = e ? Symbol.for("react.responder") : 60118, D = e ? Symbol.for("react.scope") : 60119;
    function N(me) {
      return typeof me == "string" || typeof me == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      me === r || me === h || me === s || me === a || me === b || me === x || typeof me == "object" && me !== null && (me.$$typeof === O || me.$$typeof === E || me.$$typeof === l || me.$$typeof === p || me.$$typeof === g || me.$$typeof === P || me.$$typeof === M || me.$$typeof === D || me.$$typeof === _);
    }
    function I(me) {
      if (typeof me == "object" && me !== null) {
        var Pe = me.$$typeof;
        switch (Pe) {
          case t:
            var Ee = me.type;
            switch (Ee) {
              case m:
              case h:
              case r:
              case s:
              case a:
              case b:
                return Ee;
              default:
                var Ke = Ee && Ee.$$typeof;
                switch (Ke) {
                  case p:
                  case g:
                  case O:
                  case E:
                  case l:
                    return Ke;
                  default:
                    return Pe;
                }
            }
          case n:
            return Pe;
        }
      }
    }
    var R = m, j = h, U = p, q = l, J = t, H = g, Z = r, re = O, Y = E, K = n, Q = s, te = a, ne = b, ae = !1;
    function se(me) {
      return ae || (ae = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), V(me) || I(me) === m;
    }
    function V(me) {
      return I(me) === h;
    }
    function ee(me) {
      return I(me) === p;
    }
    function he(me) {
      return I(me) === l;
    }
    function ue(me) {
      return typeof me == "object" && me !== null && me.$$typeof === t;
    }
    function fe(me) {
      return I(me) === g;
    }
    function Ce(me) {
      return I(me) === r;
    }
    function Se(me) {
      return I(me) === O;
    }
    function Te(me) {
      return I(me) === E;
    }
    function pe(me) {
      return I(me) === n;
    }
    function ye(me) {
      return I(me) === s;
    }
    function Oe(me) {
      return I(me) === a;
    }
    function Fe(me) {
      return I(me) === b;
    }
    Rr.AsyncMode = R, Rr.ConcurrentMode = j, Rr.ContextConsumer = U, Rr.ContextProvider = q, Rr.Element = J, Rr.ForwardRef = H, Rr.Fragment = Z, Rr.Lazy = re, Rr.Memo = Y, Rr.Portal = K, Rr.Profiler = Q, Rr.StrictMode = te, Rr.Suspense = ne, Rr.isAsyncMode = se, Rr.isConcurrentMode = V, Rr.isContextConsumer = ee, Rr.isContextProvider = he, Rr.isElement = ue, Rr.isForwardRef = fe, Rr.isFragment = Ce, Rr.isLazy = Se, Rr.isMemo = Te, Rr.isPortal = pe, Rr.isProfiler = ye, Rr.isStrictMode = Oe, Rr.isSuspense = Fe, Rr.isValidElementType = N, Rr.typeOf = I;
  }()), Rr;
}
process.env.NODE_ENV === "production" ? $D.exports = jte() : $D.exports = Lte();
var Fte = $D.exports, D3 = Fte, zte = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, Vte = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, $3 = {};
$3[D3.ForwardRef] = zte;
$3[D3.Memo] = Vte;
var Ute = !0;
function vT(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(a) {
    e[a] !== void 0 ? t.push(e[a] + ";") : r += a + " ";
  }), r;
}
var yT = function(t, n, r) {
  var a = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  Ute === !1) && t.registered[a] === void 0 && (t.registered[a] = n.styles);
}, aw = function(t, n, r) {
  yT(t, n, r);
  var a = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var s = n;
    do
      t.insert(n === s ? "." + a : "", s, t.sheet, !0), s = s.next;
    while (s !== void 0);
  }
};
function Bte(e) {
  for (var t = 0, n, r = 0, a = e.length; a >= 4; ++r, a -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Hte = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, fL = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, Wte = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", Yte = /[A-Z]|^ms/g, M3 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, H$ = function(t) {
  return t.charCodeAt(1) === 45;
}, pL = function(t) {
  return t != null && typeof t != "boolean";
}, ck = /* @__PURE__ */ S3(function(e) {
  return H$(e) ? e : e.replace(Yte, "-$&").toLowerCase();
}), fE = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(M3, function(r, a, s) {
          return zl = {
            name: a,
            styles: s,
            next: zl
          }, a;
        });
  }
  return Hte[t] !== 1 && !H$(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
if (process.env.NODE_ENV !== "production") {
  var qte = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, Gte = ["normal", "none", "initial", "inherit", "unset"], Kte = fE, Xte = /^-ms-/, Qte = /-(.)/g, mL = {};
  fE = function(t, n) {
    if (t === "content" && (typeof n != "string" || Gte.indexOf(n) === -1 && !qte.test(n) && (n.charAt(0) !== n.charAt(n.length - 1) || n.charAt(0) !== '"' && n.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + n + "\"'`");
    var r = Kte(t, n);
    return r !== "" && !H$(t) && t.indexOf("-") !== -1 && mL[t] === void 0 && (mL[t] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + t.replace(Xte, "ms-").replace(Qte, function(a, s) {
      return s.toUpperCase();
    }) + "?")), r;
  };
}
var N3 = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function V0(e, t, n) {
  if (n == null)
    return "";
  if (n.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && n.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(N3);
    return n;
  }
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      if (n.anim === 1)
        return zl = {
          name: n.name,
          styles: n.styles,
          next: zl
        }, n.name;
      if (n.styles !== void 0) {
        var r = n.next;
        if (r !== void 0)
          for (; r !== void 0; )
            zl = {
              name: r.name,
              styles: r.styles,
              next: zl
            }, r = r.next;
        var a = n.styles + ";";
        return process.env.NODE_ENV !== "production" && n.map !== void 0 && (a += n.map), a;
      }
      return Zte(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var s = zl, l = n(e);
        return zl = s, V0(e, t, l);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var p = [], m = n.replace(M3, function(g, b, x) {
          var E = "animation" + p.length;
          return p.push("const " + E + " = keyframes`" + x.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + E + "}";
        });
        p.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(p, ["`" + m + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + m + "`"));
      }
      break;
  }
  if (t == null)
    return n;
  var h = t[n];
  return h !== void 0 ? h : n;
}
function Zte(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var a = 0; a < n.length; a++)
      r += V0(e, t, n[a]) + ";";
  else
    for (var s in n) {
      var l = n[s];
      if (typeof l != "object")
        t != null && t[l] !== void 0 ? r += s + "{" + t[l] + "}" : pL(l) && (r += ck(s) + ":" + fE(s, l) + ";");
      else {
        if (s === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(N3);
        if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
          for (var p = 0; p < l.length; p++)
            pL(l[p]) && (r += ck(s) + ":" + fE(s, l[p]) + ";");
        else {
          var m = V0(e, t, l);
          switch (s) {
            case "animation":
            case "animationName": {
              r += ck(s) + ":" + m + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && s === "undefined" && console.error(Wte), r += s + "{" + m + "}";
          }
        }
      }
    }
  return r;
}
var hL = /label:\s*([^\s;\n{]+)\s*(;|$)/g, I3;
process.env.NODE_ENV !== "production" && (I3 = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var zl, Sm = function(t, n, r) {
  if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
    return t[0];
  var a = !0, s = "";
  zl = void 0;
  var l = t[0];
  l == null || l.raw === void 0 ? (a = !1, s += V0(r, n, l)) : (process.env.NODE_ENV !== "production" && l[0] === void 0 && console.error(fL), s += l[0]);
  for (var p = 1; p < t.length; p++)
    s += V0(r, n, t[p]), a && (process.env.NODE_ENV !== "production" && l[p] === void 0 && console.error(fL), s += l[p]);
  var m;
  process.env.NODE_ENV !== "production" && (s = s.replace(I3, function(x) {
    return m = x, "";
  })), hL.lastIndex = 0;
  for (var h = "", g; (g = hL.exec(s)) !== null; )
    h += "-" + // $FlowFixMe we know it's not null
    g[1];
  var b = Bte(s) + h;
  return process.env.NODE_ENV !== "production" ? {
    name: b,
    styles: s,
    map: m,
    next: zl,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: b,
    styles: s,
    next: zl
  };
}, Jte = function(t) {
  return t();
}, A3 = iy["useInsertionEffect"] ? iy["useInsertionEffect"] : !1, W$ = A3 || Jte, vL = A3 || C.useLayoutEffect, ene = {}.hasOwnProperty, Y$ = /* @__PURE__ */ C.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ k3({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (Y$.displayName = "EmotionCacheContext");
Y$.Provider;
var gT = function(t) {
  return /* @__PURE__ */ C.forwardRef(function(n, r) {
    var a = C.useContext(Y$);
    return t(n, a, r);
  });
}, od = /* @__PURE__ */ C.createContext({});
process.env.NODE_ENV !== "production" && (od.displayName = "EmotionThemeContext");
var tne = function(t, n) {
  if (typeof n == "function") {
    var r = n(t);
    if (process.env.NODE_ENV !== "production" && (r == null || typeof r != "object" || Array.isArray(r)))
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    return r;
  }
  if (process.env.NODE_ENV !== "production" && (n == null || typeof n != "object" || Array.isArray(n)))
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  return B({}, t, n);
}, nne = /* @__PURE__ */ sL(function(e) {
  return sL(function(t) {
    return tne(e, t);
  });
}), rne = function(t) {
  var n = C.useContext(od);
  return t.theme !== n && (n = nne(n)(t.theme)), /* @__PURE__ */ C.createElement(od.Provider, {
    value: n
  }, t.children);
}, yL = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", gL = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", one = function(t) {
  var n = t.cache, r = t.serialized, a = t.isStringTag;
  return yT(n, r, a), W$(function() {
    return aw(n, r, a);
  }), null;
}, ane = /* @__PURE__ */ gT(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var a = e[yL], s = [r], l = "";
  typeof e.className == "string" ? l = vT(t.registered, s, e.className) : e.className != null && (l = e.className + " ");
  var p = Sm(s, void 0, C.useContext(od));
  if (process.env.NODE_ENV !== "production" && p.name.indexOf("-") === -1) {
    var m = e[gL];
    m && (p = Sm([p, "label:" + m + ";"]));
  }
  l += t.key + "-" + p.name;
  var h = {};
  for (var g in e)
    ene.call(e, g) && g !== "css" && g !== yL && (process.env.NODE_ENV === "production" || g !== gL) && (h[g] = e[g]);
  return h.ref = n, h.className = l, /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(one, {
    cache: t,
    serialized: p,
    isStringTag: typeof a == "string"
  }), /* @__PURE__ */ C.createElement(a, h));
});
process.env.NODE_ENV !== "production" && (ane.displayName = "EmotionCssPropInternal");
var ine = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, bL = !1, _y = /* @__PURE__ */ gT(function(e, t) {
  process.env.NODE_ENV !== "production" && !bL && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (e.className || e.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), bL = !0);
  var n = e.styles, r = Sm([n], void 0, C.useContext(od)), a = C.useRef();
  return vL(function() {
    var s = t.key + "-global", l = new t.sheet.constructor({
      key: s,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), p = !1, m = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
    return t.sheet.tags.length && (l.before = t.sheet.tags[0]), m !== null && (p = !0, m.setAttribute("data-emotion", s), l.hydrate([m])), a.current = [l, p], function() {
      l.flush();
    };
  }, [t]), vL(function() {
    var s = a.current, l = s[0], p = s[1];
    if (p) {
      s[1] = !1;
      return;
    }
    if (r.next !== void 0 && aw(t, r.next, !0), l.tags.length) {
      var m = l.tags[l.tags.length - 1].nextElementSibling;
      l.before = m, l.flush();
    }
    t.insert("", r, l, !1);
  }, [t, r.name]), null;
});
process.env.NODE_ENV !== "production" && (_y.displayName = "EmotionGlobal");
function sne() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Sm(t);
}
var dd = function() {
  var t = sne.apply(void 0, arguments), n = "animation-" + t.name;
  return {
    name: n,
    styles: "@keyframes " + n + "{" + t.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, lne = function e(t) {
  for (var n = t.length, r = 0, a = ""; r < n; r++) {
    var s = t[r];
    if (s != null) {
      var l = void 0;
      switch (typeof s) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(s))
            l = e(s);
          else {
            process.env.NODE_ENV !== "production" && s.styles !== void 0 && s.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), l = "";
            for (var p in s)
              s[p] && p && (l && (l += " "), l += p);
          }
          break;
        }
        default:
          l = s;
      }
      l && (a && (a += " "), a += l);
    }
  }
  return a;
};
function une(e, t, n) {
  var r = [], a = vT(e, r, n);
  return r.length < 2 ? n : a + t(r);
}
var cne = function(t) {
  var n = t.cache, r = t.serializedArr;
  return W$(function() {
    for (var a = 0; a < r.length; a++)
      aw(n, r[a], !1);
  }), null;
}, dne = /* @__PURE__ */ gT(function(e, t) {
  var n = !1, r = [], a = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var h = arguments.length, g = new Array(h), b = 0; b < h; b++)
      g[b] = arguments[b];
    var x = Sm(g, t.registered);
    return r.push(x), yT(t, x, !1), t.key + "-" + x.name;
  }, s = function() {
    if (n && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var h = arguments.length, g = new Array(h), b = 0; b < h; b++)
      g[b] = arguments[b];
    return une(t.registered, a, lne(g));
  }, l = {
    css: a,
    cx: s,
    theme: C.useContext(od)
  }, p = e.children(l);
  return n = !0, /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(cne, {
    cache: t,
    serializedArr: r
  }), p);
});
process.env.NODE_ENV !== "production" && (dne.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var wL = !0, fne = typeof jest < "u" || typeof vi < "u";
  if (wL && !fne) {
    var xL = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : wL ? window : global
    ), SL = "__EMOTION_REACT_" + ine.version.split(".")[0] + "__";
    xL[SL] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), xL[SL] = !0;
  }
}
var pne = rte, mne = function(t) {
  return t !== "theme";
}, EL = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? pne : mne;
}, CL = function(t, n, r) {
  var a;
  if (n) {
    var s = n.shouldForwardProp;
    a = t.__emotion_forwardProp && s ? function(l) {
      return t.__emotion_forwardProp(l) && s(l);
    } : s;
  }
  return typeof a != "function" && r && (a = t.__emotion_forwardProp), a;
}, TL = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, hne = function(t) {
  var n = t.cache, r = t.serialized, a = t.isStringTag;
  return yT(n, r, a), W$(function() {
    return aw(n, r, a);
  }), null;
}, vne = function e(t, n) {
  if (process.env.NODE_ENV !== "production" && t === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var r = t.__emotion_real === t, a = r && t.__emotion_base || t, s, l;
  n !== void 0 && (s = n.label, l = n.target);
  var p = CL(t, n, r), m = p || EL(a), h = !m("as");
  return function() {
    var g = arguments, b = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (s !== void 0 && b.push("label:" + s + ";"), g[0] == null || g[0].raw === void 0)
      b.push.apply(b, g);
    else {
      process.env.NODE_ENV !== "production" && g[0][0] === void 0 && console.error(TL), b.push(g[0][0]);
      for (var x = g.length, E = 1; E < x; E++)
        process.env.NODE_ENV !== "production" && g[0][E] === void 0 && console.error(TL), b.push(g[E], g[0][E]);
    }
    var O = gT(function(_, P, M) {
      var D = h && _.as || a, N = "", I = [], R = _;
      if (_.theme == null) {
        R = {};
        for (var j in _)
          R[j] = _[j];
        R.theme = C.useContext(od);
      }
      typeof _.className == "string" ? N = vT(P.registered, I, _.className) : _.className != null && (N = _.className + " ");
      var U = Sm(b.concat(I), P.registered, R);
      N += P.key + "-" + U.name, l !== void 0 && (N += " " + l);
      var q = h && p === void 0 ? EL(D) : m, J = {};
      for (var H in _)
        h && H === "as" || // $FlowFixMe
        q(H) && (J[H] = _[H]);
      return J.className = N, J.ref = M, /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(hne, {
        cache: P,
        serialized: U,
        isStringTag: typeof D == "string"
      }), /* @__PURE__ */ C.createElement(D, J));
    });
    return O.displayName = s !== void 0 ? s : "Styled(" + (typeof a == "string" ? a : a.displayName || a.name || "Component") + ")", O.defaultProps = t.defaultProps, O.__emotion_real = O, O.__emotion_base = a, O.__emotion_styles = b, O.__emotion_forwardProp = p, Object.defineProperty(O, "toString", {
      value: function() {
        return l === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + l;
      }
    }), O.withComponent = function(_, P) {
      return e(_, B({}, n, P, {
        shouldForwardProp: CL(O, P, !0)
      })).apply(void 0, b);
    }, O;
  };
}, yne = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], MD = vne.bind();
yne.forEach(function(e) {
  MD[e] = MD(e);
});
function gne(e) {
  return e == null || Object.keys(e).length === 0;
}
function j3(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (a) => t(gne(a) ? n : a) : t;
  return /* @__PURE__ */ L.jsx(_y, {
    styles: r
  });
}
process.env.NODE_ENV !== "production" && (j3.propTypes = {
  defaultTheme: c.object,
  styles: c.oneOfType([c.array, c.string, c.object, c.func])
});
/**
 * @mui/styled-engine v5.13.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function bne(e, t) {
  const n = MD(e, t);
  return process.env.NODE_ENV !== "production" ? (...r) => {
    const a = typeof e == "string" ? `"${e}"` : "component";
    return r.length === 0 ? console.error([`MUI: Seems like you called \`styled(${a})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : r.some((s) => s === void 0) && console.error(`MUI: the styled(${a})(...args) API requires all its args to be defined.`), n(...r);
  } : n;
}
const wne = (e, t) => {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}, xne = ["values", "unit", "step"], Sne = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => B({}, n, {
    [r.key]: r.val
  }), {});
};
function Ene(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5
  } = e, a = st(e, xne), s = Sne(t), l = Object.keys(s);
  function p(x) {
    return `@media (min-width:${typeof t[x] == "number" ? t[x] : x}${n})`;
  }
  function m(x) {
    return `@media (max-width:${(typeof t[x] == "number" ? t[x] : x) - r / 100}${n})`;
  }
  function h(x, E) {
    const O = l.indexOf(E);
    return `@media (min-width:${typeof t[x] == "number" ? t[x] : x}${n}) and (max-width:${(O !== -1 && typeof t[l[O]] == "number" ? t[l[O]] : E) - r / 100}${n})`;
  }
  function g(x) {
    return l.indexOf(x) + 1 < l.length ? h(x, l[l.indexOf(x) + 1]) : p(x);
  }
  function b(x) {
    const E = l.indexOf(x);
    return E === 0 ? p(l[1]) : E === l.length - 1 ? m(l[E]) : h(x, l[l.indexOf(x) + 1]).replace("@media", "@media not all and");
  }
  return B({
    keys: l,
    values: s,
    up: p,
    down: m,
    between: h,
    only: g,
    not: b,
    unit: n
  }, a);
}
const Cne = {
  borderRadius: 4
}, Tne = Cne, _ne = process.env.NODE_ENV !== "production" ? c.oneOfType([c.number, c.string, c.object, c.array]) : {}, Bf = _ne;
function T0(e, t) {
  return t ? Ks(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const q$ = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, _L = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${q$[e]}px)`
};
function nl(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const s = r.breakpoints || _L;
    return t.reduce((l, p, m) => (l[s.up(s.keys[m])] = n(t[m]), l), {});
  }
  if (typeof t == "object") {
    const s = r.breakpoints || _L;
    return Object.keys(t).reduce((l, p) => {
      if (Object.keys(s.values || q$).indexOf(p) !== -1) {
        const m = s.up(p);
        l[m] = n(t[p], p);
      } else {
        const m = p;
        l[m] = t[m];
      }
      return l;
    }, {});
  }
  return n(t);
}
function One(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((r, a) => {
    const s = e.up(a);
    return r[s] = {}, r;
  }, {})) || {};
}
function Pne(e, t) {
  return e.reduce((n, r) => {
    const a = n[r];
    return (!a || Object.keys(a).length === 0) && delete n[r], n;
  }, t);
}
function Rne(e, t) {
  if (typeof e != "object")
    return {};
  const n = {}, r = Object.keys(t);
  return Array.isArray(e) ? r.forEach((a, s) => {
    s < e.length && (n[a] = !0);
  }) : r.forEach((a) => {
    e[a] != null && (n[a] = !0);
  }), n;
}
function bT({
  values: e,
  breakpoints: t,
  base: n
}) {
  const r = n || Rne(e, t), a = Object.keys(r);
  if (a.length === 0)
    return e;
  let s;
  return a.reduce((l, p, m) => (Array.isArray(e) ? (l[p] = e[m] != null ? e[m] : e[s], s = m) : typeof e == "object" ? (l[p] = e[p] != null ? e[p] : e[s], s = p) : l[p] = e, l), {});
}
function wT(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((a, s) => a && a[s] ? a[s] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, a) => r && r[a] != null ? r[a] : null, e);
}
function pE(e, t, n, r = n) {
  let a;
  return typeof e == "function" ? a = e(n) : Array.isArray(e) ? a = e[n] || r : a = wT(e, n) || r, t && (a = t(a, r, e)), a;
}
function kr(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: a
  } = e, s = (l) => {
    if (l[t] == null)
      return null;
    const p = l[t], m = l.theme, h = wT(m, r) || {};
    return nl(l, p, (b) => {
      let x = pE(h, a, b);
      return b === x && typeof b == "string" && (x = pE(h, a, `${t}${b === "default" ? "" : xt(b)}`, b)), n === !1 ? x : {
        [n]: x
      };
    });
  };
  return s.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: Bf
  } : {}, s.filterProps = [t], s;
}
function kne(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const Dne = {
  m: "margin",
  p: "padding"
}, $ne = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, OL = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, Mne = kne((e) => {
  if (e.length > 2)
    if (OL[e])
      e = OL[e];
    else
      return [e];
  const [t, n] = e.split(""), r = Dne[t], a = $ne[n] || "";
  return Array.isArray(a) ? a.map((s) => r + s) : [r + a];
}), xT = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], ST = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], Nne = [...xT, ...ST];
function iw(e, t, n, r) {
  var a;
  const s = (a = wT(e, t, !1)) != null ? a : n;
  return typeof s == "number" ? (l) => typeof l == "string" ? l : (process.env.NODE_ENV !== "production" && typeof l != "number" && console.error(`MUI: Expected ${r} argument to be a number or a string, got ${l}.`), s * l) : Array.isArray(s) ? (l) => typeof l == "string" ? l : (process.env.NODE_ENV !== "production" && (Number.isInteger(l) ? l > s.length - 1 && console.error([`MUI: The value provided (${l}) overflows.`, `The supported values are: ${JSON.stringify(s)}.`, `${l} > ${s.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`))), s[l]) : typeof s == "function" ? s : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${s}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function L3(e) {
  return iw(e, "spacing", 8, "spacing");
}
function sw(e, t) {
  if (typeof t == "string" || t == null)
    return t;
  const n = Math.abs(t), r = e(n);
  return t >= 0 ? r : typeof r == "number" ? -r : `-${r}`;
}
function Ine(e, t) {
  return (n) => e.reduce((r, a) => (r[a] = sw(t, n), r), {});
}
function Ane(e, t, n, r) {
  if (t.indexOf(n) === -1)
    return null;
  const a = Mne(n), s = Ine(a, r), l = e[n];
  return nl(e, l, s);
}
function F3(e, t) {
  const n = L3(e.theme);
  return Object.keys(e).map((r) => Ane(e, t, r, n)).reduce(T0, {});
}
function Eo(e) {
  return F3(e, xT);
}
Eo.propTypes = process.env.NODE_ENV !== "production" ? xT.reduce((e, t) => (e[t] = Bf, e), {}) : {};
Eo.filterProps = xT;
function Co(e) {
  return F3(e, ST);
}
Co.propTypes = process.env.NODE_ENV !== "production" ? ST.reduce((e, t) => (e[t] = Bf, e), {}) : {};
Co.filterProps = ST;
process.env.NODE_ENV !== "production" && Nne.reduce((e, t) => (e[t] = Bf, e), {});
function jne(e = 8) {
  if (e.mui)
    return e;
  const t = L3({
    spacing: e
  }), n = (...r) => (process.env.NODE_ENV !== "production" && (r.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${r.length}`)), (r.length === 0 ? [1] : r).map((s) => {
    const l = t(s);
    return typeof l == "number" ? `${l}px` : l;
  }).join(" "));
  return n.mui = !0, n;
}
function ET(...e) {
  const t = e.reduce((r, a) => (a.filterProps.forEach((s) => {
    r[s] = a;
  }), r), {}), n = (r) => Object.keys(r).reduce((a, s) => t[s] ? T0(a, t[s](r)) : a, {});
  return n.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((r, a) => Object.assign(r, a.propTypes), {}) : {}, n.filterProps = e.reduce((r, a) => r.concat(a.filterProps), []), n;
}
function Uu(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
const Lne = kr({
  prop: "border",
  themeKey: "borders",
  transform: Uu
}), Fne = kr({
  prop: "borderTop",
  themeKey: "borders",
  transform: Uu
}), zne = kr({
  prop: "borderRight",
  themeKey: "borders",
  transform: Uu
}), Vne = kr({
  prop: "borderBottom",
  themeKey: "borders",
  transform: Uu
}), Une = kr({
  prop: "borderLeft",
  themeKey: "borders",
  transform: Uu
}), Bne = kr({
  prop: "borderColor",
  themeKey: "palette"
}), Hne = kr({
  prop: "borderTopColor",
  themeKey: "palette"
}), Wne = kr({
  prop: "borderRightColor",
  themeKey: "palette"
}), Yne = kr({
  prop: "borderBottomColor",
  themeKey: "palette"
}), qne = kr({
  prop: "borderLeftColor",
  themeKey: "palette"
}), CT = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = iw(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: sw(t, r)
    });
    return nl(e, e.borderRadius, n);
  }
  return null;
};
CT.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: Bf
} : {};
CT.filterProps = ["borderRadius"];
ET(Lne, Fne, zne, Vne, Une, Bne, Hne, Wne, Yne, qne, CT);
const TT = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = iw(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: sw(t, r)
    });
    return nl(e, e.gap, n);
  }
  return null;
};
TT.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: Bf
} : {};
TT.filterProps = ["gap"];
const _T = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = iw(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: sw(t, r)
    });
    return nl(e, e.columnGap, n);
  }
  return null;
};
_T.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: Bf
} : {};
_T.filterProps = ["columnGap"];
const OT = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = iw(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: sw(t, r)
    });
    return nl(e, e.rowGap, n);
  }
  return null;
};
OT.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: Bf
} : {};
OT.filterProps = ["rowGap"];
const Gne = kr({
  prop: "gridColumn"
}), Kne = kr({
  prop: "gridRow"
}), Xne = kr({
  prop: "gridAutoFlow"
}), Qne = kr({
  prop: "gridAutoColumns"
}), Zne = kr({
  prop: "gridAutoRows"
}), Jne = kr({
  prop: "gridTemplateColumns"
}), ere = kr({
  prop: "gridTemplateRows"
}), tre = kr({
  prop: "gridTemplateAreas"
}), nre = kr({
  prop: "gridArea"
});
ET(TT, _T, OT, Gne, Kne, Xne, Qne, Zne, Jne, ere, tre, nre);
function Jv(e, t) {
  return t === "grey" ? t : e;
}
const rre = kr({
  prop: "color",
  themeKey: "palette",
  transform: Jv
}), ore = kr({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Jv
}), are = kr({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Jv
});
ET(rre, ore, are);
function ys(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const ire = kr({
  prop: "width",
  transform: ys
}), G$ = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var r, a, s;
      return {
        maxWidth: ((r = e.theme) == null || (a = r.breakpoints) == null || (s = a.values) == null ? void 0 : s[n]) || q$[n] || ys(n)
      };
    };
    return nl(e, e.maxWidth, t);
  }
  return null;
};
G$.filterProps = ["maxWidth"];
const sre = kr({
  prop: "minWidth",
  transform: ys
}), lre = kr({
  prop: "height",
  transform: ys
}), ure = kr({
  prop: "maxHeight",
  transform: ys
}), cre = kr({
  prop: "minHeight",
  transform: ys
});
kr({
  prop: "size",
  cssProperty: "width",
  transform: ys
});
kr({
  prop: "size",
  cssProperty: "height",
  transform: ys
});
const dre = kr({
  prop: "boxSizing"
});
ET(ire, G$, sre, lre, ure, cre, dre);
const fre = {
  // borders
  border: {
    themeKey: "borders",
    transform: Uu
  },
  borderTop: {
    themeKey: "borders",
    transform: Uu
  },
  borderRight: {
    themeKey: "borders",
    transform: Uu
  },
  borderBottom: {
    themeKey: "borders",
    transform: Uu
  },
  borderLeft: {
    themeKey: "borders",
    transform: Uu
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: CT
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Jv
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Jv
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Jv
  },
  // spacing
  p: {
    style: Co
  },
  pt: {
    style: Co
  },
  pr: {
    style: Co
  },
  pb: {
    style: Co
  },
  pl: {
    style: Co
  },
  px: {
    style: Co
  },
  py: {
    style: Co
  },
  padding: {
    style: Co
  },
  paddingTop: {
    style: Co
  },
  paddingRight: {
    style: Co
  },
  paddingBottom: {
    style: Co
  },
  paddingLeft: {
    style: Co
  },
  paddingX: {
    style: Co
  },
  paddingY: {
    style: Co
  },
  paddingInline: {
    style: Co
  },
  paddingInlineStart: {
    style: Co
  },
  paddingInlineEnd: {
    style: Co
  },
  paddingBlock: {
    style: Co
  },
  paddingBlockStart: {
    style: Co
  },
  paddingBlockEnd: {
    style: Co
  },
  m: {
    style: Eo
  },
  mt: {
    style: Eo
  },
  mr: {
    style: Eo
  },
  mb: {
    style: Eo
  },
  ml: {
    style: Eo
  },
  mx: {
    style: Eo
  },
  my: {
    style: Eo
  },
  margin: {
    style: Eo
  },
  marginTop: {
    style: Eo
  },
  marginRight: {
    style: Eo
  },
  marginBottom: {
    style: Eo
  },
  marginLeft: {
    style: Eo
  },
  marginX: {
    style: Eo
  },
  marginY: {
    style: Eo
  },
  marginInline: {
    style: Eo
  },
  marginInlineStart: {
    style: Eo
  },
  marginInlineEnd: {
    style: Eo
  },
  marginBlock: {
    style: Eo
  },
  marginBlockStart: {
    style: Eo
  },
  marginBlockEnd: {
    style: Eo
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: TT
  },
  rowGap: {
    style: OT
  },
  columnGap: {
    style: _T
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: ys
  },
  maxWidth: {
    style: G$
  },
  minWidth: {
    transform: ys
  },
  height: {
    transform: ys
  },
  maxHeight: {
    transform: ys
  },
  minHeight: {
    transform: ys
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
}, PT = fre;
function pre(...e) {
  const t = e.reduce((r, a) => r.concat(Object.keys(a)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function mre(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function hre() {
  function e(n, r, a, s) {
    const l = {
      [n]: r,
      theme: a
    }, p = s[n];
    if (!p)
      return {
        [n]: r
      };
    const {
      cssProperty: m = n,
      themeKey: h,
      transform: g,
      style: b
    } = p;
    if (r == null)
      return null;
    if (h === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const x = wT(a, h) || {};
    return b ? b(l) : nl(l, r, (O) => {
      let _ = pE(x, g, O);
      return O === _ && typeof O == "string" && (_ = pE(x, g, `${n}${O === "default" ? "" : xt(O)}`, O)), m === !1 ? _ : {
        [m]: _
      };
    });
  }
  function t(n) {
    var r;
    const {
      sx: a,
      theme: s = {}
    } = n || {};
    if (!a)
      return null;
    const l = (r = s.unstable_sxConfig) != null ? r : PT;
    function p(m) {
      let h = m;
      if (typeof m == "function")
        h = m(s);
      else if (typeof m != "object")
        return m;
      if (!h)
        return null;
      const g = One(s.breakpoints), b = Object.keys(g);
      let x = g;
      return Object.keys(h).forEach((E) => {
        const O = mre(h[E], s);
        if (O != null)
          if (typeof O == "object")
            if (l[E])
              x = T0(x, e(E, O, s, l));
            else {
              const _ = nl({
                theme: s
              }, O, (P) => ({
                [E]: P
              }));
              pre(_, O) ? x[E] = t({
                sx: O,
                theme: s
              }) : x = T0(x, _);
            }
          else
            x = T0(x, e(E, O, s, l));
      }), Pne(b, x);
    }
    return Array.isArray(a) ? a.map(p) : p(a);
  }
  return t;
}
const z3 = hre();
z3.filterProps = ["sx"];
const K$ = z3, vre = ["breakpoints", "palette", "spacing", "shape"];
function X$(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: a,
    shape: s = {}
  } = e, l = st(e, vre), p = Ene(n), m = jne(a);
  let h = Ks({
    breakpoints: p,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: B({
      mode: "light"
    }, r),
    spacing: m,
    shape: B({}, Tne, s)
  }, l);
  return h = t.reduce((g, b) => Ks(g, b), h), h.unstable_sxConfig = B({}, PT, l == null ? void 0 : l.unstable_sxConfig), h.unstable_sx = function(b) {
    return K$({
      sx: b,
      theme: this
    });
  }, h;
}
function yre(e) {
  return Object.keys(e).length === 0;
}
function RT(e = null) {
  const t = C.useContext(od);
  return !t || yre(t) ? e : t;
}
const gre = X$();
function lw(e = gre) {
  return RT(e);
}
function V3({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = lw(n), a = typeof e == "function" ? e(t && r[t] || r) : e;
  return /* @__PURE__ */ L.jsx(j3, {
    styles: a
  });
}
process.env.NODE_ENV !== "production" && (V3.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  defaultTheme: c.object,
  /**
   * @ignore
   */
  styles: c.oneOfType([c.array, c.func, c.number, c.object, c.string, c.bool]),
  /**
   * @ignore
   */
  themeId: c.string
});
const bre = ["sx"], wre = (e) => {
  var t, n;
  const r = {
    systemProps: {},
    otherProps: {}
  }, a = (t = e == null || (n = e.theme) == null ? void 0 : n.unstable_sxConfig) != null ? t : PT;
  return Object.keys(e).forEach((s) => {
    a[s] ? r.systemProps[s] = e[s] : r.otherProps[s] = e[s];
  }), r;
};
function U3(e) {
  const {
    sx: t
  } = e, n = st(e, bre), {
    systemProps: r,
    otherProps: a
  } = wre(n);
  let s;
  return Array.isArray(t) ? s = [r, ...t] : typeof t == "function" ? s = (...l) => {
    const p = t(...l);
    return um(p) ? B({}, r, p) : r;
  } : s = B({}, r, t), B({}, a, {
    sx: s
  });
}
const xre = ["variant"];
function PL(e) {
  return e.length === 0;
}
function B3(e) {
  const {
    variant: t
  } = e, n = st(e, xre);
  let r = t || "";
  return Object.keys(n).sort().forEach((a) => {
    a === "color" ? r += PL(r) ? e[a] : xt(e[a]) : r += `${PL(r) ? a : xt(a)}${xt(e[a].toString())}`;
  }), r;
}
const Sre = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function Ere(e) {
  return Object.keys(e).length === 0;
}
function Cre(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
const Tre = (e, t) => t.components && t.components[e] && t.components[e].styleOverrides ? t.components[e].styleOverrides : null, _re = (e, t) => {
  let n = [];
  t && t.components && t.components[e] && t.components[e].variants && (n = t.components[e].variants);
  const r = {};
  return n.forEach((a) => {
    const s = B3(a.props);
    r[s] = a.style;
  }), r;
}, Ore = (e, t, n, r) => {
  var a, s;
  const {
    ownerState: l = {}
  } = e, p = [], m = n == null || (a = n.components) == null || (s = a[r]) == null ? void 0 : s.variants;
  return m && m.forEach((h) => {
    let g = !0;
    Object.keys(h.props).forEach((b) => {
      l[b] !== h.props[b] && e[b] !== h.props[b] && (g = !1);
    }), g && p.push(t[B3(h.props)]);
  }), p;
};
function _0(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Pre = X$(), Rre = (e) => e.charAt(0).toLowerCase() + e.slice(1);
function qb({
  defaultTheme: e,
  theme: t,
  themeId: n
}) {
  return Ere(t) ? e : t[n] || t;
}
function kre(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = Pre,
    rootShouldForwardProp: r = _0,
    slotShouldForwardProp: a = _0
  } = e, s = (l) => K$(B({}, l, {
    theme: qb(B({}, l, {
      defaultTheme: n,
      themeId: t
    }))
  }));
  return s.__mui_systemSx = !0, (l, p = {}) => {
    wne(l, (I) => I.filter((R) => !(R != null && R.__mui_systemSx)));
    const {
      name: m,
      slot: h,
      skipVariantsResolver: g,
      skipSx: b,
      overridesResolver: x
    } = p, E = st(p, Sre), O = g !== void 0 ? g : h && h !== "Root" || !1, _ = b || !1;
    let P;
    process.env.NODE_ENV !== "production" && m && (P = `${m}-${Rre(h || "Root")}`);
    let M = _0;
    h === "Root" ? M = r : h ? M = a : Cre(l) && (M = void 0);
    const D = bne(l, B({
      shouldForwardProp: M,
      label: P
    }, E)), N = (I, ...R) => {
      const j = R ? R.map((H) => typeof H == "function" && H.__emotion_real !== H ? (Z) => H(B({}, Z, {
        theme: qb(B({}, Z, {
          defaultTheme: n,
          themeId: t
        }))
      })) : H) : [];
      let U = I;
      m && x && j.push((H) => {
        const Z = qb(B({}, H, {
          defaultTheme: n,
          themeId: t
        })), re = Tre(m, Z);
        if (re) {
          const Y = {};
          return Object.entries(re).forEach(([K, Q]) => {
            Y[K] = typeof Q == "function" ? Q(B({}, H, {
              theme: Z
            })) : Q;
          }), x(H, Y);
        }
        return null;
      }), m && !O && j.push((H) => {
        const Z = qb(B({}, H, {
          defaultTheme: n,
          themeId: t
        }));
        return Ore(H, _re(m, Z), Z, m);
      }), _ || j.push(s);
      const q = j.length - R.length;
      if (Array.isArray(I) && q > 0) {
        const H = new Array(q).fill("");
        U = [...I, ...H], U.raw = [...I.raw, ...H];
      } else
        typeof I == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        I.__emotion_real !== I && (U = (H) => I(B({}, H, {
          theme: qb(B({}, H, {
            defaultTheme: n,
            themeId: t
          }))
        })));
      const J = D(U, ...j);
      if (process.env.NODE_ENV !== "production") {
        let H;
        m && (H = `${m}${h || ""}`), H === void 0 && (H = `Styled(${jee(l)})`), J.displayName = H;
      }
      return l.muiName && (J.muiName = l.muiName), J;
    };
    return D.withConfig && (N.withConfig = D.withConfig), N;
  };
}
function H3(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : F$(t.components[n].defaultProps, r);
}
function Dre({
  props: e,
  name: t,
  defaultTheme: n,
  themeId: r
}) {
  let a = lw(n);
  return r && (a = a[r] || a), H3({
    theme: a,
    name: t,
    props: e
  });
}
function Q$(e, t = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > n) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${n}].`), Math.min(Math.max(t, e), n);
}
function $re(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, a) => a < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Em(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Em($re(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : jf(9, e));
  let r = e.substring(t + 1, e.length - 1), a;
  if (n === "color") {
    if (r = r.split(" "), a = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(a) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${a}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : jf(10, a));
  } else
    r = r.split(",");
  return r = r.map((s) => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: a
  };
}
function kT(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.indexOf("rgb") !== -1 ? r = r.map((a, s) => s < 3 ? parseInt(a, 10) : a) : t.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.indexOf("color") !== -1 ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function Mre(e) {
  e = Em(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, a = t[2] / 100, s = r * Math.min(a, 1 - a), l = (h, g = (h + n / 30) % 12) => a - s * Math.max(Math.min(g - 3, 9 - g, 1), -1);
  let p = "rgb";
  const m = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return e.type === "hsla" && (p += "a", m.push(t[3])), kT({
    type: p,
    values: m
  });
}
function RL(e) {
  e = Em(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Em(Mre(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function kL(e, t) {
  const n = RL(e), r = RL(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Wn(e, t) {
  return e = Em(e), t = Q$(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, kT(e);
}
function W3(e, t) {
  if (e = Em(e), t = Q$(t), e.type.indexOf("hsl") !== -1)
    e.values[2] *= 1 - t;
  else if (e.type.indexOf("rgb") !== -1 || e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return kT(e);
}
function Y3(e, t) {
  if (e = Em(e), t = Q$(t), e.type.indexOf("hsl") !== -1)
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.indexOf("rgb") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return kT(e);
}
const q3 = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (q3.displayName = "ThemeContext");
const G3 = q3;
function K3() {
  const e = C.useContext(G3);
  return process.env.NODE_ENV !== "production" && C.useDebugValue(e), e;
}
const Nre = typeof Symbol == "function" && Symbol.for, Ire = Nre ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function Are(e, t) {
  if (typeof t == "function") {
    const n = t(e);
    return process.env.NODE_ENV !== "production" && (n || console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join(`
`))), n;
  }
  return {
    ...e,
    ...t
  };
}
function mE(e) {
  const {
    children: t,
    theme: n
  } = e, r = K3();
  process.env.NODE_ENV !== "production" && r === null && typeof n == "function" && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const a = C.useMemo(() => {
    const s = r === null ? n : Are(r, n);
    return s != null && (s[Ire] = r !== null), s;
  }, [n, r]);
  return /* @__PURE__ */ L.jsx(G3.Provider, {
    value: a,
    children: t
  });
}
process.env.NODE_ENV !== "production" && (mE.propTypes = {
  /**
   * Your component tree.
   */
  children: c.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: c.oneOfType([c.object, c.func]).isRequired
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (mE.propTypes = dT(mE.propTypes));
const DL = {};
function $L(e, t, n, r = !1) {
  return C.useMemo(() => {
    const a = e && t[e] || t;
    if (typeof n == "function") {
      const s = n(a), l = e ? B({}, t, {
        [e]: s
      }) : s;
      return r ? () => l : l;
    }
    return e ? B({}, t, {
      [e]: n
    }) : B({}, t, n);
  }, [e, t, n, r]);
}
function hE(e) {
  const {
    children: t,
    theme: n,
    themeId: r
  } = e, a = RT(DL), s = K3() || DL;
  process.env.NODE_ENV !== "production" && (a === null && typeof n == "function" || r && a && !a[r] && typeof n == "function") && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const l = $L(r, a, n), p = $L(r, s, n, !0);
  return /* @__PURE__ */ L.jsx(mE, {
    theme: p,
    children: /* @__PURE__ */ L.jsx(od.Provider, {
      value: l,
      children: t
    })
  });
}
process.env.NODE_ENV !== "production" && (hE.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Your component tree.
   */
  children: c.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: c.oneOfType([c.func, c.object]).isRequired,
  /**
   * The design system's unique id for getting the corresponded theme when there are multiple design systems.
   */
  themeId: c.string
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (hE.propTypes = dT(hE.propTypes));
function jre(e, t) {
  return B({
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    }
  }, t);
}
const Lre = {
  black: "#000",
  white: "#fff"
}, U0 = Lre, Fre = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, zre = Fre, Vre = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, Tv = Vre, Ure = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, _v = Ure, Bre = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, Gb = Bre, Hre = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, Ov = Hre, Wre = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, Pv = Wre, Yre = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, Rv = Yre, qre = ["mode", "contrastThreshold", "tonalOffset"], ML = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: U0.white,
    default: U0.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, dk = {
  text: {
    primary: U0.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: U0.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function NL(e, t, n, r) {
  const a = r.light || r, s = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Y3(e.main, a) : t === "dark" && (e.dark = W3(e.main, s)));
}
function Gre(e = "light") {
  return e === "dark" ? {
    main: Ov[200],
    light: Ov[50],
    dark: Ov[400]
  } : {
    main: Ov[700],
    light: Ov[400],
    dark: Ov[800]
  };
}
function Kre(e = "light") {
  return e === "dark" ? {
    main: Tv[200],
    light: Tv[50],
    dark: Tv[400]
  } : {
    main: Tv[500],
    light: Tv[300],
    dark: Tv[700]
  };
}
function Xre(e = "light") {
  return e === "dark" ? {
    main: _v[500],
    light: _v[300],
    dark: _v[700]
  } : {
    main: _v[700],
    light: _v[400],
    dark: _v[800]
  };
}
function Qre(e = "light") {
  return e === "dark" ? {
    main: Pv[400],
    light: Pv[300],
    dark: Pv[700]
  } : {
    main: Pv[700],
    light: Pv[500],
    dark: Pv[900]
  };
}
function Zre(e = "light") {
  return e === "dark" ? {
    main: Rv[400],
    light: Rv[300],
    dark: Rv[700]
  } : {
    main: Rv[800],
    light: Rv[500],
    dark: Rv[900]
  };
}
function Jre(e = "light") {
  return e === "dark" ? {
    main: Gb[400],
    light: Gb[300],
    dark: Gb[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Gb[500],
    dark: Gb[900]
  };
}
function eoe(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2
  } = e, a = st(e, qre), s = e.primary || Gre(t), l = e.secondary || Kre(t), p = e.error || Xre(t), m = e.info || Qre(t), h = e.success || Zre(t), g = e.warning || Jre(t);
  function b(_) {
    const P = kL(_, dk.text.primary) >= n ? dk.text.primary : ML.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const M = kL(_, P);
      M < 3 && console.error([`MUI: The contrast ratio of ${M}:1 for ${P} on ${_}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return P;
  }
  const x = ({
    color: _,
    name: P,
    mainShade: M = 500,
    lightShade: D = 300,
    darkShade: N = 700
  }) => {
    if (_ = B({}, _), !_.main && _[M] && (_.main = _[M]), !_.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${P ? ` (${P})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${M}\` property.` : jf(11, P ? ` (${P})` : "", M));
    if (typeof _.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${P ? ` (${P})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(_.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : jf(12, P ? ` (${P})` : "", JSON.stringify(_.main)));
    return NL(_, "light", D, r), NL(_, "dark", N, r), _.contrastText || (_.contrastText = b(_.main)), _;
  }, E = {
    dark: dk,
    light: ML
  };
  return process.env.NODE_ENV !== "production" && (E[t] || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), Ks(B({
    // A collection of common colors.
    common: B({}, U0),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: x({
      color: s,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: x({
      color: l,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: x({
      color: p,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: x({
      color: g,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: x({
      color: m,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: x({
      color: h,
      name: "success"
    }),
    // The grey colors.
    grey: zre,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: b,
    // Generate a rich color object.
    augmentColor: x,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r
  }, E[t]), a);
}
const toe = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function noe(e) {
  return Math.round(e * 1e5) / 1e5;
}
const IL = {
  textTransform: "uppercase"
}, AL = '"Roboto", "Helvetica", "Arial", sans-serif';
function roe(e, t) {
  const n = typeof t == "function" ? t(e) : t, {
    fontFamily: r = AL,
    // The default font size of the Material Specification.
    fontSize: a = 14,
    // px
    fontWeightLight: s = 300,
    fontWeightRegular: l = 400,
    fontWeightMedium: p = 500,
    fontWeightBold: m = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: h = 16,
    // Apply the CSS properties to all the variants.
    allVariants: g,
    pxToRem: b
  } = n, x = st(n, toe);
  process.env.NODE_ENV !== "production" && (typeof a != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof h != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const E = a / 14, O = b || ((M) => `${M / h * E}rem`), _ = (M, D, N, I, R) => B({
    fontFamily: r,
    fontWeight: M,
    fontSize: O(D),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: N
  }, r === AL ? {
    letterSpacing: `${noe(I / D)}em`
  } : {}, R, g), P = {
    h1: _(s, 96, 1.167, -1.5),
    h2: _(s, 60, 1.2, -0.5),
    h3: _(l, 48, 1.167, 0),
    h4: _(l, 34, 1.235, 0.25),
    h5: _(l, 24, 1.334, 0),
    h6: _(p, 20, 1.6, 0.15),
    subtitle1: _(l, 16, 1.75, 0.15),
    subtitle2: _(p, 14, 1.57, 0.1),
    body1: _(l, 16, 1.5, 0.15),
    body2: _(l, 14, 1.43, 0.15),
    button: _(p, 14, 1.75, 0.4, IL),
    caption: _(l, 12, 1.66, 0.4),
    overline: _(l, 12, 2.66, 1, IL),
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Ks(B({
    htmlFontSize: h,
    pxToRem: O,
    fontFamily: r,
    fontSize: a,
    fontWeightLight: s,
    fontWeightRegular: l,
    fontWeightMedium: p,
    fontWeightBold: m
  }, P), x, {
    clone: !1
    // No need to clone deep
  });
}
const ooe = 0.2, aoe = 0.14, ioe = 0.12;
function co(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${ooe})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${aoe})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${ioe})`].join(",");
}
const soe = ["none", co(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), co(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), co(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), co(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), co(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), co(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), co(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), co(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), co(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), co(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), co(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), co(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), co(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), co(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), co(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), co(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), co(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), co(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), co(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), co(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), co(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), co(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), co(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), co(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], loe = soe, uoe = ["duration", "easing", "delay"], coe = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, doe = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function jL(e) {
  return `${Math.round(e)}ms`;
}
function foe(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.round((4 + 15 * t ** 0.25 + t / 5) * 10);
}
function poe(e) {
  const t = B({}, coe, e.easing), n = B({}, doe, e.duration);
  return B({
    getAutoHeightDuration: foe,
    create: (a = ["all"], s = {}) => {
      const {
        duration: l = n.standard,
        easing: p = t.easeInOut,
        delay: m = 0
      } = s, h = st(s, uoe);
      if (process.env.NODE_ENV !== "production") {
        const g = (x) => typeof x == "string", b = (x) => !isNaN(parseFloat(x));
        !g(a) && !Array.isArray(a) && console.error('MUI: Argument "props" must be a string or Array.'), !b(l) && !g(l) && console.error(`MUI: Argument "duration" must be a number or a string but found ${l}.`), g(p) || console.error('MUI: Argument "easing" must be a string.'), !b(m) && !g(m) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(h).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(h).join(",")}].`);
      }
      return (Array.isArray(a) ? a : [a]).map((g) => `${g} ${typeof l == "string" ? l : jL(l)} ${p} ${typeof m == "string" ? m : jL(m)}`).join(",");
    }
  }, e, {
    easing: t,
    duration: n
  });
}
const moe = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, hoe = moe, voe = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function X3(e = {}, ...t) {
  const {
    mixins: n = {},
    palette: r = {},
    transitions: a = {},
    typography: s = {}
  } = e, l = st(e, voe);
  if (e.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : jf(18));
  const p = eoe(r), m = X$(e);
  let h = Ks(m, {
    mixins: jre(m.breakpoints, n),
    palette: p,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: loe.slice(),
    typography: roe(p, s),
    transitions: poe(a),
    zIndex: B({}, hoe)
  });
  if (h = Ks(h, l), h = t.reduce((g, b) => Ks(g, b), h), process.env.NODE_ENV !== "production") {
    const g = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], b = (x, E) => {
      let O;
      for (O in x) {
        const _ = x[O];
        if (g.indexOf(O) !== -1 && Object.keys(_).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const P = Xt("", O);
            console.error([`MUI: The \`${E}\` component increases the CSS specificity of the \`${O}\` internal state.`, "You can not override it like this: ", JSON.stringify(x, null, 2), "", `Instead, you need to use the '&.${P}' syntax:`, JSON.stringify({
              root: {
                [`&.${P}`]: _
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          x[O] = {};
        }
      }
    };
    Object.keys(h.components).forEach((x) => {
      const E = h.components[x].styleOverrides;
      E && x.indexOf("Mui") === 0 && b(E, x);
    });
  }
  return h.unstable_sxConfig = B({}, PT, l == null ? void 0 : l.unstable_sxConfig), h.unstable_sx = function(b) {
    return K$({
      sx: b,
      theme: this
    });
  }, h;
}
const yoe = X3(), DT = yoe;
function Ji() {
  const e = lw(DT);
  return process.env.NODE_ENV !== "production" && C.useDebugValue(e), e[cy] || e;
}
function Lt({
  props: e,
  name: t
}) {
  return Dre({
    props: e,
    name: t,
    defaultTheme: DT,
    themeId: cy
  });
}
const ac = (e) => _0(e) && e !== "classes", goe = _0, boe = kre({
  themeId: cy,
  defaultTheme: DT,
  rootShouldForwardProp: ac
}), Ge = boe, woe = ["theme"];
function Q3(e) {
  let {
    theme: t
  } = e, n = st(e, woe);
  const r = t[cy];
  return /* @__PURE__ */ L.jsx(hE, B({}, n, {
    themeId: r ? cy : void 0,
    theme: r || t
  }));
}
process.env.NODE_ENV !== "production" && (Q3.propTypes = {
  /**
   * Your component tree.
   */
  children: c.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: c.oneOfType([c.object, c.func]).isRequired
});
const xoe = (e) => {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, (t / 100).toFixed(2);
}, LL = xoe, Soe = {
  primaryColor: "blue",
  components: {
    Tooltip: {
      styles: (e) => ({
        body: {
          padding: 0.5 * e.spacing.xs,
          paddingTop: 0.25 * e.spacing.xs,
          paddingBottom: 0.25 * e.spacing.xs,
          fontSize: e.fontSizes.xs,
          backgroundColor: e.colors.gray[6]
        }
      }),
      defaultProps: { position: "bottom", transition: "fade", openDelay: 400 }
    },
    Modal: {
      styles: {
        title: {
          fontWeight: 700
        }
      }
    },
    ActionIcon: {
      styles: (e) => ({
        hover: {
          color: e.colors.gray[6]
        }
      })
    }
  }
}, Eoe = X3({});
function vE(e, t) {
  let n = e;
  for (; (n = n.parentElement) && !n.matches(t); )
    ;
  return n;
}
function Coe(e, t, n) {
  for (let r = e - 1; r >= 0; r -= 1)
    if (!t[r].disabled)
      return r;
  if (n) {
    for (let r = t.length - 1; r > -1; r -= 1)
      if (!t[r].disabled)
        return r;
  }
  return e;
}
function Toe(e, t, n) {
  for (let r = e + 1; r < t.length; r += 1)
    if (!t[r].disabled)
      return r;
  if (n) {
    for (let r = 0; r < t.length; r += 1)
      if (!t[r].disabled)
        return r;
  }
  return e;
}
function _oe(e, t, n) {
  return vE(e, n) === vE(t, n);
}
function Z3({
  parentSelector: e,
  siblingSelector: t,
  onKeyDown: n,
  loop: r = !0,
  activateOnFocus: a = !1,
  dir: s = "rtl",
  orientation: l
}) {
  return (p) => {
    var m;
    n == null || n(p);
    const h = Array.from(((m = vE(p.currentTarget, e)) == null ? void 0 : m.querySelectorAll(t)) || []).filter((_) => _oe(p.currentTarget, _, e)), g = h.findIndex((_) => p.currentTarget === _), b = Toe(g, h, r), x = Coe(g, h, r), E = s === "rtl" ? x : b, O = s === "rtl" ? b : x;
    switch (p.key) {
      case "ArrowRight": {
        l === "horizontal" && (p.stopPropagation(), p.preventDefault(), h[E].focus(), a && h[E].click());
        break;
      }
      case "ArrowLeft": {
        l === "horizontal" && (p.stopPropagation(), p.preventDefault(), h[O].focus(), a && h[O].click());
        break;
      }
      case "ArrowUp": {
        l === "vertical" && (p.stopPropagation(), p.preventDefault(), h[x].focus(), a && h[x].click());
        break;
      }
      case "ArrowDown": {
        l === "vertical" && (p.stopPropagation(), p.preventDefault(), h[b].focus(), a && h[b].click());
        break;
      }
      case "Home": {
        p.stopPropagation(), p.preventDefault(), !h[0].disabled && h[0].focus();
        break;
      }
      case "End": {
        p.stopPropagation(), p.preventDefault();
        const _ = h.length - 1;
        !h[_].disabled && h[_].focus();
        break;
      }
    }
  };
}
function Ooe(e, t, n) {
  var r;
  return n ? Array.from(((r = vE(n, t)) == null ? void 0 : r.querySelectorAll(e)) || []).findIndex((a) => a === n) : null;
}
function $T(e) {
  const t = C.createContext(null);
  return [({ children: a, value: s }) => /* @__PURE__ */ le.createElement(t.Provider, {
    value: s
  }, a), () => {
    const a = C.useContext(t);
    if (a === null)
      throw new Error(e);
    return a;
  }];
}
function B0(e) {
  return Array.isArray(e) ? e : [e];
}
function FL(e, t) {
  return (n) => {
    if (typeof n != "string" || n.trim().length === 0)
      throw new Error(t);
    return `${e}-${n}`;
  };
}
const Poe = () => {
};
function Roe(e, t = { active: !0 }) {
  return typeof e != "function" || !t.active ? t.onKeyDown || Poe : (n) => {
    var r;
    n.key === "Escape" && (e(n), (r = t.onTrigger) == null || r.call(t));
  };
}
function Zc(e, t) {
  return (n) => {
    e == null || e(n), t == null || t(n);
  };
}
function koe() {
  const [e, t] = C.useState(-1);
  return [e, { setHovered: t, resetHovered: () => t(-1) }];
}
function J3({ data: e }) {
  const t = [], n = [], r = e.reduce((a, s, l) => (s.group ? a[s.group] ? a[s.group].push(l) : a[s.group] = [l] : n.push(l), a), {});
  return Object.keys(r).forEach((a) => {
    t.push(...r[a].map((s) => e[s]));
  }), t.push(...n.map((a) => e[a])), t;
}
function uw(e) {
  return Array.isArray(e) || e === null ? !1 : typeof e == "object" ? e.type !== le.Fragment : !1;
}
function e4(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = e4(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function t4() {
  for (var e = 0, t, n, r = ""; e < arguments.length; )
    (t = arguments[e++]) && (n = e4(t)) && (r && (r += " "), r += n);
  return r;
}
const Doe = {
  dark: [
    "#C1C2C5",
    "#A6A7AB",
    "#909296",
    "#5c5f66",
    "#373A40",
    "#2C2E33",
    "#25262b",
    "#1A1B1E",
    "#141517",
    "#101113"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
};
function $oe(e) {
  return () => ({ fontFamily: e.fontFamily || "sans-serif" });
}
var Moe = Object.defineProperty, zL = Object.getOwnPropertySymbols, Noe = Object.prototype.hasOwnProperty, Ioe = Object.prototype.propertyIsEnumerable, VL = (e, t, n) => t in e ? Moe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, UL = (e, t) => {
  for (var n in t || (t = {}))
    Noe.call(t, n) && VL(e, n, t[n]);
  if (zL)
    for (var n of zL(t))
      Ioe.call(t, n) && VL(e, n, t[n]);
  return e;
};
function Aoe(e) {
  return (t) => ({
    WebkitTapHighlightColor: "transparent",
    [t || "&:focus"]: UL({}, e.focusRing === "always" || e.focusRing === "auto" ? e.focusRingStyles.styles(e) : e.focusRingStyles.resetStyles(e)),
    [t ? t.replace(":focus", ":focus:not(:focus-visible)") : "&:focus:not(:focus-visible)"]: UL({}, e.focusRing === "auto" || e.focusRing === "never" ? e.focusRingStyles.resetStyles(e) : null)
  });
}
function cw(e) {
  return (t) => typeof e.primaryShade == "number" ? e.primaryShade : e.primaryShade[t || e.colorScheme];
}
function Z$(e) {
  const t = cw(e);
  return (n, r, a = !0, s = !0) => {
    if (typeof n == "string" && n.includes(".")) {
      const [p, m] = n.split("."), h = parseInt(m, 10);
      if (p in e.colors && h >= 0 && h < 10)
        return e.colors[p][typeof r == "number" && !s ? r : h];
    }
    const l = typeof r == "number" ? r : t();
    return n in e.colors ? e.colors[n][l] : a ? e.colors[e.primaryColor][l] : n;
  };
}
function n4(e) {
  let t = "";
  for (let n = 1; n < e.length - 1; n += 1)
    t += `${e[n]} ${n / (e.length - 1) * 100}%, `;
  return `${e[0]} 0%, ${t}${e[e.length - 1]} 100%`;
}
function joe(e, ...t) {
  return `linear-gradient(${e}deg, ${n4(t)})`;
}
function Loe(...e) {
  return `radial-gradient(circle, ${n4(e)})`;
}
function r4(e) {
  const t = Z$(e), n = cw(e);
  return (r) => {
    const a = {
      from: (r == null ? void 0 : r.from) || e.defaultGradient.from,
      to: (r == null ? void 0 : r.to) || e.defaultGradient.to,
      deg: (r == null ? void 0 : r.deg) || e.defaultGradient.deg
    };
    return `linear-gradient(${a.deg}deg, ${t(a.from, n(), !1)} 0%, ${t(a.to, n(), !1)} 100%)`;
  };
}
function J$(e) {
  if (typeof e.size == "number")
    return e.size;
  const t = e.sizes[e.size];
  return t !== void 0 ? t : e.size || e.sizes.md;
}
function Foe(e) {
  return (t) => `@media (min-width: ${J$({ size: t, sizes: e.breakpoints })}px)`;
}
function zoe(e) {
  return (t) => `@media (max-width: ${J$({ size: t, sizes: e.breakpoints }) - 1}px)`;
}
function Voe(e) {
  return /^#?([0-9A-F]{3}){1,2}$/i.test(e);
}
function Uoe(e) {
  let t = e.replace("#", "");
  if (t.length === 3) {
    const l = t.split("");
    t = [
      l[0],
      l[0],
      l[1],
      l[1],
      l[2],
      l[2]
    ].join("");
  }
  const n = parseInt(t, 16), r = n >> 16 & 255, a = n >> 8 & 255, s = n & 255;
  return {
    r,
    g: a,
    b: s,
    a: 1
  };
}
function Boe(e) {
  const [t, n, r, a] = e.replace(/[^0-9,.]/g, "").split(",").map(Number);
  return { r: t, g: n, b: r, a: a || 1 };
}
function eM(e) {
  return Voe(e) ? Uoe(e) : e.startsWith("rgb") ? Boe(e) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function Fv(e, t) {
  if (typeof e != "string" || t > 1 || t < 0)
    return "rgba(0, 0, 0, 1)";
  const { r: n, g: r, b: a } = eM(e);
  return `rgba(${n}, ${r}, ${a}, ${t})`;
}
function Hoe(e = 0) {
  return {
    position: "absolute",
    top: e,
    right: e,
    left: e,
    bottom: e
  };
}
function Woe(e, t) {
  const { r: n, g: r, b: a, a: s } = eM(e), l = 1 - t, p = (m) => Math.round(m * l);
  return `rgba(${p(n)}, ${p(r)}, ${p(a)}, ${s})`;
}
function Yoe(e, t) {
  const { r: n, g: r, b: a, a: s } = eM(e), l = (p) => Math.round(p + (255 - p) * t);
  return `rgba(${l(n)}, ${l(r)}, ${l(a)}, ${s})`;
}
function qoe(e) {
  return (t) => {
    if (typeof t == "number")
      return t;
    const n = typeof e.defaultRadius == "number" ? e.defaultRadius : e.radius[e.defaultRadius] || e.defaultRadius;
    return e.radius[t] || t || n;
  };
}
function Goe(e, t) {
  if (typeof e == "string" && e.includes(".")) {
    const [n, r] = e.split("."), a = parseInt(r, 10);
    if (n in t.colors && a >= 0 && a < 10)
      return { isSplittedColor: !0, key: n, shade: a };
  }
  return { isSplittedColor: !1 };
}
function Koe(e) {
  const t = Z$(e), n = cw(e), r = r4(e);
  return ({ variant: a, color: s, gradient: l, primaryFallback: p }) => {
    const m = Goe(s, e);
    switch (a) {
      case "light":
        return {
          border: "transparent",
          background: Fv(t(s, e.colorScheme === "dark" ? 8 : 0, p, !1), e.colorScheme === "dark" ? 0.2 : 1),
          color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : n("light")),
          hover: Fv(t(s, e.colorScheme === "dark" ? 7 : 1, p, !1), e.colorScheme === "dark" ? 0.25 : 0.65)
        };
      case "subtle":
        return {
          border: "transparent",
          background: "transparent",
          color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : n("light")),
          hover: Fv(t(s, e.colorScheme === "dark" ? 8 : 0, p, !1), e.colorScheme === "dark" ? 0.2 : 1)
        };
      case "outline":
        return {
          border: t(s, e.colorScheme === "dark" ? 5 : n("light")),
          background: "transparent",
          color: t(s, e.colorScheme === "dark" ? 5 : n("light")),
          hover: e.colorScheme === "dark" ? Fv(t(s, 5, p, !1), 0.05) : Fv(t(s, 0, p, !1), 0.35)
        };
      case "default":
        return {
          border: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4],
          background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
          color: e.colorScheme === "dark" ? e.white : e.black,
          hover: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[0]
        };
      case "white":
        return {
          border: "transparent",
          background: e.white,
          color: t(s, n()),
          hover: null
        };
      case "transparent":
        return {
          border: "transparent",
          color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : n("light")),
          background: "transparent",
          hover: null
        };
      case "gradient":
        return {
          background: r(l),
          color: e.white,
          border: "transparent",
          hover: null
        };
      default: {
        const h = n(), g = m.isSplittedColor ? m.shade : h, b = m.isSplittedColor ? m.key : s;
        return {
          border: "transparent",
          background: t(b, g, p),
          color: e.white,
          hover: t(b, g === 9 ? 8 : g + 1)
        };
      }
    }
  };
}
function Xoe(e) {
  return (t) => {
    const n = cw(e)(t);
    return e.colors[e.primaryColor][n];
  };
}
function Qoe(e) {
  return {
    "@media (hover: hover)": {
      "&:hover": e
    },
    "@media (hover: none)": {
      "&:active": e
    }
  };
}
function Zoe(e) {
  return () => ({
    userSelect: "none",
    color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
  });
}
const ra = {
  fontStyles: $oe,
  themeColor: Z$,
  focusStyles: Aoe,
  linearGradient: joe,
  radialGradient: Loe,
  smallerThan: zoe,
  largerThan: Foe,
  rgba: Fv,
  size: J$,
  cover: Hoe,
  darken: Woe,
  lighten: Yoe,
  radius: qoe,
  variant: Koe,
  primaryShade: cw,
  hover: Qoe,
  gradient: r4,
  primaryColor: Xoe,
  placeholderStyles: Zoe
};
var Joe = Object.defineProperty, eae = Object.defineProperties, tae = Object.getOwnPropertyDescriptors, BL = Object.getOwnPropertySymbols, nae = Object.prototype.hasOwnProperty, rae = Object.prototype.propertyIsEnumerable, HL = (e, t, n) => t in e ? Joe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, oae = (e, t) => {
  for (var n in t || (t = {}))
    nae.call(t, n) && HL(e, n, t[n]);
  if (BL)
    for (var n of BL(t))
      rae.call(t, n) && HL(e, n, t[n]);
  return e;
}, aae = (e, t) => eae(e, tae(t));
function o4(e) {
  return aae(oae({}, e), {
    fn: {
      fontStyles: ra.fontStyles(e),
      themeColor: ra.themeColor(e),
      focusStyles: ra.focusStyles(e),
      largerThan: ra.largerThan(e),
      smallerThan: ra.smallerThan(e),
      radialGradient: ra.radialGradient,
      linearGradient: ra.linearGradient,
      gradient: ra.gradient(e),
      rgba: ra.rgba,
      size: ra.size,
      cover: ra.cover,
      lighten: ra.lighten,
      darken: ra.darken,
      primaryShade: ra.primaryShade(e),
      radius: ra.radius(e),
      variant: ra.variant(e),
      hover: ra.hover,
      primaryColor: ra.primaryColor(e),
      placeholderStyles: ra.placeholderStyles(e)
    }
  });
}
const a4 = ["xs", "sm", "md", "lg", "xl"], iae = {
  dir: "ltr",
  primaryShade: {
    light: 6,
    dark: 8
  },
  focusRing: "auto",
  loader: "oval",
  dateFormat: "MMMM D, YYYY",
  colorScheme: "light",
  white: "#fff",
  black: "#000",
  defaultRadius: "sm",
  transitionTimingFunction: "ease",
  colors: Doe,
  lineHeight: 1.55,
  fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  primaryColor: "blue",
  respectReducedMotion: !0,
  cursorType: "default",
  defaultGradient: {
    from: "indigo",
    to: "cyan",
    deg: 45
  },
  shadows: {
    xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
    sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
    md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
    lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
    xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px"
  },
  fontSizes: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 18,
    xl: 20
  },
  radius: {
    xs: 2,
    sm: 4,
    md: 8,
    lg: 16,
    xl: 32
  },
  spacing: {
    xs: 10,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24
  },
  breakpoints: {
    xs: 576,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1400
  },
  headings: {
    fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
    fontWeight: 700,
    sizes: {
      h1: { fontSize: 34, lineHeight: 1.3, fontWeight: void 0 },
      h2: { fontSize: 26, lineHeight: 1.35, fontWeight: void 0 },
      h3: { fontSize: 22, lineHeight: 1.4, fontWeight: void 0 },
      h4: { fontSize: 18, lineHeight: 1.45, fontWeight: void 0 },
      h5: { fontSize: 16, lineHeight: 1.5, fontWeight: void 0 },
      h6: { fontSize: 14, lineHeight: 1.5, fontWeight: void 0 }
    }
  },
  other: {},
  components: {},
  activeStyles: { transform: "translateY(1px)" },
  datesLocale: "en",
  globalStyles: void 0,
  focusRingStyles: {
    styles: (e) => ({
      outlineOffset: 2,
      outline: `2px solid ${e.colors[e.primaryColor][e.colorScheme === "dark" ? 7 : 5]}`
    }),
    resetStyles: () => ({ outline: "none" }),
    inputStyles: (e) => ({
      outline: "none",
      borderColor: e.colors[e.primaryColor][typeof e.primaryShade == "object" ? e.primaryShade[e.colorScheme] : e.primaryShade]
    })
  }
}, tM = o4(iae);
var sae = Object.defineProperty, lae = Object.defineProperties, uae = Object.getOwnPropertyDescriptors, WL = Object.getOwnPropertySymbols, cae = Object.prototype.hasOwnProperty, dae = Object.prototype.propertyIsEnumerable, YL = (e, t, n) => t in e ? sae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, fae = (e, t) => {
  for (var n in t || (t = {}))
    cae.call(t, n) && YL(e, n, t[n]);
  if (WL)
    for (var n of WL(t))
      dae.call(t, n) && YL(e, n, t[n]);
  return e;
}, pae = (e, t) => lae(e, uae(t));
function mae({ theme: e }) {
  return /* @__PURE__ */ le.createElement(_y, {
    styles: {
      "*, *::before, *::after": {
        boxSizing: "border-box"
      },
      html: {
        colorScheme: e.colorScheme === "dark" ? "dark" : "light"
      },
      body: pae(fae({}, e.fn.fontStyles()), {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        lineHeight: e.lineHeight,
        fontSize: e.fontSizes.md,
        WebkitFontSmoothing: "antialiased",
        MozOsxFontSmoothing: "grayscale"
      })
    }
  });
}
function f1(e, t, n) {
  Object.keys(t).forEach((r) => {
    e[`--mantine-${n}-${r}`] = typeof t[r] == "number" ? `${t[r]}px` : t[r];
  });
}
function hae({ theme: e }) {
  const t = {
    "--mantine-color-white": e.white,
    "--mantine-color-black": e.black,
    "--mantine-transition-timing-function": e.transitionTimingFunction,
    "--mantine-line-height": `${e.lineHeight}`,
    "--mantine-font-family": e.fontFamily,
    "--mantine-font-family-monospace": e.fontFamilyMonospace,
    "--mantine-font-family-headings": e.headings.fontFamily,
    "--mantine-heading-font-weight": `${e.headings.fontWeight}`
  };
  f1(t, e.shadows, "shadow"), f1(t, e.fontSizes, "font-size"), f1(t, e.radius, "radius"), f1(t, e.spacing, "spacing"), Object.keys(e.colors).forEach((r) => {
    e.colors[r].forEach((a, s) => {
      t[`--mantine-color-${r}-${s}`] = a;
    });
  });
  const n = e.headings.sizes;
  return Object.keys(n).forEach((r) => {
    t[`--mantine-${r}-font-size`] = `${n[r].fontSize}px`, t[`--mantine-${r}-line-height`] = `${n[r].lineHeight}`;
  }), /* @__PURE__ */ le.createElement(_y, {
    styles: {
      ":root": t
    }
  });
}
var vae = Object.defineProperty, yae = Object.defineProperties, gae = Object.getOwnPropertyDescriptors, qL = Object.getOwnPropertySymbols, bae = Object.prototype.hasOwnProperty, wae = Object.prototype.propertyIsEnumerable, GL = (e, t, n) => t in e ? vae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, em = (e, t) => {
  for (var n in t || (t = {}))
    bae.call(t, n) && GL(e, n, t[n]);
  if (qL)
    for (var n of qL(t))
      wae.call(t, n) && GL(e, n, t[n]);
  return e;
}, KL = (e, t) => yae(e, gae(t));
function xae(e, t) {
  if (!t)
    return e;
  const n = Object.keys(e).reduce((r, a) => {
    if (a === "headings" && t.headings) {
      const s = t.headings.sizes ? Object.keys(e.headings.sizes).reduce((l, p) => (l[p] = em(em({}, e.headings.sizes[p]), t.headings.sizes[p]), l), {}) : e.headings.sizes;
      return KL(em({}, r), {
        headings: KL(em(em({}, e.headings), t.headings), {
          sizes: s
        })
      });
    }
    return r[a] = typeof t[a] == "object" ? em(em({}, e[a]), t[a]) : typeof t[a] == "number" || typeof t[a] == "boolean" || typeof t[a] == "function" ? t[a] : t[a] || e[a], r;
  }, {});
  if (!(n.primaryColor in n.colors))
    throw new Error("MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color");
  return n;
}
function Sae(e, t) {
  return o4(xae(e, t));
}
function i4(e) {
  return Object.keys(e).reduce((t, n) => (e[n] !== void 0 && (t[n] = e[n]), t), {});
}
const Eae = {
  html: {
    fontFamily: "sans-serif",
    lineHeight: "1.15",
    textSizeAdjust: "100%"
  },
  body: {
    margin: 0
  },
  "article, aside, footer, header, nav, section, figcaption, figure, main": {
    display: "block"
  },
  h1: {
    fontSize: "2em"
  },
  hr: {
    boxSizing: "content-box",
    height: 0,
    overflow: "visible"
  },
  pre: {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  a: {
    background: "transparent",
    textDecorationSkip: "objects"
  },
  "a:active, a:hover": {
    outlineWidth: 0
  },
  "abbr[title]": {
    borderBottom: "none",
    textDecoration: "underline"
  },
  "b, strong": {
    fontWeight: "bolder"
  },
  "code, kbp, samp": {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  dfn: {
    fontStyle: "italic"
  },
  mark: {
    backgroundColor: "#ff0",
    color: "#000"
  },
  small: {
    fontSize: "80%"
  },
  "sub, sup": {
    fontSize: "75%",
    lineHeight: 0,
    position: "relative",
    verticalAlign: "baseline"
  },
  sup: {
    top: "-0.5em"
  },
  sub: {
    bottom: "-0.25em"
  },
  "audio, video": {
    display: "inline-block"
  },
  "audio:not([controls])": {
    display: "none",
    height: 0
  },
  img: {
    borderStyle: "none",
    verticalAlign: "middle"
  },
  "svg:not(:root)": {
    overflow: "hidden"
  },
  "button, input, optgroup, select, textarea": {
    fontFamily: "sans-serif",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: 0
  },
  "button, input": {
    overflow: "visible"
  },
  "button, select": {
    textTransform: "none"
  },
  "button, [type=reset], [type=submit]": {
    WebkitAppearance: "button"
  },
  "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner": {
    borderStyle: "none",
    padding: 0
  },
  "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring": {
    outline: "1px dotted ButtonText"
  },
  legend: {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: 0,
    whiteSpace: "normal"
  },
  progress: {
    display: "inline-block",
    verticalAlign: "baseline"
  },
  textarea: {
    overflow: "auto"
  },
  "[type=checkbox], [type=radio]": {
    boxSizing: "border-box",
    padding: 0
  },
  "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button": {
    height: "auto"
  },
  "[type=search]": {
    appearance: "none"
  },
  "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration": {
    appearance: "none"
  },
  "::-webkit-file-upload-button": {
    appearance: "button",
    font: "inherit"
  },
  "details, menu": {
    display: "block"
  },
  summary: {
    display: "list-item"
  },
  canvas: {
    display: "inline-block"
  },
  template: {
    display: "none"
  },
  "[hidden]": {
    display: "none"
  }
};
function Cae() {
  return /* @__PURE__ */ le.createElement(_y, {
    styles: Eae
  });
}
var Tae = Object.defineProperty, XL = Object.getOwnPropertySymbols, _ae = Object.prototype.hasOwnProperty, Oae = Object.prototype.propertyIsEnumerable, QL = (e, t, n) => t in e ? Tae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, O0 = (e, t) => {
  for (var n in t || (t = {}))
    _ae.call(t, n) && QL(e, n, t[n]);
  if (XL)
    for (var n of XL(t))
      Oae.call(t, n) && QL(e, n, t[n]);
  return e;
};
const yE = C.createContext({
  theme: tM
});
function Da() {
  var e;
  return ((e = C.useContext(yE)) == null ? void 0 : e.theme) || tM;
}
function Pae(e) {
  const t = Da(), n = (r) => {
    var a, s;
    return {
      styles: ((a = t.components[r]) == null ? void 0 : a.styles) || {},
      classNames: ((s = t.components[r]) == null ? void 0 : s.classNames) || {}
    };
  };
  return Array.isArray(e) ? e.map(n) : [n(e)];
}
function s4() {
  var e;
  return (e = C.useContext(yE)) == null ? void 0 : e.emotionCache;
}
function vn(e, t, n) {
  var r;
  const a = Da(), s = (r = a.components[e]) == null ? void 0 : r.defaultProps, l = typeof s == "function" ? s(a) : s;
  return O0(O0(O0({}, t), l), i4(n));
}
function l4({
  theme: e,
  emotionCache: t,
  withNormalizeCSS: n = !1,
  withGlobalStyles: r = !1,
  withCSSVariables: a = !1,
  inherit: s = !1,
  children: l
}) {
  const p = C.useContext(yE), m = Sae(tM, s ? O0(O0({}, p.theme), e) : e);
  return /* @__PURE__ */ le.createElement(rne, {
    theme: m
  }, /* @__PURE__ */ le.createElement(yE.Provider, {
    value: { theme: m, emotionCache: t }
  }, n && /* @__PURE__ */ le.createElement(Cae, null), r && /* @__PURE__ */ le.createElement(mae, {
    theme: m
  }), a && /* @__PURE__ */ le.createElement(hae, {
    theme: m
  }), typeof m.globalStyles == "function" && /* @__PURE__ */ le.createElement(_y, {
    styles: m.globalStyles(m)
  }), l));
}
l4.displayName = "@mantine/core/MantineProvider";
const Rae = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function fd(e) {
  return Rae[e];
}
function kae(e, t) {
  const n = C.useRef();
  return (!n.current || t.length !== n.current.prevDeps.length || n.current.prevDeps.map((r, a) => r === t[a]).indexOf(!1) >= 0) && (n.current = {
    v: e(),
    prevDeps: [...t]
  }), n.current.v;
}
const Dae = k3({ key: "mantine", prepend: !0 });
function $ae() {
  return s4() || Dae;
}
var Mae = Object.defineProperty, ZL = Object.getOwnPropertySymbols, Nae = Object.prototype.hasOwnProperty, Iae = Object.prototype.propertyIsEnumerable, JL = (e, t, n) => t in e ? Mae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Aae = (e, t) => {
  for (var n in t || (t = {}))
    Nae.call(t, n) && JL(e, n, t[n]);
  if (ZL)
    for (var n of ZL(t))
      Iae.call(t, n) && JL(e, n, t[n]);
  return e;
};
const fk = "ref";
function jae(e) {
  let t;
  if (e.length !== 1)
    return { args: e, ref: t };
  const [n] = e;
  if (!(n instanceof Object))
    return { args: e, ref: t };
  if (!(fk in n))
    return { args: e, ref: t };
  t = n[fk];
  const r = Aae({}, n);
  return delete r[fk], { args: [r], ref: t };
}
const { cssFactory: Lae } = (() => {
  function e(n, r, a) {
    const s = [], l = vT(n, s, a);
    return s.length < 2 ? a : l + r(s);
  }
  function t(n) {
    const { cache: r } = n, a = (...l) => {
      const { ref: p, args: m } = jae(l), h = Sm(m, r.registered);
      return aw(r, h, !1), `${r.key}-${h.name}${p === void 0 ? "" : ` ${p}`}`;
    };
    return { css: a, cx: (...l) => e(r.registered, a, t4(l)) };
  }
  return { cssFactory: t };
})();
function u4() {
  const e = $ae();
  return kae(() => Lae({ cache: e }), [e]);
}
function Fae({
  cx: e,
  classes: t,
  context: n,
  classNames: r,
  name: a,
  cache: s
}) {
  const l = n.reduce((p, m) => (Object.keys(m.classNames).forEach((h) => {
    typeof p[h] != "string" ? p[h] = `${m.classNames[h]}` : p[h] = `${p[h]} ${m.classNames[h]}`;
  }), p), {});
  return Object.keys(t).reduce((p, m) => (p[m] = e(t[m], l[m], r != null && r[m], Array.isArray(a) ? a.filter(Boolean).map((h) => `${(s == null ? void 0 : s.key) || "mantine"}-${h}-${m}`).join(" ") : a ? `${(s == null ? void 0 : s.key) || "mantine"}-${a}-${m}` : null), p), {});
}
var zae = Object.defineProperty, eF = Object.getOwnPropertySymbols, Vae = Object.prototype.hasOwnProperty, Uae = Object.prototype.propertyIsEnumerable, tF = (e, t, n) => t in e ? zae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, pk = (e, t) => {
  for (var n in t || (t = {}))
    Vae.call(t, n) && tF(e, n, t[n]);
  if (eF)
    for (var n of eF(t))
      Uae.call(t, n) && tF(e, n, t[n]);
  return e;
};
function Bae(e) {
  return `__mantine-ref-${e || ""}`;
}
function nF(e, t, n) {
  const r = (a) => typeof a == "function" ? a(t, n || {}) : a || {};
  return Array.isArray(e) ? e.map((a) => r(a.styles)).reduce((a, s) => (Object.keys(s).forEach((l) => {
    a[l] ? a[l] = pk(pk({}, a[l]), s[l]) : a[l] = pk({}, s[l]);
  }), a), {}) : r(e);
}
function yn(e) {
  const t = typeof e == "function" ? e : () => e;
  function n(r, a) {
    const s = Da(), l = Pae(a == null ? void 0 : a.name), p = s4(), { css: m, cx: h } = u4(), g = t(s, r, Bae), b = nF(a == null ? void 0 : a.styles, s, r), x = nF(l, s, r), E = Object.fromEntries(Object.keys(g).map((O) => {
      const _ = h({ [m(g[O])]: !(a != null && a.unstyled) }, m(x[O]), m(b[O]));
      return [O, _];
    }));
    return {
      classes: Fae({
        cx: h,
        classes: E,
        context: l,
        classNames: a == null ? void 0 : a.classNames,
        name: a == null ? void 0 : a.name,
        cache: p
      }),
      cx: h,
      theme: s
    };
  }
  return n;
}
var Hae = Object.defineProperty, Wae = Object.defineProperties, Yae = Object.getOwnPropertyDescriptors, rF = Object.getOwnPropertySymbols, qae = Object.prototype.hasOwnProperty, Gae = Object.prototype.propertyIsEnumerable, oF = (e, t, n) => t in e ? Hae(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Kb = (e, t) => {
  for (var n in t || (t = {}))
    qae.call(t, n) && oF(e, n, t[n]);
  if (rF)
    for (var n of rF(t))
      Gae.call(t, n) && oF(e, n, t[n]);
  return e;
}, Xb = (e, t) => Wae(e, Yae(t));
const Qb = {
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: "scale(.9) translateY(10px)" },
  transitionProperty: "transform, opacity"
}, p1 = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: Xb(Kb({}, Qb), {
    common: { transformOrigin: "center center" }
  }),
  "pop-bottom-left": Xb(Kb({}, Qb), {
    common: { transformOrigin: "bottom left" }
  }),
  "pop-bottom-right": Xb(Kb({}, Qb), {
    common: { transformOrigin: "bottom right" }
  }),
  "pop-top-left": Xb(Kb({}, Qb), {
    common: { transformOrigin: "top left" }
  }),
  "pop-top-right": Xb(Kb({}, Qb), {
    common: { transformOrigin: "top right" }
  })
}, aF = ["mousedown", "touchstart"];
function Kae(e, t, n) {
  const r = C.useRef();
  return C.useEffect(() => {
    const a = (s) => {
      const { target: l } = s ?? {};
      if (Array.isArray(n)) {
        const p = (l == null ? void 0 : l.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(l) && l.tagName !== "HTML";
        n.every((h) => !!h && !s.composedPath().includes(h)) && !p && e();
      } else
        r.current && !r.current.contains(l) && e();
    };
    return (t || aF).forEach((s) => document.addEventListener(s, a)), () => {
      (t || aF).forEach((s) => document.removeEventListener(s, a));
    };
  }, [r, e, n]), r;
}
function Xae(e, t) {
  try {
    return e.addEventListener("change", t), () => e.removeEventListener("change", t);
  } catch {
    return e.addListener(t), () => e.removeListener(t);
  }
}
function Qae(e, t) {
  return typeof t == "boolean" ? t : typeof window < "u" && "matchMedia" in window ? window.matchMedia(e).matches : !1;
}
function Zae(e, t, { getInitialValueInEffect: n } = {
  getInitialValueInEffect: !0
}) {
  const [r, a] = C.useState(n ? t : Qae(e, t)), s = C.useRef();
  return C.useEffect(() => {
    if ("matchMedia" in window)
      return s.current = window.matchMedia(e), a(s.current.matches), Xae(s.current, (l) => a(l.matches));
  }, [e]), r;
}
const c4 = typeof document < "u" ? C.useLayoutEffect : C.useEffect;
function Xs(e, t) {
  const n = C.useRef(!1);
  C.useEffect(() => () => {
    n.current = !1;
  }, []), C.useEffect(() => {
    if (n.current)
      return e();
    n.current = !0;
  }, t);
}
function d4({ opened: e, shouldReturnFocus: t = !0 }) {
  const n = C.useRef(), r = () => {
    var a;
    n.current && "focus" in n.current && typeof n.current.focus == "function" && ((a = n.current) == null || a.focus({ preventScroll: !0 }));
  };
  return Xs(() => {
    let a = -1;
    const s = (l) => {
      l.key === "Tab" && window.clearTimeout(a);
    };
    return document.addEventListener("keydown", s), e ? n.current = document.activeElement : t && (a = window.setTimeout(r, 10)), () => {
      window.clearTimeout(a), document.removeEventListener("keydown", s);
    };
  }, [e, t]), r;
}
const Jae = /input|select|textarea|button|object/, f4 = "a, input, select, textarea, button, object, [tabindex]";
function eie(e) {
  return process.env.NODE_ENV === "test" ? !1 : e.style.display === "none";
}
function tie(e) {
  if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || e.getAttribute("type") === "hidden")
    return !1;
  let n = e;
  for (; n && !(n === document.body || n.nodeType === 11); ) {
    if (eie(n))
      return !1;
    n = n.parentNode;
  }
  return !0;
}
function p4(e) {
  let t = e.getAttribute("tabindex");
  return t === null && (t = void 0), parseInt(t, 10);
}
function ND(e) {
  const t = e.nodeName.toLowerCase(), n = !Number.isNaN(p4(e));
  return (Jae.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || n) && tie(e);
}
function m4(e) {
  const t = p4(e);
  return (Number.isNaN(t) || t >= 0) && ND(e);
}
function nie(e) {
  return Array.from(e.querySelectorAll(f4)).filter(m4);
}
function rie(e, t) {
  const n = nie(e);
  if (!n.length) {
    t.preventDefault();
    return;
  }
  const r = n[t.shiftKey ? 0 : n.length - 1], a = e.getRootNode();
  if (!(r === a.activeElement || e === a.activeElement))
    return;
  t.preventDefault();
  const l = n[t.shiftKey ? n.length - 1 : 0];
  l && l.focus();
}
function oie(e, t = "body > :not(script)") {
  const n = Array.from(document.querySelectorAll(t)).map((r) => {
    var a;
    if ((a = r == null ? void 0 : r.shadowRoot) != null && a.contains(e) || r.contains(e))
      return;
    const s = r.getAttribute("aria-hidden");
    return (s === null || s === "false") && r.setAttribute("aria-hidden", "true"), { node: r, ariaHidden: s };
  });
  return () => {
    n.forEach((r) => {
      r && (r.ariaHidden === null ? r.node.removeAttribute("aria-hidden") : r.node.setAttribute("aria-hidden", r.ariaHidden));
    });
  };
}
function h4(e = !0) {
  const t = C.useRef(), n = C.useRef(null), r = C.useCallback((a) => {
    if (e) {
      if (a === null) {
        n.current && (n.current(), n.current = null);
        return;
      }
      if (n.current = oie(a), t.current !== a)
        if (a) {
          const s = () => {
            let l = a.querySelector("[data-autofocus]");
            if (!l) {
              const p = Array.from(a.querySelectorAll(f4));
              l = p.find(m4) || p.find(ND) || null, !l && ND(a) && (l = a);
            }
            l ? l.focus({ preventScroll: !0 }) : process.env.NODE_ENV === "development" && console.warn("[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node", a);
          };
          setTimeout(() => {
            a.getRootNode() ? s() : process.env.NODE_ENV === "development" && console.warn("[@mantine/hooks/use-focus-trap] Ref node is not part of the dom", a);
          }), t.current = a;
        } else
          t.current = null;
    }
  }, [e]);
  return C.useEffect(() => {
    if (!e)
      return;
    const a = (s) => {
      s.key === "Tab" && t.current && rie(t.current, s);
    };
    return document.addEventListener("keydown", a), () => {
      document.removeEventListener("keydown", a), n.current && n.current();
    };
  }, [e]), r;
}
const aie = () => `mantine-${Math.random().toString(36).slice(2, 11)}`, iie = le["useId".toString()] || (() => {
});
function sie() {
  const [e, t] = C.useState("");
  return c4(() => {
    t(aie());
  }, []), e;
}
function lie() {
  const e = iie();
  return e ? `mantine-${e.replace(/:/g, "")}` : "";
}
function Hf(e) {
  return typeof e == "string" ? e : lie() || sie();
}
function ID(e, t, n) {
  C.useEffect(() => (window.addEventListener(e, t, n), () => window.removeEventListener(e, t, n)), [e, t]);
}
function uie(e, t) {
  typeof e == "function" ? e(t) : typeof e == "object" && e !== null && "current" in e && (e.current = t);
}
function cie(...e) {
  return (t) => {
    e.forEach((n) => uie(n, t));
  };
}
function Wf(...e) {
  return C.useCallback(cie(...e), e);
}
function Ju({
  value: e,
  defaultValue: t,
  finalValue: n,
  onChange: r = () => {
  }
}) {
  const [a, s] = C.useState(t !== void 0 ? t : n), l = (p) => {
    s(p), r == null || r(p);
  };
  return e !== void 0 ? [e, r, !0] : [a, l, !1];
}
function v4(e, t) {
  return Zae("(prefers-reduced-motion: reduce)", e, t);
}
const die = (e) => e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e, fie = ({
  axis: e,
  target: t,
  parent: n,
  alignment: r,
  offset: a,
  isList: s
}) => {
  if (!t || !n && typeof document > "u")
    return 0;
  const l = !!n, m = (n || document.body).getBoundingClientRect(), h = t.getBoundingClientRect(), g = (b) => h[b] - m[b];
  if (e === "y") {
    const b = g("top");
    if (b === 0)
      return 0;
    if (r === "start") {
      const E = b - a;
      return E <= h.height * (s ? 0 : 1) || !s ? E : 0;
    }
    const x = l ? m.height : window.innerHeight;
    if (r === "end") {
      const E = b + a - x + h.height;
      return E >= -h.height * (s ? 0 : 1) || !s ? E : 0;
    }
    return r === "center" ? b - x / 2 + h.height / 2 : 0;
  }
  if (e === "x") {
    const b = g("left");
    if (b === 0)
      return 0;
    if (r === "start") {
      const E = b - a;
      return E <= h.width || !s ? E : 0;
    }
    const x = l ? m.width : window.innerWidth;
    if (r === "end") {
      const E = b + a - x + h.width;
      return E >= -h.width || !s ? E : 0;
    }
    return r === "center" ? b - x / 2 + h.width / 2 : 0;
  }
  return 0;
}, pie = ({ axis: e, parent: t }) => {
  if (!t && typeof document > "u")
    return 0;
  const n = e === "y" ? "scrollTop" : "scrollLeft";
  if (t)
    return t[n];
  const { body: r, documentElement: a } = document;
  return r[n] + a[n];
}, mie = ({ axis: e, parent: t, distance: n }) => {
  if (!t && typeof document > "u")
    return;
  const r = e === "y" ? "scrollTop" : "scrollLeft";
  if (t)
    t[r] = n;
  else {
    const { body: a, documentElement: s } = document;
    a[r] = n, s[r] = n;
  }
};
function y4({
  duration: e = 1250,
  axis: t = "y",
  onScrollFinish: n,
  easing: r = die,
  offset: a = 0,
  cancelable: s = !0,
  isList: l = !1
} = {}) {
  const p = C.useRef(0), m = C.useRef(0), h = C.useRef(!1), g = C.useRef(null), b = C.useRef(null), x = v4(), E = () => {
    p.current && cancelAnimationFrame(p.current);
  }, O = C.useCallback(({ alignment: P = "start" } = {}) => {
    var M;
    h.current = !1, p.current && E();
    const D = (M = pie({ parent: g.current, axis: t })) != null ? M : 0, N = fie({
      parent: g.current,
      target: b.current,
      axis: t,
      alignment: P,
      offset: a,
      isList: l
    }) - (g.current ? 0 : D);
    function I() {
      m.current === 0 && (m.current = performance.now());
      const j = performance.now() - m.current, U = x || e === 0 ? 1 : j / e, q = D + N * r(U);
      mie({
        parent: g.current,
        axis: t,
        distance: q
      }), !h.current && U < 1 ? p.current = requestAnimationFrame(I) : (typeof n == "function" && n(), m.current = 0, p.current = 0, E());
    }
    I();
  }, [t, e, r, l, a, n, x]), _ = () => {
    s && (h.current = !0);
  };
  return ID("wheel", _, {
    passive: !0
  }), ID("touchmove", _, {
    passive: !0
  }), C.useEffect(() => E, []), {
    scrollableRef: g,
    targetRef: b,
    scrollIntoView: O,
    cancel: E
  };
}
function hie() {
  if (typeof window > "u" || typeof document > "u")
    return 0;
  const e = parseInt(window.getComputedStyle(document.body).paddingRight, 10), t = window.innerWidth - document.documentElement.clientWidth;
  return e + t;
}
const vie = ({ disableBodyPadding: e }) => {
  const t = e ? null : hie();
  return `body {
        --removed-scroll-width: ${t}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${t ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
};
function yie(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function gie(e) {
  (document.head || document.getElementsByTagName("head")[0]).appendChild(e);
}
function bie() {
  const e = document.createElement("style");
  return e.type = "text/css", e.setAttribute("mantine-scroll-lock", ""), e;
}
function wie(e, t = {
  disableBodyPadding: !1
}) {
  const [n, r] = C.useState(e || !1), a = C.useRef(0), { disableBodyPadding: s } = t, l = C.useRef(null), p = () => {
    a.current = window.scrollY;
    const h = vie({ disableBodyPadding: s }), g = bie();
    yie(g, h), gie(g), l.current = g;
  }, m = () => {
    l != null && l.current && (l.current.parentNode.removeChild(l.current), l.current = null);
  };
  return C.useEffect(() => (n ? p() : m(), m), [n]), C.useEffect(() => {
    e !== void 0 && r(e);
  }, [e]), C.useEffect(() => {
    e === void 0 && typeof window < "u" && window.document.body.style.overflow === "hidden" && r(!0);
  }, [r]), [n, r];
}
function g4(e) {
  const t = C.useRef();
  return C.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}
function xie() {
  return `mantine-${Math.random().toString(36).slice(2, 11)}`;
}
var iF = Object.getOwnPropertySymbols, Sie = Object.prototype.hasOwnProperty, Eie = Object.prototype.propertyIsEnumerable, Cie = (e, t) => {
  var n = {};
  for (var r in e)
    Sie.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && iF)
    for (var r of iF(e))
      t.indexOf(r) < 0 && Eie.call(e, r) && (n[r] = e[r]);
  return n;
};
function Oy(e) {
  const t = e, {
    m: n,
    mx: r,
    my: a,
    mt: s,
    mb: l,
    ml: p,
    mr: m,
    p: h,
    px: g,
    py: b,
    pt: x,
    pb: E,
    pl: O,
    pr: _,
    bg: P,
    c: M,
    opacity: D,
    ff: N,
    fz: I,
    fw: R,
    lts: j,
    ta: U,
    lh: q,
    fs: J,
    tt: H,
    td: Z,
    w: re,
    miw: Y,
    maw: K,
    h: Q,
    mih: te,
    mah: ne,
    bgsz: ae,
    bgp: se,
    bgr: V,
    bga: ee,
    pos: he,
    top: ue,
    left: fe,
    bottom: Ce,
    right: Se,
    inset: Te,
    display: pe
  } = t, ye = Cie(t, [
    "m",
    "mx",
    "my",
    "mt",
    "mb",
    "ml",
    "mr",
    "p",
    "px",
    "py",
    "pt",
    "pb",
    "pl",
    "pr",
    "bg",
    "c",
    "opacity",
    "ff",
    "fz",
    "fw",
    "lts",
    "ta",
    "lh",
    "fs",
    "tt",
    "td",
    "w",
    "miw",
    "maw",
    "h",
    "mih",
    "mah",
    "bgsz",
    "bgp",
    "bgr",
    "bga",
    "pos",
    "top",
    "left",
    "bottom",
    "right",
    "inset",
    "display"
  ]);
  return { systemStyles: i4({
    m: n,
    mx: r,
    my: a,
    mt: s,
    mb: l,
    ml: p,
    mr: m,
    p: h,
    px: g,
    py: b,
    pt: x,
    pb: E,
    pl: O,
    pr: _,
    bg: P,
    c: M,
    opacity: D,
    ff: N,
    fz: I,
    fw: R,
    lts: j,
    ta: U,
    lh: q,
    fs: J,
    tt: H,
    td: Z,
    w: re,
    miw: Y,
    maw: K,
    h: Q,
    mih: te,
    mah: ne,
    bgsz: ae,
    bgp: se,
    bgr: V,
    bga: ee,
    pos: he,
    top: ue,
    left: fe,
    bottom: Ce,
    right: Se,
    inset: Te,
    display: pe
  }), rest: ye };
}
function Tie(e, t) {
  const n = Object.keys(e).filter((r) => r !== "base").sort((r, a) => t.fn.size({ size: r, sizes: t.breakpoints }) - t.fn.size({ size: a, sizes: t.breakpoints }));
  return "base" in e ? ["base", ...n] : n;
}
function _ie({ value: e, theme: t, getValue: n, property: r }) {
  if (e == null)
    return;
  if (typeof e == "object")
    return Tie(e, t).reduce((l, p) => {
      if (p === "base" && e.base !== void 0) {
        const h = n(e.base, t);
        return Array.isArray(r) ? (r.forEach((g) => {
          l[g] = h;
        }), l) : (l[r] = h, l);
      }
      const m = n(e[p], t);
      return Array.isArray(r) ? (l[t.fn.largerThan(p)] = {}, r.forEach((h) => {
        l[t.fn.largerThan(p)][h] = m;
      }), l) : (l[t.fn.largerThan(p)] = {
        [r]: m
      }, l);
    }, {});
  const a = n(e, t);
  return Array.isArray(r) ? r.reduce((s, l) => (s[l] = a, s), {}) : { [r]: a };
}
function Oie(e, t) {
  return e === "dimmed" ? t.colorScheme === "dark" ? t.colors.dark[2] : t.colors.gray[6] : t.fn.variant({ variant: "filled", color: e, primaryFallback: !1 }).background;
}
function Pie(e) {
  return e;
}
function Rie(e, t) {
  return t.fn.size({ size: e, sizes: t.fontSizes });
}
const kie = ["-xs", "-sm", "-md", "-lg", "-xl"];
function Die(e, t) {
  return kie.includes(e) ? t.fn.size({ size: e.replace("-", ""), sizes: t.spacing }) * -1 : t.fn.size({ size: e, sizes: t.spacing });
}
const $ie = {
  color: Oie,
  default: Pie,
  fontSize: Rie,
  spacing: Die
}, Mie = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  mx: { type: "spacing", property: ["marginRight", "marginLeft"] },
  my: { type: "spacing", property: ["marginTop", "marginBottom"] },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  px: { type: "spacing", property: ["paddingRight", "paddingLeft"] },
  py: { type: "spacing", property: ["paddingTop", "paddingBottom"] },
  bg: { type: "color", property: "background" },
  c: { type: "color", property: "color" },
  opacity: { type: "default", property: "opacity" },
  ff: { type: "default", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "default", property: "fontWeight" },
  lts: { type: "default", property: "letterSpacing" },
  ta: { type: "default", property: "textAlign" },
  lh: { type: "default", property: "lineHeight" },
  fs: { type: "default", property: "fontStyle" },
  tt: { type: "default", property: "textTransform" },
  td: { type: "default", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "default", property: "background-size" },
  bgp: { type: "default", property: "background-position" },
  bgr: { type: "default", property: "background-repeat" },
  bga: { type: "default", property: "background-attachment" },
  pos: { type: "default", property: "position" },
  top: { type: "default", property: "top" },
  left: { type: "default", property: "left" },
  bottom: { type: "default", property: "bottom" },
  right: { type: "default", property: "right" },
  inset: { type: "default", property: "inset" },
  display: { type: "default", property: "display" }
};
var Nie = Object.defineProperty, sF = Object.getOwnPropertySymbols, Iie = Object.prototype.hasOwnProperty, Aie = Object.prototype.propertyIsEnumerable, lF = (e, t, n) => t in e ? Nie(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, uF = (e, t) => {
  for (var n in t || (t = {}))
    Iie.call(t, n) && lF(e, n, t[n]);
  if (sF)
    for (var n of sF(t))
      Aie.call(t, n) && lF(e, n, t[n]);
  return e;
};
function cF(e, t, n = Mie) {
  return Object.keys(n).reduce((a, s) => (s in e && e[s] !== void 0 && a.push(_ie({
    value: e[s],
    getValue: $ie[n[s].type],
    property: n[s].property,
    theme: t
  })), a), []).reduce((a, s) => (Object.keys(s).forEach((l) => {
    typeof s[l] == "object" && s[l] !== null && l in a ? a[l] = uF(uF({}, a[l]), s[l]) : a[l] = s[l];
  }), a), {});
}
function dF(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function jie(e, t, n) {
  const r = Da(), { css: a, cx: s } = u4();
  return Array.isArray(e) ? s(n, a(cF(t, r)), e.map((l) => a(dF(l, r)))) : s(n, a(dF(e, r)), a(cF(t, r)));
}
var Lie = Object.defineProperty, gE = Object.getOwnPropertySymbols, b4 = Object.prototype.hasOwnProperty, w4 = Object.prototype.propertyIsEnumerable, fF = (e, t, n) => t in e ? Lie(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Fie = (e, t) => {
  for (var n in t || (t = {}))
    b4.call(t, n) && fF(e, n, t[n]);
  if (gE)
    for (var n of gE(t))
      w4.call(t, n) && fF(e, n, t[n]);
  return e;
}, zie = (e, t) => {
  var n = {};
  for (var r in e)
    b4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && gE)
    for (var r of gE(e))
      t.indexOf(r) < 0 && w4.call(e, r) && (n[r] = e[r]);
  return n;
};
const x4 = C.forwardRef((e, t) => {
  var n = e, { className: r, component: a, style: s, sx: l } = n, p = zie(n, ["className", "component", "style", "sx"]);
  const { systemStyles: m, rest: h } = Oy(p), g = a || "div";
  return /* @__PURE__ */ le.createElement(g, Fie({
    ref: t,
    className: jie(l, m, r),
    style: s
  }, h));
});
x4.displayName = "@mantine/core/Box";
const hn = x4;
var Vie = Object.defineProperty, Uie = Object.defineProperties, Bie = Object.getOwnPropertyDescriptors, pF = Object.getOwnPropertySymbols, Hie = Object.prototype.hasOwnProperty, Wie = Object.prototype.propertyIsEnumerable, mF = (e, t, n) => t in e ? Vie(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, hF = (e, t) => {
  for (var n in t || (t = {}))
    Hie.call(t, n) && mF(e, n, t[n]);
  if (pF)
    for (var n of pF(t))
      Wie.call(t, n) && mF(e, n, t[n]);
  return e;
}, Yie = (e, t) => Uie(e, Bie(t)), qie = yn((e) => ({
  root: Yie(hF(hF({}, e.fn.focusStyles()), e.fn.fontStyles()), {
    cursor: "pointer",
    border: 0,
    padding: 0,
    appearance: "none",
    fontSize: e.fontSizes.md,
    backgroundColor: "transparent",
    textAlign: "left",
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    textDecoration: "none",
    boxSizing: "border-box"
  })
}));
const Gie = qie;
var Kie = Object.defineProperty, bE = Object.getOwnPropertySymbols, S4 = Object.prototype.hasOwnProperty, E4 = Object.prototype.propertyIsEnumerable, vF = (e, t, n) => t in e ? Kie(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Xie = (e, t) => {
  for (var n in t || (t = {}))
    S4.call(t, n) && vF(e, n, t[n]);
  if (bE)
    for (var n of bE(t))
      E4.call(t, n) && vF(e, n, t[n]);
  return e;
}, Qie = (e, t) => {
  var n = {};
  for (var r in e)
    S4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && bE)
    for (var r of bE(e))
      t.indexOf(r) < 0 && E4.call(e, r) && (n[r] = e[r]);
  return n;
};
const C4 = C.forwardRef((e, t) => {
  const n = vn("UnstyledButton", {}, e), {
    className: r,
    component: a = "button",
    unstyled: s
  } = n, l = Qie(n, [
    "className",
    "component",
    "unstyled"
  ]), { classes: p, cx: m } = Gie(null, { name: "UnstyledButton", unstyled: s });
  return /* @__PURE__ */ le.createElement(hn, Xie({
    component: a,
    ref: t,
    className: m(p.root, r),
    type: a === "button" ? "button" : void 0
  }, l));
});
C4.displayName = "@mantine/core/UnstyledButton";
const MT = C4;
var AD = { exports: {} }, Bi = {}, m1 = { exports: {} }, mk = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yF;
function Zie() {
  return yF || (yF = 1, function(e) {
    function t(ae, se) {
      var V = ae.length;
      ae.push(se);
      e:
        for (; 0 < V; ) {
          var ee = V - 1 >>> 1, he = ae[ee];
          if (0 < a(he, se))
            ae[ee] = se, ae[V] = he, V = ee;
          else
            break e;
        }
    }
    function n(ae) {
      return ae.length === 0 ? null : ae[0];
    }
    function r(ae) {
      if (ae.length === 0)
        return null;
      var se = ae[0], V = ae.pop();
      if (V !== se) {
        ae[0] = V;
        e:
          for (var ee = 0, he = ae.length, ue = he >>> 1; ee < ue; ) {
            var fe = 2 * (ee + 1) - 1, Ce = ae[fe], Se = fe + 1, Te = ae[Se];
            if (0 > a(Ce, V))
              Se < he && 0 > a(Te, Ce) ? (ae[ee] = Te, ae[Se] = V, ee = Se) : (ae[ee] = Ce, ae[fe] = V, ee = fe);
            else if (Se < he && 0 > a(Te, V))
              ae[ee] = Te, ae[Se] = V, ee = Se;
            else
              break e;
          }
      }
      return se;
    }
    function a(ae, se) {
      var V = ae.sortIndex - se.sortIndex;
      return V !== 0 ? V : ae.id - se.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, p = l.now();
      e.unstable_now = function() {
        return l.now() - p;
      };
    }
    var m = [], h = [], g = 1, b = null, x = 3, E = !1, O = !1, _ = !1, P = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, D = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function N(ae) {
      for (var se = n(h); se !== null; ) {
        if (se.callback === null)
          r(h);
        else if (se.startTime <= ae)
          r(h), se.sortIndex = se.expirationTime, t(m, se);
        else
          break;
        se = n(h);
      }
    }
    function I(ae) {
      if (_ = !1, N(ae), !O)
        if (n(m) !== null)
          O = !0, te(R);
        else {
          var se = n(h);
          se !== null && ne(I, se.startTime - ae);
        }
    }
    function R(ae, se) {
      O = !1, _ && (_ = !1, M(q), q = -1), E = !0;
      var V = x;
      try {
        for (N(se), b = n(m); b !== null && (!(b.expirationTime > se) || ae && !Z()); ) {
          var ee = b.callback;
          if (typeof ee == "function") {
            b.callback = null, x = b.priorityLevel;
            var he = ee(b.expirationTime <= se);
            se = e.unstable_now(), typeof he == "function" ? b.callback = he : b === n(m) && r(m), N(se);
          } else
            r(m);
          b = n(m);
        }
        if (b !== null)
          var ue = !0;
        else {
          var fe = n(h);
          fe !== null && ne(I, fe.startTime - se), ue = !1;
        }
        return ue;
      } finally {
        b = null, x = V, E = !1;
      }
    }
    var j = !1, U = null, q = -1, J = 5, H = -1;
    function Z() {
      return !(e.unstable_now() - H < J);
    }
    function re() {
      if (U !== null) {
        var ae = e.unstable_now();
        H = ae;
        var se = !0;
        try {
          se = U(!0, ae);
        } finally {
          se ? Y() : (j = !1, U = null);
        }
      } else
        j = !1;
    }
    var Y;
    if (typeof D == "function")
      Y = function() {
        D(re);
      };
    else if (typeof MessageChannel < "u") {
      var K = new MessageChannel(), Q = K.port2;
      K.port1.onmessage = re, Y = function() {
        Q.postMessage(null);
      };
    } else
      Y = function() {
        P(re, 0);
      };
    function te(ae) {
      U = ae, j || (j = !0, Y());
    }
    function ne(ae, se) {
      q = P(function() {
        ae(e.unstable_now());
      }, se);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(ae) {
      ae.callback = null;
    }, e.unstable_continueExecution = function() {
      O || E || (O = !0, te(R));
    }, e.unstable_forceFrameRate = function(ae) {
      0 > ae || 125 < ae ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : J = 0 < ae ? Math.floor(1e3 / ae) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(m);
    }, e.unstable_next = function(ae) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var se = 3;
          break;
        default:
          se = x;
      }
      var V = x;
      x = se;
      try {
        return ae();
      } finally {
        x = V;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(ae, se) {
      switch (ae) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ae = 3;
      }
      var V = x;
      x = ae;
      try {
        return se();
      } finally {
        x = V;
      }
    }, e.unstable_scheduleCallback = function(ae, se, V) {
      var ee = e.unstable_now();
      switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? ee + V : ee) : V = ee, ae) {
        case 1:
          var he = -1;
          break;
        case 2:
          he = 250;
          break;
        case 5:
          he = 1073741823;
          break;
        case 4:
          he = 1e4;
          break;
        default:
          he = 5e3;
      }
      return he = V + he, ae = { id: g++, callback: se, priorityLevel: ae, startTime: V, expirationTime: he, sortIndex: -1 }, V > ee ? (ae.sortIndex = V, t(h, ae), n(m) === null && ae === n(h) && (_ ? (M(q), q = -1) : _ = !0, ne(I, V - ee))) : (ae.sortIndex = he, t(m, ae), O || E || (O = !0, te(R))), ae;
    }, e.unstable_shouldYield = Z, e.unstable_wrapCallback = function(ae) {
      var se = x;
      return function() {
        var V = x;
        x = se;
        try {
          return ae.apply(this, arguments);
        } finally {
          x = V;
        }
      };
    };
  }(mk)), mk;
}
var hk = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gF;
function Jie() {
  return gF || (gF = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, n = !1, r = 5;
      function a(Ne, Ie) {
        var Je = Ne.length;
        Ne.push(Ie), p(Ne, Ie, Je);
      }
      function s(Ne) {
        return Ne.length === 0 ? null : Ne[0];
      }
      function l(Ne) {
        if (Ne.length === 0)
          return null;
        var Ie = Ne[0], Je = Ne.pop();
        return Je !== Ie && (Ne[0] = Je, m(Ne, Je, 0)), Ie;
      }
      function p(Ne, Ie, Je) {
        for (var pt = Je; pt > 0; ) {
          var ht = pt - 1 >>> 1, vt = Ne[ht];
          if (h(vt, Ie) > 0)
            Ne[ht] = Ie, Ne[pt] = vt, pt = ht;
          else
            return;
        }
      }
      function m(Ne, Ie, Je) {
        for (var pt = Je, ht = Ne.length, vt = ht >>> 1; pt < vt; ) {
          var Nt = (pt + 1) * 2 - 1, Tn = Ne[Nt], bt = Nt + 1, Pn = Ne[bt];
          if (h(Tn, Ie) < 0)
            bt < ht && h(Pn, Tn) < 0 ? (Ne[pt] = Pn, Ne[bt] = Ie, pt = bt) : (Ne[pt] = Tn, Ne[Nt] = Ie, pt = Nt);
          else if (bt < ht && h(Pn, Ie) < 0)
            Ne[pt] = Pn, Ne[bt] = Ie, pt = bt;
          else
            return;
        }
      }
      function h(Ne, Ie) {
        var Je = Ne.sortIndex - Ie.sortIndex;
        return Je !== 0 ? Je : Ne.id - Ie.id;
      }
      var g = 1, b = 2, x = 3, E = 4, O = 5;
      function _(Ne, Ie) {
      }
      var P = typeof performance == "object" && typeof performance.now == "function";
      if (P) {
        var M = performance;
        e.unstable_now = function() {
          return M.now();
        };
      } else {
        var D = Date, N = D.now();
        e.unstable_now = function() {
          return D.now() - N;
        };
      }
      var I = 1073741823, R = -1, j = 250, U = 5e3, q = 1e4, J = I, H = [], Z = [], re = 1, Y = null, K = x, Q = !1, te = !1, ne = !1, ae = typeof setTimeout == "function" ? setTimeout : null, se = typeof clearTimeout == "function" ? clearTimeout : null, V = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ee(Ne) {
        for (var Ie = s(Z); Ie !== null; ) {
          if (Ie.callback === null)
            l(Z);
          else if (Ie.startTime <= Ne)
            l(Z), Ie.sortIndex = Ie.expirationTime, a(H, Ie);
          else
            return;
          Ie = s(Z);
        }
      }
      function he(Ne) {
        if (ne = !1, ee(Ne), !te)
          if (s(H) !== null)
            te = !0, Qt(ue);
          else {
            var Ie = s(Z);
            Ie !== null && Ht(he, Ie.startTime - Ne);
          }
      }
      function ue(Ne, Ie) {
        te = !1, ne && (ne = !1, kt()), Q = !0;
        var Je = K;
        try {
          var pt;
          if (!n)
            return fe(Ne, Ie);
        } finally {
          Y = null, K = Je, Q = !1;
        }
      }
      function fe(Ne, Ie) {
        var Je = Ie;
        for (ee(Je), Y = s(H); Y !== null && !t && !(Y.expirationTime > Je && (!Ne || Me())); ) {
          var pt = Y.callback;
          if (typeof pt == "function") {
            Y.callback = null, K = Y.priorityLevel;
            var ht = Y.expirationTime <= Je, vt = pt(ht);
            Je = e.unstable_now(), typeof vt == "function" ? Y.callback = vt : Y === s(H) && l(H), ee(Je);
          } else
            l(H);
          Y = s(H);
        }
        if (Y !== null)
          return !0;
        var Nt = s(Z);
        return Nt !== null && Ht(he, Nt.startTime - Je), !1;
      }
      function Ce(Ne, Ie) {
        switch (Ne) {
          case g:
          case b:
          case x:
          case E:
          case O:
            break;
          default:
            Ne = x;
        }
        var Je = K;
        K = Ne;
        try {
          return Ie();
        } finally {
          K = Je;
        }
      }
      function Se(Ne) {
        var Ie;
        switch (K) {
          case g:
          case b:
          case x:
            Ie = x;
            break;
          default:
            Ie = K;
            break;
        }
        var Je = K;
        K = Ie;
        try {
          return Ne();
        } finally {
          K = Je;
        }
      }
      function Te(Ne) {
        var Ie = K;
        return function() {
          var Je = K;
          K = Ie;
          try {
            return Ne.apply(this, arguments);
          } finally {
            K = Je;
          }
        };
      }
      function pe(Ne, Ie, Je) {
        var pt = e.unstable_now(), ht;
        if (typeof Je == "object" && Je !== null) {
          var vt = Je.delay;
          typeof vt == "number" && vt > 0 ? ht = pt + vt : ht = pt;
        } else
          ht = pt;
        var Nt;
        switch (Ne) {
          case g:
            Nt = R;
            break;
          case b:
            Nt = j;
            break;
          case O:
            Nt = J;
            break;
          case E:
            Nt = q;
            break;
          case x:
          default:
            Nt = U;
            break;
        }
        var Tn = ht + Nt, bt = {
          id: re++,
          callback: Ie,
          priorityLevel: Ne,
          startTime: ht,
          expirationTime: Tn,
          sortIndex: -1
        };
        return ht > pt ? (bt.sortIndex = ht, a(Z, bt), s(H) === null && bt === s(Z) && (ne ? kt() : ne = !0, Ht(he, ht - pt))) : (bt.sortIndex = Tn, a(H, bt), !te && !Q && (te = !0, Qt(ue))), bt;
      }
      function ye() {
      }
      function Oe() {
        !te && !Q && (te = !0, Qt(ue));
      }
      function Fe() {
        return s(H);
      }
      function me(Ne) {
        Ne.callback = null;
      }
      function Pe() {
        return K;
      }
      var Ee = !1, Ke = null, oe = -1, de = r, we = -1;
      function Me() {
        var Ne = e.unstable_now() - we;
        return !(Ne < de);
      }
      function Ae() {
      }
      function je(Ne) {
        if (Ne < 0 || Ne > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ne > 0 ? de = Math.floor(1e3 / Ne) : de = r;
      }
      var qe = function() {
        if (Ke !== null) {
          var Ne = e.unstable_now();
          we = Ne;
          var Ie = !0, Je = !0;
          try {
            Je = Ke(Ie, Ne);
          } finally {
            Je ? ot() : (Ee = !1, Ke = null);
          }
        } else
          Ee = !1;
      }, ot;
      if (typeof V == "function")
        ot = function() {
          V(qe);
        };
      else if (typeof MessageChannel < "u") {
        var et = new MessageChannel(), ct = et.port2;
        et.port1.onmessage = qe, ot = function() {
          ct.postMessage(null);
        };
      } else
        ot = function() {
          ae(qe, 0);
        };
      function Qt(Ne) {
        Ke = Ne, Ee || (Ee = !0, ot());
      }
      function Ht(Ne, Ie) {
        oe = ae(function() {
          Ne(e.unstable_now());
        }, Ie);
      }
      function kt() {
        se(oe), oe = -1;
      }
      var St = Ae, cn = null;
      e.unstable_IdlePriority = O, e.unstable_ImmediatePriority = g, e.unstable_LowPriority = E, e.unstable_NormalPriority = x, e.unstable_Profiling = cn, e.unstable_UserBlockingPriority = b, e.unstable_cancelCallback = me, e.unstable_continueExecution = Oe, e.unstable_forceFrameRate = je, e.unstable_getCurrentPriorityLevel = Pe, e.unstable_getFirstCallbackNode = Fe, e.unstable_next = Se, e.unstable_pauseExecution = ye, e.unstable_requestPaint = St, e.unstable_runWithPriority = Ce, e.unstable_scheduleCallback = pe, e.unstable_shouldYield = Me, e.unstable_wrapCallback = Te, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(hk)), hk;
}
var bF;
function T4() {
  return bF || (bF = 1, process.env.NODE_ENV === "production" ? m1.exports = Zie() : m1.exports = Jie()), m1.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wF;
function ese() {
  if (wF)
    return Bi;
  wF = 1;
  var e = C, t = T4();
  function n(u) {
    for (var d = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, y = 1; y < arguments.length; y++)
      d += "&args[]=" + encodeURIComponent(arguments[y]);
    return "Minified React error #" + u + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), a = {};
  function s(u, d) {
    l(u, d), l(u + "Capture", d);
  }
  function l(u, d) {
    for (a[u] = d, u = 0; u < d.length; u++)
      r.add(d[u]);
  }
  var p = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), m = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, g = {}, b = {};
  function x(u) {
    return m.call(b, u) ? !0 : m.call(g, u) ? !1 : h.test(u) ? b[u] = !0 : (g[u] = !0, !1);
  }
  function E(u, d, y, S) {
    if (y !== null && y.type === 0)
      return !1;
    switch (typeof d) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return S ? !1 : y !== null ? !y.acceptsBooleans : (u = u.toLowerCase().slice(0, 5), u !== "data-" && u !== "aria-");
      default:
        return !1;
    }
  }
  function O(u, d, y, S) {
    if (d === null || typeof d > "u" || E(u, d, y, S))
      return !0;
    if (S)
      return !1;
    if (y !== null)
      switch (y.type) {
        case 3:
          return !d;
        case 4:
          return d === !1;
        case 5:
          return isNaN(d);
        case 6:
          return isNaN(d) || 1 > d;
      }
    return !1;
  }
  function _(u, d, y, S, k, A, X) {
    this.acceptsBooleans = d === 2 || d === 3 || d === 4, this.attributeName = S, this.attributeNamespace = k, this.mustUseProperty = y, this.propertyName = u, this.type = d, this.sanitizeURL = A, this.removeEmptyString = X;
  }
  var P = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u) {
    P[u] = new _(u, 0, !1, u, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
    var d = u[0];
    P[d] = new _(d, 1, !1, u[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
    P[u] = new _(u, 2, !1, u.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
    P[u] = new _(u, 2, !1, u, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u) {
    P[u] = new _(u, 3, !1, u.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(u) {
    P[u] = new _(u, 3, !0, u, null, !1, !1);
  }), ["capture", "download"].forEach(function(u) {
    P[u] = new _(u, 4, !1, u, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(u) {
    P[u] = new _(u, 6, !1, u, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(u) {
    P[u] = new _(u, 5, !1, u.toLowerCase(), null, !1, !1);
  });
  var M = /[\-:]([a-z])/g;
  function D(u) {
    return u[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u) {
    var d = u.replace(
      M,
      D
    );
    P[d] = new _(d, 1, !1, u, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u) {
    var d = u.replace(M, D);
    P[d] = new _(d, 1, !1, u, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(u) {
    var d = u.replace(M, D);
    P[d] = new _(d, 1, !1, u, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(u) {
    P[u] = new _(u, 1, !1, u.toLowerCase(), null, !1, !1);
  }), P.xlinkHref = new _("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(u) {
    P[u] = new _(u, 1, !1, u.toLowerCase(), null, !0, !0);
  });
  function N(u, d, y, S) {
    var k = P.hasOwnProperty(d) ? P[d] : null;
    (k !== null ? k.type !== 0 : S || !(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (O(d, y, k, S) && (y = null), S || k === null ? x(d) && (y === null ? u.removeAttribute(d) : u.setAttribute(d, "" + y)) : k.mustUseProperty ? u[k.propertyName] = y === null ? k.type === 3 ? !1 : "" : y : (d = k.attributeName, S = k.attributeNamespace, y === null ? u.removeAttribute(d) : (k = k.type, y = k === 3 || k === 4 && y === !0 ? "" : "" + y, S ? u.setAttributeNS(S, d, y) : u.setAttribute(d, y))));
  }
  var I = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, R = Symbol.for("react.element"), j = Symbol.for("react.portal"), U = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), H = Symbol.for("react.provider"), Z = Symbol.for("react.context"), re = Symbol.for("react.forward_ref"), Y = Symbol.for("react.suspense"), K = Symbol.for("react.suspense_list"), Q = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), ne = Symbol.for("react.offscreen"), ae = Symbol.iterator;
  function se(u) {
    return u === null || typeof u != "object" ? null : (u = ae && u[ae] || u["@@iterator"], typeof u == "function" ? u : null);
  }
  var V = Object.assign, ee;
  function he(u) {
    if (ee === void 0)
      try {
        throw Error();
      } catch (y) {
        var d = y.stack.trim().match(/\n( *(at )?)/);
        ee = d && d[1] || "";
      }
    return `
` + ee + u;
  }
  var ue = !1;
  function fe(u, d) {
    if (!u || ue)
      return "";
    ue = !0;
    var y = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (d)
        if (d = function() {
          throw Error();
        }, Object.defineProperty(d.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(d, []);
          } catch (Ye) {
            var S = Ye;
          }
          Reflect.construct(u, [], d);
        } else {
          try {
            d.call();
          } catch (Ye) {
            S = Ye;
          }
          u.call(d.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ye) {
          S = Ye;
        }
        u();
      }
    } catch (Ye) {
      if (Ye && S && typeof Ye.stack == "string") {
        for (var k = Ye.stack.split(`
`), A = S.stack.split(`
`), X = k.length - 1, ve = A.length - 1; 1 <= X && 0 <= ve && k[X] !== A[ve]; )
          ve--;
        for (; 1 <= X && 0 <= ve; X--, ve--)
          if (k[X] !== A[ve]) {
            if (X !== 1 || ve !== 1)
              do
                if (X--, ve--, 0 > ve || k[X] !== A[ve]) {
                  var _e = `
` + k[X].replace(" at new ", " at ");
                  return u.displayName && _e.includes("<anonymous>") && (_e = _e.replace("<anonymous>", u.displayName)), _e;
                }
              while (1 <= X && 0 <= ve);
            break;
          }
      }
    } finally {
      ue = !1, Error.prepareStackTrace = y;
    }
    return (u = u ? u.displayName || u.name : "") ? he(u) : "";
  }
  function Ce(u) {
    switch (u.tag) {
      case 5:
        return he(u.type);
      case 16:
        return he("Lazy");
      case 13:
        return he("Suspense");
      case 19:
        return he("SuspenseList");
      case 0:
      case 2:
      case 15:
        return u = fe(u.type, !1), u;
      case 11:
        return u = fe(u.type.render, !1), u;
      case 1:
        return u = fe(u.type, !0), u;
      default:
        return "";
    }
  }
  function Se(u) {
    if (u == null)
      return null;
    if (typeof u == "function")
      return u.displayName || u.name || null;
    if (typeof u == "string")
      return u;
    switch (u) {
      case U:
        return "Fragment";
      case j:
        return "Portal";
      case J:
        return "Profiler";
      case q:
        return "StrictMode";
      case Y:
        return "Suspense";
      case K:
        return "SuspenseList";
    }
    if (typeof u == "object")
      switch (u.$$typeof) {
        case Z:
          return (u.displayName || "Context") + ".Consumer";
        case H:
          return (u._context.displayName || "Context") + ".Provider";
        case re:
          var d = u.render;
          return u = u.displayName, u || (u = d.displayName || d.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u;
        case Q:
          return d = u.displayName || null, d !== null ? d : Se(u.type) || "Memo";
        case te:
          d = u._payload, u = u._init;
          try {
            return Se(u(d));
          } catch {
          }
      }
    return null;
  }
  function Te(u) {
    var d = u.type;
    switch (u.tag) {
      case 24:
        return "Cache";
      case 9:
        return (d.displayName || "Context") + ".Consumer";
      case 10:
        return (d._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return u = d.render, u = u.displayName || u.name || "", d.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return d;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Se(d);
      case 8:
        return d === q ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof d == "function")
          return d.displayName || d.name || null;
        if (typeof d == "string")
          return d;
    }
    return null;
  }
  function pe(u) {
    switch (typeof u) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return u;
      case "object":
        return u;
      default:
        return "";
    }
  }
  function ye(u) {
    var d = u.type;
    return (u = u.nodeName) && u.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
  }
  function Oe(u) {
    var d = ye(u) ? "checked" : "value", y = Object.getOwnPropertyDescriptor(u.constructor.prototype, d), S = "" + u[d];
    if (!u.hasOwnProperty(d) && typeof y < "u" && typeof y.get == "function" && typeof y.set == "function") {
      var k = y.get, A = y.set;
      return Object.defineProperty(u, d, { configurable: !0, get: function() {
        return k.call(this);
      }, set: function(X) {
        S = "" + X, A.call(this, X);
      } }), Object.defineProperty(u, d, { enumerable: y.enumerable }), { getValue: function() {
        return S;
      }, setValue: function(X) {
        S = "" + X;
      }, stopTracking: function() {
        u._valueTracker = null, delete u[d];
      } };
    }
  }
  function Fe(u) {
    u._valueTracker || (u._valueTracker = Oe(u));
  }
  function me(u) {
    if (!u)
      return !1;
    var d = u._valueTracker;
    if (!d)
      return !0;
    var y = d.getValue(), S = "";
    return u && (S = ye(u) ? u.checked ? "true" : "false" : u.value), u = S, u !== y ? (d.setValue(u), !0) : !1;
  }
  function Pe(u) {
    if (u = u || (typeof document < "u" ? document : void 0), typeof u > "u")
      return null;
    try {
      return u.activeElement || u.body;
    } catch {
      return u.body;
    }
  }
  function Ee(u, d) {
    var y = d.checked;
    return V({}, d, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: y ?? u._wrapperState.initialChecked });
  }
  function Ke(u, d) {
    var y = d.defaultValue == null ? "" : d.defaultValue, S = d.checked != null ? d.checked : d.defaultChecked;
    y = pe(d.value != null ? d.value : y), u._wrapperState = { initialChecked: S, initialValue: y, controlled: d.type === "checkbox" || d.type === "radio" ? d.checked != null : d.value != null };
  }
  function oe(u, d) {
    d = d.checked, d != null && N(u, "checked", d, !1);
  }
  function de(u, d) {
    oe(u, d);
    var y = pe(d.value), S = d.type;
    if (y != null)
      S === "number" ? (y === 0 && u.value === "" || u.value != y) && (u.value = "" + y) : u.value !== "" + y && (u.value = "" + y);
    else if (S === "submit" || S === "reset") {
      u.removeAttribute("value");
      return;
    }
    d.hasOwnProperty("value") ? Me(u, d.type, y) : d.hasOwnProperty("defaultValue") && Me(u, d.type, pe(d.defaultValue)), d.checked == null && d.defaultChecked != null && (u.defaultChecked = !!d.defaultChecked);
  }
  function we(u, d, y) {
    if (d.hasOwnProperty("value") || d.hasOwnProperty("defaultValue")) {
      var S = d.type;
      if (!(S !== "submit" && S !== "reset" || d.value !== void 0 && d.value !== null))
        return;
      d = "" + u._wrapperState.initialValue, y || d === u.value || (u.value = d), u.defaultValue = d;
    }
    y = u.name, y !== "" && (u.name = ""), u.defaultChecked = !!u._wrapperState.initialChecked, y !== "" && (u.name = y);
  }
  function Me(u, d, y) {
    (d !== "number" || Pe(u.ownerDocument) !== u) && (y == null ? u.defaultValue = "" + u._wrapperState.initialValue : u.defaultValue !== "" + y && (u.defaultValue = "" + y));
  }
  var Ae = Array.isArray;
  function je(u, d, y, S) {
    if (u = u.options, d) {
      d = {};
      for (var k = 0; k < y.length; k++)
        d["$" + y[k]] = !0;
      for (y = 0; y < u.length; y++)
        k = d.hasOwnProperty("$" + u[y].value), u[y].selected !== k && (u[y].selected = k), k && S && (u[y].defaultSelected = !0);
    } else {
      for (y = "" + pe(y), d = null, k = 0; k < u.length; k++) {
        if (u[k].value === y) {
          u[k].selected = !0, S && (u[k].defaultSelected = !0);
          return;
        }
        d !== null || u[k].disabled || (d = u[k]);
      }
      d !== null && (d.selected = !0);
    }
  }
  function qe(u, d) {
    if (d.dangerouslySetInnerHTML != null)
      throw Error(n(91));
    return V({}, d, { value: void 0, defaultValue: void 0, children: "" + u._wrapperState.initialValue });
  }
  function ot(u, d) {
    var y = d.value;
    if (y == null) {
      if (y = d.children, d = d.defaultValue, y != null) {
        if (d != null)
          throw Error(n(92));
        if (Ae(y)) {
          if (1 < y.length)
            throw Error(n(93));
          y = y[0];
        }
        d = y;
      }
      d == null && (d = ""), y = d;
    }
    u._wrapperState = { initialValue: pe(y) };
  }
  function et(u, d) {
    var y = pe(d.value), S = pe(d.defaultValue);
    y != null && (y = "" + y, y !== u.value && (u.value = y), d.defaultValue == null && u.defaultValue !== y && (u.defaultValue = y)), S != null && (u.defaultValue = "" + S);
  }
  function ct(u) {
    var d = u.textContent;
    d === u._wrapperState.initialValue && d !== "" && d !== null && (u.value = d);
  }
  function Qt(u) {
    switch (u) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ht(u, d) {
    return u == null || u === "http://www.w3.org/1999/xhtml" ? Qt(d) : u === "http://www.w3.org/2000/svg" && d === "foreignObject" ? "http://www.w3.org/1999/xhtml" : u;
  }
  var kt, St = function(u) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(d, y, S, k) {
      MSApp.execUnsafeLocalFunction(function() {
        return u(d, y, S, k);
      });
    } : u;
  }(function(u, d) {
    if (u.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in u)
      u.innerHTML = d;
    else {
      for (kt = kt || document.createElement("div"), kt.innerHTML = "<svg>" + d.valueOf().toString() + "</svg>", d = kt.firstChild; u.firstChild; )
        u.removeChild(u.firstChild);
      for (; d.firstChild; )
        u.appendChild(d.firstChild);
    }
  });
  function cn(u, d) {
    if (d) {
      var y = u.firstChild;
      if (y && y === u.lastChild && y.nodeType === 3) {
        y.nodeValue = d;
        return;
      }
    }
    u.textContent = d;
  }
  var Ne = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Ie = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ne).forEach(function(u) {
    Ie.forEach(function(d) {
      d = d + u.charAt(0).toUpperCase() + u.substring(1), Ne[d] = Ne[u];
    });
  });
  function Je(u, d, y) {
    return d == null || typeof d == "boolean" || d === "" ? "" : y || typeof d != "number" || d === 0 || Ne.hasOwnProperty(u) && Ne[u] ? ("" + d).trim() : d + "px";
  }
  function pt(u, d) {
    u = u.style;
    for (var y in d)
      if (d.hasOwnProperty(y)) {
        var S = y.indexOf("--") === 0, k = Je(y, d[y], S);
        y === "float" && (y = "cssFloat"), S ? u.setProperty(y, k) : u[y] = k;
      }
  }
  var ht = V({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function vt(u, d) {
    if (d) {
      if (ht[u] && (d.children != null || d.dangerouslySetInnerHTML != null))
        throw Error(n(137, u));
      if (d.dangerouslySetInnerHTML != null) {
        if (d.children != null)
          throw Error(n(60));
        if (typeof d.dangerouslySetInnerHTML != "object" || !("__html" in d.dangerouslySetInnerHTML))
          throw Error(n(61));
      }
      if (d.style != null && typeof d.style != "object")
        throw Error(n(62));
    }
  }
  function Nt(u, d) {
    if (u.indexOf("-") === -1)
      return typeof d.is == "string";
    switch (u) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tn = null;
  function bt(u) {
    return u = u.target || u.srcElement || window, u.correspondingUseElement && (u = u.correspondingUseElement), u.nodeType === 3 ? u.parentNode : u;
  }
  var Pn = null, wn = null, Cn = null;
  function ar(u) {
    if (u = pp(u)) {
      if (typeof Pn != "function")
        throw Error(n(280));
      var d = u.stateNode;
      d && (d = nn(d), Pn(u.stateNode, u.type, d));
    }
  }
  function ir(u) {
    wn ? Cn ? Cn.push(u) : Cn = [u] : wn = u;
  }
  function go() {
    if (wn) {
      var u = wn, d = Cn;
      if (Cn = wn = null, ar(u), d)
        for (u = 0; u < d.length; u++)
          ar(d[u]);
    }
  }
  function Kr(u, d) {
    return u(d);
  }
  function xr() {
  }
  var Ln = !1;
  function Dn(u, d, y) {
    if (Ln)
      return u(d, y);
    Ln = !0;
    try {
      return Kr(u, d, y);
    } finally {
      Ln = !1, (wn !== null || Cn !== null) && (xr(), go());
    }
  }
  function Yn(u, d) {
    var y = u.stateNode;
    if (y === null)
      return null;
    var S = nn(y);
    if (S === null)
      return null;
    y = S[d];
    e:
      switch (d) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (S = !S.disabled) || (u = u.type, S = !(u === "button" || u === "input" || u === "select" || u === "textarea")), u = !S;
          break e;
        default:
          u = !1;
      }
    if (u)
      return null;
    if (y && typeof y != "function")
      throw Error(n(231, d, typeof y));
    return y;
  }
  var Jr = !1;
  if (p)
    try {
      var dr = {};
      Object.defineProperty(dr, "passive", { get: function() {
        Jr = !0;
      } }), window.addEventListener("test", dr, dr), window.removeEventListener("test", dr, dr);
    } catch {
      Jr = !1;
    }
  function Dr(u, d, y, S, k, A, X, ve, _e) {
    var Ye = Array.prototype.slice.call(arguments, 3);
    try {
      d.apply(y, Ye);
    } catch (ut) {
      this.onError(ut);
    }
  }
  var Fr = !1, zr = null, Vr = !1, be = null, at = { onError: function(u) {
    Fr = !0, zr = u;
  } };
  function wt(u, d, y, S, k, A, X, ve, _e) {
    Fr = !1, zr = null, Dr.apply(at, arguments);
  }
  function Tt(u, d, y, S, k, A, X, ve, _e) {
    if (wt.apply(this, arguments), Fr) {
      if (Fr) {
        var Ye = zr;
        Fr = !1, zr = null;
      } else
        throw Error(n(198));
      Vr || (Vr = !0, be = Ye);
    }
  }
  function it(u) {
    var d = u, y = u;
    if (u.alternate)
      for (; d.return; )
        d = d.return;
    else {
      u = d;
      do
        d = u, d.flags & 4098 && (y = d.return), u = d.return;
      while (u);
    }
    return d.tag === 3 ? y : null;
  }
  function nt(u) {
    if (u.tag === 13) {
      var d = u.memoizedState;
      if (d === null && (u = u.alternate, u !== null && (d = u.memoizedState)), d !== null)
        return d.dehydrated;
    }
    return null;
  }
  function ge(u) {
    if (it(u) !== u)
      throw Error(n(188));
  }
  function $e(u) {
    var d = u.alternate;
    if (!d) {
      if (d = it(u), d === null)
        throw Error(n(188));
      return d !== u ? null : u;
    }
    for (var y = u, S = d; ; ) {
      var k = y.return;
      if (k === null)
        break;
      var A = k.alternate;
      if (A === null) {
        if (S = k.return, S !== null) {
          y = S;
          continue;
        }
        break;
      }
      if (k.child === A.child) {
        for (A = k.child; A; ) {
          if (A === y)
            return ge(k), u;
          if (A === S)
            return ge(k), d;
          A = A.sibling;
        }
        throw Error(n(188));
      }
      if (y.return !== S.return)
        y = k, S = A;
      else {
        for (var X = !1, ve = k.child; ve; ) {
          if (ve === y) {
            X = !0, y = k, S = A;
            break;
          }
          if (ve === S) {
            X = !0, S = k, y = A;
            break;
          }
          ve = ve.sibling;
        }
        if (!X) {
          for (ve = A.child; ve; ) {
            if (ve === y) {
              X = !0, y = A, S = k;
              break;
            }
            if (ve === S) {
              X = !0, S = A, y = k;
              break;
            }
            ve = ve.sibling;
          }
          if (!X)
            throw Error(n(189));
        }
      }
      if (y.alternate !== S)
        throw Error(n(190));
    }
    if (y.tag !== 3)
      throw Error(n(188));
    return y.stateNode.current === y ? u : d;
  }
  function dt(u) {
    return u = $e(u), u !== null ? Ft(u) : null;
  }
  function Ft(u) {
    if (u.tag === 5 || u.tag === 6)
      return u;
    for (u = u.child; u !== null; ) {
      var d = Ft(u);
      if (d !== null)
        return d;
      u = u.sibling;
    }
    return null;
  }
  var fn = t.unstable_scheduleCallback, er = t.unstable_cancelCallback, In = t.unstable_shouldYield, An = t.unstable_requestPaint, _n = t.unstable_now, rs = t.unstable_getCurrentPriorityLevel, $a = t.unstable_ImmediatePriority, On = t.unstable_UserBlockingPriority, Si = t.unstable_NormalPriority, Ts = t.unstable_LowPriority, Zl = t.unstable_IdlePriority, ri = null, zt = null;
  function Kn(u) {
    if (zt && typeof zt.onCommitFiberRoot == "function")
      try {
        zt.onCommitFiberRoot(ri, u, void 0, (u.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ur = Math.clz32 ? Math.clz32 : Na, Ma = Math.log, oi = Math.LN2;
  function Na(u) {
    return u >>>= 0, u === 0 ? 32 : 31 - (Ma(u) / oi | 0) | 0;
  }
  var Ei = 64, la = 4194304;
  function os(u) {
    switch (u & -u) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return u & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return u;
    }
  }
  function ya(u, d) {
    var y = u.pendingLanes;
    if (y === 0)
      return 0;
    var S = 0, k = u.suspendedLanes, A = u.pingedLanes, X = y & 268435455;
    if (X !== 0) {
      var ve = X & ~k;
      ve !== 0 ? S = os(ve) : (A &= X, A !== 0 && (S = os(A)));
    } else
      X = y & ~k, X !== 0 ? S = os(X) : A !== 0 && (S = os(A));
    if (S === 0)
      return 0;
    if (d !== 0 && d !== S && !(d & k) && (k = S & -S, A = d & -d, k >= A || k === 16 && (A & 4194240) !== 0))
      return d;
    if (S & 4 && (S |= y & 16), d = u.entangledLanes, d !== 0)
      for (u = u.entanglements, d &= S; 0 < d; )
        y = 31 - Ur(d), k = 1 << y, S |= u[y], d &= ~k;
    return S;
  }
  function Jl(u, d) {
    switch (u) {
      case 1:
      case 2:
      case 4:
        return d + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function eu(u, d) {
    for (var y = u.suspendedLanes, S = u.pingedLanes, k = u.expirationTimes, A = u.pendingLanes; 0 < A; ) {
      var X = 31 - Ur(A), ve = 1 << X, _e = k[X];
      _e === -1 ? (!(ve & y) || ve & S) && (k[X] = Jl(ve, d)) : _e <= d && (u.expiredLanes |= ve), A &= ~ve;
    }
  }
  function tu(u) {
    return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0;
  }
  function yd() {
    var u = Ei;
    return Ei <<= 1, !(Ei & 4194240) && (Ei = 64), u;
  }
  function gd(u) {
    for (var d = [], y = 0; 31 > y; y++)
      d.push(u);
    return d;
  }
  function ul(u, d, y) {
    u.pendingLanes |= d, d !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, d = 31 - Ur(d), u[d] = y;
  }
  function Ay(u, d) {
    var y = u.pendingLanes & ~d;
    u.pendingLanes = d, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= d, u.mutableReadLanes &= d, u.entangledLanes &= d, d = u.entanglements;
    var S = u.eventTimes;
    for (u = u.expirationTimes; 0 < y; ) {
      var k = 31 - Ur(y), A = 1 << k;
      d[k] = 0, S[k] = -1, u[k] = -1, y &= ~A;
    }
  }
  function _s(u, d) {
    var y = u.entangledLanes |= d;
    for (u = u.entanglements; y; ) {
      var S = 31 - Ur(y), k = 1 << S;
      k & d | u[S] & d && (u[S] |= d), y &= ~k;
    }
  }
  var tr = 0;
  function bd(u) {
    return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var lc, wd, qn, xd, Sd, gn = !1, uc = [], eo = null, Ia = null, ga = null, nu = /* @__PURE__ */ new Map(), io = /* @__PURE__ */ new Map(), fr = [], Fm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Aa(u, d) {
    switch (u) {
      case "focusin":
      case "focusout":
        eo = null;
        break;
      case "dragenter":
      case "dragleave":
        Ia = null;
        break;
      case "mouseover":
      case "mouseout":
        ga = null;
        break;
      case "pointerover":
      case "pointerout":
        nu.delete(d.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        io.delete(d.pointerId);
    }
  }
  function jo(u, d, y, S, k, A) {
    return u === null || u.nativeEvent !== A ? (u = { blockedOn: d, domEventName: y, eventSystemFlags: S, nativeEvent: A, targetContainers: [k] }, d !== null && (d = pp(d), d !== null && wd(d)), u) : (u.eventSystemFlags |= S, d = u.targetContainers, k !== null && d.indexOf(k) === -1 && d.push(k), u);
  }
  function Os(u, d, y, S, k) {
    switch (d) {
      case "focusin":
        return eo = jo(eo, u, d, y, S, k), !0;
      case "dragenter":
        return Ia = jo(Ia, u, d, y, S, k), !0;
      case "mouseover":
        return ga = jo(ga, u, d, y, S, k), !0;
      case "pointerover":
        var A = k.pointerId;
        return nu.set(A, jo(nu.get(A) || null, u, d, y, S, k)), !0;
      case "gotpointercapture":
        return A = k.pointerId, io.set(A, jo(io.get(A) || null, u, d, y, S, k)), !0;
    }
    return !1;
  }
  function zm(u) {
    var d = Oi(u.target);
    if (d !== null) {
      var y = it(d);
      if (y !== null) {
        if (d = y.tag, d === 13) {
          if (d = nt(y), d !== null) {
            u.blockedOn = d, Sd(u.priority, function() {
              qn(y);
            });
            return;
          }
        } else if (d === 3 && y.stateNode.current.memoizedState.isDehydrated) {
          u.blockedOn = y.tag === 3 ? y.stateNode.containerInfo : null;
          return;
        }
      }
    }
    u.blockedOn = null;
  }
  function cl(u) {
    if (u.blockedOn !== null)
      return !1;
    for (var d = u.targetContainers; 0 < d.length; ) {
      var y = Cd(u.domEventName, u.eventSystemFlags, d[0], u.nativeEvent);
      if (y === null) {
        y = u.nativeEvent;
        var S = new y.constructor(y.type, y);
        Tn = S, y.target.dispatchEvent(S), Tn = null;
      } else
        return d = pp(y), d !== null && wd(d), u.blockedOn = y, !1;
      d.shift();
    }
    return !0;
  }
  function ru(u, d, y) {
    cl(u) && y.delete(d);
  }
  function Vm() {
    gn = !1, eo !== null && cl(eo) && (eo = null), Ia !== null && cl(Ia) && (Ia = null), ga !== null && cl(ga) && (ga = null), nu.forEach(ru), io.forEach(ru);
  }
  function Ci(u, d) {
    u.blockedOn === d && (u.blockedOn = null, gn || (gn = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Vm)));
  }
  function ou(u) {
    function d(k) {
      return Ci(k, u);
    }
    if (0 < uc.length) {
      Ci(uc[0], u);
      for (var y = 1; y < uc.length; y++) {
        var S = uc[y];
        S.blockedOn === u && (S.blockedOn = null);
      }
    }
    for (eo !== null && Ci(eo, u), Ia !== null && Ci(Ia, u), ga !== null && Ci(ga, u), nu.forEach(d), io.forEach(d), y = 0; y < fr.length; y++)
      S = fr[y], S.blockedOn === u && (S.blockedOn = null);
    for (; 0 < fr.length && (y = fr[0], y.blockedOn === null); )
      zm(y), y.blockedOn === null && fr.shift();
  }
  var au = I.ReactCurrentBatchConfig, Ti = !0;
  function Ed(u, d, y, S) {
    var k = tr, A = au.transition;
    au.transition = null;
    try {
      tr = 1, su(u, d, y, S);
    } finally {
      tr = k, au.transition = A;
    }
  }
  function iu(u, d, y, S) {
    var k = tr, A = au.transition;
    au.transition = null;
    try {
      tr = 4, su(u, d, y, S);
    } finally {
      tr = k, au.transition = A;
    }
  }
  function su(u, d, y, S) {
    if (Ti) {
      var k = Cd(u, d, y, S);
      if (k === null)
        Xm(u, d, S, cc, y), Aa(u, S);
      else if (Os(k, u, d, y, S))
        S.stopPropagation();
      else if (Aa(u, S), d & 4 && -1 < Fm.indexOf(u)) {
        for (; k !== null; ) {
          var A = pp(k);
          if (A !== null && lc(A), A = Cd(u, d, y, S), A === null && Xm(u, d, S, cc, y), A === k)
            break;
          k = A;
        }
        k !== null && S.stopPropagation();
      } else
        Xm(u, d, S, null, y);
    }
  }
  var cc = null;
  function Cd(u, d, y, S) {
    if (cc = null, u = bt(S), u = Oi(u), u !== null)
      if (d = it(u), d === null)
        u = null;
      else if (y = d.tag, y === 13) {
        if (u = nt(d), u !== null)
          return u;
        u = null;
      } else if (y === 3) {
        if (d.stateNode.current.memoizedState.isDehydrated)
          return d.tag === 3 ? d.stateNode.containerInfo : null;
        u = null;
      } else
        d !== u && (u = null);
    return cc = u, null;
  }
  function Jf(u) {
    switch (u) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (rs()) {
          case $a:
            return 1;
          case On:
            return 4;
          case Si:
          case Ts:
            return 16;
          case Zl:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var as = null, G = null, xe = null;
  function He() {
    if (xe)
      return xe;
    var u, d = G, y = d.length, S, k = "value" in as ? as.value : as.textContent, A = k.length;
    for (u = 0; u < y && d[u] === k[u]; u++)
      ;
    var X = y - u;
    for (S = 1; S <= X && d[y - S] === k[A - S]; S++)
      ;
    return xe = k.slice(u, 1 < S ? 1 - S : void 0);
  }
  function Xe(u) {
    var d = u.keyCode;
    return "charCode" in u ? (u = u.charCode, u === 0 && d === 13 && (u = 13)) : u = d, u === 10 && (u = 13), 32 <= u || u === 13 ? u : 0;
  }
  function yt() {
    return !0;
  }
  function sn() {
    return !1;
  }
  function Ot(u) {
    function d(y, S, k, A, X) {
      this._reactName = y, this._targetInst = k, this.type = S, this.nativeEvent = A, this.target = X, this.currentTarget = null;
      for (var ve in u)
        u.hasOwnProperty(ve) && (y = u[ve], this[ve] = y ? y(A) : A[ve]);
      return this.isDefaultPrevented = (A.defaultPrevented != null ? A.defaultPrevented : A.returnValue === !1) ? yt : sn, this.isPropagationStopped = sn, this;
    }
    return V(d.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var y = this.nativeEvent;
      y && (y.preventDefault ? y.preventDefault() : typeof y.returnValue != "unknown" && (y.returnValue = !1), this.isDefaultPrevented = yt);
    }, stopPropagation: function() {
      var y = this.nativeEvent;
      y && (y.stopPropagation ? y.stopPropagation() : typeof y.cancelBubble != "unknown" && (y.cancelBubble = !0), this.isPropagationStopped = yt);
    }, persist: function() {
    }, isPersistent: yt }), d;
  }
  var on = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(u) {
    return u.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Rn = Ot(on), Gn = V({}, on, { view: 0, detail: 0 }), $r = Ot(Gn), yr, Mr, Ar, jn = V({}, Gn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Vy, button: 0, buttons: 0, relatedTarget: function(u) {
    return u.relatedTarget === void 0 ? u.fromElement === u.srcElement ? u.toElement : u.fromElement : u.relatedTarget;
  }, movementX: function(u) {
    return "movementX" in u ? u.movementX : (u !== Ar && (Ar && u.type === "mousemove" ? (yr = u.screenX - Ar.screenX, Mr = u.screenY - Ar.screenY) : Mr = yr = 0, Ar = u), yr);
  }, movementY: function(u) {
    return "movementY" in u ? u.movementY : Mr;
  } }), dl = Ot(jn), Td = V({}, jn, { dataTransfer: 0 }), ep = Ot(Td), jy = V({}, Gn, { relatedTarget: 0 }), is = Ot(jy), tp = V({}, on, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), np = Ot(tp), Ly = V({}, on, { clipboardData: function(u) {
    return "clipboardData" in u ? u.clipboardData : window.clipboardData;
  } }), $_ = Ot(Ly), M_ = V({}, on, { data: 0 }), Fy = Ot(M_), zy = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Tw = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, _w = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ow(u) {
    var d = this.nativeEvent;
    return d.getModifierState ? d.getModifierState(u) : (u = _w[u]) ? !!d[u] : !1;
  }
  function Vy() {
    return Ow;
  }
  var fl = V({}, Gn, { key: function(u) {
    if (u.key) {
      var d = zy[u.key] || u.key;
      if (d !== "Unidentified")
        return d;
    }
    return u.type === "keypress" ? (u = Xe(u), u === 13 ? "Enter" : String.fromCharCode(u)) : u.type === "keydown" || u.type === "keyup" ? Tw[u.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Vy, charCode: function(u) {
    return u.type === "keypress" ? Xe(u) : 0;
  }, keyCode: function(u) {
    return u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
  }, which: function(u) {
    return u.type === "keypress" ? Xe(u) : u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
  } }), N_ = Ot(fl), Uy = V({}, jn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Um = Ot(Uy), By = V({}, Gn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Vy }), I_ = Ot(By), Bm = V({}, on, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Pw = Ot(Bm), ja = V({}, jn, {
    deltaX: function(u) {
      return "deltaX" in u ? u.deltaX : "wheelDeltaX" in u ? -u.wheelDeltaX : 0;
    },
    deltaY: function(u) {
      return "deltaY" in u ? u.deltaY : "wheelDeltaY" in u ? -u.wheelDeltaY : "wheelDelta" in u ? -u.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), pl = Ot(ja), bo = [9, 13, 27, 32], ss = p && "CompositionEvent" in window, dc = null;
  p && "documentMode" in document && (dc = document.documentMode);
  var Hm = p && "TextEvent" in window && !dc, Rw = p && (!ss || dc && 8 < dc && 11 >= dc), _d = String.fromCharCode(32), kw = !1;
  function Dw(u, d) {
    switch (u) {
      case "keyup":
        return bo.indexOf(d.keyCode) !== -1;
      case "keydown":
        return d.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Wm(u) {
    return u = u.detail, typeof u == "object" && "data" in u ? u.data : null;
  }
  var Od = !1;
  function A_(u, d) {
    switch (u) {
      case "compositionend":
        return Wm(d);
      case "keypress":
        return d.which !== 32 ? null : (kw = !0, _d);
      case "textInput":
        return u = d.data, u === _d && kw ? null : u;
      default:
        return null;
    }
  }
  function j_(u, d) {
    if (Od)
      return u === "compositionend" || !ss && Dw(u, d) ? (u = He(), xe = G = as = null, Od = !1, u) : null;
    switch (u) {
      case "paste":
        return null;
      case "keypress":
        if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
          if (d.char && 1 < d.char.length)
            return d.char;
          if (d.which)
            return String.fromCharCode(d.which);
        }
        return null;
      case "compositionend":
        return Rw && d.locale !== "ko" ? null : d.data;
      default:
        return null;
    }
  }
  var $w = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Mw(u) {
    var d = u && u.nodeName && u.nodeName.toLowerCase();
    return d === "input" ? !!$w[u.type] : d === "textarea";
  }
  function Nw(u, d, y, S) {
    ir(S), d = cp(d, "onChange"), 0 < d.length && (y = new Rn("onChange", "change", null, y, S), u.push({ event: y, listeners: d }));
  }
  var rp = null, Pd = null;
  function Rd(u) {
    Km(u, 0);
  }
  function kd(u) {
    var d = $d(u);
    if (me(d))
      return u;
  }
  function Iw(u, d) {
    if (u === "change")
      return d;
  }
  var Hy = !1;
  if (p) {
    var Wy;
    if (p) {
      var Yy = "oninput" in document;
      if (!Yy) {
        var Aw = document.createElement("div");
        Aw.setAttribute("oninput", "return;"), Yy = typeof Aw.oninput == "function";
      }
      Wy = Yy;
    } else
      Wy = !1;
    Hy = Wy && (!document.documentMode || 9 < document.documentMode);
  }
  function jw() {
    rp && (rp.detachEvent("onpropertychange", Lw), Pd = rp = null);
  }
  function Lw(u) {
    if (u.propertyName === "value" && kd(Pd)) {
      var d = [];
      Nw(d, Pd, u, bt(u)), Dn(Rd, d);
    }
  }
  function L_(u, d, y) {
    u === "focusin" ? (jw(), rp = d, Pd = y, rp.attachEvent("onpropertychange", Lw)) : u === "focusout" && jw();
  }
  function F_(u) {
    if (u === "selectionchange" || u === "keyup" || u === "keydown")
      return kd(Pd);
  }
  function z_(u, d) {
    if (u === "click")
      return kd(d);
  }
  function Fw(u, d) {
    if (u === "input" || u === "change")
      return kd(d);
  }
  function V_(u, d) {
    return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
  }
  var _i = typeof Object.is == "function" ? Object.is : V_;
  function op(u, d) {
    if (_i(u, d))
      return !0;
    if (typeof u != "object" || u === null || typeof d != "object" || d === null)
      return !1;
    var y = Object.keys(u), S = Object.keys(d);
    if (y.length !== S.length)
      return !1;
    for (S = 0; S < y.length; S++) {
      var k = y[S];
      if (!m.call(d, k) || !_i(u[k], d[k]))
        return !1;
    }
    return !0;
  }
  function zw(u) {
    for (; u && u.firstChild; )
      u = u.firstChild;
    return u;
  }
  function Vw(u, d) {
    var y = zw(u);
    u = 0;
    for (var S; y; ) {
      if (y.nodeType === 3) {
        if (S = u + y.textContent.length, u <= d && S >= d)
          return { node: y, offset: d - u };
        u = S;
      }
      e: {
        for (; y; ) {
          if (y.nextSibling) {
            y = y.nextSibling;
            break e;
          }
          y = y.parentNode;
        }
        y = void 0;
      }
      y = zw(y);
    }
  }
  function Uw(u, d) {
    return u && d ? u === d ? !0 : u && u.nodeType === 3 ? !1 : d && d.nodeType === 3 ? Uw(u, d.parentNode) : "contains" in u ? u.contains(d) : u.compareDocumentPosition ? !!(u.compareDocumentPosition(d) & 16) : !1 : !1;
  }
  function Ym() {
    for (var u = window, d = Pe(); d instanceof u.HTMLIFrameElement; ) {
      try {
        var y = typeof d.contentWindow.location.href == "string";
      } catch {
        y = !1;
      }
      if (y)
        u = d.contentWindow;
      else
        break;
      d = Pe(u.document);
    }
    return d;
  }
  function ml(u) {
    var d = u && u.nodeName && u.nodeName.toLowerCase();
    return d && (d === "input" && (u.type === "text" || u.type === "search" || u.type === "tel" || u.type === "url" || u.type === "password") || d === "textarea" || u.contentEditable === "true");
  }
  function qm(u) {
    var d = Ym(), y = u.focusedElem, S = u.selectionRange;
    if (d !== y && y && y.ownerDocument && Uw(y.ownerDocument.documentElement, y)) {
      if (S !== null && ml(y)) {
        if (d = S.start, u = S.end, u === void 0 && (u = d), "selectionStart" in y)
          y.selectionStart = d, y.selectionEnd = Math.min(u, y.value.length);
        else if (u = (d = y.ownerDocument || document) && d.defaultView || window, u.getSelection) {
          u = u.getSelection();
          var k = y.textContent.length, A = Math.min(S.start, k);
          S = S.end === void 0 ? A : Math.min(S.end, k), !u.extend && A > S && (k = S, S = A, A = k), k = Vw(y, A);
          var X = Vw(
            y,
            S
          );
          k && X && (u.rangeCount !== 1 || u.anchorNode !== k.node || u.anchorOffset !== k.offset || u.focusNode !== X.node || u.focusOffset !== X.offset) && (d = d.createRange(), d.setStart(k.node, k.offset), u.removeAllRanges(), A > S ? (u.addRange(d), u.extend(X.node, X.offset)) : (d.setEnd(X.node, X.offset), u.addRange(d)));
        }
      }
      for (d = [], u = y; u = u.parentNode; )
        u.nodeType === 1 && d.push({ element: u, left: u.scrollLeft, top: u.scrollTop });
      for (typeof y.focus == "function" && y.focus(), y = 0; y < d.length; y++)
        u = d[y], u.element.scrollLeft = u.left, u.element.scrollTop = u.top;
    }
  }
  var Bw = p && "documentMode" in document && 11 >= document.documentMode, ls = null, qy = null, ap = null, Gy = !1;
  function Hw(u, d, y) {
    var S = y.window === y ? y.document : y.nodeType === 9 ? y : y.ownerDocument;
    Gy || ls == null || ls !== Pe(S) || (S = ls, "selectionStart" in S && ml(S) ? S = { start: S.selectionStart, end: S.selectionEnd } : (S = (S.ownerDocument && S.ownerDocument.defaultView || window).getSelection(), S = { anchorNode: S.anchorNode, anchorOffset: S.anchorOffset, focusNode: S.focusNode, focusOffset: S.focusOffset }), ap && op(ap, S) || (ap = S, S = cp(qy, "onSelect"), 0 < S.length && (d = new Rn("onSelect", "select", null, d, y), u.push({ event: d, listeners: S }), d.target = ls)));
  }
  function Gm(u, d) {
    var y = {};
    return y[u.toLowerCase()] = d.toLowerCase(), y["Webkit" + u] = "webkit" + d, y["Moz" + u] = "moz" + d, y;
  }
  var fc = { animationend: Gm("Animation", "AnimationEnd"), animationiteration: Gm("Animation", "AnimationIteration"), animationstart: Gm("Animation", "AnimationStart"), transitionend: Gm("Transition", "TransitionEnd") }, Ky = {}, Xy = {};
  p && (Xy = document.createElement("div").style, "AnimationEvent" in window || (delete fc.animationend.animation, delete fc.animationiteration.animation, delete fc.animationstart.animation), "TransitionEvent" in window || delete fc.transitionend.transition);
  function Lo(u) {
    if (Ky[u])
      return Ky[u];
    if (!fc[u])
      return u;
    var d = fc[u], y;
    for (y in d)
      if (d.hasOwnProperty(y) && y in Xy)
        return Ky[u] = d[y];
    return u;
  }
  var Qy = Lo("animationend"), Ww = Lo("animationiteration"), Yw = Lo("animationstart"), qw = Lo("transitionend"), Gw = /* @__PURE__ */ new Map(), Kw = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function hl(u, d) {
    Gw.set(u, d), s(d, [u]);
  }
  for (var ip = 0; ip < Kw.length; ip++) {
    var pc = Kw[ip], U_ = pc.toLowerCase(), sp = pc[0].toUpperCase() + pc.slice(1);
    hl(U_, "on" + sp);
  }
  hl(Qy, "onAnimationEnd"), hl(Ww, "onAnimationIteration"), hl(Yw, "onAnimationStart"), hl("dblclick", "onDoubleClick"), hl("focusin", "onFocus"), hl("focusout", "onBlur"), hl(qw, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), B_ = new Set("cancel close invalid load scroll toggle".split(" ").concat(lp));
  function Xw(u, d, y) {
    var S = u.type || "unknown-event";
    u.currentTarget = y, Tt(S, d, void 0, u), u.currentTarget = null;
  }
  function Km(u, d) {
    d = (d & 4) !== 0;
    for (var y = 0; y < u.length; y++) {
      var S = u[y], k = S.event;
      S = S.listeners;
      e: {
        var A = void 0;
        if (d)
          for (var X = S.length - 1; 0 <= X; X--) {
            var ve = S[X], _e = ve.instance, Ye = ve.currentTarget;
            if (ve = ve.listener, _e !== A && k.isPropagationStopped())
              break e;
            Xw(k, ve, Ye), A = _e;
          }
        else
          for (X = 0; X < S.length; X++) {
            if (ve = S[X], _e = ve.instance, Ye = ve.currentTarget, ve = ve.listener, _e !== A && k.isPropagationStopped())
              break e;
            Xw(k, ve, Ye), A = _e;
          }
      }
    }
    if (Vr)
      throw u = be, Vr = !1, be = null, u;
  }
  function Nr(u, d) {
    var y = d[og];
    y === void 0 && (y = d[og] = /* @__PURE__ */ new Set());
    var S = u + "__bubble";
    y.has(S) || (Qw(d, u, 2, !1), y.add(S));
  }
  function lu(u, d, y) {
    var S = 0;
    d && (S |= 4), Qw(y, u, S, d);
  }
  var vl = "_reactListening" + Math.random().toString(36).slice(2);
  function Dd(u) {
    if (!u[vl]) {
      u[vl] = !0, r.forEach(function(y) {
        y !== "selectionchange" && (B_.has(y) || lu(y, !1, u), lu(y, !0, u));
      });
      var d = u.nodeType === 9 ? u : u.ownerDocument;
      d === null || d[vl] || (d[vl] = !0, lu("selectionchange", !1, d));
    }
  }
  function Qw(u, d, y, S) {
    switch (Jf(d)) {
      case 1:
        var k = Ed;
        break;
      case 4:
        k = iu;
        break;
      default:
        k = su;
    }
    y = k.bind(null, d, y, u), k = void 0, !Jr || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (k = !0), S ? k !== void 0 ? u.addEventListener(d, y, { capture: !0, passive: k }) : u.addEventListener(d, y, !0) : k !== void 0 ? u.addEventListener(d, y, { passive: k }) : u.addEventListener(d, y, !1);
  }
  function Xm(u, d, y, S, k) {
    var A = S;
    if (!(d & 1) && !(d & 2) && S !== null)
      e:
        for (; ; ) {
          if (S === null)
            return;
          var X = S.tag;
          if (X === 3 || X === 4) {
            var ve = S.stateNode.containerInfo;
            if (ve === k || ve.nodeType === 8 && ve.parentNode === k)
              break;
            if (X === 4)
              for (X = S.return; X !== null; ) {
                var _e = X.tag;
                if ((_e === 3 || _e === 4) && (_e = X.stateNode.containerInfo, _e === k || _e.nodeType === 8 && _e.parentNode === k))
                  return;
                X = X.return;
              }
            for (; ve !== null; ) {
              if (X = Oi(ve), X === null)
                return;
              if (_e = X.tag, _e === 5 || _e === 6) {
                S = A = X;
                continue e;
              }
              ve = ve.parentNode;
            }
          }
          S = S.return;
        }
    Dn(function() {
      var Ye = A, ut = bt(y), ft = [];
      e: {
        var lt = Gw.get(u);
        if (lt !== void 0) {
          var $t = Rn, Yt = u;
          switch (u) {
            case "keypress":
              if (Xe(y) === 0)
                break e;
            case "keydown":
            case "keyup":
              $t = N_;
              break;
            case "focusin":
              Yt = "focus", $t = is;
              break;
            case "focusout":
              Yt = "blur", $t = is;
              break;
            case "beforeblur":
            case "afterblur":
              $t = is;
              break;
            case "click":
              if (y.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              $t = dl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              $t = ep;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              $t = I_;
              break;
            case Qy:
            case Ww:
            case Yw:
              $t = np;
              break;
            case qw:
              $t = Pw;
              break;
            case "scroll":
              $t = $r;
              break;
            case "wheel":
              $t = pl;
              break;
            case "copy":
            case "cut":
            case "paste":
              $t = $_;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              $t = Um;
          }
          var Zt = (d & 4) !== 0, po = !Zt && u === "scroll", Le = Zt ? lt !== null ? lt + "Capture" : null : lt;
          Zt = [];
          for (var ke = Ye, Ue; ke !== null; ) {
            Ue = ke;
            var gt = Ue.stateNode;
            if (Ue.tag === 5 && gt !== null && (Ue = gt, Le !== null && (gt = Yn(ke, Le), gt != null && Zt.push(up(ke, gt, Ue)))), po)
              break;
            ke = ke.return;
          }
          0 < Zt.length && (lt = new $t(lt, Yt, null, y, ut), ft.push({ event: lt, listeners: Zt }));
        }
      }
      if (!(d & 7)) {
        e: {
          if (lt = u === "mouseover" || u === "pointerover", $t = u === "mouseout" || u === "pointerout", lt && y !== Tn && (Yt = y.relatedTarget || y.fromElement) && (Oi(Yt) || Yt[yl]))
            break e;
          if (($t || lt) && (lt = ut.window === ut ? ut : (lt = ut.ownerDocument) ? lt.defaultView || lt.parentWindow : window, $t ? (Yt = y.relatedTarget || y.toElement, $t = Ye, Yt = Yt ? Oi(Yt) : null, Yt !== null && (po = it(Yt), Yt !== po || Yt.tag !== 5 && Yt.tag !== 6) && (Yt = null)) : ($t = null, Yt = Ye), $t !== Yt)) {
            if (Zt = dl, gt = "onMouseLeave", Le = "onMouseEnter", ke = "mouse", (u === "pointerout" || u === "pointerover") && (Zt = Um, gt = "onPointerLeave", Le = "onPointerEnter", ke = "pointer"), po = $t == null ? lt : $d($t), Ue = Yt == null ? lt : $d(Yt), lt = new Zt(gt, ke + "leave", $t, y, ut), lt.target = po, lt.relatedTarget = Ue, gt = null, Oi(ut) === Ye && (Zt = new Zt(Le, ke + "enter", Yt, y, ut), Zt.target = Ue, Zt.relatedTarget = po, gt = Zt), po = gt, $t && Yt)
              t: {
                for (Zt = $t, Le = Yt, ke = 0, Ue = Zt; Ue; Ue = mc(Ue))
                  ke++;
                for (Ue = 0, gt = Le; gt; gt = mc(gt))
                  Ue++;
                for (; 0 < ke - Ue; )
                  Zt = mc(Zt), ke--;
                for (; 0 < Ue - ke; )
                  Le = mc(Le), Ue--;
                for (; ke--; ) {
                  if (Zt === Le || Le !== null && Zt === Le.alternate)
                    break t;
                  Zt = mc(Zt), Le = mc(Le);
                }
                Zt = null;
              }
            else
              Zt = null;
            $t !== null && Zy(ft, lt, $t, Zt, !1), Yt !== null && po !== null && Zy(ft, po, Yt, Zt, !0);
          }
        }
        e: {
          if (lt = Ye ? $d(Ye) : window, $t = lt.nodeName && lt.nodeName.toLowerCase(), $t === "select" || $t === "input" && lt.type === "file")
            var Jt = Iw;
          else if (Mw(lt))
            if (Hy)
              Jt = Fw;
            else {
              Jt = F_;
              var qt = L_;
            }
          else
            ($t = lt.nodeName) && $t.toLowerCase() === "input" && (lt.type === "checkbox" || lt.type === "radio") && (Jt = z_);
          if (Jt && (Jt = Jt(u, Ye))) {
            Nw(ft, Jt, y, ut);
            break e;
          }
          qt && qt(u, lt, Ye), u === "focusout" && (qt = lt._wrapperState) && qt.controlled && lt.type === "number" && Me(lt, "number", lt.value);
        }
        switch (qt = Ye ? $d(Ye) : window, u) {
          case "focusin":
            (Mw(qt) || qt.contentEditable === "true") && (ls = qt, qy = Ye, ap = null);
            break;
          case "focusout":
            ap = qy = ls = null;
            break;
          case "mousedown":
            Gy = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Gy = !1, Hw(ft, y, ut);
            break;
          case "selectionchange":
            if (Bw)
              break;
          case "keydown":
          case "keyup":
            Hw(ft, y, ut);
        }
        var tn;
        if (ss)
          e: {
            switch (u) {
              case "compositionstart":
                var mn = "onCompositionStart";
                break e;
              case "compositionend":
                mn = "onCompositionEnd";
                break e;
              case "compositionupdate":
                mn = "onCompositionUpdate";
                break e;
            }
            mn = void 0;
          }
        else
          Od ? Dw(u, y) && (mn = "onCompositionEnd") : u === "keydown" && y.keyCode === 229 && (mn = "onCompositionStart");
        mn && (Rw && y.locale !== "ko" && (Od || mn !== "onCompositionStart" ? mn === "onCompositionEnd" && Od && (tn = He()) : (as = ut, G = "value" in as ? as.value : as.textContent, Od = !0)), qt = cp(Ye, mn), 0 < qt.length && (mn = new Fy(mn, u, null, y, ut), ft.push({ event: mn, listeners: qt }), tn ? mn.data = tn : (tn = Wm(y), tn !== null && (mn.data = tn)))), (tn = Hm ? A_(u, y) : j_(u, y)) && (Ye = cp(Ye, "onBeforeInput"), 0 < Ye.length && (ut = new Fy("onBeforeInput", "beforeinput", null, y, ut), ft.push({ event: ut, listeners: Ye }), ut.data = tn));
      }
      Km(ft, d);
    });
  }
  function up(u, d, y) {
    return { instance: u, listener: d, currentTarget: y };
  }
  function cp(u, d) {
    for (var y = d + "Capture", S = []; u !== null; ) {
      var k = u, A = k.stateNode;
      k.tag === 5 && A !== null && (k = A, A = Yn(u, y), A != null && S.unshift(up(u, A, k)), A = Yn(u, d), A != null && S.push(up(u, A, k))), u = u.return;
    }
    return S;
  }
  function mc(u) {
    if (u === null)
      return null;
    do
      u = u.return;
    while (u && u.tag !== 5);
    return u || null;
  }
  function Zy(u, d, y, S, k) {
    for (var A = d._reactName, X = []; y !== null && y !== S; ) {
      var ve = y, _e = ve.alternate, Ye = ve.stateNode;
      if (_e !== null && _e === S)
        break;
      ve.tag === 5 && Ye !== null && (ve = Ye, k ? (_e = Yn(y, A), _e != null && X.unshift(up(y, _e, ve))) : k || (_e = Yn(y, A), _e != null && X.push(up(y, _e, ve)))), y = y.return;
    }
    X.length !== 0 && u.push({ event: d, listeners: X });
  }
  var Jy = /\r\n?/g, H_ = /\u0000|\uFFFD/g;
  function eg(u) {
    return (typeof u == "string" ? u : "" + u).replace(Jy, `
`).replace(H_, "");
  }
  function Qm(u, d, y) {
    if (d = eg(d), eg(u) !== d && y)
      throw Error(n(425));
  }
  function Zm() {
  }
  var tg = null, hc = null;
  function dp(u, d) {
    return u === "textarea" || u === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
  }
  var vc = typeof setTimeout == "function" ? setTimeout : void 0, Zw = typeof clearTimeout == "function" ? clearTimeout : void 0, ng = typeof Promise == "function" ? Promise : void 0, rg = typeof queueMicrotask == "function" ? queueMicrotask : typeof ng < "u" ? function(u) {
    return ng.resolve(null).then(u).catch(W_);
  } : vc;
  function W_(u) {
    setTimeout(function() {
      throw u;
    });
  }
  function uu(u, d) {
    var y = d, S = 0;
    do {
      var k = y.nextSibling;
      if (u.removeChild(y), k && k.nodeType === 8)
        if (y = k.data, y === "/$") {
          if (S === 0) {
            u.removeChild(k), ou(d);
            return;
          }
          S--;
        } else
          y !== "$" && y !== "$?" && y !== "$!" || S++;
      y = k;
    } while (y);
    ou(d);
  }
  function us(u) {
    for (; u != null; u = u.nextSibling) {
      var d = u.nodeType;
      if (d === 1 || d === 3)
        break;
      if (d === 8) {
        if (d = u.data, d === "$" || d === "$!" || d === "$?")
          break;
        if (d === "/$")
          return null;
      }
    }
    return u;
  }
  function fp(u) {
    u = u.previousSibling;
    for (var d = 0; u; ) {
      if (u.nodeType === 8) {
        var y = u.data;
        if (y === "$" || y === "$!" || y === "$?") {
          if (d === 0)
            return u;
          d--;
        } else
          y === "/$" && d++;
      }
      u = u.previousSibling;
    }
    return null;
  }
  var cu = Math.random().toString(36).slice(2), Ps = "__reactFiber$" + cu, yc = "__reactProps$" + cu, yl = "__reactContainer$" + cu, og = "__reactEvents$" + cu, Y_ = "__reactListeners$" + cu, ag = "__reactHandles$" + cu;
  function Oi(u) {
    var d = u[Ps];
    if (d)
      return d;
    for (var y = u.parentNode; y; ) {
      if (d = y[yl] || y[Ps]) {
        if (y = d.alternate, d.child !== null || y !== null && y.child !== null)
          for (u = fp(u); u !== null; ) {
            if (y = u[Ps])
              return y;
            u = fp(u);
          }
        return d;
      }
      u = y, y = u.parentNode;
    }
    return null;
  }
  function pp(u) {
    return u = u[Ps] || u[yl], !u || u.tag !== 5 && u.tag !== 6 && u.tag !== 13 && u.tag !== 3 ? null : u;
  }
  function $d(u) {
    if (u.tag === 5 || u.tag === 6)
      return u.stateNode;
    throw Error(n(33));
  }
  function nn(u) {
    return u[yc] || null;
  }
  var du = [], Br = -1;
  function Sn(u) {
    return { current: u };
  }
  function sr(u) {
    0 > Br || (u.current = du[Br], du[Br] = null, Br--);
  }
  function pr(u, d) {
    Br++, du[Br] = u.current, u.current = d;
  }
  var Rs = {}, pn = Sn(Rs), so = Sn(!1), La = Rs;
  function Pi(u, d) {
    var y = u.type.contextTypes;
    if (!y)
      return Rs;
    var S = u.stateNode;
    if (S && S.__reactInternalMemoizedUnmaskedChildContext === d)
      return S.__reactInternalMemoizedMaskedChildContext;
    var k = {}, A;
    for (A in y)
      k[A] = d[A];
    return S && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = d, u.__reactInternalMemoizedMaskedChildContext = k), k;
  }
  function Xr(u) {
    return u = u.childContextTypes, u != null;
  }
  function Ri() {
    sr(so), sr(pn);
  }
  function fu(u, d, y) {
    if (pn.current !== Rs)
      throw Error(n(168));
    pr(pn, d), pr(so, y);
  }
  function mp(u, d, y) {
    var S = u.stateNode;
    if (d = d.childContextTypes, typeof S.getChildContext != "function")
      return y;
    S = S.getChildContext();
    for (var k in S)
      if (!(k in d))
        throw Error(n(108, Te(u) || "Unknown", k));
    return V({}, y, S);
  }
  function Jm(u) {
    return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || Rs, La = pn.current, pr(pn, u), pr(so, so.current), !0;
  }
  function Jw(u, d, y) {
    var S = u.stateNode;
    if (!S)
      throw Error(n(169));
    y ? (u = mp(u, d, La), S.__reactInternalMemoizedMergedChildContext = u, sr(so), sr(pn), pr(pn, u)) : sr(so), pr(so, y);
  }
  var ai = null, Fo = !1, hp = !1;
  function ig(u) {
    ai === null ? ai = [u] : ai.push(u);
  }
  function sg(u) {
    Fo = !0, ig(u);
  }
  function Fa() {
    if (!hp && ai !== null) {
      hp = !0;
      var u = 0, d = tr;
      try {
        var y = ai;
        for (tr = 1; u < y.length; u++) {
          var S = y[u];
          do
            S = S(!0);
          while (S !== null);
        }
        ai = null, Fo = !1;
      } catch (k) {
        throw ai !== null && (ai = ai.slice(u + 1)), fn($a, Fa), k;
      } finally {
        tr = d, hp = !1;
      }
    }
    return null;
  }
  var pu = [], za = 0, gc = null, Md = 0, Va = [], ua = 0, ki = null, Yo = 1, gl = "";
  function ii(u, d) {
    pu[za++] = Md, pu[za++] = gc, gc = u, Md = d;
  }
  function lg(u, d, y) {
    Va[ua++] = Yo, Va[ua++] = gl, Va[ua++] = ki, ki = u;
    var S = Yo;
    u = gl;
    var k = 32 - Ur(S) - 1;
    S &= ~(1 << k), y += 1;
    var A = 32 - Ur(d) + k;
    if (30 < A) {
      var X = k - k % 5;
      A = (S & (1 << X) - 1).toString(32), S >>= X, k -= X, Yo = 1 << 32 - Ur(d) + k | y << k | S, gl = A + u;
    } else
      Yo = 1 << A | y << k | S, gl = u;
  }
  function eh(u) {
    u.return !== null && (ii(u, 1), lg(u, 1, 0));
  }
  function ug(u) {
    for (; u === gc; )
      gc = pu[--za], pu[za] = null, Md = pu[--za], pu[za] = null;
    for (; u === ki; )
      ki = Va[--ua], Va[ua] = null, gl = Va[--ua], Va[ua] = null, Yo = Va[--ua], Va[ua] = null;
  }
  var si = null, Ua = null, Hr = !1, Di = null;
  function cg(u, d) {
    var y = ji(5, null, null, 0);
    y.elementType = "DELETED", y.stateNode = d, y.return = u, d = u.deletions, d === null ? (u.deletions = [y], u.flags |= 16) : d.push(y);
  }
  function ex(u, d) {
    switch (u.tag) {
      case 5:
        var y = u.type;
        return d = d.nodeType !== 1 || y.toLowerCase() !== d.nodeName.toLowerCase() ? null : d, d !== null ? (u.stateNode = d, si = u, Ua = us(d.firstChild), !0) : !1;
      case 6:
        return d = u.pendingProps === "" || d.nodeType !== 3 ? null : d, d !== null ? (u.stateNode = d, si = u, Ua = null, !0) : !1;
      case 13:
        return d = d.nodeType !== 8 ? null : d, d !== null ? (y = ki !== null ? { id: Yo, overflow: gl } : null, u.memoizedState = { dehydrated: d, treeContext: y, retryLane: 1073741824 }, y = ji(18, null, null, 0), y.stateNode = d, y.return = u, u.child = y, si = u, Ua = null, !0) : !1;
      default:
        return !1;
    }
  }
  function th(u) {
    return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
  }
  function nh(u) {
    if (Hr) {
      var d = Ua;
      if (d) {
        var y = d;
        if (!ex(u, d)) {
          if (th(u))
            throw Error(n(418));
          d = us(y.nextSibling);
          var S = si;
          d && ex(u, d) ? cg(S, y) : (u.flags = u.flags & -4097 | 2, Hr = !1, si = u);
        }
      } else {
        if (th(u))
          throw Error(n(418));
        u.flags = u.flags & -4097 | 2, Hr = !1, si = u;
      }
    }
  }
  function tx(u) {
    for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; )
      u = u.return;
    si = u;
  }
  function rh(u) {
    if (u !== si)
      return !1;
    if (!Hr)
      return tx(u), Hr = !0, !1;
    var d;
    if ((d = u.tag !== 3) && !(d = u.tag !== 5) && (d = u.type, d = d !== "head" && d !== "body" && !dp(u.type, u.memoizedProps)), d && (d = Ua)) {
      if (th(u))
        throw nx(), Error(n(418));
      for (; d; )
        cg(u, d), d = us(d.nextSibling);
    }
    if (tx(u), u.tag === 13) {
      if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u)
        throw Error(n(317));
      e: {
        for (u = u.nextSibling, d = 0; u; ) {
          if (u.nodeType === 8) {
            var y = u.data;
            if (y === "/$") {
              if (d === 0) {
                Ua = us(u.nextSibling);
                break e;
              }
              d--;
            } else
              y !== "$" && y !== "$!" && y !== "$?" || d++;
          }
          u = u.nextSibling;
        }
        Ua = null;
      }
    } else
      Ua = si ? us(u.stateNode.nextSibling) : null;
    return !0;
  }
  function nx() {
    for (var u = Ua; u; )
      u = us(u.nextSibling);
  }
  function to() {
    Ua = si = null, Hr = !1;
  }
  function dg(u) {
    Di === null ? Di = [u] : Di.push(u);
  }
  var oh = I.ReactCurrentBatchConfig;
  function li(u, d) {
    if (u && u.defaultProps) {
      d = V({}, d), u = u.defaultProps;
      for (var y in u)
        d[y] === void 0 && (d[y] = u[y]);
      return d;
    }
    return d;
  }
  var ks = Sn(null), ah = null, mu = null, fg = null;
  function pg() {
    fg = mu = ah = null;
  }
  function hu(u) {
    var d = ks.current;
    sr(ks), u._currentValue = d;
  }
  function zo(u, d, y) {
    for (; u !== null; ) {
      var S = u.alternate;
      if ((u.childLanes & d) !== d ? (u.childLanes |= d, S !== null && (S.childLanes |= d)) : S !== null && (S.childLanes & d) !== d && (S.childLanes |= d), u === y)
        break;
      u = u.return;
    }
  }
  function Et(u, d) {
    ah = u, fg = mu = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & d && (wo = !0), u.firstContext = null);
  }
  function fo(u) {
    var d = u._currentValue;
    if (fg !== u)
      if (u = { context: u, memoizedValue: d, next: null }, mu === null) {
        if (ah === null)
          throw Error(n(308));
        mu = u, ah.dependencies = { lanes: 0, firstContext: u };
      } else
        mu = mu.next = u;
    return d;
  }
  var qo = null;
  function mg(u) {
    qo === null ? qo = [u] : qo.push(u);
  }
  function rx(u, d, y, S) {
    var k = d.interleaved;
    return k === null ? (y.next = y, mg(d)) : (y.next = k.next, k.next = y), d.interleaved = y, bl(u, S);
  }
  function bl(u, d) {
    u.lanes |= d;
    var y = u.alternate;
    for (y !== null && (y.lanes |= d), y = u, u = u.return; u !== null; )
      u.childLanes |= d, y = u.alternate, y !== null && (y.childLanes |= d), y = u, u = u.return;
    return y.tag === 3 ? y.stateNode : null;
  }
  var vu = !1;
  function hg(u) {
    u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Po(u, d) {
    u = u.updateQueue, d.updateQueue === u && (d.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects });
  }
  function wl(u, d) {
    return { eventTime: u, lane: d, tag: 0, payload: null, callback: null, next: null };
  }
  function yu(u, d, y) {
    var S = u.updateQueue;
    if (S === null)
      return null;
    if (S = S.shared, Mn & 2) {
      var k = S.pending;
      return k === null ? d.next = d : (d.next = k.next, k.next = d), S.pending = d, bl(u, y);
    }
    return k = S.interleaved, k === null ? (d.next = d, mg(S)) : (d.next = k.next, k.next = d), S.interleaved = d, bl(u, y);
  }
  function ih(u, d, y) {
    if (d = d.updateQueue, d !== null && (d = d.shared, (y & 4194240) !== 0)) {
      var S = d.lanes;
      S &= u.pendingLanes, y |= S, d.lanes = y, _s(u, y);
    }
  }
  function vg(u, d) {
    var y = u.updateQueue, S = u.alternate;
    if (S !== null && (S = S.updateQueue, y === S)) {
      var k = null, A = null;
      if (y = y.firstBaseUpdate, y !== null) {
        do {
          var X = { eventTime: y.eventTime, lane: y.lane, tag: y.tag, payload: y.payload, callback: y.callback, next: null };
          A === null ? k = A = X : A = A.next = X, y = y.next;
        } while (y !== null);
        A === null ? k = A = d : A = A.next = d;
      } else
        k = A = d;
      y = { baseState: S.baseState, firstBaseUpdate: k, lastBaseUpdate: A, shared: S.shared, effects: S.effects }, u.updateQueue = y;
      return;
    }
    u = y.lastBaseUpdate, u === null ? y.firstBaseUpdate = d : u.next = d, y.lastBaseUpdate = d;
  }
  function gu(u, d, y, S) {
    var k = u.updateQueue;
    vu = !1;
    var A = k.firstBaseUpdate, X = k.lastBaseUpdate, ve = k.shared.pending;
    if (ve !== null) {
      k.shared.pending = null;
      var _e = ve, Ye = _e.next;
      _e.next = null, X === null ? A = Ye : X.next = Ye, X = _e;
      var ut = u.alternate;
      ut !== null && (ut = ut.updateQueue, ve = ut.lastBaseUpdate, ve !== X && (ve === null ? ut.firstBaseUpdate = Ye : ve.next = Ye, ut.lastBaseUpdate = _e));
    }
    if (A !== null) {
      var ft = k.baseState;
      X = 0, ut = Ye = _e = null, ve = A;
      do {
        var lt = ve.lane, $t = ve.eventTime;
        if ((S & lt) === lt) {
          ut !== null && (ut = ut.next = {
            eventTime: $t,
            lane: 0,
            tag: ve.tag,
            payload: ve.payload,
            callback: ve.callback,
            next: null
          });
          e: {
            var Yt = u, Zt = ve;
            switch (lt = d, $t = y, Zt.tag) {
              case 1:
                if (Yt = Zt.payload, typeof Yt == "function") {
                  ft = Yt.call($t, ft, lt);
                  break e;
                }
                ft = Yt;
                break e;
              case 3:
                Yt.flags = Yt.flags & -65537 | 128;
              case 0:
                if (Yt = Zt.payload, lt = typeof Yt == "function" ? Yt.call($t, ft, lt) : Yt, lt == null)
                  break e;
                ft = V({}, ft, lt);
                break e;
              case 2:
                vu = !0;
            }
          }
          ve.callback !== null && ve.lane !== 0 && (u.flags |= 64, lt = k.effects, lt === null ? k.effects = [ve] : lt.push(ve));
        } else
          $t = { eventTime: $t, lane: lt, tag: ve.tag, payload: ve.payload, callback: ve.callback, next: null }, ut === null ? (Ye = ut = $t, _e = ft) : ut = ut.next = $t, X |= lt;
        if (ve = ve.next, ve === null) {
          if (ve = k.shared.pending, ve === null)
            break;
          lt = ve, ve = lt.next, lt.next = null, k.lastBaseUpdate = lt, k.shared.pending = null;
        }
      } while (1);
      if (ut === null && (_e = ft), k.baseState = _e, k.firstBaseUpdate = Ye, k.lastBaseUpdate = ut, d = k.shared.interleaved, d !== null) {
        k = d;
        do
          X |= k.lane, k = k.next;
        while (k !== d);
      } else
        A === null && (k.shared.lanes = 0);
      Cl |= X, u.lanes = X, u.memoizedState = ft;
    }
  }
  function bc(u, d, y) {
    if (u = d.effects, d.effects = null, u !== null)
      for (d = 0; d < u.length; d++) {
        var S = u[d], k = S.callback;
        if (k !== null) {
          if (S.callback = null, S = y, typeof k != "function")
            throw Error(n(191, k));
          k.call(S);
        }
      }
  }
  var ox = new e.Component().refs;
  function yg(u, d, y, S) {
    d = u.memoizedState, y = y(S, d), y = y == null ? d : V({}, d, y), u.memoizedState = y, u.lanes === 0 && (u.updateQueue.baseState = y);
  }
  var sh = { isMounted: function(u) {
    return (u = u._reactInternals) ? it(u) === u : !1;
  }, enqueueSetState: function(u, d, y) {
    u = u._reactInternals;
    var S = pa(), k = xo(u), A = wl(S, k);
    A.payload = d, y != null && (A.callback = y), d = yu(u, A, k), d !== null && (ma(d, u, k, S), ih(d, u, k));
  }, enqueueReplaceState: function(u, d, y) {
    u = u._reactInternals;
    var S = pa(), k = xo(u), A = wl(S, k);
    A.tag = 1, A.payload = d, y != null && (A.callback = y), d = yu(u, A, k), d !== null && (ma(d, u, k, S), ih(d, u, k));
  }, enqueueForceUpdate: function(u, d) {
    u = u._reactInternals;
    var y = pa(), S = xo(u), k = wl(y, S);
    k.tag = 2, d != null && (k.callback = d), d = yu(u, k, S), d !== null && (ma(d, u, S, y), ih(d, u, S));
  } };
  function ax(u, d, y, S, k, A, X) {
    return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(S, A, X) : d.prototype && d.prototype.isPureReactComponent ? !op(y, S) || !op(k, A) : !0;
  }
  function ix(u, d, y) {
    var S = !1, k = Rs, A = d.contextType;
    return typeof A == "object" && A !== null ? A = fo(A) : (k = Xr(d) ? La : pn.current, S = d.contextTypes, A = (S = S != null) ? Pi(u, k) : Rs), d = new d(y, A), u.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null, d.updater = sh, u.stateNode = d, d._reactInternals = u, S && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = k, u.__reactInternalMemoizedMaskedChildContext = A), d;
  }
  function sx(u, d, y, S) {
    u = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(y, S), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(y, S), d.state !== u && sh.enqueueReplaceState(d, d.state, null);
  }
  function lh(u, d, y, S) {
    var k = u.stateNode;
    k.props = y, k.state = u.memoizedState, k.refs = ox, hg(u);
    var A = d.contextType;
    typeof A == "object" && A !== null ? k.context = fo(A) : (A = Xr(d) ? La : pn.current, k.context = Pi(u, A)), k.state = u.memoizedState, A = d.getDerivedStateFromProps, typeof A == "function" && (yg(u, d, A, y), k.state = u.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof k.getSnapshotBeforeUpdate == "function" || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (d = k.state, typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount(), d !== k.state && sh.enqueueReplaceState(k, k.state, null), gu(u, y, k, S), k.state = u.memoizedState), typeof k.componentDidMount == "function" && (u.flags |= 4194308);
  }
  function Nd(u, d, y) {
    if (u = y.ref, u !== null && typeof u != "function" && typeof u != "object") {
      if (y._owner) {
        if (y = y._owner, y) {
          if (y.tag !== 1)
            throw Error(n(309));
          var S = y.stateNode;
        }
        if (!S)
          throw Error(n(147, u));
        var k = S, A = "" + u;
        return d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === A ? d.ref : (d = function(X) {
          var ve = k.refs;
          ve === ox && (ve = k.refs = {}), X === null ? delete ve[A] : ve[A] = X;
        }, d._stringRef = A, d);
      }
      if (typeof u != "string")
        throw Error(n(284));
      if (!y._owner)
        throw Error(n(290, u));
    }
    return u;
  }
  function uh(u, d) {
    throw u = Object.prototype.toString.call(d), Error(n(31, u === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : u));
  }
  function lx(u) {
    var d = u._init;
    return d(u._payload);
  }
  function ux(u) {
    function d(Le, ke) {
      if (u) {
        var Ue = Le.deletions;
        Ue === null ? (Le.deletions = [ke], Le.flags |= 16) : Ue.push(ke);
      }
    }
    function y(Le, ke) {
      if (!u)
        return null;
      for (; ke !== null; )
        d(Le, ke), ke = ke.sibling;
      return null;
    }
    function S(Le, ke) {
      for (Le = /* @__PURE__ */ new Map(); ke !== null; )
        ke.key !== null ? Le.set(ke.key, ke) : Le.set(ke.index, ke), ke = ke.sibling;
      return Le;
    }
    function k(Le, ke) {
      return Le = _u(Le, ke), Le.index = 0, Le.sibling = null, Le;
    }
    function A(Le, ke, Ue) {
      return Le.index = Ue, u ? (Ue = Le.alternate, Ue !== null ? (Ue = Ue.index, Ue < ke ? (Le.flags |= 2, ke) : Ue) : (Le.flags |= 2, ke)) : (Le.flags |= 1048576, ke);
    }
    function X(Le) {
      return u && Le.alternate === null && (Le.flags |= 2), Le;
    }
    function ve(Le, ke, Ue, gt) {
      return ke === null || ke.tag !== 6 ? (ke = Np(Ue, Le.mode, gt), ke.return = Le, ke) : (ke = k(ke, Ue), ke.return = Le, ke);
    }
    function _e(Le, ke, Ue, gt) {
      var Jt = Ue.type;
      return Jt === U ? ut(Le, ke, Ue.props.children, gt, Ue.key) : ke !== null && (ke.elementType === Jt || typeof Jt == "object" && Jt !== null && Jt.$$typeof === te && lx(Jt) === ke.type) ? (gt = k(ke, Ue.props), gt.ref = Nd(Le, ke, Ue), gt.return = Le, gt) : (gt = Vh(Ue.type, Ue.key, Ue.props, null, Le.mode, gt), gt.ref = Nd(Le, ke, Ue), gt.return = Le, gt);
    }
    function Ye(Le, ke, Ue, gt) {
      return ke === null || ke.tag !== 4 || ke.stateNode.containerInfo !== Ue.containerInfo || ke.stateNode.implementation !== Ue.implementation ? (ke = Lc(Ue, Le.mode, gt), ke.return = Le, ke) : (ke = k(ke, Ue.children || []), ke.return = Le, ke);
    }
    function ut(Le, ke, Ue, gt, Jt) {
      return ke === null || ke.tag !== 7 ? (ke = jc(Ue, Le.mode, gt, Jt), ke.return = Le, ke) : (ke = k(ke, Ue), ke.return = Le, ke);
    }
    function ft(Le, ke, Ue) {
      if (typeof ke == "string" && ke !== "" || typeof ke == "number")
        return ke = Np("" + ke, Le.mode, Ue), ke.return = Le, ke;
      if (typeof ke == "object" && ke !== null) {
        switch (ke.$$typeof) {
          case R:
            return Ue = Vh(ke.type, ke.key, ke.props, null, Le.mode, Ue), Ue.ref = Nd(Le, null, ke), Ue.return = Le, Ue;
          case j:
            return ke = Lc(ke, Le.mode, Ue), ke.return = Le, ke;
          case te:
            var gt = ke._init;
            return ft(Le, gt(ke._payload), Ue);
        }
        if (Ae(ke) || se(ke))
          return ke = jc(ke, Le.mode, Ue, null), ke.return = Le, ke;
        uh(Le, ke);
      }
      return null;
    }
    function lt(Le, ke, Ue, gt) {
      var Jt = ke !== null ? ke.key : null;
      if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number")
        return Jt !== null ? null : ve(Le, ke, "" + Ue, gt);
      if (typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case R:
            return Ue.key === Jt ? _e(Le, ke, Ue, gt) : null;
          case j:
            return Ue.key === Jt ? Ye(Le, ke, Ue, gt) : null;
          case te:
            return Jt = Ue._init, lt(
              Le,
              ke,
              Jt(Ue._payload),
              gt
            );
        }
        if (Ae(Ue) || se(Ue))
          return Jt !== null ? null : ut(Le, ke, Ue, gt, null);
        uh(Le, Ue);
      }
      return null;
    }
    function $t(Le, ke, Ue, gt, Jt) {
      if (typeof gt == "string" && gt !== "" || typeof gt == "number")
        return Le = Le.get(Ue) || null, ve(ke, Le, "" + gt, Jt);
      if (typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case R:
            return Le = Le.get(gt.key === null ? Ue : gt.key) || null, _e(ke, Le, gt, Jt);
          case j:
            return Le = Le.get(gt.key === null ? Ue : gt.key) || null, Ye(ke, Le, gt, Jt);
          case te:
            var qt = gt._init;
            return $t(Le, ke, Ue, qt(gt._payload), Jt);
        }
        if (Ae(gt) || se(gt))
          return Le = Le.get(Ue) || null, ut(ke, Le, gt, Jt, null);
        uh(ke, gt);
      }
      return null;
    }
    function Yt(Le, ke, Ue, gt) {
      for (var Jt = null, qt = null, tn = ke, mn = ke = 0, Bo = null; tn !== null && mn < Ue.length; mn++) {
        tn.index > mn ? (Bo = tn, tn = null) : Bo = tn.sibling;
        var Xn = lt(Le, tn, Ue[mn], gt);
        if (Xn === null) {
          tn === null && (tn = Bo);
          break;
        }
        u && tn && Xn.alternate === null && d(Le, tn), ke = A(Xn, ke, mn), qt === null ? Jt = Xn : qt.sibling = Xn, qt = Xn, tn = Bo;
      }
      if (mn === Ue.length)
        return y(Le, tn), Hr && ii(Le, mn), Jt;
      if (tn === null) {
        for (; mn < Ue.length; mn++)
          tn = ft(Le, Ue[mn], gt), tn !== null && (ke = A(tn, ke, mn), qt === null ? Jt = tn : qt.sibling = tn, qt = tn);
        return Hr && ii(Le, mn), Jt;
      }
      for (tn = S(Le, tn); mn < Ue.length; mn++)
        Bo = $t(tn, Le, mn, Ue[mn], gt), Bo !== null && (u && Bo.alternate !== null && tn.delete(Bo.key === null ? mn : Bo.key), ke = A(Bo, ke, mn), qt === null ? Jt = Bo : qt.sibling = Bo, qt = Bo);
      return u && tn.forEach(function(Ou) {
        return d(Le, Ou);
      }), Hr && ii(Le, mn), Jt;
    }
    function Zt(Le, ke, Ue, gt) {
      var Jt = se(Ue);
      if (typeof Jt != "function")
        throw Error(n(150));
      if (Ue = Jt.call(Ue), Ue == null)
        throw Error(n(151));
      for (var qt = Jt = null, tn = ke, mn = ke = 0, Bo = null, Xn = Ue.next(); tn !== null && !Xn.done; mn++, Xn = Ue.next()) {
        tn.index > mn ? (Bo = tn, tn = null) : Bo = tn.sibling;
        var Ou = lt(Le, tn, Xn.value, gt);
        if (Ou === null) {
          tn === null && (tn = Bo);
          break;
        }
        u && tn && Ou.alternate === null && d(Le, tn), ke = A(Ou, ke, mn), qt === null ? Jt = Ou : qt.sibling = Ou, qt = Ou, tn = Bo;
      }
      if (Xn.done)
        return y(
          Le,
          tn
        ), Hr && ii(Le, mn), Jt;
      if (tn === null) {
        for (; !Xn.done; mn++, Xn = Ue.next())
          Xn = ft(Le, Xn.value, gt), Xn !== null && (ke = A(Xn, ke, mn), qt === null ? Jt = Xn : qt.sibling = Xn, qt = Xn);
        return Hr && ii(Le, mn), Jt;
      }
      for (tn = S(Le, tn); !Xn.done; mn++, Xn = Ue.next())
        Xn = $t(tn, Le, mn, Xn.value, gt), Xn !== null && (u && Xn.alternate !== null && tn.delete(Xn.key === null ? mn : Xn.key), ke = A(Xn, ke, mn), qt === null ? Jt = Xn : qt.sibling = Xn, qt = Xn);
      return u && tn.forEach(function(fO) {
        return d(Le, fO);
      }), Hr && ii(Le, mn), Jt;
    }
    function po(Le, ke, Ue, gt) {
      if (typeof Ue == "object" && Ue !== null && Ue.type === U && Ue.key === null && (Ue = Ue.props.children), typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case R:
            e: {
              for (var Jt = Ue.key, qt = ke; qt !== null; ) {
                if (qt.key === Jt) {
                  if (Jt = Ue.type, Jt === U) {
                    if (qt.tag === 7) {
                      y(Le, qt.sibling), ke = k(qt, Ue.props.children), ke.return = Le, Le = ke;
                      break e;
                    }
                  } else if (qt.elementType === Jt || typeof Jt == "object" && Jt !== null && Jt.$$typeof === te && lx(Jt) === qt.type) {
                    y(Le, qt.sibling), ke = k(qt, Ue.props), ke.ref = Nd(Le, qt, Ue), ke.return = Le, Le = ke;
                    break e;
                  }
                  y(Le, qt);
                  break;
                } else
                  d(Le, qt);
                qt = qt.sibling;
              }
              Ue.type === U ? (ke = jc(Ue.props.children, Le.mode, gt, Ue.key), ke.return = Le, Le = ke) : (gt = Vh(Ue.type, Ue.key, Ue.props, null, Le.mode, gt), gt.ref = Nd(Le, ke, Ue), gt.return = Le, Le = gt);
            }
            return X(Le);
          case j:
            e: {
              for (qt = Ue.key; ke !== null; ) {
                if (ke.key === qt)
                  if (ke.tag === 4 && ke.stateNode.containerInfo === Ue.containerInfo && ke.stateNode.implementation === Ue.implementation) {
                    y(Le, ke.sibling), ke = k(ke, Ue.children || []), ke.return = Le, Le = ke;
                    break e;
                  } else {
                    y(Le, ke);
                    break;
                  }
                else
                  d(Le, ke);
                ke = ke.sibling;
              }
              ke = Lc(Ue, Le.mode, gt), ke.return = Le, Le = ke;
            }
            return X(Le);
          case te:
            return qt = Ue._init, po(Le, ke, qt(Ue._payload), gt);
        }
        if (Ae(Ue))
          return Yt(Le, ke, Ue, gt);
        if (se(Ue))
          return Zt(Le, ke, Ue, gt);
        uh(Le, Ue);
      }
      return typeof Ue == "string" && Ue !== "" || typeof Ue == "number" ? (Ue = "" + Ue, ke !== null && ke.tag === 6 ? (y(Le, ke.sibling), ke = k(ke, Ue), ke.return = Le, Le = ke) : (y(Le, ke), ke = Np(Ue, Le.mode, gt), ke.return = Le, Le = ke), X(Le)) : y(Le, ke);
    }
    return po;
  }
  var Id = ux(!0), cx = ux(!1), vp = {}, cs = Sn(vp), yp = Sn(vp), Ad = Sn(vp);
  function wc(u) {
    if (u === vp)
      throw Error(n(174));
    return u;
  }
  function gg(u, d) {
    switch (pr(Ad, d), pr(yp, u), pr(cs, vp), u = d.nodeType, u) {
      case 9:
      case 11:
        d = (d = d.documentElement) ? d.namespaceURI : Ht(null, "");
        break;
      default:
        u = u === 8 ? d.parentNode : d, d = u.namespaceURI || null, u = u.tagName, d = Ht(d, u);
    }
    sr(cs), pr(cs, d);
  }
  function bu() {
    sr(cs), sr(yp), sr(Ad);
  }
  function an(u) {
    wc(Ad.current);
    var d = wc(cs.current), y = Ht(d, u.type);
    d !== y && (pr(yp, u), pr(cs, y));
  }
  function kn(u) {
    yp.current === u && (sr(cs), sr(yp));
  }
  var ln = Sn(0);
  function no(u) {
    for (var d = u; d !== null; ) {
      if (d.tag === 13) {
        var y = d.memoizedState;
        if (y !== null && (y = y.dehydrated, y === null || y.data === "$?" || y.data === "$!"))
          return d;
      } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) {
        if (d.flags & 128)
          return d;
      } else if (d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === u)
        break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === u)
          return null;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
    return null;
  }
  var $i = [];
  function ch() {
    for (var u = 0; u < $i.length; u++)
      $i[u]._workInProgressVersionPrimary = null;
    $i.length = 0;
  }
  var dh = I.ReactCurrentDispatcher, bg = I.ReactCurrentBatchConfig, xc = 0, Wr = null, tt = null, Fn = null, un = !1, Ds = !1, ui = 0, Sc = 0;
  function Yr() {
    throw Error(n(321));
  }
  function Ec(u, d) {
    if (d === null)
      return !1;
    for (var y = 0; y < d.length && y < u.length; y++)
      if (!_i(u[y], d[y]))
        return !1;
    return !0;
  }
  function wu(u, d, y, S, k, A) {
    if (xc = A, Wr = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, dh.current = u === null || u.memoizedState === null ? G_ : K_, u = y(S, k), Ds) {
      A = 0;
      do {
        if (Ds = !1, ui = 0, 25 <= A)
          throw Error(n(301));
        A += 1, Fn = tt = null, d.updateQueue = null, dh.current = xg, u = y(S, k);
      } while (Ds);
    }
    if (dh.current = Oh, d = tt !== null && tt.next !== null, xc = 0, Fn = tt = Wr = null, un = !1, d)
      throw Error(n(300));
    return u;
  }
  function Cc() {
    var u = ui !== 0;
    return ui = 0, u;
  }
  function Mi() {
    var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Fn === null ? Wr.memoizedState = Fn = u : Fn = Fn.next = u, Fn;
  }
  function Ba() {
    if (tt === null) {
      var u = Wr.alternate;
      u = u !== null ? u.memoizedState : null;
    } else
      u = tt.next;
    var d = Fn === null ? Wr.memoizedState : Fn.next;
    if (d !== null)
      Fn = d, tt = u;
    else {
      if (u === null)
        throw Error(n(310));
      tt = u, u = { memoizedState: tt.memoizedState, baseState: tt.baseState, baseQueue: tt.baseQueue, queue: tt.queue, next: null }, Fn === null ? Wr.memoizedState = Fn = u : Fn = Fn.next = u;
    }
    return Fn;
  }
  function Tc(u, d) {
    return typeof d == "function" ? d(u) : d;
  }
  function gp(u) {
    var d = Ba(), y = d.queue;
    if (y === null)
      throw Error(n(311));
    y.lastRenderedReducer = u;
    var S = tt, k = S.baseQueue, A = y.pending;
    if (A !== null) {
      if (k !== null) {
        var X = k.next;
        k.next = A.next, A.next = X;
      }
      S.baseQueue = k = A, y.pending = null;
    }
    if (k !== null) {
      A = k.next, S = S.baseState;
      var ve = X = null, _e = null, Ye = A;
      do {
        var ut = Ye.lane;
        if ((xc & ut) === ut)
          _e !== null && (_e = _e.next = { lane: 0, action: Ye.action, hasEagerState: Ye.hasEagerState, eagerState: Ye.eagerState, next: null }), S = Ye.hasEagerState ? Ye.eagerState : u(S, Ye.action);
        else {
          var ft = {
            lane: ut,
            action: Ye.action,
            hasEagerState: Ye.hasEagerState,
            eagerState: Ye.eagerState,
            next: null
          };
          _e === null ? (ve = _e = ft, X = S) : _e = _e.next = ft, Wr.lanes |= ut, Cl |= ut;
        }
        Ye = Ye.next;
      } while (Ye !== null && Ye !== A);
      _e === null ? X = S : _e.next = ve, _i(S, d.memoizedState) || (wo = !0), d.memoizedState = S, d.baseState = X, d.baseQueue = _e, y.lastRenderedState = S;
    }
    if (u = y.interleaved, u !== null) {
      k = u;
      do
        A = k.lane, Wr.lanes |= A, Cl |= A, k = k.next;
      while (k !== u);
    } else
      k === null && (y.lanes = 0);
    return [d.memoizedState, y.dispatch];
  }
  function bp(u) {
    var d = Ba(), y = d.queue;
    if (y === null)
      throw Error(n(311));
    y.lastRenderedReducer = u;
    var S = y.dispatch, k = y.pending, A = d.memoizedState;
    if (k !== null) {
      y.pending = null;
      var X = k = k.next;
      do
        A = u(A, X.action), X = X.next;
      while (X !== k);
      _i(A, d.memoizedState) || (wo = !0), d.memoizedState = A, d.baseQueue === null && (d.baseState = A), y.lastRenderedState = A;
    }
    return [A, S];
  }
  function fh() {
  }
  function ph(u, d) {
    var y = Wr, S = Ba(), k = d(), A = !_i(S.memoizedState, k);
    if (A && (S.memoizedState = k, wo = !0), S = S.queue, wp(vh.bind(null, y, S, u), [u]), S.getSnapshot !== d || A || Fn !== null && Fn.memoizedState.tag & 1) {
      if (y.flags |= 2048, _c(9, hh.bind(null, y, S, k, d), void 0, null), ro === null)
        throw Error(n(349));
      xc & 30 || mh(y, d, k);
    }
    return k;
  }
  function mh(u, d, y) {
    u.flags |= 16384, u = { getSnapshot: d, value: y }, d = Wr.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, Wr.updateQueue = d, d.stores = [u]) : (y = d.stores, y === null ? d.stores = [u] : y.push(u));
  }
  function hh(u, d, y, S) {
    d.value = y, d.getSnapshot = S, yh(d) && gh(u);
  }
  function vh(u, d, y) {
    return y(function() {
      yh(d) && gh(u);
    });
  }
  function yh(u) {
    var d = u.getSnapshot;
    u = u.value;
    try {
      var y = d();
      return !_i(u, y);
    } catch {
      return !0;
    }
  }
  function gh(u) {
    var d = bl(u, 1);
    d !== null && ma(d, u, 1, -1);
  }
  function bh(u) {
    var d = Mi();
    return typeof u == "function" && (u = u()), d.memoizedState = d.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Tc, lastRenderedState: u }, d.queue = u, u = u.dispatch = _h.bind(null, Wr, u), [d.memoizedState, u];
  }
  function _c(u, d, y, S) {
    return u = { tag: u, create: d, destroy: y, deps: S, next: null }, d = Wr.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, Wr.updateQueue = d, d.lastEffect = u.next = u) : (y = d.lastEffect, y === null ? d.lastEffect = u.next = u : (S = y.next, y.next = u, u.next = S, d.lastEffect = u)), u;
  }
  function wh() {
    return Ba().memoizedState;
  }
  function Oc(u, d, y, S) {
    var k = Mi();
    Wr.flags |= u, k.memoizedState = _c(1 | d, y, void 0, S === void 0 ? null : S);
  }
  function xl(u, d, y, S) {
    var k = Ba();
    S = S === void 0 ? null : S;
    var A = void 0;
    if (tt !== null) {
      var X = tt.memoizedState;
      if (A = X.destroy, S !== null && Ec(S, X.deps)) {
        k.memoizedState = _c(d, y, A, S);
        return;
      }
    }
    Wr.flags |= u, k.memoizedState = _c(1 | d, y, A, S);
  }
  function xh(u, d) {
    return Oc(8390656, 8, u, d);
  }
  function wp(u, d) {
    return xl(2048, 8, u, d);
  }
  function Sh(u, d) {
    return xl(4, 2, u, d);
  }
  function Eh(u, d) {
    return xl(4, 4, u, d);
  }
  function wg(u, d) {
    if (typeof d == "function")
      return u = u(), d(u), function() {
        d(null);
      };
    if (d != null)
      return u = u(), d.current = u, function() {
        d.current = null;
      };
  }
  function jd(u, d, y) {
    return y = y != null ? y.concat([u]) : null, xl(4, 4, wg.bind(null, d, u), y);
  }
  function Ch() {
  }
  function Ld(u, d) {
    var y = Ba();
    d = d === void 0 ? null : d;
    var S = y.memoizedState;
    return S !== null && d !== null && Ec(d, S[1]) ? S[0] : (y.memoizedState = [u, d], u);
  }
  function xu(u, d) {
    var y = Ba();
    d = d === void 0 ? null : d;
    var S = y.memoizedState;
    return S !== null && d !== null && Ec(d, S[1]) ? S[0] : (u = u(), y.memoizedState = [u, d], u);
  }
  function Ha(u, d, y) {
    return xc & 21 ? (_i(y, d) || (y = yd(), Wr.lanes |= y, Cl |= y, u.baseState = !0), d) : (u.baseState && (u.baseState = !1, wo = !0), u.memoizedState = y);
  }
  function q_(u, d) {
    var y = tr;
    tr = y !== 0 && 4 > y ? y : 4, u(!0);
    var S = bg.transition;
    bg.transition = {};
    try {
      u(!1), d();
    } finally {
      tr = y, bg.transition = S;
    }
  }
  function Ir() {
    return Ba().memoizedState;
  }
  function Th(u, d, y) {
    var S = xo(u);
    if (y = { lane: S, action: y, hasEagerState: !1, eagerState: null, next: null }, Fd(u))
      xp(d, y);
    else if (y = rx(u, d, y, S), y !== null) {
      var k = pa();
      ma(y, u, S, k), dx(y, d, S);
    }
  }
  function _h(u, d, y) {
    var S = xo(u), k = { lane: S, action: y, hasEagerState: !1, eagerState: null, next: null };
    if (Fd(u))
      xp(d, k);
    else {
      var A = u.alternate;
      if (u.lanes === 0 && (A === null || A.lanes === 0) && (A = d.lastRenderedReducer, A !== null))
        try {
          var X = d.lastRenderedState, ve = A(X, y);
          if (k.hasEagerState = !0, k.eagerState = ve, _i(ve, X)) {
            var _e = d.interleaved;
            _e === null ? (k.next = k, mg(d)) : (k.next = _e.next, _e.next = k), d.interleaved = k;
            return;
          }
        } catch {
        } finally {
        }
      y = rx(u, d, k, S), y !== null && (k = pa(), ma(y, u, S, k), dx(y, d, S));
    }
  }
  function Fd(u) {
    var d = u.alternate;
    return u === Wr || d !== null && d === Wr;
  }
  function xp(u, d) {
    Ds = un = !0;
    var y = u.pending;
    y === null ? d.next = d : (d.next = y.next, y.next = d), u.pending = d;
  }
  function dx(u, d, y) {
    if (y & 4194240) {
      var S = d.lanes;
      S &= u.pendingLanes, y |= S, d.lanes = y, _s(u, y);
    }
  }
  var Oh = { readContext: fo, useCallback: Yr, useContext: Yr, useEffect: Yr, useImperativeHandle: Yr, useInsertionEffect: Yr, useLayoutEffect: Yr, useMemo: Yr, useReducer: Yr, useRef: Yr, useState: Yr, useDebugValue: Yr, useDeferredValue: Yr, useTransition: Yr, useMutableSource: Yr, useSyncExternalStore: Yr, useId: Yr, unstable_isNewReconciler: !1 }, G_ = { readContext: fo, useCallback: function(u, d) {
    return Mi().memoizedState = [u, d === void 0 ? null : d], u;
  }, useContext: fo, useEffect: xh, useImperativeHandle: function(u, d, y) {
    return y = y != null ? y.concat([u]) : null, Oc(
      4194308,
      4,
      wg.bind(null, d, u),
      y
    );
  }, useLayoutEffect: function(u, d) {
    return Oc(4194308, 4, u, d);
  }, useInsertionEffect: function(u, d) {
    return Oc(4, 2, u, d);
  }, useMemo: function(u, d) {
    var y = Mi();
    return d = d === void 0 ? null : d, u = u(), y.memoizedState = [u, d], u;
  }, useReducer: function(u, d, y) {
    var S = Mi();
    return d = y !== void 0 ? y(d) : d, S.memoizedState = S.baseState = d, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: d }, S.queue = u, u = u.dispatch = Th.bind(null, Wr, u), [S.memoizedState, u];
  }, useRef: function(u) {
    var d = Mi();
    return u = { current: u }, d.memoizedState = u;
  }, useState: bh, useDebugValue: Ch, useDeferredValue: function(u) {
    return Mi().memoizedState = u;
  }, useTransition: function() {
    var u = bh(!1), d = u[0];
    return u = q_.bind(null, u[1]), Mi().memoizedState = u, [d, u];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(u, d, y) {
    var S = Wr, k = Mi();
    if (Hr) {
      if (y === void 0)
        throw Error(n(407));
      y = y();
    } else {
      if (y = d(), ro === null)
        throw Error(n(349));
      xc & 30 || mh(S, d, y);
    }
    k.memoizedState = y;
    var A = { value: y, getSnapshot: d };
    return k.queue = A, xh(vh.bind(
      null,
      S,
      A,
      u
    ), [u]), S.flags |= 2048, _c(9, hh.bind(null, S, A, y, d), void 0, null), y;
  }, useId: function() {
    var u = Mi(), d = ro.identifierPrefix;
    if (Hr) {
      var y = gl, S = Yo;
      y = (S & ~(1 << 32 - Ur(S) - 1)).toString(32) + y, d = ":" + d + "R" + y, y = ui++, 0 < y && (d += "H" + y.toString(32)), d += ":";
    } else
      y = Sc++, d = ":" + d + "r" + y.toString(32) + ":";
    return u.memoizedState = d;
  }, unstable_isNewReconciler: !1 }, K_ = {
    readContext: fo,
    useCallback: Ld,
    useContext: fo,
    useEffect: wp,
    useImperativeHandle: jd,
    useInsertionEffect: Sh,
    useLayoutEffect: Eh,
    useMemo: xu,
    useReducer: gp,
    useRef: wh,
    useState: function() {
      return gp(Tc);
    },
    useDebugValue: Ch,
    useDeferredValue: function(u) {
      var d = Ba();
      return Ha(d, tt.memoizedState, u);
    },
    useTransition: function() {
      var u = gp(Tc)[0], d = Ba().memoizedState;
      return [u, d];
    },
    useMutableSource: fh,
    useSyncExternalStore: ph,
    useId: Ir,
    unstable_isNewReconciler: !1
  }, xg = { readContext: fo, useCallback: Ld, useContext: fo, useEffect: wp, useImperativeHandle: jd, useInsertionEffect: Sh, useLayoutEffect: Eh, useMemo: xu, useReducer: bp, useRef: wh, useState: function() {
    return bp(Tc);
  }, useDebugValue: Ch, useDeferredValue: function(u) {
    var d = Ba();
    return tt === null ? d.memoizedState = u : Ha(d, tt.memoizedState, u);
  }, useTransition: function() {
    var u = bp(Tc)[0], d = Ba().memoizedState;
    return [u, d];
  }, useMutableSource: fh, useSyncExternalStore: ph, useId: Ir, unstable_isNewReconciler: !1 };
  function zd(u, d) {
    try {
      var y = "", S = d;
      do
        y += Ce(S), S = S.return;
      while (S);
      var k = y;
    } catch (A) {
      k = `
Error generating stack: ` + A.message + `
` + A.stack;
    }
    return { value: u, source: d, stack: k, digest: null };
  }
  function Sp(u, d, y) {
    return { value: u, source: null, stack: y ?? null, digest: d ?? null };
  }
  function Ph(u, d) {
    try {
      console.error(d.value);
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  var X_ = typeof WeakMap == "function" ? WeakMap : Map;
  function fx(u, d, y) {
    y = wl(-1, y), y.tag = 3, y.payload = { element: null };
    var S = d.value;
    return y.callback = function() {
      Ih || (Ih = !0, $c = S), Ph(u, d);
    }, y;
  }
  function Ep(u, d, y) {
    y = wl(-1, y), y.tag = 3;
    var S = u.type.getDerivedStateFromError;
    if (typeof S == "function") {
      var k = d.value;
      y.payload = function() {
        return S(k);
      }, y.callback = function() {
        Ph(u, d);
      };
    }
    var A = u.stateNode;
    return A !== null && typeof A.componentDidCatch == "function" && (y.callback = function() {
      Ph(u, d), typeof S != "function" && (Ns === null ? Ns = /* @__PURE__ */ new Set([this]) : Ns.add(this));
      var X = d.stack;
      this.componentDidCatch(d.value, { componentStack: X !== null ? X : "" });
    }), y;
  }
  function px(u, d, y) {
    var S = u.pingCache;
    if (S === null) {
      S = u.pingCache = new X_();
      var k = /* @__PURE__ */ new Set();
      S.set(d, k);
    } else
      k = S.get(d), k === void 0 && (k = /* @__PURE__ */ new Set(), S.set(d, k));
    k.has(y) || (k.add(y), u = rO.bind(null, u, d, y), d.then(u, u));
  }
  function Sg(u) {
    do {
      var d;
      if ((d = u.tag === 13) && (d = u.memoizedState, d = d !== null ? d.dehydrated !== null : !0), d)
        return u;
      u = u.return;
    } while (u !== null);
    return null;
  }
  function Eg(u, d, y, S, k) {
    return u.mode & 1 ? (u.flags |= 65536, u.lanes = k, u) : (u === d ? u.flags |= 65536 : (u.flags |= 128, y.flags |= 131072, y.flags &= -52805, y.tag === 1 && (y.alternate === null ? y.tag = 17 : (d = wl(-1, 1), d.tag = 2, yu(y, d, 1))), y.lanes |= 1), u);
  }
  var Q_ = I.ReactCurrentOwner, wo = !1;
  function Ro(u, d, y, S) {
    d.child = u === null ? cx(d, null, y, S) : Id(d, u.child, y, S);
  }
  function Su(u, d, y, S, k) {
    y = y.render;
    var A = d.ref;
    return Et(d, k), S = wu(u, d, y, S, A, k), y = Cc(), u !== null && !wo ? (d.updateQueue = u.updateQueue, d.flags &= -2053, u.lanes &= ~k, Go(u, d, k)) : (Hr && y && eh(d), d.flags |= 1, Ro(u, d, S, k), d.child);
  }
  function Rh(u, d, y, S, k) {
    if (u === null) {
      var A = y.type;
      return typeof A == "function" && !Ug(A) && A.defaultProps === void 0 && y.compare === null && y.defaultProps === void 0 ? (d.tag = 15, d.type = A, Wa(u, d, A, S, k)) : (u = Vh(y.type, null, S, d, d.mode, k), u.ref = d.ref, u.return = d, d.child = u);
    }
    if (A = u.child, !(u.lanes & k)) {
      var X = A.memoizedProps;
      if (y = y.compare, y = y !== null ? y : op, y(X, S) && u.ref === d.ref)
        return Go(u, d, k);
    }
    return d.flags |= 1, u = _u(A, S), u.ref = d.ref, u.return = d, d.child = u;
  }
  function Wa(u, d, y, S, k) {
    if (u !== null) {
      var A = u.memoizedProps;
      if (op(A, S) && u.ref === d.ref)
        if (wo = !1, d.pendingProps = S = A, (u.lanes & k) !== 0)
          u.flags & 131072 && (wo = !0);
        else
          return d.lanes = u.lanes, Go(u, d, k);
    }
    return Vd(u, d, y, S, k);
  }
  function Pc(u, d, y) {
    var S = d.pendingProps, k = S.children, A = u !== null ? u.memoizedState : null;
    if (S.mode === "hidden")
      if (!(d.mode & 1))
        d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, pr(qd, ci), ci |= y;
      else {
        if (!(y & 1073741824))
          return u = A !== null ? A.baseLanes | y : y, d.lanes = d.childLanes = 1073741824, d.memoizedState = { baseLanes: u, cachePool: null, transitions: null }, d.updateQueue = null, pr(qd, ci), ci |= u, null;
        d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, S = A !== null ? A.baseLanes : y, pr(qd, ci), ci |= S;
      }
    else
      A !== null ? (S = A.baseLanes | y, d.memoizedState = null) : S = y, pr(qd, ci), ci |= S;
    return Ro(u, d, k, y), d.child;
  }
  function En(u, d) {
    var y = d.ref;
    (u === null && y !== null || u !== null && u.ref !== y) && (d.flags |= 512, d.flags |= 2097152);
  }
  function Vd(u, d, y, S, k) {
    var A = Xr(y) ? La : pn.current;
    return A = Pi(d, A), Et(d, k), y = wu(u, d, y, S, A, k), S = Cc(), u !== null && !wo ? (d.updateQueue = u.updateQueue, d.flags &= -2053, u.lanes &= ~k, Go(u, d, k)) : (Hr && S && eh(d), d.flags |= 1, Ro(u, d, y, k), d.child);
  }
  function Cg(u, d, y, S, k) {
    if (Xr(y)) {
      var A = !0;
      Jm(d);
    } else
      A = !1;
    if (Et(d, k), d.stateNode === null)
      ca(u, d), ix(d, y, S), lh(d, y, S, k), S = !0;
    else if (u === null) {
      var X = d.stateNode, ve = d.memoizedProps;
      X.props = ve;
      var _e = X.context, Ye = y.contextType;
      typeof Ye == "object" && Ye !== null ? Ye = fo(Ye) : (Ye = Xr(y) ? La : pn.current, Ye = Pi(d, Ye));
      var ut = y.getDerivedStateFromProps, ft = typeof ut == "function" || typeof X.getSnapshotBeforeUpdate == "function";
      ft || typeof X.UNSAFE_componentWillReceiveProps != "function" && typeof X.componentWillReceiveProps != "function" || (ve !== S || _e !== Ye) && sx(d, X, S, Ye), vu = !1;
      var lt = d.memoizedState;
      X.state = lt, gu(d, S, X, k), _e = d.memoizedState, ve !== S || lt !== _e || so.current || vu ? (typeof ut == "function" && (yg(d, y, ut, S), _e = d.memoizedState), (ve = vu || ax(d, y, ve, S, lt, _e, Ye)) ? (ft || typeof X.UNSAFE_componentWillMount != "function" && typeof X.componentWillMount != "function" || (typeof X.componentWillMount == "function" && X.componentWillMount(), typeof X.UNSAFE_componentWillMount == "function" && X.UNSAFE_componentWillMount()), typeof X.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof X.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = S, d.memoizedState = _e), X.props = S, X.state = _e, X.context = Ye, S = ve) : (typeof X.componentDidMount == "function" && (d.flags |= 4194308), S = !1);
    } else {
      X = d.stateNode, Po(u, d), ve = d.memoizedProps, Ye = d.type === d.elementType ? ve : li(d.type, ve), X.props = Ye, ft = d.pendingProps, lt = X.context, _e = y.contextType, typeof _e == "object" && _e !== null ? _e = fo(_e) : (_e = Xr(y) ? La : pn.current, _e = Pi(d, _e));
      var $t = y.getDerivedStateFromProps;
      (ut = typeof $t == "function" || typeof X.getSnapshotBeforeUpdate == "function") || typeof X.UNSAFE_componentWillReceiveProps != "function" && typeof X.componentWillReceiveProps != "function" || (ve !== ft || lt !== _e) && sx(d, X, S, _e), vu = !1, lt = d.memoizedState, X.state = lt, gu(d, S, X, k);
      var Yt = d.memoizedState;
      ve !== ft || lt !== Yt || so.current || vu ? (typeof $t == "function" && (yg(d, y, $t, S), Yt = d.memoizedState), (Ye = vu || ax(d, y, Ye, S, lt, Yt, _e) || !1) ? (ut || typeof X.UNSAFE_componentWillUpdate != "function" && typeof X.componentWillUpdate != "function" || (typeof X.componentWillUpdate == "function" && X.componentWillUpdate(S, Yt, _e), typeof X.UNSAFE_componentWillUpdate == "function" && X.UNSAFE_componentWillUpdate(S, Yt, _e)), typeof X.componentDidUpdate == "function" && (d.flags |= 4), typeof X.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof X.componentDidUpdate != "function" || ve === u.memoizedProps && lt === u.memoizedState || (d.flags |= 4), typeof X.getSnapshotBeforeUpdate != "function" || ve === u.memoizedProps && lt === u.memoizedState || (d.flags |= 1024), d.memoizedProps = S, d.memoizedState = Yt), X.props = S, X.state = Yt, X.context = _e, S = Ye) : (typeof X.componentDidUpdate != "function" || ve === u.memoizedProps && lt === u.memoizedState || (d.flags |= 4), typeof X.getSnapshotBeforeUpdate != "function" || ve === u.memoizedProps && lt === u.memoizedState || (d.flags |= 1024), S = !1);
    }
    return mx(u, d, y, S, A, k);
  }
  function mx(u, d, y, S, k, A) {
    En(u, d);
    var X = (d.flags & 128) !== 0;
    if (!S && !X)
      return k && Jw(d, y, !1), Go(u, d, A);
    S = d.stateNode, Q_.current = d;
    var ve = X && typeof y.getDerivedStateFromError != "function" ? null : S.render();
    return d.flags |= 1, u !== null && X ? (d.child = Id(d, u.child, null, A), d.child = Id(d, null, ve, A)) : Ro(u, d, ve, A), d.memoizedState = S.state, k && Jw(d, y, !0), d.child;
  }
  function hx(u) {
    var d = u.stateNode;
    d.pendingContext ? fu(u, d.pendingContext, d.pendingContext !== d.context) : d.context && fu(u, d.context, !1), gg(u, d.containerInfo);
  }
  function kh(u, d, y, S, k) {
    return to(), dg(k), d.flags |= 256, Ro(u, d, y, S), d.child;
  }
  var Rc = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Tg(u) {
    return { baseLanes: u, cachePool: null, transitions: null };
  }
  function _g(u, d, y) {
    var S = d.pendingProps, k = ln.current, A = !1, X = (d.flags & 128) !== 0, ve;
    if ((ve = X) || (ve = u !== null && u.memoizedState === null ? !1 : (k & 2) !== 0), ve ? (A = !0, d.flags &= -129) : (u === null || u.memoizedState !== null) && (k |= 1), pr(ln, k & 1), u === null)
      return nh(d), u = d.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (d.mode & 1 ? u.data === "$!" ? d.lanes = 8 : d.lanes = 1073741824 : d.lanes = 1, null) : (X = S.children, u = S.fallback, A ? (S = d.mode, A = d.child, X = { mode: "hidden", children: X }, !(S & 1) && A !== null ? (A.childLanes = 0, A.pendingProps = X) : A = Mp(X, S, 0, null), u = jc(u, S, y, null), A.return = d, u.return = d, A.sibling = u, d.child = A, d.child.memoizedState = Tg(y), d.memoizedState = Rc, u) : Og(d, X));
    if (k = u.memoizedState, k !== null && (ve = k.dehydrated, ve !== null))
      return Z_(u, d, X, S, ve, k, y);
    if (A) {
      A = S.fallback, X = d.mode, k = u.child, ve = k.sibling;
      var _e = { mode: "hidden", children: S.children };
      return !(X & 1) && d.child !== k ? (S = d.child, S.childLanes = 0, S.pendingProps = _e, d.deletions = null) : (S = _u(k, _e), S.subtreeFlags = k.subtreeFlags & 14680064), ve !== null ? A = _u(ve, A) : (A = jc(A, X, y, null), A.flags |= 2), A.return = d, S.return = d, S.sibling = A, d.child = S, S = A, A = d.child, X = u.child.memoizedState, X = X === null ? Tg(y) : { baseLanes: X.baseLanes | y, cachePool: null, transitions: X.transitions }, A.memoizedState = X, A.childLanes = u.childLanes & ~y, d.memoizedState = Rc, S;
    }
    return A = u.child, u = A.sibling, S = _u(A, { mode: "visible", children: S.children }), !(d.mode & 1) && (S.lanes = y), S.return = d, S.sibling = null, u !== null && (y = d.deletions, y === null ? (d.deletions = [u], d.flags |= 16) : y.push(u)), d.child = S, d.memoizedState = null, S;
  }
  function Og(u, d) {
    return d = Mp({ mode: "visible", children: d }, u.mode, 0, null), d.return = u, u.child = d;
  }
  function Ud(u, d, y, S) {
    return S !== null && dg(S), Id(d, u.child, null, y), u = Og(d, d.pendingProps.children), u.flags |= 2, d.memoizedState = null, u;
  }
  function Z_(u, d, y, S, k, A, X) {
    if (y)
      return d.flags & 256 ? (d.flags &= -257, S = Sp(Error(n(422))), Ud(u, d, X, S)) : d.memoizedState !== null ? (d.child = u.child, d.flags |= 128, null) : (A = S.fallback, k = d.mode, S = Mp({ mode: "visible", children: S.children }, k, 0, null), A = jc(A, k, X, null), A.flags |= 2, S.return = d, A.return = d, S.sibling = A, d.child = S, d.mode & 1 && Id(d, u.child, null, X), d.child.memoizedState = Tg(X), d.memoizedState = Rc, A);
    if (!(d.mode & 1))
      return Ud(u, d, X, null);
    if (k.data === "$!") {
      if (S = k.nextSibling && k.nextSibling.dataset, S)
        var ve = S.dgst;
      return S = ve, A = Error(n(419)), S = Sp(A, S, void 0), Ud(u, d, X, S);
    }
    if (ve = (X & u.childLanes) !== 0, wo || ve) {
      if (S = ro, S !== null) {
        switch (X & -X) {
          case 4:
            k = 2;
            break;
          case 16:
            k = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            k = 32;
            break;
          case 536870912:
            k = 268435456;
            break;
          default:
            k = 0;
        }
        k = k & (S.suspendedLanes | X) ? 0 : k, k !== 0 && k !== A.retryLane && (A.retryLane = k, bl(u, k), ma(S, u, k, -1));
      }
      return Fg(), S = Sp(Error(n(421))), Ud(u, d, X, S);
    }
    return k.data === "$?" ? (d.flags |= 128, d.child = u.child, d = oO.bind(null, u), k._reactRetry = d, null) : (u = A.treeContext, Ua = us(k.nextSibling), si = d, Hr = !0, Di = null, u !== null && (Va[ua++] = Yo, Va[ua++] = gl, Va[ua++] = ki, Yo = u.id, gl = u.overflow, ki = d), d = Og(d, S.children), d.flags |= 4096, d);
  }
  function Pg(u, d, y) {
    u.lanes |= d;
    var S = u.alternate;
    S !== null && (S.lanes |= d), zo(u.return, d, y);
  }
  function Dh(u, d, y, S, k) {
    var A = u.memoizedState;
    A === null ? u.memoizedState = { isBackwards: d, rendering: null, renderingStartTime: 0, last: S, tail: y, tailMode: k } : (A.isBackwards = d, A.rendering = null, A.renderingStartTime = 0, A.last = S, A.tail = y, A.tailMode = k);
  }
  function Rg(u, d, y) {
    var S = d.pendingProps, k = S.revealOrder, A = S.tail;
    if (Ro(u, d, S.children, y), S = ln.current, S & 2)
      S = S & 1 | 2, d.flags |= 128;
    else {
      if (u !== null && u.flags & 128)
        e:
          for (u = d.child; u !== null; ) {
            if (u.tag === 13)
              u.memoizedState !== null && Pg(u, y, d);
            else if (u.tag === 19)
              Pg(u, y, d);
            else if (u.child !== null) {
              u.child.return = u, u = u.child;
              continue;
            }
            if (u === d)
              break e;
            for (; u.sibling === null; ) {
              if (u.return === null || u.return === d)
                break e;
              u = u.return;
            }
            u.sibling.return = u.return, u = u.sibling;
          }
      S &= 1;
    }
    if (pr(ln, S), !(d.mode & 1))
      d.memoizedState = null;
    else
      switch (k) {
        case "forwards":
          for (y = d.child, k = null; y !== null; )
            u = y.alternate, u !== null && no(u) === null && (k = y), y = y.sibling;
          y = k, y === null ? (k = d.child, d.child = null) : (k = y.sibling, y.sibling = null), Dh(d, !1, k, y, A);
          break;
        case "backwards":
          for (y = null, k = d.child, d.child = null; k !== null; ) {
            if (u = k.alternate, u !== null && no(u) === null) {
              d.child = k;
              break;
            }
            u = k.sibling, k.sibling = y, y = k, k = u;
          }
          Dh(d, !0, y, null, A);
          break;
        case "together":
          Dh(d, !1, null, null, void 0);
          break;
        default:
          d.memoizedState = null;
      }
    return d.child;
  }
  function ca(u, d) {
    !(d.mode & 1) && u !== null && (u.alternate = null, d.alternate = null, d.flags |= 2);
  }
  function Go(u, d, y) {
    if (u !== null && (d.dependencies = u.dependencies), Cl |= d.lanes, !(y & d.childLanes))
      return null;
    if (u !== null && d.child !== u.child)
      throw Error(n(153));
    if (d.child !== null) {
      for (u = d.child, y = _u(u, u.pendingProps), d.child = y, y.return = d; u.sibling !== null; )
        u = u.sibling, y = y.sibling = _u(u, u.pendingProps), y.return = d;
      y.sibling = null;
    }
    return d.child;
  }
  function Sl(u, d, y) {
    switch (d.tag) {
      case 3:
        hx(d), to();
        break;
      case 5:
        an(d);
        break;
      case 1:
        Xr(d.type) && Jm(d);
        break;
      case 4:
        gg(d, d.stateNode.containerInfo);
        break;
      case 10:
        var S = d.type._context, k = d.memoizedProps.value;
        pr(ks, S._currentValue), S._currentValue = k;
        break;
      case 13:
        if (S = d.memoizedState, S !== null)
          return S.dehydrated !== null ? (pr(ln, ln.current & 1), d.flags |= 128, null) : y & d.child.childLanes ? _g(u, d, y) : (pr(ln, ln.current & 1), u = Go(u, d, y), u !== null ? u.sibling : null);
        pr(ln, ln.current & 1);
        break;
      case 19:
        if (S = (y & d.childLanes) !== 0, u.flags & 128) {
          if (S)
            return Rg(u, d, y);
          d.flags |= 128;
        }
        if (k = d.memoizedState, k !== null && (k.rendering = null, k.tail = null, k.lastEffect = null), pr(ln, ln.current), S)
          break;
        return null;
      case 22:
      case 23:
        return d.lanes = 0, Pc(u, d, y);
    }
    return Go(u, d, y);
  }
  var Cp, kc, Ni, ko;
  Cp = function(u, d) {
    for (var y = d.child; y !== null; ) {
      if (y.tag === 5 || y.tag === 6)
        u.appendChild(y.stateNode);
      else if (y.tag !== 4 && y.child !== null) {
        y.child.return = y, y = y.child;
        continue;
      }
      if (y === d)
        break;
      for (; y.sibling === null; ) {
        if (y.return === null || y.return === d)
          return;
        y = y.return;
      }
      y.sibling.return = y.return, y = y.sibling;
    }
  }, kc = function() {
  }, Ni = function(u, d, y, S) {
    var k = u.memoizedProps;
    if (k !== S) {
      u = d.stateNode, wc(cs.current);
      var A = null;
      switch (y) {
        case "input":
          k = Ee(u, k), S = Ee(u, S), A = [];
          break;
        case "select":
          k = V({}, k, { value: void 0 }), S = V({}, S, { value: void 0 }), A = [];
          break;
        case "textarea":
          k = qe(u, k), S = qe(u, S), A = [];
          break;
        default:
          typeof k.onClick != "function" && typeof S.onClick == "function" && (u.onclick = Zm);
      }
      vt(y, S);
      var X;
      y = null;
      for (Ye in k)
        if (!S.hasOwnProperty(Ye) && k.hasOwnProperty(Ye) && k[Ye] != null)
          if (Ye === "style") {
            var ve = k[Ye];
            for (X in ve)
              ve.hasOwnProperty(X) && (y || (y = {}), y[X] = "");
          } else
            Ye !== "dangerouslySetInnerHTML" && Ye !== "children" && Ye !== "suppressContentEditableWarning" && Ye !== "suppressHydrationWarning" && Ye !== "autoFocus" && (a.hasOwnProperty(Ye) ? A || (A = []) : (A = A || []).push(Ye, null));
      for (Ye in S) {
        var _e = S[Ye];
        if (ve = k != null ? k[Ye] : void 0, S.hasOwnProperty(Ye) && _e !== ve && (_e != null || ve != null))
          if (Ye === "style")
            if (ve) {
              for (X in ve)
                !ve.hasOwnProperty(X) || _e && _e.hasOwnProperty(X) || (y || (y = {}), y[X] = "");
              for (X in _e)
                _e.hasOwnProperty(X) && ve[X] !== _e[X] && (y || (y = {}), y[X] = _e[X]);
            } else
              y || (A || (A = []), A.push(
                Ye,
                y
              )), y = _e;
          else
            Ye === "dangerouslySetInnerHTML" ? (_e = _e ? _e.__html : void 0, ve = ve ? ve.__html : void 0, _e != null && ve !== _e && (A = A || []).push(Ye, _e)) : Ye === "children" ? typeof _e != "string" && typeof _e != "number" || (A = A || []).push(Ye, "" + _e) : Ye !== "suppressContentEditableWarning" && Ye !== "suppressHydrationWarning" && (a.hasOwnProperty(Ye) ? (_e != null && Ye === "onScroll" && Nr("scroll", u), A || ve === _e || (A = [])) : (A = A || []).push(Ye, _e));
      }
      y && (A = A || []).push("style", y);
      var Ye = A;
      (d.updateQueue = Ye) && (d.flags |= 4);
    }
  }, ko = function(u, d, y, S) {
    y !== S && (d.flags |= 4);
  };
  function Tp(u, d) {
    if (!Hr)
      switch (u.tailMode) {
        case "hidden":
          d = u.tail;
          for (var y = null; d !== null; )
            d.alternate !== null && (y = d), d = d.sibling;
          y === null ? u.tail = null : y.sibling = null;
          break;
        case "collapsed":
          y = u.tail;
          for (var S = null; y !== null; )
            y.alternate !== null && (S = y), y = y.sibling;
          S === null ? d || u.tail === null ? u.tail = null : u.tail.sibling = null : S.sibling = null;
      }
  }
  function da(u) {
    var d = u.alternate !== null && u.alternate.child === u.child, y = 0, S = 0;
    if (d)
      for (var k = u.child; k !== null; )
        y |= k.lanes | k.childLanes, S |= k.subtreeFlags & 14680064, S |= k.flags & 14680064, k.return = u, k = k.sibling;
    else
      for (k = u.child; k !== null; )
        y |= k.lanes | k.childLanes, S |= k.subtreeFlags, S |= k.flags, k.return = u, k = k.sibling;
    return u.subtreeFlags |= S, u.childLanes = y, d;
  }
  function J_(u, d, y) {
    var S = d.pendingProps;
    switch (ug(d), d.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return da(d), null;
      case 1:
        return Xr(d.type) && Ri(), da(d), null;
      case 3:
        return S = d.stateNode, bu(), sr(so), sr(pn), ch(), S.pendingContext && (S.context = S.pendingContext, S.pendingContext = null), (u === null || u.child === null) && (rh(d) ? d.flags |= 4 : u === null || u.memoizedState.isDehydrated && !(d.flags & 256) || (d.flags |= 1024, Di !== null && ($p(Di), Di = null))), kc(u, d), da(d), null;
      case 5:
        kn(d);
        var k = wc(Ad.current);
        if (y = d.type, u !== null && d.stateNode != null)
          Ni(u, d, y, S, k), u.ref !== d.ref && (d.flags |= 512, d.flags |= 2097152);
        else {
          if (!S) {
            if (d.stateNode === null)
              throw Error(n(166));
            return da(d), null;
          }
          if (u = wc(cs.current), rh(d)) {
            S = d.stateNode, y = d.type;
            var A = d.memoizedProps;
            switch (S[Ps] = d, S[yc] = A, u = (d.mode & 1) !== 0, y) {
              case "dialog":
                Nr("cancel", S), Nr("close", S);
                break;
              case "iframe":
              case "object":
              case "embed":
                Nr("load", S);
                break;
              case "video":
              case "audio":
                for (k = 0; k < lp.length; k++)
                  Nr(lp[k], S);
                break;
              case "source":
                Nr("error", S);
                break;
              case "img":
              case "image":
              case "link":
                Nr(
                  "error",
                  S
                ), Nr("load", S);
                break;
              case "details":
                Nr("toggle", S);
                break;
              case "input":
                Ke(S, A), Nr("invalid", S);
                break;
              case "select":
                S._wrapperState = { wasMultiple: !!A.multiple }, Nr("invalid", S);
                break;
              case "textarea":
                ot(S, A), Nr("invalid", S);
            }
            vt(y, A), k = null;
            for (var X in A)
              if (A.hasOwnProperty(X)) {
                var ve = A[X];
                X === "children" ? typeof ve == "string" ? S.textContent !== ve && (A.suppressHydrationWarning !== !0 && Qm(S.textContent, ve, u), k = ["children", ve]) : typeof ve == "number" && S.textContent !== "" + ve && (A.suppressHydrationWarning !== !0 && Qm(
                  S.textContent,
                  ve,
                  u
                ), k = ["children", "" + ve]) : a.hasOwnProperty(X) && ve != null && X === "onScroll" && Nr("scroll", S);
              }
            switch (y) {
              case "input":
                Fe(S), we(S, A, !0);
                break;
              case "textarea":
                Fe(S), ct(S);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof A.onClick == "function" && (S.onclick = Zm);
            }
            S = k, d.updateQueue = S, S !== null && (d.flags |= 4);
          } else {
            X = k.nodeType === 9 ? k : k.ownerDocument, u === "http://www.w3.org/1999/xhtml" && (u = Qt(y)), u === "http://www.w3.org/1999/xhtml" ? y === "script" ? (u = X.createElement("div"), u.innerHTML = "<script><\/script>", u = u.removeChild(u.firstChild)) : typeof S.is == "string" ? u = X.createElement(y, { is: S.is }) : (u = X.createElement(y), y === "select" && (X = u, S.multiple ? X.multiple = !0 : S.size && (X.size = S.size))) : u = X.createElementNS(u, y), u[Ps] = d, u[yc] = S, Cp(u, d, !1, !1), d.stateNode = u;
            e: {
              switch (X = Nt(y, S), y) {
                case "dialog":
                  Nr("cancel", u), Nr("close", u), k = S;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Nr("load", u), k = S;
                  break;
                case "video":
                case "audio":
                  for (k = 0; k < lp.length; k++)
                    Nr(lp[k], u);
                  k = S;
                  break;
                case "source":
                  Nr("error", u), k = S;
                  break;
                case "img":
                case "image":
                case "link":
                  Nr(
                    "error",
                    u
                  ), Nr("load", u), k = S;
                  break;
                case "details":
                  Nr("toggle", u), k = S;
                  break;
                case "input":
                  Ke(u, S), k = Ee(u, S), Nr("invalid", u);
                  break;
                case "option":
                  k = S;
                  break;
                case "select":
                  u._wrapperState = { wasMultiple: !!S.multiple }, k = V({}, S, { value: void 0 }), Nr("invalid", u);
                  break;
                case "textarea":
                  ot(u, S), k = qe(u, S), Nr("invalid", u);
                  break;
                default:
                  k = S;
              }
              vt(y, k), ve = k;
              for (A in ve)
                if (ve.hasOwnProperty(A)) {
                  var _e = ve[A];
                  A === "style" ? pt(u, _e) : A === "dangerouslySetInnerHTML" ? (_e = _e ? _e.__html : void 0, _e != null && St(u, _e)) : A === "children" ? typeof _e == "string" ? (y !== "textarea" || _e !== "") && cn(u, _e) : typeof _e == "number" && cn(u, "" + _e) : A !== "suppressContentEditableWarning" && A !== "suppressHydrationWarning" && A !== "autoFocus" && (a.hasOwnProperty(A) ? _e != null && A === "onScroll" && Nr("scroll", u) : _e != null && N(u, A, _e, X));
                }
              switch (y) {
                case "input":
                  Fe(u), we(u, S, !1);
                  break;
                case "textarea":
                  Fe(u), ct(u);
                  break;
                case "option":
                  S.value != null && u.setAttribute("value", "" + pe(S.value));
                  break;
                case "select":
                  u.multiple = !!S.multiple, A = S.value, A != null ? je(u, !!S.multiple, A, !1) : S.defaultValue != null && je(
                    u,
                    !!S.multiple,
                    S.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof k.onClick == "function" && (u.onclick = Zm);
              }
              switch (y) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  S = !!S.autoFocus;
                  break e;
                case "img":
                  S = !0;
                  break e;
                default:
                  S = !1;
              }
            }
            S && (d.flags |= 4);
          }
          d.ref !== null && (d.flags |= 512, d.flags |= 2097152);
        }
        return da(d), null;
      case 6:
        if (u && d.stateNode != null)
          ko(u, d, u.memoizedProps, S);
        else {
          if (typeof S != "string" && d.stateNode === null)
            throw Error(n(166));
          if (y = wc(Ad.current), wc(cs.current), rh(d)) {
            if (S = d.stateNode, y = d.memoizedProps, S[Ps] = d, (A = S.nodeValue !== y) && (u = si, u !== null))
              switch (u.tag) {
                case 3:
                  Qm(S.nodeValue, y, (u.mode & 1) !== 0);
                  break;
                case 5:
                  u.memoizedProps.suppressHydrationWarning !== !0 && Qm(S.nodeValue, y, (u.mode & 1) !== 0);
              }
            A && (d.flags |= 4);
          } else
            S = (y.nodeType === 9 ? y : y.ownerDocument).createTextNode(S), S[Ps] = d, d.stateNode = S;
        }
        return da(d), null;
      case 13:
        if (sr(ln), S = d.memoizedState, u === null || u.memoizedState !== null && u.memoizedState.dehydrated !== null) {
          if (Hr && Ua !== null && d.mode & 1 && !(d.flags & 128))
            nx(), to(), d.flags |= 98560, A = !1;
          else if (A = rh(d), S !== null && S.dehydrated !== null) {
            if (u === null) {
              if (!A)
                throw Error(n(318));
              if (A = d.memoizedState, A = A !== null ? A.dehydrated : null, !A)
                throw Error(n(317));
              A[Ps] = d;
            } else
              to(), !(d.flags & 128) && (d.memoizedState = null), d.flags |= 4;
            da(d), A = !1;
          } else
            Di !== null && ($p(Di), Di = null), A = !0;
          if (!A)
            return d.flags & 65536 ? d : null;
        }
        return d.flags & 128 ? (d.lanes = y, d) : (S = S !== null, S !== (u !== null && u.memoizedState !== null) && S && (d.child.flags |= 8192, d.mode & 1 && (u === null || ln.current & 1 ? $o === 0 && ($o = 3) : Fg())), d.updateQueue !== null && (d.flags |= 4), da(d), null);
      case 4:
        return bu(), kc(u, d), u === null && Dd(d.stateNode.containerInfo), da(d), null;
      case 10:
        return hu(d.type._context), da(d), null;
      case 17:
        return Xr(d.type) && Ri(), da(d), null;
      case 19:
        if (sr(ln), A = d.memoizedState, A === null)
          return da(d), null;
        if (S = (d.flags & 128) !== 0, X = A.rendering, X === null)
          if (S)
            Tp(A, !1);
          else {
            if ($o !== 0 || u !== null && u.flags & 128)
              for (u = d.child; u !== null; ) {
                if (X = no(u), X !== null) {
                  for (d.flags |= 128, Tp(A, !1), S = X.updateQueue, S !== null && (d.updateQueue = S, d.flags |= 4), d.subtreeFlags = 0, S = y, y = d.child; y !== null; )
                    A = y, u = S, A.flags &= 14680066, X = A.alternate, X === null ? (A.childLanes = 0, A.lanes = u, A.child = null, A.subtreeFlags = 0, A.memoizedProps = null, A.memoizedState = null, A.updateQueue = null, A.dependencies = null, A.stateNode = null) : (A.childLanes = X.childLanes, A.lanes = X.lanes, A.child = X.child, A.subtreeFlags = 0, A.deletions = null, A.memoizedProps = X.memoizedProps, A.memoizedState = X.memoizedState, A.updateQueue = X.updateQueue, A.type = X.type, u = X.dependencies, A.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }), y = y.sibling;
                  return pr(ln, ln.current & 1 | 2), d.child;
                }
                u = u.sibling;
              }
            A.tail !== null && _n() > Kd && (d.flags |= 128, S = !0, Tp(A, !1), d.lanes = 4194304);
          }
        else {
          if (!S)
            if (u = no(X), u !== null) {
              if (d.flags |= 128, S = !0, y = u.updateQueue, y !== null && (d.updateQueue = y, d.flags |= 4), Tp(A, !0), A.tail === null && A.tailMode === "hidden" && !X.alternate && !Hr)
                return da(d), null;
            } else
              2 * _n() - A.renderingStartTime > Kd && y !== 1073741824 && (d.flags |= 128, S = !0, Tp(A, !1), d.lanes = 4194304);
          A.isBackwards ? (X.sibling = d.child, d.child = X) : (y = A.last, y !== null ? y.sibling = X : d.child = X, A.last = X);
        }
        return A.tail !== null ? (d = A.tail, A.rendering = d, A.tail = d.sibling, A.renderingStartTime = _n(), d.sibling = null, y = ln.current, pr(ln, S ? y & 1 | 2 : y & 1), d) : (da(d), null);
      case 22:
      case 23:
        return Lg(), S = d.memoizedState !== null, u !== null && u.memoizedState !== null !== S && (d.flags |= 8192), S && d.mode & 1 ? ci & 1073741824 && (da(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : da(d), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, d.tag));
  }
  function kg(u, d) {
    switch (ug(d), d.tag) {
      case 1:
        return Xr(d.type) && Ri(), u = d.flags, u & 65536 ? (d.flags = u & -65537 | 128, d) : null;
      case 3:
        return bu(), sr(so), sr(pn), ch(), u = d.flags, u & 65536 && !(u & 128) ? (d.flags = u & -65537 | 128, d) : null;
      case 5:
        return kn(d), null;
      case 13:
        if (sr(ln), u = d.memoizedState, u !== null && u.dehydrated !== null) {
          if (d.alternate === null)
            throw Error(n(340));
          to();
        }
        return u = d.flags, u & 65536 ? (d.flags = u & -65537 | 128, d) : null;
      case 19:
        return sr(ln), null;
      case 4:
        return bu(), null;
      case 10:
        return hu(d.type._context), null;
      case 22:
      case 23:
        return Lg(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var _p = !1, Do = !1, vx = typeof WeakSet == "function" ? WeakSet : Set, Vt = null;
  function Bd(u, d) {
    var y = u.ref;
    if (y !== null)
      if (typeof y == "function")
        try {
          y(null);
        } catch (S) {
          uo(u, d, S);
        }
      else
        y.current = null;
  }
  function Op(u, d, y) {
    try {
      y();
    } catch (S) {
      uo(u, d, S);
    }
  }
  var yx = !1;
  function gx(u, d) {
    if (tg = Ti, u = Ym(), ml(u)) {
      if ("selectionStart" in u)
        var y = { start: u.selectionStart, end: u.selectionEnd };
      else
        e: {
          y = (y = u.ownerDocument) && y.defaultView || window;
          var S = y.getSelection && y.getSelection();
          if (S && S.rangeCount !== 0) {
            y = S.anchorNode;
            var k = S.anchorOffset, A = S.focusNode;
            S = S.focusOffset;
            try {
              y.nodeType, A.nodeType;
            } catch {
              y = null;
              break e;
            }
            var X = 0, ve = -1, _e = -1, Ye = 0, ut = 0, ft = u, lt = null;
            t:
              for (; ; ) {
                for (var $t; ft !== y || k !== 0 && ft.nodeType !== 3 || (ve = X + k), ft !== A || S !== 0 && ft.nodeType !== 3 || (_e = X + S), ft.nodeType === 3 && (X += ft.nodeValue.length), ($t = ft.firstChild) !== null; )
                  lt = ft, ft = $t;
                for (; ; ) {
                  if (ft === u)
                    break t;
                  if (lt === y && ++Ye === k && (ve = X), lt === A && ++ut === S && (_e = X), ($t = ft.nextSibling) !== null)
                    break;
                  ft = lt, lt = ft.parentNode;
                }
                ft = $t;
              }
            y = ve === -1 || _e === -1 ? null : { start: ve, end: _e };
          } else
            y = null;
        }
      y = y || { start: 0, end: 0 };
    } else
      y = null;
    for (hc = { focusedElem: u, selectionRange: y }, Ti = !1, Vt = d; Vt !== null; )
      if (d = Vt, u = d.child, (d.subtreeFlags & 1028) !== 0 && u !== null)
        u.return = d, Vt = u;
      else
        for (; Vt !== null; ) {
          d = Vt;
          try {
            var Yt = d.alternate;
            if (d.flags & 1024)
              switch (d.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Yt !== null) {
                    var Zt = Yt.memoizedProps, po = Yt.memoizedState, Le = d.stateNode, ke = Le.getSnapshotBeforeUpdate(d.elementType === d.type ? Zt : li(d.type, Zt), po);
                    Le.__reactInternalSnapshotBeforeUpdate = ke;
                  }
                  break;
                case 3:
                  var Ue = d.stateNode.containerInfo;
                  Ue.nodeType === 1 ? Ue.textContent = "" : Ue.nodeType === 9 && Ue.documentElement && Ue.removeChild(Ue.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (gt) {
            uo(d, d.return, gt);
          }
          if (u = d.sibling, u !== null) {
            u.return = d.return, Vt = u;
            break;
          }
          Vt = d.return;
        }
    return Yt = yx, yx = !1, Yt;
  }
  function Pp(u, d, y) {
    var S = d.updateQueue;
    if (S = S !== null ? S.lastEffect : null, S !== null) {
      var k = S = S.next;
      do {
        if ((k.tag & u) === u) {
          var A = k.destroy;
          k.destroy = void 0, A !== void 0 && Op(d, y, A);
        }
        k = k.next;
      } while (k !== S);
    }
  }
  function Rp(u, d) {
    if (d = d.updateQueue, d = d !== null ? d.lastEffect : null, d !== null) {
      var y = d = d.next;
      do {
        if ((y.tag & u) === u) {
          var S = y.create;
          y.destroy = S();
        }
        y = y.next;
      } while (y !== d);
    }
  }
  function Dg(u) {
    var d = u.ref;
    if (d !== null) {
      var y = u.stateNode;
      switch (u.tag) {
        case 5:
          u = y;
          break;
        default:
          u = y;
      }
      typeof d == "function" ? d(u) : d.current = u;
    }
  }
  function $g(u) {
    var d = u.alternate;
    d !== null && (u.alternate = null, $g(d)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (d = u.stateNode, d !== null && (delete d[Ps], delete d[yc], delete d[og], delete d[Y_], delete d[ag])), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
  }
  function bx(u) {
    return u.tag === 5 || u.tag === 3 || u.tag === 4;
  }
  function $h(u) {
    e:
      for (; ; ) {
        for (; u.sibling === null; ) {
          if (u.return === null || bx(u.return))
            return null;
          u = u.return;
        }
        for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
          if (u.flags & 2 || u.child === null || u.tag === 4)
            continue e;
          u.child.return = u, u = u.child;
        }
        if (!(u.flags & 2))
          return u.stateNode;
      }
  }
  function Hd(u, d, y) {
    var S = u.tag;
    if (S === 5 || S === 6)
      u = u.stateNode, d ? y.nodeType === 8 ? y.parentNode.insertBefore(u, d) : y.insertBefore(u, d) : (y.nodeType === 8 ? (d = y.parentNode, d.insertBefore(u, y)) : (d = y, d.appendChild(u)), y = y._reactRootContainer, y != null || d.onclick !== null || (d.onclick = Zm));
    else if (S !== 4 && (u = u.child, u !== null))
      for (Hd(u, d, y), u = u.sibling; u !== null; )
        Hd(u, d, y), u = u.sibling;
  }
  function $s(u, d, y) {
    var S = u.tag;
    if (S === 5 || S === 6)
      u = u.stateNode, d ? y.insertBefore(u, d) : y.appendChild(u);
    else if (S !== 4 && (u = u.child, u !== null))
      for ($s(u, d, y), u = u.sibling; u !== null; )
        $s(u, d, y), u = u.sibling;
  }
  var Qr = null, Vo = !1;
  function Ii(u, d, y) {
    for (y = y.child; y !== null; )
      Wd(u, d, y), y = y.sibling;
  }
  function Wd(u, d, y) {
    if (zt && typeof zt.onCommitFiberUnmount == "function")
      try {
        zt.onCommitFiberUnmount(ri, y);
      } catch {
      }
    switch (y.tag) {
      case 5:
        Do || Bd(y, d);
      case 6:
        var S = Qr, k = Vo;
        Qr = null, Ii(u, d, y), Qr = S, Vo = k, Qr !== null && (Vo ? (u = Qr, y = y.stateNode, u.nodeType === 8 ? u.parentNode.removeChild(y) : u.removeChild(y)) : Qr.removeChild(y.stateNode));
        break;
      case 18:
        Qr !== null && (Vo ? (u = Qr, y = y.stateNode, u.nodeType === 8 ? uu(u.parentNode, y) : u.nodeType === 1 && uu(u, y), ou(u)) : uu(Qr, y.stateNode));
        break;
      case 4:
        S = Qr, k = Vo, Qr = y.stateNode.containerInfo, Vo = !0, Ii(u, d, y), Qr = S, Vo = k;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Do && (S = y.updateQueue, S !== null && (S = S.lastEffect, S !== null))) {
          k = S = S.next;
          do {
            var A = k, X = A.destroy;
            A = A.tag, X !== void 0 && (A & 2 || A & 4) && Op(y, d, X), k = k.next;
          } while (k !== S);
        }
        Ii(u, d, y);
        break;
      case 1:
        if (!Do && (Bd(y, d), S = y.stateNode, typeof S.componentWillUnmount == "function"))
          try {
            S.props = y.memoizedProps, S.state = y.memoizedState, S.componentWillUnmount();
          } catch (ve) {
            uo(y, d, ve);
          }
        Ii(u, d, y);
        break;
      case 21:
        Ii(u, d, y);
        break;
      case 22:
        y.mode & 1 ? (Do = (S = Do) || y.memoizedState !== null, Ii(u, d, y), Do = S) : Ii(u, d, y);
        break;
      default:
        Ii(u, d, y);
    }
  }
  function El(u) {
    var d = u.updateQueue;
    if (d !== null) {
      u.updateQueue = null;
      var y = u.stateNode;
      y === null && (y = u.stateNode = new vx()), d.forEach(function(S) {
        var k = aO.bind(null, u, S);
        y.has(S) || (y.add(S), S.then(k, k));
      });
    }
  }
  function ds(u, d) {
    var y = d.deletions;
    if (y !== null)
      for (var S = 0; S < y.length; S++) {
        var k = y[S];
        try {
          var A = u, X = d, ve = X;
          e:
            for (; ve !== null; ) {
              switch (ve.tag) {
                case 5:
                  Qr = ve.stateNode, Vo = !1;
                  break e;
                case 3:
                  Qr = ve.stateNode.containerInfo, Vo = !0;
                  break e;
                case 4:
                  Qr = ve.stateNode.containerInfo, Vo = !0;
                  break e;
              }
              ve = ve.return;
            }
          if (Qr === null)
            throw Error(n(160));
          Wd(A, X, k), Qr = null, Vo = !1;
          var _e = k.alternate;
          _e !== null && (_e.return = null), k.return = null;
        } catch (Ye) {
          uo(k, d, Ye);
        }
      }
    if (d.subtreeFlags & 12854)
      for (d = d.child; d !== null; )
        wx(d, u), d = d.sibling;
  }
  function wx(u, d) {
    var y = u.alternate, S = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ds(d, u), Ms(u), S & 4) {
          try {
            Pp(3, u, u.return), Rp(3, u);
          } catch (Zt) {
            uo(u, u.return, Zt);
          }
          try {
            Pp(5, u, u.return);
          } catch (Zt) {
            uo(u, u.return, Zt);
          }
        }
        break;
      case 1:
        ds(d, u), Ms(u), S & 512 && y !== null && Bd(y, y.return);
        break;
      case 5:
        if (ds(d, u), Ms(u), S & 512 && y !== null && Bd(y, y.return), u.flags & 32) {
          var k = u.stateNode;
          try {
            cn(k, "");
          } catch (Zt) {
            uo(u, u.return, Zt);
          }
        }
        if (S & 4 && (k = u.stateNode, k != null)) {
          var A = u.memoizedProps, X = y !== null ? y.memoizedProps : A, ve = u.type, _e = u.updateQueue;
          if (u.updateQueue = null, _e !== null)
            try {
              ve === "input" && A.type === "radio" && A.name != null && oe(k, A), Nt(ve, X);
              var Ye = Nt(ve, A);
              for (X = 0; X < _e.length; X += 2) {
                var ut = _e[X], ft = _e[X + 1];
                ut === "style" ? pt(k, ft) : ut === "dangerouslySetInnerHTML" ? St(k, ft) : ut === "children" ? cn(k, ft) : N(k, ut, ft, Ye);
              }
              switch (ve) {
                case "input":
                  de(k, A);
                  break;
                case "textarea":
                  et(k, A);
                  break;
                case "select":
                  var lt = k._wrapperState.wasMultiple;
                  k._wrapperState.wasMultiple = !!A.multiple;
                  var $t = A.value;
                  $t != null ? je(k, !!A.multiple, $t, !1) : lt !== !!A.multiple && (A.defaultValue != null ? je(
                    k,
                    !!A.multiple,
                    A.defaultValue,
                    !0
                  ) : je(k, !!A.multiple, A.multiple ? [] : "", !1));
              }
              k[yc] = A;
            } catch (Zt) {
              uo(u, u.return, Zt);
            }
        }
        break;
      case 6:
        if (ds(d, u), Ms(u), S & 4) {
          if (u.stateNode === null)
            throw Error(n(162));
          k = u.stateNode, A = u.memoizedProps;
          try {
            k.nodeValue = A;
          } catch (Zt) {
            uo(u, u.return, Zt);
          }
        }
        break;
      case 3:
        if (ds(d, u), Ms(u), S & 4 && y !== null && y.memoizedState.isDehydrated)
          try {
            ou(d.containerInfo);
          } catch (Zt) {
            uo(u, u.return, Zt);
          }
        break;
      case 4:
        ds(d, u), Ms(u);
        break;
      case 13:
        ds(d, u), Ms(u), k = u.child, k.flags & 8192 && (A = k.memoizedState !== null, k.stateNode.isHidden = A, !A || k.alternate !== null && k.alternate.memoizedState !== null || (Ig = _n())), S & 4 && El(u);
        break;
      case 22:
        if (ut = y !== null && y.memoizedState !== null, u.mode & 1 ? (Do = (Ye = Do) || ut, ds(d, u), Do = Ye) : ds(d, u), Ms(u), S & 8192) {
          if (Ye = u.memoizedState !== null, (u.stateNode.isHidden = Ye) && !ut && u.mode & 1)
            for (Vt = u, ut = u.child; ut !== null; ) {
              for (ft = Vt = ut; Vt !== null; ) {
                switch (lt = Vt, $t = lt.child, lt.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pp(4, lt, lt.return);
                    break;
                  case 1:
                    Bd(lt, lt.return);
                    var Yt = lt.stateNode;
                    if (typeof Yt.componentWillUnmount == "function") {
                      S = lt, y = lt.return;
                      try {
                        d = S, Yt.props = d.memoizedProps, Yt.state = d.memoizedState, Yt.componentWillUnmount();
                      } catch (Zt) {
                        uo(S, y, Zt);
                      }
                    }
                    break;
                  case 5:
                    Bd(lt, lt.return);
                    break;
                  case 22:
                    if (lt.memoizedState !== null) {
                      Mg(ft);
                      continue;
                    }
                }
                $t !== null ? ($t.return = lt, Vt = $t) : Mg(ft);
              }
              ut = ut.sibling;
            }
          e:
            for (ut = null, ft = u; ; ) {
              if (ft.tag === 5) {
                if (ut === null) {
                  ut = ft;
                  try {
                    k = ft.stateNode, Ye ? (A = k.style, typeof A.setProperty == "function" ? A.setProperty("display", "none", "important") : A.display = "none") : (ve = ft.stateNode, _e = ft.memoizedProps.style, X = _e != null && _e.hasOwnProperty("display") ? _e.display : null, ve.style.display = Je("display", X));
                  } catch (Zt) {
                    uo(u, u.return, Zt);
                  }
                }
              } else if (ft.tag === 6) {
                if (ut === null)
                  try {
                    ft.stateNode.nodeValue = Ye ? "" : ft.memoizedProps;
                  } catch (Zt) {
                    uo(u, u.return, Zt);
                  }
              } else if ((ft.tag !== 22 && ft.tag !== 23 || ft.memoizedState === null || ft === u) && ft.child !== null) {
                ft.child.return = ft, ft = ft.child;
                continue;
              }
              if (ft === u)
                break e;
              for (; ft.sibling === null; ) {
                if (ft.return === null || ft.return === u)
                  break e;
                ut === ft && (ut = null), ft = ft.return;
              }
              ut === ft && (ut = null), ft.sibling.return = ft.return, ft = ft.sibling;
            }
        }
        break;
      case 19:
        ds(d, u), Ms(u), S & 4 && El(u);
        break;
      case 21:
        break;
      default:
        ds(
          d,
          u
        ), Ms(u);
    }
  }
  function Ms(u) {
    var d = u.flags;
    if (d & 2) {
      try {
        e: {
          for (var y = u.return; y !== null; ) {
            if (bx(y)) {
              var S = y;
              break e;
            }
            y = y.return;
          }
          throw Error(n(160));
        }
        switch (S.tag) {
          case 5:
            var k = S.stateNode;
            S.flags & 32 && (cn(k, ""), S.flags &= -33);
            var A = $h(u);
            $s(u, A, k);
            break;
          case 3:
          case 4:
            var X = S.stateNode.containerInfo, ve = $h(u);
            Hd(u, ve, X);
            break;
          default:
            throw Error(n(161));
        }
      } catch (_e) {
        uo(u, u.return, _e);
      }
      u.flags &= -3;
    }
    d & 4096 && (u.flags &= -4097);
  }
  function xx(u, d, y) {
    Vt = u, Yd(u);
  }
  function Yd(u, d, y) {
    for (var S = (u.mode & 1) !== 0; Vt !== null; ) {
      var k = Vt, A = k.child;
      if (k.tag === 22 && S) {
        var X = k.memoizedState !== null || _p;
        if (!X) {
          var ve = k.alternate, _e = ve !== null && ve.memoizedState !== null || Do;
          ve = _p;
          var Ye = Do;
          if (_p = X, (Do = _e) && !Ye)
            for (Vt = k; Vt !== null; )
              X = Vt, _e = X.child, X.tag === 22 && X.memoizedState !== null ? Ex(k) : _e !== null ? (_e.return = X, Vt = _e) : Ex(k);
          for (; A !== null; )
            Vt = A, Yd(A), A = A.sibling;
          Vt = k, _p = ve, Do = Ye;
        }
        Sx(u);
      } else
        k.subtreeFlags & 8772 && A !== null ? (A.return = k, Vt = A) : Sx(u);
    }
  }
  function Sx(u) {
    for (; Vt !== null; ) {
      var d = Vt;
      if (d.flags & 8772) {
        var y = d.alternate;
        try {
          if (d.flags & 8772)
            switch (d.tag) {
              case 0:
              case 11:
              case 15:
                Do || Rp(5, d);
                break;
              case 1:
                var S = d.stateNode;
                if (d.flags & 4 && !Do)
                  if (y === null)
                    S.componentDidMount();
                  else {
                    var k = d.elementType === d.type ? y.memoizedProps : li(d.type, y.memoizedProps);
                    S.componentDidUpdate(k, y.memoizedState, S.__reactInternalSnapshotBeforeUpdate);
                  }
                var A = d.updateQueue;
                A !== null && bc(d, A, S);
                break;
              case 3:
                var X = d.updateQueue;
                if (X !== null) {
                  if (y = null, d.child !== null)
                    switch (d.child.tag) {
                      case 5:
                        y = d.child.stateNode;
                        break;
                      case 1:
                        y = d.child.stateNode;
                    }
                  bc(d, X, y);
                }
                break;
              case 5:
                var ve = d.stateNode;
                if (y === null && d.flags & 4) {
                  y = ve;
                  var _e = d.memoizedProps;
                  switch (d.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      _e.autoFocus && y.focus();
                      break;
                    case "img":
                      _e.src && (y.src = _e.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (d.memoizedState === null) {
                  var Ye = d.alternate;
                  if (Ye !== null) {
                    var ut = Ye.memoizedState;
                    if (ut !== null) {
                      var ft = ut.dehydrated;
                      ft !== null && ou(ft);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          Do || d.flags & 512 && Dg(d);
        } catch (lt) {
          uo(d, d.return, lt);
        }
      }
      if (d === u) {
        Vt = null;
        break;
      }
      if (y = d.sibling, y !== null) {
        y.return = d.return, Vt = y;
        break;
      }
      Vt = d.return;
    }
  }
  function Mg(u) {
    for (; Vt !== null; ) {
      var d = Vt;
      if (d === u) {
        Vt = null;
        break;
      }
      var y = d.sibling;
      if (y !== null) {
        y.return = d.return, Vt = y;
        break;
      }
      Vt = d.return;
    }
  }
  function Ex(u) {
    for (; Vt !== null; ) {
      var d = Vt;
      try {
        switch (d.tag) {
          case 0:
          case 11:
          case 15:
            var y = d.return;
            try {
              Rp(4, d);
            } catch (_e) {
              uo(d, y, _e);
            }
            break;
          case 1:
            var S = d.stateNode;
            if (typeof S.componentDidMount == "function") {
              var k = d.return;
              try {
                S.componentDidMount();
              } catch (_e) {
                uo(d, k, _e);
              }
            }
            var A = d.return;
            try {
              Dg(d);
            } catch (_e) {
              uo(d, A, _e);
            }
            break;
          case 5:
            var X = d.return;
            try {
              Dg(d);
            } catch (_e) {
              uo(d, X, _e);
            }
        }
      } catch (_e) {
        uo(d, d.return, _e);
      }
      if (d === u) {
        Vt = null;
        break;
      }
      var ve = d.sibling;
      if (ve !== null) {
        ve.return = d.return, Vt = ve;
        break;
      }
      Vt = d.return;
    }
  }
  var Mh = Math.ceil, kp = I.ReactCurrentDispatcher, Ng = I.ReactCurrentOwner, fa = I.ReactCurrentBatchConfig, Mn = 0, ro = null, lo = null, Uo = 0, ci = 0, qd = Sn(0), $o = 0, Dp = null, Cl = 0, Nh = 0, Gd = 0, Dc = null, ba = null, Ig = 0, Kd = 1 / 0, Tl = null, Ih = !1, $c = null, Ns = null, Eu = !1, Cu = null, Ah = 0, Xd = 0, jh = null, Mc = -1, Nc = 0;
  function pa() {
    return Mn & 6 ? _n() : Mc !== -1 ? Mc : Mc = _n();
  }
  function xo(u) {
    return u.mode & 1 ? Mn & 2 && Uo !== 0 ? Uo & -Uo : oh.transition !== null ? (Nc === 0 && (Nc = yd()), Nc) : (u = tr, u !== 0 || (u = window.event, u = u === void 0 ? 16 : Jf(u.type)), u) : 1;
  }
  function ma(u, d, y, S) {
    if (50 < Xd)
      throw Xd = 0, jh = null, Error(n(185));
    ul(u, y, S), (!(Mn & 2) || u !== ro) && (u === ro && (!(Mn & 2) && (Nh |= y), $o === 4 && Ai(u, Uo)), ha(u, S), y === 1 && Mn === 0 && !(d.mode & 1) && (Kd = _n() + 500, Fo && Fa()));
  }
  function ha(u, d) {
    var y = u.callbackNode;
    eu(u, d);
    var S = ya(u, u === ro ? Uo : 0);
    if (S === 0)
      y !== null && er(y), u.callbackNode = null, u.callbackPriority = 0;
    else if (d = S & -S, u.callbackPriority !== d) {
      if (y != null && er(y), d === 1)
        u.tag === 0 ? sg(Cx.bind(null, u)) : ig(Cx.bind(null, u)), rg(function() {
          !(Mn & 6) && Fa();
        }), y = null;
      else {
        switch (bd(S)) {
          case 1:
            y = $a;
            break;
          case 4:
            y = On;
            break;
          case 16:
            y = Si;
            break;
          case 536870912:
            y = Zl;
            break;
          default:
            y = Si;
        }
        y = Vg(y, Qd.bind(null, u));
      }
      u.callbackPriority = d, u.callbackNode = y;
    }
  }
  function Qd(u, d) {
    if (Mc = -1, Nc = 0, Mn & 6)
      throw Error(n(327));
    var y = u.callbackNode;
    if (Jd() && u.callbackNode !== y)
      return null;
    var S = ya(u, u === ro ? Uo : 0);
    if (S === 0)
      return null;
    if (S & 30 || S & u.expiredLanes || d)
      d = Fh(u, S);
    else {
      d = S;
      var k = Mn;
      Mn |= 2;
      var A = Lh();
      (ro !== u || Uo !== d) && (Tl = null, Kd = _n() + 500, Ic(u, d));
      do
        try {
          tO();
          break;
        } catch (ve) {
          Tx(u, ve);
        }
      while (1);
      pg(), kp.current = A, Mn = k, lo !== null ? d = 0 : (ro = null, Uo = 0, d = $o);
    }
    if (d !== 0) {
      if (d === 2 && (k = tu(u), k !== 0 && (S = k, d = Ag(u, k))), d === 1)
        throw y = Dp, Ic(u, 0), Ai(u, S), ha(u, _n()), y;
      if (d === 6)
        Ai(u, S);
      else {
        if (k = u.current.alternate, !(S & 30) && !jg(k) && (d = Fh(u, S), d === 2 && (A = tu(u), A !== 0 && (S = A, d = Ag(u, A))), d === 1))
          throw y = Dp, Ic(u, 0), Ai(u, S), ha(u, _n()), y;
        switch (u.finishedWork = k, u.finishedLanes = S, d) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            Ac(u, ba, Tl);
            break;
          case 3:
            if (Ai(u, S), (S & 130023424) === S && (d = Ig + 500 - _n(), 10 < d)) {
              if (ya(u, 0) !== 0)
                break;
              if (k = u.suspendedLanes, (k & S) !== S) {
                pa(), u.pingedLanes |= u.suspendedLanes & k;
                break;
              }
              u.timeoutHandle = vc(Ac.bind(null, u, ba, Tl), d);
              break;
            }
            Ac(u, ba, Tl);
            break;
          case 4:
            if (Ai(u, S), (S & 4194240) === S)
              break;
            for (d = u.eventTimes, k = -1; 0 < S; ) {
              var X = 31 - Ur(S);
              A = 1 << X, X = d[X], X > k && (k = X), S &= ~A;
            }
            if (S = k, S = _n() - S, S = (120 > S ? 120 : 480 > S ? 480 : 1080 > S ? 1080 : 1920 > S ? 1920 : 3e3 > S ? 3e3 : 4320 > S ? 4320 : 1960 * Mh(S / 1960)) - S, 10 < S) {
              u.timeoutHandle = vc(Ac.bind(null, u, ba, Tl), S);
              break;
            }
            Ac(u, ba, Tl);
            break;
          case 5:
            Ac(u, ba, Tl);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return ha(u, _n()), u.callbackNode === y ? Qd.bind(null, u) : null;
  }
  function Ag(u, d) {
    var y = Dc;
    return u.current.memoizedState.isDehydrated && (Ic(u, d).flags |= 256), u = Fh(u, d), u !== 2 && (d = ba, ba = y, d !== null && $p(d)), u;
  }
  function $p(u) {
    ba === null ? ba = u : ba.push.apply(ba, u);
  }
  function jg(u) {
    for (var d = u; ; ) {
      if (d.flags & 16384) {
        var y = d.updateQueue;
        if (y !== null && (y = y.stores, y !== null))
          for (var S = 0; S < y.length; S++) {
            var k = y[S], A = k.getSnapshot;
            k = k.value;
            try {
              if (!_i(A(), k))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (y = d.child, d.subtreeFlags & 16384 && y !== null)
        y.return = d, d = y;
      else {
        if (d === u)
          break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === u)
            return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    return !0;
  }
  function Ai(u, d) {
    for (d &= ~Gd, d &= ~Nh, u.suspendedLanes |= d, u.pingedLanes &= ~d, u = u.expirationTimes; 0 < d; ) {
      var y = 31 - Ur(d), S = 1 << y;
      u[y] = -1, d &= ~S;
    }
  }
  function Cx(u) {
    if (Mn & 6)
      throw Error(n(327));
    Jd();
    var d = ya(u, 0);
    if (!(d & 1))
      return ha(u, _n()), null;
    var y = Fh(u, d);
    if (u.tag !== 0 && y === 2) {
      var S = tu(u);
      S !== 0 && (d = S, y = Ag(u, S));
    }
    if (y === 1)
      throw y = Dp, Ic(u, 0), Ai(u, d), ha(u, _n()), y;
    if (y === 6)
      throw Error(n(345));
    return u.finishedWork = u.current.alternate, u.finishedLanes = d, Ac(u, ba, Tl), ha(u, _n()), null;
  }
  function Zd(u, d) {
    var y = Mn;
    Mn |= 1;
    try {
      return u(d);
    } finally {
      Mn = y, Mn === 0 && (Kd = _n() + 500, Fo && Fa());
    }
  }
  function Tu(u) {
    Cu !== null && Cu.tag === 0 && !(Mn & 6) && Jd();
    var d = Mn;
    Mn |= 1;
    var y = fa.transition, S = tr;
    try {
      if (fa.transition = null, tr = 1, u)
        return u();
    } finally {
      tr = S, fa.transition = y, Mn = d, !(Mn & 6) && Fa();
    }
  }
  function Lg() {
    ci = qd.current, sr(qd);
  }
  function Ic(u, d) {
    u.finishedWork = null, u.finishedLanes = 0;
    var y = u.timeoutHandle;
    if (y !== -1 && (u.timeoutHandle = -1, Zw(y)), lo !== null)
      for (y = lo.return; y !== null; ) {
        var S = y;
        switch (ug(S), S.tag) {
          case 1:
            S = S.type.childContextTypes, S != null && Ri();
            break;
          case 3:
            bu(), sr(so), sr(pn), ch();
            break;
          case 5:
            kn(S);
            break;
          case 4:
            bu();
            break;
          case 13:
            sr(ln);
            break;
          case 19:
            sr(ln);
            break;
          case 10:
            hu(S.type._context);
            break;
          case 22:
          case 23:
            Lg();
        }
        y = y.return;
      }
    if (ro = u, lo = u = _u(u.current, null), Uo = ci = d, $o = 0, Dp = null, Gd = Nh = Cl = 0, ba = Dc = null, qo !== null) {
      for (d = 0; d < qo.length; d++)
        if (y = qo[d], S = y.interleaved, S !== null) {
          y.interleaved = null;
          var k = S.next, A = y.pending;
          if (A !== null) {
            var X = A.next;
            A.next = k, S.next = X;
          }
          y.pending = S;
        }
      qo = null;
    }
    return u;
  }
  function Tx(u, d) {
    do {
      var y = lo;
      try {
        if (pg(), dh.current = Oh, un) {
          for (var S = Wr.memoizedState; S !== null; ) {
            var k = S.queue;
            k !== null && (k.pending = null), S = S.next;
          }
          un = !1;
        }
        if (xc = 0, Fn = tt = Wr = null, Ds = !1, ui = 0, Ng.current = null, y === null || y.return === null) {
          $o = 1, Dp = d, lo = null;
          break;
        }
        e: {
          var A = u, X = y.return, ve = y, _e = d;
          if (d = Uo, ve.flags |= 32768, _e !== null && typeof _e == "object" && typeof _e.then == "function") {
            var Ye = _e, ut = ve, ft = ut.tag;
            if (!(ut.mode & 1) && (ft === 0 || ft === 11 || ft === 15)) {
              var lt = ut.alternate;
              lt ? (ut.updateQueue = lt.updateQueue, ut.memoizedState = lt.memoizedState, ut.lanes = lt.lanes) : (ut.updateQueue = null, ut.memoizedState = null);
            }
            var $t = Sg(X);
            if ($t !== null) {
              $t.flags &= -257, Eg($t, X, ve, A, d), $t.mode & 1 && px(A, Ye, d), d = $t, _e = Ye;
              var Yt = d.updateQueue;
              if (Yt === null) {
                var Zt = /* @__PURE__ */ new Set();
                Zt.add(_e), d.updateQueue = Zt;
              } else
                Yt.add(_e);
              break e;
            } else {
              if (!(d & 1)) {
                px(A, Ye, d), Fg();
                break e;
              }
              _e = Error(n(426));
            }
          } else if (Hr && ve.mode & 1) {
            var po = Sg(X);
            if (po !== null) {
              !(po.flags & 65536) && (po.flags |= 256), Eg(po, X, ve, A, d), dg(zd(_e, ve));
              break e;
            }
          }
          A = _e = zd(_e, ve), $o !== 4 && ($o = 2), Dc === null ? Dc = [A] : Dc.push(A), A = X;
          do {
            switch (A.tag) {
              case 3:
                A.flags |= 65536, d &= -d, A.lanes |= d;
                var Le = fx(A, _e, d);
                vg(A, Le);
                break e;
              case 1:
                ve = _e;
                var ke = A.type, Ue = A.stateNode;
                if (!(A.flags & 128) && (typeof ke.getDerivedStateFromError == "function" || Ue !== null && typeof Ue.componentDidCatch == "function" && (Ns === null || !Ns.has(Ue)))) {
                  A.flags |= 65536, d &= -d, A.lanes |= d;
                  var gt = Ep(A, ve, d);
                  vg(A, gt);
                  break e;
                }
            }
            A = A.return;
          } while (A !== null);
        }
        zg(y);
      } catch (Jt) {
        d = Jt, lo === y && y !== null && (lo = y = y.return);
        continue;
      }
      break;
    } while (1);
  }
  function Lh() {
    var u = kp.current;
    return kp.current = Oh, u === null ? Oh : u;
  }
  function Fg() {
    ($o === 0 || $o === 3 || $o === 2) && ($o = 4), ro === null || !(Cl & 268435455) && !(Nh & 268435455) || Ai(ro, Uo);
  }
  function Fh(u, d) {
    var y = Mn;
    Mn |= 2;
    var S = Lh();
    (ro !== u || Uo !== d) && (Tl = null, Ic(u, d));
    do
      try {
        eO();
        break;
      } catch (k) {
        Tx(u, k);
      }
    while (1);
    if (pg(), Mn = y, kp.current = S, lo !== null)
      throw Error(n(261));
    return ro = null, Uo = 0, $o;
  }
  function eO() {
    for (; lo !== null; )
      _x(lo);
  }
  function tO() {
    for (; lo !== null && !In(); )
      _x(lo);
  }
  function _x(u) {
    var d = Px(u.alternate, u, ci);
    u.memoizedProps = u.pendingProps, d === null ? zg(u) : lo = d, Ng.current = null;
  }
  function zg(u) {
    var d = u;
    do {
      var y = d.alternate;
      if (u = d.return, d.flags & 32768) {
        if (y = kg(y, d), y !== null) {
          y.flags &= 32767, lo = y;
          return;
        }
        if (u !== null)
          u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null;
        else {
          $o = 6, lo = null;
          return;
        }
      } else if (y = J_(y, d, ci), y !== null) {
        lo = y;
        return;
      }
      if (d = d.sibling, d !== null) {
        lo = d;
        return;
      }
      lo = d = u;
    } while (d !== null);
    $o === 0 && ($o = 5);
  }
  function Ac(u, d, y) {
    var S = tr, k = fa.transition;
    try {
      fa.transition = null, tr = 1, nO(u, d, y, S);
    } finally {
      fa.transition = k, tr = S;
    }
    return null;
  }
  function nO(u, d, y, S) {
    do
      Jd();
    while (Cu !== null);
    if (Mn & 6)
      throw Error(n(327));
    y = u.finishedWork;
    var k = u.finishedLanes;
    if (y === null)
      return null;
    if (u.finishedWork = null, u.finishedLanes = 0, y === u.current)
      throw Error(n(177));
    u.callbackNode = null, u.callbackPriority = 0;
    var A = y.lanes | y.childLanes;
    if (Ay(u, A), u === ro && (lo = ro = null, Uo = 0), !(y.subtreeFlags & 2064) && !(y.flags & 2064) || Eu || (Eu = !0, Vg(Si, function() {
      return Jd(), null;
    })), A = (y.flags & 15990) !== 0, y.subtreeFlags & 15990 || A) {
      A = fa.transition, fa.transition = null;
      var X = tr;
      tr = 1;
      var ve = Mn;
      Mn |= 4, Ng.current = null, gx(u, y), wx(y, u), qm(hc), Ti = !!tg, hc = tg = null, u.current = y, xx(y), An(), Mn = ve, tr = X, fa.transition = A;
    } else
      u.current = y;
    if (Eu && (Eu = !1, Cu = u, Ah = k), A = u.pendingLanes, A === 0 && (Ns = null), Kn(y.stateNode), ha(u, _n()), d !== null)
      for (S = u.onRecoverableError, y = 0; y < d.length; y++)
        k = d[y], S(k.value, { componentStack: k.stack, digest: k.digest });
    if (Ih)
      throw Ih = !1, u = $c, $c = null, u;
    return Ah & 1 && u.tag !== 0 && Jd(), A = u.pendingLanes, A & 1 ? u === jh ? Xd++ : (Xd = 0, jh = u) : Xd = 0, Fa(), null;
  }
  function Jd() {
    if (Cu !== null) {
      var u = bd(Ah), d = fa.transition, y = tr;
      try {
        if (fa.transition = null, tr = 16 > u ? 16 : u, Cu === null)
          var S = !1;
        else {
          if (u = Cu, Cu = null, Ah = 0, Mn & 6)
            throw Error(n(331));
          var k = Mn;
          for (Mn |= 4, Vt = u.current; Vt !== null; ) {
            var A = Vt, X = A.child;
            if (Vt.flags & 16) {
              var ve = A.deletions;
              if (ve !== null) {
                for (var _e = 0; _e < ve.length; _e++) {
                  var Ye = ve[_e];
                  for (Vt = Ye; Vt !== null; ) {
                    var ut = Vt;
                    switch (ut.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pp(8, ut, A);
                    }
                    var ft = ut.child;
                    if (ft !== null)
                      ft.return = ut, Vt = ft;
                    else
                      for (; Vt !== null; ) {
                        ut = Vt;
                        var lt = ut.sibling, $t = ut.return;
                        if ($g(ut), ut === Ye) {
                          Vt = null;
                          break;
                        }
                        if (lt !== null) {
                          lt.return = $t, Vt = lt;
                          break;
                        }
                        Vt = $t;
                      }
                  }
                }
                var Yt = A.alternate;
                if (Yt !== null) {
                  var Zt = Yt.child;
                  if (Zt !== null) {
                    Yt.child = null;
                    do {
                      var po = Zt.sibling;
                      Zt.sibling = null, Zt = po;
                    } while (Zt !== null);
                  }
                }
                Vt = A;
              }
            }
            if (A.subtreeFlags & 2064 && X !== null)
              X.return = A, Vt = X;
            else
              e:
                for (; Vt !== null; ) {
                  if (A = Vt, A.flags & 2048)
                    switch (A.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pp(9, A, A.return);
                    }
                  var Le = A.sibling;
                  if (Le !== null) {
                    Le.return = A.return, Vt = Le;
                    break e;
                  }
                  Vt = A.return;
                }
          }
          var ke = u.current;
          for (Vt = ke; Vt !== null; ) {
            X = Vt;
            var Ue = X.child;
            if (X.subtreeFlags & 2064 && Ue !== null)
              Ue.return = X, Vt = Ue;
            else
              e:
                for (X = ke; Vt !== null; ) {
                  if (ve = Vt, ve.flags & 2048)
                    try {
                      switch (ve.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Rp(9, ve);
                      }
                    } catch (Jt) {
                      uo(ve, ve.return, Jt);
                    }
                  if (ve === X) {
                    Vt = null;
                    break e;
                  }
                  var gt = ve.sibling;
                  if (gt !== null) {
                    gt.return = ve.return, Vt = gt;
                    break e;
                  }
                  Vt = ve.return;
                }
          }
          if (Mn = k, Fa(), zt && typeof zt.onPostCommitFiberRoot == "function")
            try {
              zt.onPostCommitFiberRoot(ri, u);
            } catch {
            }
          S = !0;
        }
        return S;
      } finally {
        tr = y, fa.transition = d;
      }
    }
    return !1;
  }
  function Ox(u, d, y) {
    d = zd(y, d), d = fx(u, d, 1), u = yu(u, d, 1), d = pa(), u !== null && (ul(u, 1, d), ha(u, d));
  }
  function uo(u, d, y) {
    if (u.tag === 3)
      Ox(u, u, y);
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          Ox(d, u, y);
          break;
        } else if (d.tag === 1) {
          var S = d.stateNode;
          if (typeof d.type.getDerivedStateFromError == "function" || typeof S.componentDidCatch == "function" && (Ns === null || !Ns.has(S))) {
            u = zd(y, u), u = Ep(d, u, 1), d = yu(d, u, 1), u = pa(), d !== null && (ul(d, 1, u), ha(d, u));
            break;
          }
        }
        d = d.return;
      }
  }
  function rO(u, d, y) {
    var S = u.pingCache;
    S !== null && S.delete(d), d = pa(), u.pingedLanes |= u.suspendedLanes & y, ro === u && (Uo & y) === y && ($o === 4 || $o === 3 && (Uo & 130023424) === Uo && 500 > _n() - Ig ? Ic(u, 0) : Gd |= y), ha(u, d);
  }
  function zh(u, d) {
    d === 0 && (u.mode & 1 ? (d = la, la <<= 1, !(la & 130023424) && (la = 4194304)) : d = 1);
    var y = pa();
    u = bl(u, d), u !== null && (ul(u, d, y), ha(u, y));
  }
  function oO(u) {
    var d = u.memoizedState, y = 0;
    d !== null && (y = d.retryLane), zh(u, y);
  }
  function aO(u, d) {
    var y = 0;
    switch (u.tag) {
      case 13:
        var S = u.stateNode, k = u.memoizedState;
        k !== null && (y = k.retryLane);
        break;
      case 19:
        S = u.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    S !== null && S.delete(d), zh(u, y);
  }
  var Px;
  Px = function(u, d, y) {
    if (u !== null)
      if (u.memoizedProps !== d.pendingProps || so.current)
        wo = !0;
      else {
        if (!(u.lanes & y) && !(d.flags & 128))
          return wo = !1, Sl(u, d, y);
        wo = !!(u.flags & 131072);
      }
    else
      wo = !1, Hr && d.flags & 1048576 && lg(d, Md, d.index);
    switch (d.lanes = 0, d.tag) {
      case 2:
        var S = d.type;
        ca(u, d), u = d.pendingProps;
        var k = Pi(d, pn.current);
        Et(d, y), k = wu(null, d, S, u, k, y);
        var A = Cc();
        return d.flags |= 1, typeof k == "object" && k !== null && typeof k.render == "function" && k.$$typeof === void 0 ? (d.tag = 1, d.memoizedState = null, d.updateQueue = null, Xr(S) ? (A = !0, Jm(d)) : A = !1, d.memoizedState = k.state !== null && k.state !== void 0 ? k.state : null, hg(d), k.updater = sh, d.stateNode = k, k._reactInternals = d, lh(d, S, u, y), d = mx(null, d, S, !0, A, y)) : (d.tag = 0, Hr && A && eh(d), Ro(null, d, k, y), d = d.child), d;
      case 16:
        S = d.elementType;
        e: {
          switch (ca(u, d), u = d.pendingProps, k = S._init, S = k(S._payload), d.type = S, k = d.tag = sO(S), u = li(S, u), k) {
            case 0:
              d = Vd(null, d, S, u, y);
              break e;
            case 1:
              d = Cg(null, d, S, u, y);
              break e;
            case 11:
              d = Su(null, d, S, u, y);
              break e;
            case 14:
              d = Rh(null, d, S, li(S.type, u), y);
              break e;
          }
          throw Error(n(
            306,
            S,
            ""
          ));
        }
        return d;
      case 0:
        return S = d.type, k = d.pendingProps, k = d.elementType === S ? k : li(S, k), Vd(u, d, S, k, y);
      case 1:
        return S = d.type, k = d.pendingProps, k = d.elementType === S ? k : li(S, k), Cg(u, d, S, k, y);
      case 3:
        e: {
          if (hx(d), u === null)
            throw Error(n(387));
          S = d.pendingProps, A = d.memoizedState, k = A.element, Po(u, d), gu(d, S, null, y);
          var X = d.memoizedState;
          if (S = X.element, A.isDehydrated)
            if (A = { element: S, isDehydrated: !1, cache: X.cache, pendingSuspenseBoundaries: X.pendingSuspenseBoundaries, transitions: X.transitions }, d.updateQueue.baseState = A, d.memoizedState = A, d.flags & 256) {
              k = zd(Error(n(423)), d), d = kh(u, d, S, y, k);
              break e;
            } else if (S !== k) {
              k = zd(Error(n(424)), d), d = kh(u, d, S, y, k);
              break e;
            } else
              for (Ua = us(d.stateNode.containerInfo.firstChild), si = d, Hr = !0, Di = null, y = cx(d, null, S, y), d.child = y; y; )
                y.flags = y.flags & -3 | 4096, y = y.sibling;
          else {
            if (to(), S === k) {
              d = Go(u, d, y);
              break e;
            }
            Ro(u, d, S, y);
          }
          d = d.child;
        }
        return d;
      case 5:
        return an(d), u === null && nh(d), S = d.type, k = d.pendingProps, A = u !== null ? u.memoizedProps : null, X = k.children, dp(S, k) ? X = null : A !== null && dp(S, A) && (d.flags |= 32), En(u, d), Ro(u, d, X, y), d.child;
      case 6:
        return u === null && nh(d), null;
      case 13:
        return _g(u, d, y);
      case 4:
        return gg(d, d.stateNode.containerInfo), S = d.pendingProps, u === null ? d.child = Id(d, null, S, y) : Ro(u, d, S, y), d.child;
      case 11:
        return S = d.type, k = d.pendingProps, k = d.elementType === S ? k : li(S, k), Su(u, d, S, k, y);
      case 7:
        return Ro(u, d, d.pendingProps, y), d.child;
      case 8:
        return Ro(u, d, d.pendingProps.children, y), d.child;
      case 12:
        return Ro(u, d, d.pendingProps.children, y), d.child;
      case 10:
        e: {
          if (S = d.type._context, k = d.pendingProps, A = d.memoizedProps, X = k.value, pr(ks, S._currentValue), S._currentValue = X, A !== null)
            if (_i(A.value, X)) {
              if (A.children === k.children && !so.current) {
                d = Go(u, d, y);
                break e;
              }
            } else
              for (A = d.child, A !== null && (A.return = d); A !== null; ) {
                var ve = A.dependencies;
                if (ve !== null) {
                  X = A.child;
                  for (var _e = ve.firstContext; _e !== null; ) {
                    if (_e.context === S) {
                      if (A.tag === 1) {
                        _e = wl(-1, y & -y), _e.tag = 2;
                        var Ye = A.updateQueue;
                        if (Ye !== null) {
                          Ye = Ye.shared;
                          var ut = Ye.pending;
                          ut === null ? _e.next = _e : (_e.next = ut.next, ut.next = _e), Ye.pending = _e;
                        }
                      }
                      A.lanes |= y, _e = A.alternate, _e !== null && (_e.lanes |= y), zo(
                        A.return,
                        y,
                        d
                      ), ve.lanes |= y;
                      break;
                    }
                    _e = _e.next;
                  }
                } else if (A.tag === 10)
                  X = A.type === d.type ? null : A.child;
                else if (A.tag === 18) {
                  if (X = A.return, X === null)
                    throw Error(n(341));
                  X.lanes |= y, ve = X.alternate, ve !== null && (ve.lanes |= y), zo(X, y, d), X = A.sibling;
                } else
                  X = A.child;
                if (X !== null)
                  X.return = A;
                else
                  for (X = A; X !== null; ) {
                    if (X === d) {
                      X = null;
                      break;
                    }
                    if (A = X.sibling, A !== null) {
                      A.return = X.return, X = A;
                      break;
                    }
                    X = X.return;
                  }
                A = X;
              }
          Ro(u, d, k.children, y), d = d.child;
        }
        return d;
      case 9:
        return k = d.type, S = d.pendingProps.children, Et(d, y), k = fo(k), S = S(k), d.flags |= 1, Ro(u, d, S, y), d.child;
      case 14:
        return S = d.type, k = li(S, d.pendingProps), k = li(S.type, k), Rh(u, d, S, k, y);
      case 15:
        return Wa(u, d, d.type, d.pendingProps, y);
      case 17:
        return S = d.type, k = d.pendingProps, k = d.elementType === S ? k : li(S, k), ca(u, d), d.tag = 1, Xr(S) ? (u = !0, Jm(d)) : u = !1, Et(d, y), ix(d, S, k), lh(d, S, k, y), mx(null, d, S, !0, u, y);
      case 19:
        return Rg(u, d, y);
      case 22:
        return Pc(u, d, y);
    }
    throw Error(n(156, d.tag));
  };
  function Vg(u, d) {
    return fn(u, d);
  }
  function iO(u, d, y, S) {
    this.tag = u, this.key = y, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = S, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ji(u, d, y, S) {
    return new iO(u, d, y, S);
  }
  function Ug(u) {
    return u = u.prototype, !(!u || !u.isReactComponent);
  }
  function sO(u) {
    if (typeof u == "function")
      return Ug(u) ? 1 : 0;
    if (u != null) {
      if (u = u.$$typeof, u === re)
        return 11;
      if (u === Q)
        return 14;
    }
    return 2;
  }
  function _u(u, d) {
    var y = u.alternate;
    return y === null ? (y = ji(u.tag, d, u.key, u.mode), y.elementType = u.elementType, y.type = u.type, y.stateNode = u.stateNode, y.alternate = u, u.alternate = y) : (y.pendingProps = d, y.type = u.type, y.flags = 0, y.subtreeFlags = 0, y.deletions = null), y.flags = u.flags & 14680064, y.childLanes = u.childLanes, y.lanes = u.lanes, y.child = u.child, y.memoizedProps = u.memoizedProps, y.memoizedState = u.memoizedState, y.updateQueue = u.updateQueue, d = u.dependencies, y.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, y.sibling = u.sibling, y.index = u.index, y.ref = u.ref, y;
  }
  function Vh(u, d, y, S, k, A) {
    var X = 2;
    if (S = u, typeof u == "function")
      Ug(u) && (X = 1);
    else if (typeof u == "string")
      X = 5;
    else
      e:
        switch (u) {
          case U:
            return jc(y.children, k, A, d);
          case q:
            X = 8, k |= 8;
            break;
          case J:
            return u = ji(12, y, d, k | 2), u.elementType = J, u.lanes = A, u;
          case Y:
            return u = ji(13, y, d, k), u.elementType = Y, u.lanes = A, u;
          case K:
            return u = ji(19, y, d, k), u.elementType = K, u.lanes = A, u;
          case ne:
            return Mp(y, k, A, d);
          default:
            if (typeof u == "object" && u !== null)
              switch (u.$$typeof) {
                case H:
                  X = 10;
                  break e;
                case Z:
                  X = 9;
                  break e;
                case re:
                  X = 11;
                  break e;
                case Q:
                  X = 14;
                  break e;
                case te:
                  X = 16, S = null;
                  break e;
              }
            throw Error(n(130, u == null ? u : typeof u, ""));
        }
    return d = ji(X, y, d, k), d.elementType = u, d.type = S, d.lanes = A, d;
  }
  function jc(u, d, y, S) {
    return u = ji(7, u, S, d), u.lanes = y, u;
  }
  function Mp(u, d, y, S) {
    return u = ji(22, u, S, d), u.elementType = ne, u.lanes = y, u.stateNode = { isHidden: !1 }, u;
  }
  function Np(u, d, y) {
    return u = ji(6, u, null, d), u.lanes = y, u;
  }
  function Lc(u, d, y) {
    return d = ji(4, u.children !== null ? u.children : [], u.key, d), d.lanes = y, d.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, d;
  }
  function lO(u, d, y, S, k) {
    this.tag = d, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gd(0), this.expirationTimes = gd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gd(0), this.identifierPrefix = S, this.onRecoverableError = k, this.mutableSourceEagerHydrationData = null;
  }
  function Uh(u, d, y, S, k, A, X, ve, _e) {
    return u = new lO(u, d, y, ve, _e), d === 1 ? (d = 1, A === !0 && (d |= 8)) : d = 0, A = ji(3, null, null, d), u.current = A, A.stateNode = u, A.memoizedState = { element: S, isDehydrated: y, cache: null, transitions: null, pendingSuspenseBoundaries: null }, hg(A), u;
  }
  function Rx(u, d, y) {
    var S = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: j, key: S == null ? null : "" + S, children: u, containerInfo: d, implementation: y };
  }
  function Bg(u) {
    if (!u)
      return Rs;
    u = u._reactInternals;
    e: {
      if (it(u) !== u || u.tag !== 1)
        throw Error(n(170));
      var d = u;
      do {
        switch (d.tag) {
          case 3:
            d = d.stateNode.context;
            break e;
          case 1:
            if (Xr(d.type)) {
              d = d.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        d = d.return;
      } while (d !== null);
      throw Error(n(171));
    }
    if (u.tag === 1) {
      var y = u.type;
      if (Xr(y))
        return mp(u, y, d);
    }
    return d;
  }
  function kx(u, d, y, S, k, A, X, ve, _e) {
    return u = Uh(y, S, !0, u, k, A, X, ve, _e), u.context = Bg(null), y = u.current, S = pa(), k = xo(y), A = wl(S, k), A.callback = d ?? null, yu(y, A, k), u.current.lanes = k, ul(u, k, S), ha(u, S), u;
  }
  function Ip(u, d, y, S) {
    var k = d.current, A = pa(), X = xo(k);
    return y = Bg(y), d.context === null ? d.context = y : d.pendingContext = y, d = wl(A, X), d.payload = { element: u }, S = S === void 0 ? null : S, S !== null && (d.callback = S), u = yu(k, d, X), u !== null && (ma(u, k, X, A), ih(u, k, X)), X;
  }
  function Bh(u) {
    if (u = u.current, !u.child)
      return null;
    switch (u.child.tag) {
      case 5:
        return u.child.stateNode;
      default:
        return u.child.stateNode;
    }
  }
  function Dx(u, d) {
    if (u = u.memoizedState, u !== null && u.dehydrated !== null) {
      var y = u.retryLane;
      u.retryLane = y !== 0 && y < d ? y : d;
    }
  }
  function Hg(u, d) {
    Dx(u, d), (u = u.alternate) && Dx(u, d);
  }
  function $x() {
    return null;
  }
  var Wg = typeof reportError == "function" ? reportError : function(u) {
    console.error(u);
  };
  function Hh(u) {
    this._internalRoot = u;
  }
  _l.prototype.render = Hh.prototype.render = function(u) {
    var d = this._internalRoot;
    if (d === null)
      throw Error(n(409));
    Ip(u, d, null, null);
  }, _l.prototype.unmount = Hh.prototype.unmount = function() {
    var u = this._internalRoot;
    if (u !== null) {
      this._internalRoot = null;
      var d = u.containerInfo;
      Tu(function() {
        Ip(null, u, null, null);
      }), d[yl] = null;
    }
  };
  function _l(u) {
    this._internalRoot = u;
  }
  _l.prototype.unstable_scheduleHydration = function(u) {
    if (u) {
      var d = xd();
      u = { blockedOn: null, target: u, priority: d };
      for (var y = 0; y < fr.length && d !== 0 && d < fr[y].priority; y++)
        ;
      fr.splice(y, 0, u), y === 0 && zm(u);
    }
  };
  function Yg(u) {
    return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11);
  }
  function Wh(u) {
    return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11 && (u.nodeType !== 8 || u.nodeValue !== " react-mount-point-unstable "));
  }
  function Mx() {
  }
  function uO(u, d, y, S, k) {
    if (k) {
      if (typeof S == "function") {
        var A = S;
        S = function() {
          var Ye = Bh(X);
          A.call(Ye);
        };
      }
      var X = kx(d, S, u, 0, null, !1, !1, "", Mx);
      return u._reactRootContainer = X, u[yl] = X.current, Dd(u.nodeType === 8 ? u.parentNode : u), Tu(), X;
    }
    for (; k = u.lastChild; )
      u.removeChild(k);
    if (typeof S == "function") {
      var ve = S;
      S = function() {
        var Ye = Bh(_e);
        ve.call(Ye);
      };
    }
    var _e = Uh(u, 0, !1, null, null, !1, !1, "", Mx);
    return u._reactRootContainer = _e, u[yl] = _e.current, Dd(u.nodeType === 8 ? u.parentNode : u), Tu(function() {
      Ip(d, _e, y, S);
    }), _e;
  }
  function Yh(u, d, y, S, k) {
    var A = y._reactRootContainer;
    if (A) {
      var X = A;
      if (typeof k == "function") {
        var ve = k;
        k = function() {
          var _e = Bh(X);
          ve.call(_e);
        };
      }
      Ip(d, X, u, k);
    } else
      X = uO(y, d, u, k, S);
    return Bh(X);
  }
  lc = function(u) {
    switch (u.tag) {
      case 3:
        var d = u.stateNode;
        if (d.current.memoizedState.isDehydrated) {
          var y = os(d.pendingLanes);
          y !== 0 && (_s(d, y | 1), ha(d, _n()), !(Mn & 6) && (Kd = _n() + 500, Fa()));
        }
        break;
      case 13:
        Tu(function() {
          var S = bl(u, 1);
          if (S !== null) {
            var k = pa();
            ma(S, u, 1, k);
          }
        }), Hg(u, 1);
    }
  }, wd = function(u) {
    if (u.tag === 13) {
      var d = bl(u, 134217728);
      if (d !== null) {
        var y = pa();
        ma(d, u, 134217728, y);
      }
      Hg(u, 134217728);
    }
  }, qn = function(u) {
    if (u.tag === 13) {
      var d = xo(u), y = bl(u, d);
      if (y !== null) {
        var S = pa();
        ma(y, u, d, S);
      }
      Hg(u, d);
    }
  }, xd = function() {
    return tr;
  }, Sd = function(u, d) {
    var y = tr;
    try {
      return tr = u, d();
    } finally {
      tr = y;
    }
  }, Pn = function(u, d, y) {
    switch (d) {
      case "input":
        if (de(u, y), d = y.name, y.type === "radio" && d != null) {
          for (y = u; y.parentNode; )
            y = y.parentNode;
          for (y = y.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), d = 0; d < y.length; d++) {
            var S = y[d];
            if (S !== u && S.form === u.form) {
              var k = nn(S);
              if (!k)
                throw Error(n(90));
              me(S), de(S, k);
            }
          }
        }
        break;
      case "textarea":
        et(u, y);
        break;
      case "select":
        d = y.value, d != null && je(u, !!y.multiple, d, !1);
    }
  }, Kr = Zd, xr = Tu;
  var cO = { usingClientEntryPoint: !1, Events: [pp, $d, nn, ir, go, Zd] }, ef = { findFiberByHostInstance: Oi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, dO = { bundleType: ef.bundleType, version: ef.version, rendererPackageName: ef.rendererPackageName, rendererConfig: ef.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: I.ReactCurrentDispatcher, findHostInstanceByFiber: function(u) {
    return u = dt(u), u === null ? null : u.stateNode;
  }, findFiberByHostInstance: ef.findFiberByHostInstance || $x, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qh.isDisabled && qh.supportsFiber)
      try {
        ri = qh.inject(dO), zt = qh;
      } catch {
      }
  }
  return Bi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cO, Bi.createPortal = function(u, d) {
    var y = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Yg(d))
      throw Error(n(200));
    return Rx(u, d, null, y);
  }, Bi.createRoot = function(u, d) {
    if (!Yg(u))
      throw Error(n(299));
    var y = !1, S = "", k = Wg;
    return d != null && (d.unstable_strictMode === !0 && (y = !0), d.identifierPrefix !== void 0 && (S = d.identifierPrefix), d.onRecoverableError !== void 0 && (k = d.onRecoverableError)), d = Uh(u, 1, !1, null, null, y, !1, S, k), u[yl] = d.current, Dd(u.nodeType === 8 ? u.parentNode : u), new Hh(d);
  }, Bi.findDOMNode = function(u) {
    if (u == null)
      return null;
    if (u.nodeType === 1)
      return u;
    var d = u._reactInternals;
    if (d === void 0)
      throw typeof u.render == "function" ? Error(n(188)) : (u = Object.keys(u).join(","), Error(n(268, u)));
    return u = dt(d), u = u === null ? null : u.stateNode, u;
  }, Bi.flushSync = function(u) {
    return Tu(u);
  }, Bi.hydrate = function(u, d, y) {
    if (!Wh(d))
      throw Error(n(200));
    return Yh(null, u, d, !0, y);
  }, Bi.hydrateRoot = function(u, d, y) {
    if (!Yg(u))
      throw Error(n(405));
    var S = y != null && y.hydratedSources || null, k = !1, A = "", X = Wg;
    if (y != null && (y.unstable_strictMode === !0 && (k = !0), y.identifierPrefix !== void 0 && (A = y.identifierPrefix), y.onRecoverableError !== void 0 && (X = y.onRecoverableError)), d = kx(d, null, u, 1, y ?? null, k, !1, A, X), u[yl] = d.current, Dd(u), S)
      for (u = 0; u < S.length; u++)
        y = S[u], k = y._getVersion, k = k(y._source), d.mutableSourceEagerHydrationData == null ? d.mutableSourceEagerHydrationData = [y, k] : d.mutableSourceEagerHydrationData.push(
          y,
          k
        );
    return new _l(d);
  }, Bi.render = function(u, d, y) {
    if (!Wh(d))
      throw Error(n(200));
    return Yh(null, u, d, !1, y);
  }, Bi.unmountComponentAtNode = function(u) {
    if (!Wh(u))
      throw Error(n(40));
    return u._reactRootContainer ? (Tu(function() {
      Yh(null, null, u, !1, function() {
        u._reactRootContainer = null, u[yl] = null;
      });
    }), !0) : !1;
  }, Bi.unstable_batchedUpdates = Zd, Bi.unstable_renderSubtreeIntoContainer = function(u, d, y, S) {
    if (!Wh(y))
      throw Error(n(200));
    if (u == null || u._reactInternals === void 0)
      throw Error(n(38));
    return Yh(u, d, y, !1, S);
  }, Bi.version = "18.2.0-next-9e3b772b8-20220608", Bi;
}
var Hi = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xF;
function tse() {
  return xF || (xF = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = C, t = T4(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function a(o) {
      r = o;
    }
    function s(o) {
      if (!r) {
        for (var i = arguments.length, f = new Array(i > 1 ? i - 1 : 0), v = 1; v < i; v++)
          f[v - 1] = arguments[v];
        p("warn", o, f);
      }
    }
    function l(o) {
      if (!r) {
        for (var i = arguments.length, f = new Array(i > 1 ? i - 1 : 0), v = 1; v < i; v++)
          f[v - 1] = arguments[v];
        p("error", o, f);
      }
    }
    function p(o, i, f) {
      {
        var v = n.ReactDebugCurrentFrame, w = v.getStackAddendum();
        w !== "" && (i += "%s", f = f.concat([w]));
        var T = f.map(function($) {
          return String($);
        });
        T.unshift("Warning: " + i), Function.prototype.apply.call(console[o], console, T);
      }
    }
    var m = 0, h = 1, g = 2, b = 3, x = 4, E = 5, O = 6, _ = 7, P = 8, M = 9, D = 10, N = 11, I = 12, R = 13, j = 14, U = 15, q = 16, J = 17, H = 18, Z = 19, re = 21, Y = 22, K = 23, Q = 24, te = 25, ne = !0, ae = !1, se = !1, V = !1, ee = !1, he = !0, ue = !1, fe = !1, Ce = !0, Se = !0, Te = !0, pe = /* @__PURE__ */ new Set(), ye = {}, Oe = {};
    function Fe(o, i) {
      me(o, i), me(o + "Capture", i);
    }
    function me(o, i) {
      ye[o] && l("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", o), ye[o] = i;
      {
        var f = o.toLowerCase();
        Oe[f] = o, o === "onDoubleClick" && (Oe.ondblclick = o);
      }
      for (var v = 0; v < i.length; v++)
        pe.add(i[v]);
    }
    var Pe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ee = Object.prototype.hasOwnProperty;
    function Ke(o) {
      {
        var i = typeof Symbol == "function" && Symbol.toStringTag, f = i && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return f;
      }
    }
    function oe(o) {
      try {
        return de(o), !1;
      } catch {
        return !0;
      }
    }
    function de(o) {
      return "" + o;
    }
    function we(o, i) {
      if (oe(o))
        return l("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ke(o)), de(o);
    }
    function Me(o) {
      if (oe(o))
        return l("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(o)), de(o);
    }
    function Ae(o, i) {
      if (oe(o))
        return l("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ke(o)), de(o);
    }
    function je(o, i) {
      if (oe(o))
        return l("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", i, Ke(o)), de(o);
    }
    function qe(o) {
      if (oe(o))
        return l("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", Ke(o)), de(o);
    }
    function ot(o) {
      if (oe(o))
        return l("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", Ke(o)), de(o);
    }
    var et = 0, ct = 1, Qt = 2, Ht = 3, kt = 4, St = 5, cn = 6, Ne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ie = Ne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Je = new RegExp("^[" + Ne + "][" + Ie + "]*$"), pt = {}, ht = {};
    function vt(o) {
      return Ee.call(ht, o) ? !0 : Ee.call(pt, o) ? !1 : Je.test(o) ? (ht[o] = !0, !0) : (pt[o] = !0, l("Invalid attribute name: `%s`", o), !1);
    }
    function Nt(o, i, f) {
      return i !== null ? i.type === et : f ? !1 : o.length > 2 && (o[0] === "o" || o[0] === "O") && (o[1] === "n" || o[1] === "N");
    }
    function Tn(o, i, f, v) {
      if (f !== null && f.type === et)
        return !1;
      switch (typeof i) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (v)
            return !1;
          if (f !== null)
            return !f.acceptsBooleans;
          var w = o.toLowerCase().slice(0, 5);
          return w !== "data-" && w !== "aria-";
        }
        default:
          return !1;
      }
    }
    function bt(o, i, f, v) {
      if (i === null || typeof i > "u" || Tn(o, i, f, v))
        return !0;
      if (v)
        return !1;
      if (f !== null)
        switch (f.type) {
          case Ht:
            return !i;
          case kt:
            return i === !1;
          case St:
            return isNaN(i);
          case cn:
            return isNaN(i) || i < 1;
        }
      return !1;
    }
    function Pn(o) {
      return Cn.hasOwnProperty(o) ? Cn[o] : null;
    }
    function wn(o, i, f, v, w, T, $) {
      this.acceptsBooleans = i === Qt || i === Ht || i === kt, this.attributeName = v, this.attributeNamespace = w, this.mustUseProperty = f, this.propertyName = o, this.type = i, this.sanitizeURL = T, this.removeEmptyString = $;
    }
    var Cn = {}, ar = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ar.forEach(function(o) {
      Cn[o] = new wn(
        o,
        et,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
      var i = o[0], f = o[1];
      Cn[i] = new wn(
        i,
        ct,
        !1,
        // mustUseProperty
        f,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
      Cn[o] = new wn(
        o,
        Qt,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
      Cn[o] = new wn(
        o,
        Qt,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(o) {
      Cn[o] = new wn(
        o,
        Ht,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      Cn[o] = new wn(
        o,
        Ht,
        !0,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      Cn[o] = new wn(
        o,
        kt,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      Cn[o] = new wn(
        o,
        cn,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(o) {
      Cn[o] = new wn(
        o,
        St,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ir = /[\-\:]([a-z])/g, go = function(o) {
      return o[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var i = o.replace(ir, go);
      Cn[i] = new wn(
        i,
        ct,
        !1,
        // mustUseProperty
        o,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var i = o.replace(ir, go);
      Cn[i] = new wn(
        i,
        ct,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var i = o.replace(ir, go);
      Cn[i] = new wn(
        i,
        ct,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(o) {
      Cn[o] = new wn(
        o,
        ct,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Kr = "xlinkHref";
    Cn[Kr] = new wn(
      "xlinkHref",
      ct,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(o) {
      Cn[o] = new wn(
        o,
        ct,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var xr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ln = !1;
    function Dn(o) {
      !Ln && xr.test(o) && (Ln = !0, l("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(o)));
    }
    function Yn(o, i, f, v) {
      if (v.mustUseProperty) {
        var w = v.propertyName;
        return o[w];
      } else {
        we(f, i), v.sanitizeURL && Dn("" + f);
        var T = v.attributeName, $ = null;
        if (v.type === kt) {
          if (o.hasAttribute(T)) {
            var F = o.getAttribute(T);
            return F === "" ? !0 : bt(i, f, v, !1) ? F : F === "" + f ? f : F;
          }
        } else if (o.hasAttribute(T)) {
          if (bt(i, f, v, !1))
            return o.getAttribute(T);
          if (v.type === Ht)
            return f;
          $ = o.getAttribute(T);
        }
        return bt(i, f, v, !1) ? $ === null ? f : $ : $ === "" + f ? f : $;
      }
    }
    function Jr(o, i, f, v) {
      {
        if (!vt(i))
          return;
        if (!o.hasAttribute(i))
          return f === void 0 ? void 0 : null;
        var w = o.getAttribute(i);
        return we(f, i), w === "" + f ? f : w;
      }
    }
    function dr(o, i, f, v) {
      var w = Pn(i);
      if (!Nt(i, w, v)) {
        if (bt(i, f, w, v) && (f = null), v || w === null) {
          if (vt(i)) {
            var T = i;
            f === null ? o.removeAttribute(T) : (we(f, i), o.setAttribute(T, "" + f));
          }
          return;
        }
        var $ = w.mustUseProperty;
        if ($) {
          var F = w.propertyName;
          if (f === null) {
            var W = w.type;
            o[F] = W === Ht ? !1 : "";
          } else
            o[F] = f;
          return;
        }
        var ie = w.attributeName, ce = w.attributeNamespace;
        if (f === null)
          o.removeAttribute(ie);
        else {
          var De = w.type, Re;
          De === Ht || De === kt && f === !0 ? Re = "" : (we(f, ie), Re = "" + f, w.sanitizeURL && Dn(Re.toString())), ce ? o.setAttributeNS(ce, ie, Re) : o.setAttribute(ie, Re);
        }
      }
    }
    var Dr = Symbol.for("react.element"), Fr = Symbol.for("react.portal"), zr = Symbol.for("react.fragment"), Vr = Symbol.for("react.strict_mode"), be = Symbol.for("react.profiler"), at = Symbol.for("react.provider"), wt = Symbol.for("react.context"), Tt = Symbol.for("react.forward_ref"), it = Symbol.for("react.suspense"), nt = Symbol.for("react.suspense_list"), ge = Symbol.for("react.memo"), $e = Symbol.for("react.lazy"), dt = Symbol.for("react.scope"), Ft = Symbol.for("react.debug_trace_mode"), fn = Symbol.for("react.offscreen"), er = Symbol.for("react.legacy_hidden"), In = Symbol.for("react.cache"), An = Symbol.for("react.tracing_marker"), _n = Symbol.iterator, rs = "@@iterator";
    function $a(o) {
      if (o === null || typeof o != "object")
        return null;
      var i = _n && o[_n] || o[rs];
      return typeof i == "function" ? i : null;
    }
    var On = Object.assign, Si = 0, Ts, Zl, ri, zt, Kn, Ur, Ma;
    function oi() {
    }
    oi.__reactDisabledLog = !0;
    function Na() {
      {
        if (Si === 0) {
          Ts = console.log, Zl = console.info, ri = console.warn, zt = console.error, Kn = console.group, Ur = console.groupCollapsed, Ma = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: oi,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        Si++;
      }
    }
    function Ei() {
      {
        if (Si--, Si === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: On({}, o, {
              value: Ts
            }),
            info: On({}, o, {
              value: Zl
            }),
            warn: On({}, o, {
              value: ri
            }),
            error: On({}, o, {
              value: zt
            }),
            group: On({}, o, {
              value: Kn
            }),
            groupCollapsed: On({}, o, {
              value: Ur
            }),
            groupEnd: On({}, o, {
              value: Ma
            })
          });
        }
        Si < 0 && l("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var la = n.ReactCurrentDispatcher, os;
    function ya(o, i, f) {
      {
        if (os === void 0)
          try {
            throw Error();
          } catch (w) {
            var v = w.stack.trim().match(/\n( *(at )?)/);
            os = v && v[1] || "";
          }
        return `
` + os + o;
      }
    }
    var Jl = !1, eu;
    {
      var tu = typeof WeakMap == "function" ? WeakMap : Map;
      eu = new tu();
    }
    function yd(o, i) {
      if (!o || Jl)
        return "";
      {
        var f = eu.get(o);
        if (f !== void 0)
          return f;
      }
      var v;
      Jl = !0;
      var w = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var T;
      T = la.current, la.current = null, Na();
      try {
        if (i) {
          var $ = function() {
            throw Error();
          };
          if (Object.defineProperty($.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct($, []);
            } catch (We) {
              v = We;
            }
            Reflect.construct(o, [], $);
          } else {
            try {
              $.call();
            } catch (We) {
              v = We;
            }
            o.call($.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (We) {
            v = We;
          }
          o();
        }
      } catch (We) {
        if (We && v && typeof We.stack == "string") {
          for (var F = We.stack.split(`
`), W = v.stack.split(`
`), ie = F.length - 1, ce = W.length - 1; ie >= 1 && ce >= 0 && F[ie] !== W[ce]; )
            ce--;
          for (; ie >= 1 && ce >= 0; ie--, ce--)
            if (F[ie] !== W[ce]) {
              if (ie !== 1 || ce !== 1)
                do
                  if (ie--, ce--, ce < 0 || F[ie] !== W[ce]) {
                    var De = `
` + F[ie].replace(" at new ", " at ");
                    return o.displayName && De.includes("<anonymous>") && (De = De.replace("<anonymous>", o.displayName)), typeof o == "function" && eu.set(o, De), De;
                  }
                while (ie >= 1 && ce >= 0);
              break;
            }
        }
      } finally {
        Jl = !1, la.current = T, Ei(), Error.prepareStackTrace = w;
      }
      var Re = o ? o.displayName || o.name : "", Be = Re ? ya(Re) : "";
      return typeof o == "function" && eu.set(o, Be), Be;
    }
    function gd(o, i, f) {
      return yd(o, !0);
    }
    function ul(o, i, f) {
      return yd(o, !1);
    }
    function Ay(o) {
      var i = o.prototype;
      return !!(i && i.isReactComponent);
    }
    function _s(o, i, f) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return yd(o, Ay(o));
      if (typeof o == "string")
        return ya(o);
      switch (o) {
        case it:
          return ya("Suspense");
        case nt:
          return ya("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case Tt:
            return ul(o.render);
          case ge:
            return _s(o.type, i, f);
          case $e: {
            var v = o, w = v._payload, T = v._init;
            try {
              return _s(T(w), i, f);
            } catch {
            }
          }
        }
      return "";
    }
    function tr(o) {
      switch (o._debugOwner && o._debugOwner.type, o._debugSource, o.tag) {
        case E:
          return ya(o.type);
        case q:
          return ya("Lazy");
        case R:
          return ya("Suspense");
        case Z:
          return ya("SuspenseList");
        case m:
        case g:
        case U:
          return ul(o.type);
        case N:
          return ul(o.type.render);
        case h:
          return gd(o.type);
        default:
          return "";
      }
    }
    function bd(o) {
      try {
        var i = "", f = o;
        do
          i += tr(f), f = f.return;
        while (f);
        return i;
      } catch (v) {
        return `
Error generating stack: ` + v.message + `
` + v.stack;
      }
    }
    function lc(o, i, f) {
      var v = o.displayName;
      if (v)
        return v;
      var w = i.displayName || i.name || "";
      return w !== "" ? f + "(" + w + ")" : f;
    }
    function wd(o) {
      return o.displayName || "Context";
    }
    function qn(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && l("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case zr:
          return "Fragment";
        case Fr:
          return "Portal";
        case be:
          return "Profiler";
        case Vr:
          return "StrictMode";
        case it:
          return "Suspense";
        case nt:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case wt:
            var i = o;
            return wd(i) + ".Consumer";
          case at:
            var f = o;
            return wd(f._context) + ".Provider";
          case Tt:
            return lc(o, o.render, "ForwardRef");
          case ge:
            var v = o.displayName || null;
            return v !== null ? v : qn(o.type) || "Memo";
          case $e: {
            var w = o, T = w._payload, $ = w._init;
            try {
              return qn($(T));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function xd(o, i, f) {
      var v = i.displayName || i.name || "";
      return o.displayName || (v !== "" ? f + "(" + v + ")" : f);
    }
    function Sd(o) {
      return o.displayName || "Context";
    }
    function gn(o) {
      var i = o.tag, f = o.type;
      switch (i) {
        case Q:
          return "Cache";
        case M:
          var v = f;
          return Sd(v) + ".Consumer";
        case D:
          var w = f;
          return Sd(w._context) + ".Provider";
        case H:
          return "DehydratedFragment";
        case N:
          return xd(f, f.render, "ForwardRef");
        case _:
          return "Fragment";
        case E:
          return f;
        case x:
          return "Portal";
        case b:
          return "Root";
        case O:
          return "Text";
        case q:
          return qn(f);
        case P:
          return f === Vr ? "StrictMode" : "Mode";
        case Y:
          return "Offscreen";
        case I:
          return "Profiler";
        case re:
          return "Scope";
        case R:
          return "Suspense";
        case Z:
          return "SuspenseList";
        case te:
          return "TracingMarker";
        case h:
        case m:
        case J:
        case g:
        case j:
        case U:
          if (typeof f == "function")
            return f.displayName || f.name || null;
          if (typeof f == "string")
            return f;
          break;
      }
      return null;
    }
    var uc = n.ReactDebugCurrentFrame, eo = null, Ia = !1;
    function ga() {
      {
        if (eo === null)
          return null;
        var o = eo._debugOwner;
        if (o !== null && typeof o < "u")
          return gn(o);
      }
      return null;
    }
    function nu() {
      return eo === null ? "" : bd(eo);
    }
    function io() {
      uc.getCurrentStack = null, eo = null, Ia = !1;
    }
    function fr(o) {
      uc.getCurrentStack = o === null ? null : nu, eo = o, Ia = !1;
    }
    function Fm() {
      return eo;
    }
    function Aa(o) {
      Ia = o;
    }
    function jo(o) {
      return "" + o;
    }
    function Os(o) {
      switch (typeof o) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return o;
        case "object":
          return ot(o), o;
        default:
          return "";
      }
    }
    var zm = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function cl(o, i) {
      zm[i.type] || i.onChange || i.onInput || i.readOnly || i.disabled || i.value == null || l("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), i.onChange || i.readOnly || i.disabled || i.checked == null || l("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ru(o) {
      var i = o.type, f = o.nodeName;
      return f && f.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
    }
    function Vm(o) {
      return o._valueTracker;
    }
    function Ci(o) {
      o._valueTracker = null;
    }
    function ou(o) {
      var i = "";
      return o && (ru(o) ? i = o.checked ? "true" : "false" : i = o.value), i;
    }
    function au(o) {
      var i = ru(o) ? "checked" : "value", f = Object.getOwnPropertyDescriptor(o.constructor.prototype, i);
      ot(o[i]);
      var v = "" + o[i];
      if (!(o.hasOwnProperty(i) || typeof f > "u" || typeof f.get != "function" || typeof f.set != "function")) {
        var w = f.get, T = f.set;
        Object.defineProperty(o, i, {
          configurable: !0,
          get: function() {
            return w.call(this);
          },
          set: function(F) {
            ot(F), v = "" + F, T.call(this, F);
          }
        }), Object.defineProperty(o, i, {
          enumerable: f.enumerable
        });
        var $ = {
          getValue: function() {
            return v;
          },
          setValue: function(F) {
            ot(F), v = "" + F;
          },
          stopTracking: function() {
            Ci(o), delete o[i];
          }
        };
        return $;
      }
    }
    function Ti(o) {
      Vm(o) || (o._valueTracker = au(o));
    }
    function Ed(o) {
      if (!o)
        return !1;
      var i = Vm(o);
      if (!i)
        return !0;
      var f = i.getValue(), v = ou(o);
      return v !== f ? (i.setValue(v), !0) : !1;
    }
    function iu(o) {
      if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u")
        return null;
      try {
        return o.activeElement || o.body;
      } catch {
        return o.body;
      }
    }
    var su = !1, cc = !1, Cd = !1, Jf = !1;
    function as(o) {
      var i = o.type === "checkbox" || o.type === "radio";
      return i ? o.checked != null : o.value != null;
    }
    function G(o, i) {
      var f = o, v = i.checked, w = On({}, i, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: v ?? f._wrapperState.initialChecked
      });
      return w;
    }
    function xe(o, i) {
      cl("input", i), i.checked !== void 0 && i.defaultChecked !== void 0 && !cc && (l("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ga() || "A component", i.type), cc = !0), i.value !== void 0 && i.defaultValue !== void 0 && !su && (l("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", ga() || "A component", i.type), su = !0);
      var f = o, v = i.defaultValue == null ? "" : i.defaultValue;
      f._wrapperState = {
        initialChecked: i.checked != null ? i.checked : i.defaultChecked,
        initialValue: Os(i.value != null ? i.value : v),
        controlled: as(i)
      };
    }
    function He(o, i) {
      var f = o, v = i.checked;
      v != null && dr(f, "checked", v, !1);
    }
    function Xe(o, i) {
      var f = o;
      {
        var v = as(i);
        !f._wrapperState.controlled && v && !Jf && (l("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Jf = !0), f._wrapperState.controlled && !v && !Cd && (l("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Cd = !0);
      }
      He(o, i);
      var w = Os(i.value), T = i.type;
      if (w != null)
        T === "number" ? (w === 0 && f.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        f.value != w) && (f.value = jo(w)) : f.value !== jo(w) && (f.value = jo(w));
      else if (T === "submit" || T === "reset") {
        f.removeAttribute("value");
        return;
      }
      i.hasOwnProperty("value") ? on(f, i.type, w) : i.hasOwnProperty("defaultValue") && on(f, i.type, Os(i.defaultValue)), i.checked == null && i.defaultChecked != null && (f.defaultChecked = !!i.defaultChecked);
    }
    function yt(o, i, f) {
      var v = o;
      if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
        var w = i.type, T = w === "submit" || w === "reset";
        if (T && (i.value === void 0 || i.value === null))
          return;
        var $ = jo(v._wrapperState.initialValue);
        f || $ !== v.value && (v.value = $), v.defaultValue = $;
      }
      var F = v.name;
      F !== "" && (v.name = ""), v.defaultChecked = !v.defaultChecked, v.defaultChecked = !!v._wrapperState.initialChecked, F !== "" && (v.name = F);
    }
    function sn(o, i) {
      var f = o;
      Xe(f, i), Ot(f, i);
    }
    function Ot(o, i) {
      var f = i.name;
      if (i.type === "radio" && f != null) {
        for (var v = o; v.parentNode; )
          v = v.parentNode;
        we(f, "name");
        for (var w = v.querySelectorAll("input[name=" + JSON.stringify("" + f) + '][type="radio"]'), T = 0; T < w.length; T++) {
          var $ = w[T];
          if (!($ === o || $.form !== o.form)) {
            var F = Xx($);
            if (!F)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Ed($), Xe($, F);
          }
        }
      }
    }
    function on(o, i, f) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (i !== "number" || iu(o.ownerDocument) !== o) && (f == null ? o.defaultValue = jo(o._wrapperState.initialValue) : o.defaultValue !== jo(f) && (o.defaultValue = jo(f)));
    }
    var Rn = !1, Gn = !1, $r = !1;
    function yr(o, i) {
      i.value == null && (typeof i.children == "object" && i.children !== null ? e.Children.forEach(i.children, function(f) {
        f != null && (typeof f == "string" || typeof f == "number" || Gn || (Gn = !0, l("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : i.dangerouslySetInnerHTML != null && ($r || ($r = !0, l("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), i.selected != null && !Rn && (l("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Rn = !0);
    }
    function Mr(o, i) {
      i.value != null && o.setAttribute("value", jo(Os(i.value)));
    }
    var Ar = Array.isArray;
    function jn(o) {
      return Ar(o);
    }
    var dl;
    dl = !1;
    function Td() {
      var o = ga();
      return o ? `

Check the render method of \`` + o + "`." : "";
    }
    var ep = ["value", "defaultValue"];
    function jy(o) {
      {
        cl("select", o);
        for (var i = 0; i < ep.length; i++) {
          var f = ep[i];
          if (o[f] != null) {
            var v = jn(o[f]);
            o.multiple && !v ? l("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", f, Td()) : !o.multiple && v && l("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", f, Td());
          }
        }
      }
    }
    function is(o, i, f, v) {
      var w = o.options;
      if (i) {
        for (var T = f, $ = {}, F = 0; F < T.length; F++)
          $["$" + T[F]] = !0;
        for (var W = 0; W < w.length; W++) {
          var ie = $.hasOwnProperty("$" + w[W].value);
          w[W].selected !== ie && (w[W].selected = ie), ie && v && (w[W].defaultSelected = !0);
        }
      } else {
        for (var ce = jo(Os(f)), De = null, Re = 0; Re < w.length; Re++) {
          if (w[Re].value === ce) {
            w[Re].selected = !0, v && (w[Re].defaultSelected = !0);
            return;
          }
          De === null && !w[Re].disabled && (De = w[Re]);
        }
        De !== null && (De.selected = !0);
      }
    }
    function tp(o, i) {
      return On({}, i, {
        value: void 0
      });
    }
    function np(o, i) {
      var f = o;
      jy(i), f._wrapperState = {
        wasMultiple: !!i.multiple
      }, i.value !== void 0 && i.defaultValue !== void 0 && !dl && (l("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), dl = !0);
    }
    function Ly(o, i) {
      var f = o;
      f.multiple = !!i.multiple;
      var v = i.value;
      v != null ? is(f, !!i.multiple, v, !1) : i.defaultValue != null && is(f, !!i.multiple, i.defaultValue, !0);
    }
    function $_(o, i) {
      var f = o, v = f._wrapperState.wasMultiple;
      f._wrapperState.wasMultiple = !!i.multiple;
      var w = i.value;
      w != null ? is(f, !!i.multiple, w, !1) : v !== !!i.multiple && (i.defaultValue != null ? is(f, !!i.multiple, i.defaultValue, !0) : is(f, !!i.multiple, i.multiple ? [] : "", !1));
    }
    function M_(o, i) {
      var f = o, v = i.value;
      v != null && is(f, !!i.multiple, v, !1);
    }
    var Fy = !1;
    function zy(o, i) {
      var f = o;
      if (i.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var v = On({}, i, {
        value: void 0,
        defaultValue: void 0,
        children: jo(f._wrapperState.initialValue)
      });
      return v;
    }
    function Tw(o, i) {
      var f = o;
      cl("textarea", i), i.value !== void 0 && i.defaultValue !== void 0 && !Fy && (l("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", ga() || "A component"), Fy = !0);
      var v = i.value;
      if (v == null) {
        var w = i.children, T = i.defaultValue;
        if (w != null) {
          l("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (T != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (jn(w)) {
              if (w.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              w = w[0];
            }
            T = w;
          }
        }
        T == null && (T = ""), v = T;
      }
      f._wrapperState = {
        initialValue: Os(v)
      };
    }
    function _w(o, i) {
      var f = o, v = Os(i.value), w = Os(i.defaultValue);
      if (v != null) {
        var T = jo(v);
        T !== f.value && (f.value = T), i.defaultValue == null && f.defaultValue !== T && (f.defaultValue = T);
      }
      w != null && (f.defaultValue = jo(w));
    }
    function Ow(o, i) {
      var f = o, v = f.textContent;
      v === f._wrapperState.initialValue && v !== "" && v !== null && (f.value = v);
    }
    function Vy(o, i) {
      _w(o, i);
    }
    var fl = "http://www.w3.org/1999/xhtml", N_ = "http://www.w3.org/1998/Math/MathML", Uy = "http://www.w3.org/2000/svg";
    function Um(o) {
      switch (o) {
        case "svg":
          return Uy;
        case "math":
          return N_;
        default:
          return fl;
      }
    }
    function By(o, i) {
      return o == null || o === fl ? Um(i) : o === Uy && i === "foreignObject" ? fl : o;
    }
    var I_ = function(o) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, f, v, w) {
        MSApp.execUnsafeLocalFunction(function() {
          return o(i, f, v, w);
        });
      } : o;
    }, Bm, Pw = I_(function(o, i) {
      if (o.namespaceURI === Uy && !("innerHTML" in o)) {
        Bm = Bm || document.createElement("div"), Bm.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>";
        for (var f = Bm.firstChild; o.firstChild; )
          o.removeChild(o.firstChild);
        for (; f.firstChild; )
          o.appendChild(f.firstChild);
        return;
      }
      o.innerHTML = i;
    }), ja = 1, pl = 3, bo = 8, ss = 9, dc = 11, Hm = function(o, i) {
      if (i) {
        var f = o.firstChild;
        if (f && f === o.lastChild && f.nodeType === pl) {
          f.nodeValue = i;
          return;
        }
      }
      o.textContent = i;
    }, Rw = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, _d = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function kw(o, i) {
      return o + i.charAt(0).toUpperCase() + i.substring(1);
    }
    var Dw = ["Webkit", "ms", "Moz", "O"];
    Object.keys(_d).forEach(function(o) {
      Dw.forEach(function(i) {
        _d[kw(i, o)] = _d[o];
      });
    });
    function Wm(o, i, f) {
      var v = i == null || typeof i == "boolean" || i === "";
      return v ? "" : !f && typeof i == "number" && i !== 0 && !(_d.hasOwnProperty(o) && _d[o]) ? i + "px" : (je(i, o), ("" + i).trim());
    }
    var Od = /([A-Z])/g, A_ = /^ms-/;
    function j_(o) {
      return o.replace(Od, "-$1").toLowerCase().replace(A_, "-ms-");
    }
    var $w = function() {
    };
    {
      var Mw = /^(?:webkit|moz|o)[A-Z]/, Nw = /^-ms-/, rp = /-(.)/g, Pd = /;\s*$/, Rd = {}, kd = {}, Iw = !1, Hy = !1, Wy = function(o) {
        return o.replace(rp, function(i, f) {
          return f.toUpperCase();
        });
      }, Yy = function(o) {
        Rd.hasOwnProperty(o) && Rd[o] || (Rd[o] = !0, l(
          "Unsupported style property %s. Did you mean %s?",
          o,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Wy(o.replace(Nw, "ms-"))
        ));
      }, Aw = function(o) {
        Rd.hasOwnProperty(o) && Rd[o] || (Rd[o] = !0, l("Unsupported vendor-prefixed style property %s. Did you mean %s?", o, o.charAt(0).toUpperCase() + o.slice(1)));
      }, jw = function(o, i) {
        kd.hasOwnProperty(i) && kd[i] || (kd[i] = !0, l(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, o, i.replace(Pd, "")));
      }, Lw = function(o, i) {
        Iw || (Iw = !0, l("`NaN` is an invalid value for the `%s` css style property.", o));
      }, L_ = function(o, i) {
        Hy || (Hy = !0, l("`Infinity` is an invalid value for the `%s` css style property.", o));
      };
      $w = function(o, i) {
        o.indexOf("-") > -1 ? Yy(o) : Mw.test(o) ? Aw(o) : Pd.test(i) && jw(o, i), typeof i == "number" && (isNaN(i) ? Lw(o, i) : isFinite(i) || L_(o, i));
      };
    }
    var F_ = $w;
    function z_(o) {
      {
        var i = "", f = "";
        for (var v in o)
          if (o.hasOwnProperty(v)) {
            var w = o[v];
            if (w != null) {
              var T = v.indexOf("--") === 0;
              i += f + (T ? v : j_(v)) + ":", i += Wm(v, w, T), f = ";";
            }
          }
        return i || null;
      }
    }
    function Fw(o, i) {
      var f = o.style;
      for (var v in i)
        if (i.hasOwnProperty(v)) {
          var w = v.indexOf("--") === 0;
          w || F_(v, i[v]);
          var T = Wm(v, i[v], w);
          v === "float" && (v = "cssFloat"), w ? f.setProperty(v, T) : f[v] = T;
        }
    }
    function V_(o) {
      return o == null || typeof o == "boolean" || o === "";
    }
    function _i(o) {
      var i = {};
      for (var f in o)
        for (var v = Rw[f] || [f], w = 0; w < v.length; w++)
          i[v[w]] = f;
      return i;
    }
    function op(o, i) {
      {
        if (!i)
          return;
        var f = _i(o), v = _i(i), w = {};
        for (var T in f) {
          var $ = f[T], F = v[T];
          if (F && $ !== F) {
            var W = $ + "," + F;
            if (w[W])
              continue;
            w[W] = !0, l("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", V_(o[$]) ? "Removing" : "Updating", $, F);
          }
        }
      }
    }
    var zw = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Vw = On({
      menuitem: !0
    }, zw), Uw = "__html";
    function Ym(o, i) {
      if (i) {
        if (Vw[o] && (i.children != null || i.dangerouslySetInnerHTML != null))
          throw new Error(o + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (i.dangerouslySetInnerHTML != null) {
          if (i.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof i.dangerouslySetInnerHTML != "object" || !(Uw in i.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!i.suppressContentEditableWarning && i.contentEditable && i.children != null && l("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), i.style != null && typeof i.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ml(o, i) {
      if (o.indexOf("-") === -1)
        return typeof i.is == "string";
      switch (o) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var qm = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Bw = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ls = {}, qy = new RegExp("^(aria)-[" + Ie + "]*$"), ap = new RegExp("^(aria)[A-Z][" + Ie + "]*$");
    function Gy(o, i) {
      {
        if (Ee.call(ls, i) && ls[i])
          return !0;
        if (ap.test(i)) {
          var f = "aria-" + i.slice(4).toLowerCase(), v = Bw.hasOwnProperty(f) ? f : null;
          if (v == null)
            return l("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", i), ls[i] = !0, !0;
          if (i !== v)
            return l("Invalid ARIA attribute `%s`. Did you mean `%s`?", i, v), ls[i] = !0, !0;
        }
        if (qy.test(i)) {
          var w = i.toLowerCase(), T = Bw.hasOwnProperty(w) ? w : null;
          if (T == null)
            return ls[i] = !0, !1;
          if (i !== T)
            return l("Unknown ARIA attribute `%s`. Did you mean `%s`?", i, T), ls[i] = !0, !0;
        }
      }
      return !0;
    }
    function Hw(o, i) {
      {
        var f = [];
        for (var v in i) {
          var w = Gy(o, v);
          w || f.push(v);
        }
        var T = f.map(function($) {
          return "`" + $ + "`";
        }).join(", ");
        f.length === 1 ? l("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", T, o) : f.length > 1 && l("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", T, o);
      }
    }
    function Gm(o, i) {
      ml(o, i) || Hw(o, i);
    }
    var fc = !1;
    function Ky(o, i) {
      {
        if (o !== "input" && o !== "textarea" && o !== "select")
          return;
        i != null && i.value === null && !fc && (fc = !0, o === "select" && i.multiple ? l("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", o) : l("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", o));
      }
    }
    var Xy = function() {
    };
    {
      var Lo = {}, Qy = /^on./, Ww = /^on[^A-Z]/, Yw = new RegExp("^(aria)-[" + Ie + "]*$"), qw = new RegExp("^(aria)[A-Z][" + Ie + "]*$");
      Xy = function(o, i, f, v) {
        if (Ee.call(Lo, i) && Lo[i])
          return !0;
        var w = i.toLowerCase();
        if (w === "onfocusin" || w === "onfocusout")
          return l("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Lo[i] = !0, !0;
        if (v != null) {
          var T = v.registrationNameDependencies, $ = v.possibleRegistrationNames;
          if (T.hasOwnProperty(i))
            return !0;
          var F = $.hasOwnProperty(w) ? $[w] : null;
          if (F != null)
            return l("Invalid event handler property `%s`. Did you mean `%s`?", i, F), Lo[i] = !0, !0;
          if (Qy.test(i))
            return l("Unknown event handler property `%s`. It will be ignored.", i), Lo[i] = !0, !0;
        } else if (Qy.test(i))
          return Ww.test(i) && l("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", i), Lo[i] = !0, !0;
        if (Yw.test(i) || qw.test(i))
          return !0;
        if (w === "innerhtml")
          return l("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Lo[i] = !0, !0;
        if (w === "aria")
          return l("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Lo[i] = !0, !0;
        if (w === "is" && f !== null && f !== void 0 && typeof f != "string")
          return l("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof f), Lo[i] = !0, !0;
        if (typeof f == "number" && isNaN(f))
          return l("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", i), Lo[i] = !0, !0;
        var W = Pn(i), ie = W !== null && W.type === et;
        if (qm.hasOwnProperty(w)) {
          var ce = qm[w];
          if (ce !== i)
            return l("Invalid DOM property `%s`. Did you mean `%s`?", i, ce), Lo[i] = !0, !0;
        } else if (!ie && i !== w)
          return l("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", i, w), Lo[i] = !0, !0;
        return typeof f == "boolean" && Tn(i, f, W, !1) ? (f ? l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', f, i, i, f, i) : l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', f, i, i, f, i, i, i), Lo[i] = !0, !0) : ie ? !0 : Tn(i, f, W, !1) ? (Lo[i] = !0, !1) : ((f === "false" || f === "true") && W !== null && W.type === Ht && (l("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", f, i, f === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', i, f), Lo[i] = !0), !0);
      };
    }
    var Gw = function(o, i, f) {
      {
        var v = [];
        for (var w in i) {
          var T = Xy(o, w, i[w], f);
          T || v.push(w);
        }
        var $ = v.map(function(F) {
          return "`" + F + "`";
        }).join(", ");
        v.length === 1 ? l("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", $, o) : v.length > 1 && l("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", $, o);
      }
    };
    function Kw(o, i, f) {
      ml(o, i) || Gw(o, i, f);
    }
    var hl = 1, ip = 2, pc = 4, U_ = hl | ip | pc, sp = null;
    function lp(o) {
      sp !== null && l("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), sp = o;
    }
    function B_() {
      sp === null && l("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), sp = null;
    }
    function Xw(o) {
      return o === sp;
    }
    function Km(o) {
      var i = o.target || o.srcElement || window;
      return i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === pl ? i.parentNode : i;
    }
    var Nr = null, lu = null, vl = null;
    function Dd(o) {
      var i = rf(o);
      if (i) {
        if (typeof Nr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var f = i.stateNode;
        if (f) {
          var v = Xx(f);
          Nr(i.stateNode, i.type, v);
        }
      }
    }
    function Qw(o) {
      Nr = o;
    }
    function Xm(o) {
      lu ? vl ? vl.push(o) : vl = [o] : lu = o;
    }
    function up() {
      return lu !== null || vl !== null;
    }
    function cp() {
      if (lu) {
        var o = lu, i = vl;
        if (lu = null, vl = null, Dd(o), i)
          for (var f = 0; f < i.length; f++)
            Dd(i[f]);
      }
    }
    var mc = function(o, i) {
      return o(i);
    }, Zy = function() {
    }, Jy = !1;
    function H_() {
      var o = up();
      o && (Zy(), cp());
    }
    function eg(o, i, f) {
      if (Jy)
        return o(i, f);
      Jy = !0;
      try {
        return mc(o, i, f);
      } finally {
        Jy = !1, H_();
      }
    }
    function Qm(o, i, f) {
      mc = o, Zy = f;
    }
    function Zm(o) {
      return o === "button" || o === "input" || o === "select" || o === "textarea";
    }
    function tg(o, i, f) {
      switch (o) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(f.disabled && Zm(i));
        default:
          return !1;
      }
    }
    function hc(o, i) {
      var f = o.stateNode;
      if (f === null)
        return null;
      var v = Xx(f);
      if (v === null)
        return null;
      var w = v[i];
      if (tg(i, o.type, v))
        return null;
      if (w && typeof w != "function")
        throw new Error("Expected `" + i + "` listener to be a function, instead got a value of `" + typeof w + "` type.");
      return w;
    }
    var dp = !1;
    if (Pe)
      try {
        var vc = {};
        Object.defineProperty(vc, "passive", {
          get: function() {
            dp = !0;
          }
        }), window.addEventListener("test", vc, vc), window.removeEventListener("test", vc, vc);
      } catch {
        dp = !1;
      }
    function Zw(o, i, f, v, w, T, $, F, W) {
      var ie = Array.prototype.slice.call(arguments, 3);
      try {
        i.apply(f, ie);
      } catch (ce) {
        this.onError(ce);
      }
    }
    var ng = Zw;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var rg = document.createElement("react");
      ng = function(i, f, v, w, T, $, F, W, ie) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ce = document.createEvent("Event"), De = !1, Re = !0, Be = window.event, We = Object.getOwnPropertyDescriptor(window, "event");
        function Qe() {
          rg.removeEventListener(Ze, rn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Be);
        }
        var It = Array.prototype.slice.call(arguments, 3);
        function rn() {
          De = !0, Qe(), f.apply(v, It), Re = !1;
        }
        var en, Vn = !1, Nn = !1;
        function ze(Ve) {
          if (en = Ve.error, Vn = !0, en === null && Ve.colno === 0 && Ve.lineno === 0 && (Nn = !0), Ve.defaultPrevented && en != null && typeof en == "object")
            try {
              en._suppressLogging = !0;
            } catch {
            }
        }
        var Ze = "react-" + (i || "invokeguardedcallback");
        if (window.addEventListener("error", ze), rg.addEventListener(Ze, rn, !1), ce.initEvent(Ze, !1, !1), rg.dispatchEvent(ce), We && Object.defineProperty(window, "event", We), De && Re && (Vn ? Nn && (en = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : en = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(en)), window.removeEventListener("error", ze), !De)
          return Qe(), Zw.apply(this, arguments);
      };
    }
    var W_ = ng, uu = !1, us = null, fp = !1, cu = null, Ps = {
      onError: function(o) {
        uu = !0, us = o;
      }
    };
    function yc(o, i, f, v, w, T, $, F, W) {
      uu = !1, us = null, W_.apply(Ps, arguments);
    }
    function yl(o, i, f, v, w, T, $, F, W) {
      if (yc.apply(this, arguments), uu) {
        var ie = ag();
        fp || (fp = !0, cu = ie);
      }
    }
    function og() {
      if (fp) {
        var o = cu;
        throw fp = !1, cu = null, o;
      }
    }
    function Y_() {
      return uu;
    }
    function ag() {
      if (uu) {
        var o = us;
        return uu = !1, us = null, o;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Oi(o) {
      return o._reactInternals;
    }
    function pp(o) {
      return o._reactInternals !== void 0;
    }
    function $d(o, i) {
      o._reactInternals = i;
    }
    var nn = (
      /*                      */
      0
    ), du = (
      /*                */
      1
    ), Br = (
      /*                    */
      2
    ), Sn = (
      /*                       */
      4
    ), sr = (
      /*                */
      16
    ), pr = (
      /*                 */
      32
    ), Rs = (
      /*                     */
      64
    ), pn = (
      /*                   */
      128
    ), so = (
      /*            */
      256
    ), La = (
      /*                          */
      512
    ), Pi = (
      /*                     */
      1024
    ), Xr = (
      /*                      */
      2048
    ), Ri = (
      /*                    */
      4096
    ), fu = (
      /*                   */
      8192
    ), mp = (
      /*             */
      16384
    ), Jm = Xr | Sn | Rs | La | Pi | mp, Jw = (
      /*               */
      32767
    ), ai = (
      /*                   */
      32768
    ), Fo = (
      /*                */
      65536
    ), hp = (
      /* */
      131072
    ), ig = (
      /*                       */
      1048576
    ), sg = (
      /*                    */
      2097152
    ), Fa = (
      /*                 */
      4194304
    ), pu = (
      /*                */
      8388608
    ), za = (
      /*               */
      16777216
    ), gc = (
      /*              */
      33554432
    ), Md = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Sn | Pi | 0
    ), Va = Br | Sn | sr | pr | La | Ri | fu, ua = Sn | Rs | La | fu, ki = Xr | sr, Yo = Fa | pu | sg, gl = n.ReactCurrentOwner;
    function ii(o) {
      var i = o, f = o;
      if (o.alternate)
        for (; i.return; )
          i = i.return;
      else {
        var v = i;
        do
          i = v, (i.flags & (Br | Ri)) !== nn && (f = i.return), v = i.return;
        while (v);
      }
      return i.tag === b ? f : null;
    }
    function lg(o) {
      if (o.tag === R) {
        var i = o.memoizedState;
        if (i === null) {
          var f = o.alternate;
          f !== null && (i = f.memoizedState);
        }
        if (i !== null)
          return i.dehydrated;
      }
      return null;
    }
    function eh(o) {
      return o.tag === b ? o.stateNode.containerInfo : null;
    }
    function ug(o) {
      return ii(o) === o;
    }
    function si(o) {
      {
        var i = gl.current;
        if (i !== null && i.tag === h) {
          var f = i, v = f.stateNode;
          v._warnedAboutRefsInRender || l("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", gn(f) || "A component"), v._warnedAboutRefsInRender = !0;
        }
      }
      var w = Oi(o);
      return w ? ii(w) === w : !1;
    }
    function Ua(o) {
      if (ii(o) !== o)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Hr(o) {
      var i = o.alternate;
      if (!i) {
        var f = ii(o);
        if (f === null)
          throw new Error("Unable to find node on an unmounted component.");
        return f !== o ? null : o;
      }
      for (var v = o, w = i; ; ) {
        var T = v.return;
        if (T === null)
          break;
        var $ = T.alternate;
        if ($ === null) {
          var F = T.return;
          if (F !== null) {
            v = w = F;
            continue;
          }
          break;
        }
        if (T.child === $.child) {
          for (var W = T.child; W; ) {
            if (W === v)
              return Ua(T), o;
            if (W === w)
              return Ua(T), i;
            W = W.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (v.return !== w.return)
          v = T, w = $;
        else {
          for (var ie = !1, ce = T.child; ce; ) {
            if (ce === v) {
              ie = !0, v = T, w = $;
              break;
            }
            if (ce === w) {
              ie = !0, w = T, v = $;
              break;
            }
            ce = ce.sibling;
          }
          if (!ie) {
            for (ce = $.child; ce; ) {
              if (ce === v) {
                ie = !0, v = $, w = T;
                break;
              }
              if (ce === w) {
                ie = !0, w = $, v = T;
                break;
              }
              ce = ce.sibling;
            }
            if (!ie)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (v.alternate !== w)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (v.tag !== b)
        throw new Error("Unable to find node on an unmounted component.");
      return v.stateNode.current === v ? o : i;
    }
    function Di(o) {
      var i = Hr(o);
      return i !== null ? cg(i) : null;
    }
    function cg(o) {
      if (o.tag === E || o.tag === O)
        return o;
      for (var i = o.child; i !== null; ) {
        var f = cg(i);
        if (f !== null)
          return f;
        i = i.sibling;
      }
      return null;
    }
    function ex(o) {
      var i = Hr(o);
      return i !== null ? th(i) : null;
    }
    function th(o) {
      if (o.tag === E || o.tag === O)
        return o;
      for (var i = o.child; i !== null; ) {
        if (i.tag !== x) {
          var f = th(i);
          if (f !== null)
            return f;
        }
        i = i.sibling;
      }
      return null;
    }
    var nh = t.unstable_scheduleCallback, tx = t.unstable_cancelCallback, rh = t.unstable_shouldYield, nx = t.unstable_requestPaint, to = t.unstable_now, dg = t.unstable_getCurrentPriorityLevel, oh = t.unstable_ImmediatePriority, li = t.unstable_UserBlockingPriority, ks = t.unstable_NormalPriority, ah = t.unstable_LowPriority, mu = t.unstable_IdlePriority, fg = t.unstable_yieldValue, pg = t.unstable_setDisableYieldValue, hu = null, zo = null, Et = null, fo = !1, qo = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function mg(o) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var i = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (i.isDisabled)
        return !0;
      if (!i.supportsFiber)
        return l("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ce && (o = On({}, o, {
          getLaneLabelMap: yu,
          injectProfilingHooks: wl
        })), hu = i.inject(o), zo = i;
      } catch (f) {
        l("React instrumentation encountered an error: %s.", f);
      }
      return !!i.checkDCE;
    }
    function rx(o, i) {
      if (zo && typeof zo.onScheduleFiberRoot == "function")
        try {
          zo.onScheduleFiberRoot(hu, o, i);
        } catch (f) {
          fo || (fo = !0, l("React instrumentation encountered an error: %s", f));
        }
    }
    function bl(o, i) {
      if (zo && typeof zo.onCommitFiberRoot == "function")
        try {
          var f = (o.current.flags & pn) === pn;
          if (Se) {
            var v;
            switch (i) {
              case ca:
                v = oh;
                break;
              case Go:
                v = li;
                break;
              case Sl:
                v = ks;
                break;
              case Cp:
                v = mu;
                break;
              default:
                v = ks;
                break;
            }
            zo.onCommitFiberRoot(hu, o, v, f);
          }
        } catch (w) {
          fo || (fo = !0, l("React instrumentation encountered an error: %s", w));
        }
    }
    function vu(o) {
      if (zo && typeof zo.onPostCommitFiberRoot == "function")
        try {
          zo.onPostCommitFiberRoot(hu, o);
        } catch (i) {
          fo || (fo = !0, l("React instrumentation encountered an error: %s", i));
        }
    }
    function hg(o) {
      if (zo && typeof zo.onCommitFiberUnmount == "function")
        try {
          zo.onCommitFiberUnmount(hu, o);
        } catch (i) {
          fo || (fo = !0, l("React instrumentation encountered an error: %s", i));
        }
    }
    function Po(o) {
      if (typeof fg == "function" && (pg(o), a(o)), zo && typeof zo.setStrictMode == "function")
        try {
          zo.setStrictMode(hu, o);
        } catch (i) {
          fo || (fo = !0, l("React instrumentation encountered an error: %s", i));
        }
    }
    function wl(o) {
      Et = o;
    }
    function yu() {
      {
        for (var o = /* @__PURE__ */ new Map(), i = 1, f = 0; f < Wr; f++) {
          var v = q_(i);
          o.set(i, v), i *= 2;
        }
        return o;
      }
    }
    function ih(o) {
      Et !== null && typeof Et.markCommitStarted == "function" && Et.markCommitStarted(o);
    }
    function vg() {
      Et !== null && typeof Et.markCommitStopped == "function" && Et.markCommitStopped();
    }
    function gu(o) {
      Et !== null && typeof Et.markComponentRenderStarted == "function" && Et.markComponentRenderStarted(o);
    }
    function bc() {
      Et !== null && typeof Et.markComponentRenderStopped == "function" && Et.markComponentRenderStopped();
    }
    function ox(o) {
      Et !== null && typeof Et.markComponentPassiveEffectMountStarted == "function" && Et.markComponentPassiveEffectMountStarted(o);
    }
    function yg() {
      Et !== null && typeof Et.markComponentPassiveEffectMountStopped == "function" && Et.markComponentPassiveEffectMountStopped();
    }
    function sh(o) {
      Et !== null && typeof Et.markComponentPassiveEffectUnmountStarted == "function" && Et.markComponentPassiveEffectUnmountStarted(o);
    }
    function ax() {
      Et !== null && typeof Et.markComponentPassiveEffectUnmountStopped == "function" && Et.markComponentPassiveEffectUnmountStopped();
    }
    function ix(o) {
      Et !== null && typeof Et.markComponentLayoutEffectMountStarted == "function" && Et.markComponentLayoutEffectMountStarted(o);
    }
    function sx() {
      Et !== null && typeof Et.markComponentLayoutEffectMountStopped == "function" && Et.markComponentLayoutEffectMountStopped();
    }
    function lh(o) {
      Et !== null && typeof Et.markComponentLayoutEffectUnmountStarted == "function" && Et.markComponentLayoutEffectUnmountStarted(o);
    }
    function Nd() {
      Et !== null && typeof Et.markComponentLayoutEffectUnmountStopped == "function" && Et.markComponentLayoutEffectUnmountStopped();
    }
    function uh(o, i, f) {
      Et !== null && typeof Et.markComponentErrored == "function" && Et.markComponentErrored(o, i, f);
    }
    function lx(o, i, f) {
      Et !== null && typeof Et.markComponentSuspended == "function" && Et.markComponentSuspended(o, i, f);
    }
    function ux(o) {
      Et !== null && typeof Et.markLayoutEffectsStarted == "function" && Et.markLayoutEffectsStarted(o);
    }
    function Id() {
      Et !== null && typeof Et.markLayoutEffectsStopped == "function" && Et.markLayoutEffectsStopped();
    }
    function cx(o) {
      Et !== null && typeof Et.markPassiveEffectsStarted == "function" && Et.markPassiveEffectsStarted(o);
    }
    function vp() {
      Et !== null && typeof Et.markPassiveEffectsStopped == "function" && Et.markPassiveEffectsStopped();
    }
    function cs(o) {
      Et !== null && typeof Et.markRenderStarted == "function" && Et.markRenderStarted(o);
    }
    function yp() {
      Et !== null && typeof Et.markRenderYielded == "function" && Et.markRenderYielded();
    }
    function Ad() {
      Et !== null && typeof Et.markRenderStopped == "function" && Et.markRenderStopped();
    }
    function wc(o) {
      Et !== null && typeof Et.markRenderScheduled == "function" && Et.markRenderScheduled(o);
    }
    function gg(o, i) {
      Et !== null && typeof Et.markForceUpdateScheduled == "function" && Et.markForceUpdateScheduled(o, i);
    }
    function bu(o, i) {
      Et !== null && typeof Et.markStateUpdateScheduled == "function" && Et.markStateUpdateScheduled(o, i);
    }
    var an = (
      /*                         */
      0
    ), kn = (
      /*                 */
      1
    ), ln = (
      /*                    */
      2
    ), no = (
      /*               */
      8
    ), $i = (
      /*              */
      16
    ), ch = Math.clz32 ? Math.clz32 : xc, dh = Math.log, bg = Math.LN2;
    function xc(o) {
      var i = o >>> 0;
      return i === 0 ? 32 : 31 - (dh(i) / bg | 0) | 0;
    }
    var Wr = 31, tt = (
      /*                        */
      0
    ), Fn = (
      /*                          */
      0
    ), un = (
      /*                        */
      1
    ), Ds = (
      /*    */
      2
    ), ui = (
      /*             */
      4
    ), Sc = (
      /*            */
      8
    ), Yr = (
      /*                     */
      16
    ), Ec = (
      /*                */
      32
    ), wu = (
      /*                       */
      4194240
    ), Cc = (
      /*                        */
      64
    ), Mi = (
      /*                        */
      128
    ), Ba = (
      /*                        */
      256
    ), Tc = (
      /*                        */
      512
    ), gp = (
      /*                        */
      1024
    ), bp = (
      /*                        */
      2048
    ), fh = (
      /*                        */
      4096
    ), ph = (
      /*                        */
      8192
    ), mh = (
      /*                        */
      16384
    ), hh = (
      /*                       */
      32768
    ), vh = (
      /*                       */
      65536
    ), yh = (
      /*                       */
      131072
    ), gh = (
      /*                       */
      262144
    ), bh = (
      /*                       */
      524288
    ), _c = (
      /*                       */
      1048576
    ), wh = (
      /*                       */
      2097152
    ), Oc = (
      /*                            */
      130023424
    ), xl = (
      /*                             */
      4194304
    ), xh = (
      /*                             */
      8388608
    ), wp = (
      /*                             */
      16777216
    ), Sh = (
      /*                             */
      33554432
    ), Eh = (
      /*                             */
      67108864
    ), wg = xl, jd = (
      /*          */
      134217728
    ), Ch = (
      /*                          */
      268435455
    ), Ld = (
      /*               */
      268435456
    ), xu = (
      /*                        */
      536870912
    ), Ha = (
      /*                   */
      1073741824
    );
    function q_(o) {
      {
        if (o & un)
          return "Sync";
        if (o & Ds)
          return "InputContinuousHydration";
        if (o & ui)
          return "InputContinuous";
        if (o & Sc)
          return "DefaultHydration";
        if (o & Yr)
          return "Default";
        if (o & Ec)
          return "TransitionHydration";
        if (o & wu)
          return "Transition";
        if (o & Oc)
          return "Retry";
        if (o & jd)
          return "SelectiveHydration";
        if (o & Ld)
          return "IdleHydration";
        if (o & xu)
          return "Idle";
        if (o & Ha)
          return "Offscreen";
      }
    }
    var Ir = -1, Th = Cc, _h = xl;
    function Fd(o) {
      switch (wo(o)) {
        case un:
          return un;
        case Ds:
          return Ds;
        case ui:
          return ui;
        case Sc:
          return Sc;
        case Yr:
          return Yr;
        case Ec:
          return Ec;
        case Cc:
        case Mi:
        case Ba:
        case Tc:
        case gp:
        case bp:
        case fh:
        case ph:
        case mh:
        case hh:
        case vh:
        case yh:
        case gh:
        case bh:
        case _c:
        case wh:
          return o & wu;
        case xl:
        case xh:
        case wp:
        case Sh:
        case Eh:
          return o & Oc;
        case jd:
          return jd;
        case Ld:
          return Ld;
        case xu:
          return xu;
        case Ha:
          return Ha;
        default:
          return l("Should have found matching lanes. This is a bug in React."), o;
      }
    }
    function xp(o, i) {
      var f = o.pendingLanes;
      if (f === tt)
        return tt;
      var v = tt, w = o.suspendedLanes, T = o.pingedLanes, $ = f & Ch;
      if ($ !== tt) {
        var F = $ & ~w;
        if (F !== tt)
          v = Fd(F);
        else {
          var W = $ & T;
          W !== tt && (v = Fd(W));
        }
      } else {
        var ie = f & ~w;
        ie !== tt ? v = Fd(ie) : T !== tt && (v = Fd(T));
      }
      if (v === tt)
        return tt;
      if (i !== tt && i !== v && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (i & w) === tt) {
        var ce = wo(v), De = wo(i);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ce >= De || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ce === Yr && (De & wu) !== tt
        )
          return i;
      }
      (v & ui) !== tt && (v |= f & Yr);
      var Re = o.entangledLanes;
      if (Re !== tt)
        for (var Be = o.entanglements, We = v & Re; We > 0; ) {
          var Qe = Su(We), It = 1 << Qe;
          v |= Be[Qe], We &= ~It;
        }
      return v;
    }
    function dx(o, i) {
      for (var f = o.eventTimes, v = Ir; i > 0; ) {
        var w = Su(i), T = 1 << w, $ = f[w];
        $ > v && (v = $), i &= ~T;
      }
      return v;
    }
    function Oh(o, i) {
      switch (o) {
        case un:
        case Ds:
        case ui:
          return i + 250;
        case Sc:
        case Yr:
        case Ec:
        case Cc:
        case Mi:
        case Ba:
        case Tc:
        case gp:
        case bp:
        case fh:
        case ph:
        case mh:
        case hh:
        case vh:
        case yh:
        case gh:
        case bh:
        case _c:
        case wh:
          return i + 5e3;
        case xl:
        case xh:
        case wp:
        case Sh:
        case Eh:
          return Ir;
        case jd:
        case Ld:
        case xu:
        case Ha:
          return Ir;
        default:
          return l("Should have found matching lanes. This is a bug in React."), Ir;
      }
    }
    function G_(o, i) {
      for (var f = o.pendingLanes, v = o.suspendedLanes, w = o.pingedLanes, T = o.expirationTimes, $ = f; $ > 0; ) {
        var F = Su($), W = 1 << F, ie = T[F];
        ie === Ir ? ((W & v) === tt || (W & w) !== tt) && (T[F] = Oh(W, i)) : ie <= i && (o.expiredLanes |= W), $ &= ~W;
      }
    }
    function K_(o) {
      return Fd(o.pendingLanes);
    }
    function xg(o) {
      var i = o.pendingLanes & ~Ha;
      return i !== tt ? i : i & Ha ? Ha : tt;
    }
    function zd(o) {
      return (o & un) !== tt;
    }
    function Sp(o) {
      return (o & Ch) !== tt;
    }
    function Ph(o) {
      return (o & Oc) === o;
    }
    function X_(o) {
      var i = un | ui | Yr;
      return (o & i) === tt;
    }
    function fx(o) {
      return (o & wu) === o;
    }
    function Ep(o, i) {
      var f = Ds | ui | Sc | Yr;
      return (i & f) !== tt;
    }
    function px(o, i) {
      return (i & o.expiredLanes) !== tt;
    }
    function Sg(o) {
      return (o & wu) !== tt;
    }
    function Eg() {
      var o = Th;
      return Th <<= 1, (Th & wu) === tt && (Th = Cc), o;
    }
    function Q_() {
      var o = _h;
      return _h <<= 1, (_h & Oc) === tt && (_h = xl), o;
    }
    function wo(o) {
      return o & -o;
    }
    function Ro(o) {
      return wo(o);
    }
    function Su(o) {
      return 31 - ch(o);
    }
    function Rh(o) {
      return Su(o);
    }
    function Wa(o, i) {
      return (o & i) !== tt;
    }
    function Pc(o, i) {
      return (o & i) === i;
    }
    function En(o, i) {
      return o | i;
    }
    function Vd(o, i) {
      return o & ~i;
    }
    function Cg(o, i) {
      return o & i;
    }
    function mx(o) {
      return o;
    }
    function hx(o, i) {
      return o !== Fn && o < i ? o : i;
    }
    function kh(o) {
      for (var i = [], f = 0; f < Wr; f++)
        i.push(o);
      return i;
    }
    function Rc(o, i, f) {
      o.pendingLanes |= i, i !== xu && (o.suspendedLanes = tt, o.pingedLanes = tt);
      var v = o.eventTimes, w = Rh(i);
      v[w] = f;
    }
    function Tg(o, i) {
      o.suspendedLanes |= i, o.pingedLanes &= ~i;
      for (var f = o.expirationTimes, v = i; v > 0; ) {
        var w = Su(v), T = 1 << w;
        f[w] = Ir, v &= ~T;
      }
    }
    function _g(o, i, f) {
      o.pingedLanes |= o.suspendedLanes & i;
    }
    function Og(o, i) {
      var f = o.pendingLanes & ~i;
      o.pendingLanes = i, o.suspendedLanes = tt, o.pingedLanes = tt, o.expiredLanes &= i, o.mutableReadLanes &= i, o.entangledLanes &= i;
      for (var v = o.entanglements, w = o.eventTimes, T = o.expirationTimes, $ = f; $ > 0; ) {
        var F = Su($), W = 1 << F;
        v[F] = tt, w[F] = Ir, T[F] = Ir, $ &= ~W;
      }
    }
    function Ud(o, i) {
      for (var f = o.entangledLanes |= i, v = o.entanglements, w = f; w; ) {
        var T = Su(w), $ = 1 << T;
        // Is this one of the newly entangled lanes?
        $ & i | // Is this lane transitively entangled with the newly entangled lanes?
        v[T] & i && (v[T] |= i), w &= ~$;
      }
    }
    function Z_(o, i) {
      var f = wo(i), v;
      switch (f) {
        case ui:
          v = Ds;
          break;
        case Yr:
          v = Sc;
          break;
        case Cc:
        case Mi:
        case Ba:
        case Tc:
        case gp:
        case bp:
        case fh:
        case ph:
        case mh:
        case hh:
        case vh:
        case yh:
        case gh:
        case bh:
        case _c:
        case wh:
        case xl:
        case xh:
        case wp:
        case Sh:
        case Eh:
          v = Ec;
          break;
        case xu:
          v = Ld;
          break;
        default:
          v = Fn;
          break;
      }
      return (v & (o.suspendedLanes | i)) !== Fn ? Fn : v;
    }
    function Pg(o, i, f) {
      if (qo)
        for (var v = o.pendingUpdatersLaneMap; f > 0; ) {
          var w = Rh(f), T = 1 << w, $ = v[w];
          $.add(i), f &= ~T;
        }
    }
    function Dh(o, i) {
      if (qo)
        for (var f = o.pendingUpdatersLaneMap, v = o.memoizedUpdaters; i > 0; ) {
          var w = Rh(i), T = 1 << w, $ = f[w];
          $.size > 0 && ($.forEach(function(F) {
            var W = F.alternate;
            (W === null || !v.has(W)) && v.add(F);
          }), $.clear()), i &= ~T;
        }
    }
    function Rg(o, i) {
      return null;
    }
    var ca = un, Go = ui, Sl = Yr, Cp = xu, kc = Fn;
    function Ni() {
      return kc;
    }
    function ko(o) {
      kc = o;
    }
    function Tp(o, i) {
      var f = kc;
      try {
        return kc = o, i();
      } finally {
        kc = f;
      }
    }
    function da(o, i) {
      return o !== 0 && o < i ? o : i;
    }
    function J_(o, i) {
      return o === 0 || o > i ? o : i;
    }
    function kg(o, i) {
      return o !== 0 && o < i;
    }
    function _p(o) {
      var i = wo(o);
      return kg(ca, i) ? kg(Go, i) ? Sp(i) ? Sl : Cp : Go : ca;
    }
    function Do(o) {
      var i = o.current.memoizedState;
      return i.isDehydrated;
    }
    var vx;
    function Vt(o) {
      vx = o;
    }
    function Bd(o) {
      vx(o);
    }
    var Op;
    function yx(o) {
      Op = o;
    }
    var gx;
    function Pp(o) {
      gx = o;
    }
    var Rp;
    function Dg(o) {
      Rp = o;
    }
    var $g;
    function bx(o) {
      $g = o;
    }
    var $h = !1, Hd = [], $s = null, Qr = null, Vo = null, Ii = /* @__PURE__ */ new Map(), Wd = /* @__PURE__ */ new Map(), El = [], ds = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function wx(o) {
      return ds.indexOf(o) > -1;
    }
    function Ms(o, i, f, v, w) {
      return {
        blockedOn: o,
        domEventName: i,
        eventSystemFlags: f,
        nativeEvent: w,
        targetContainers: [v]
      };
    }
    function xx(o, i) {
      switch (o) {
        case "focusin":
        case "focusout":
          $s = null;
          break;
        case "dragenter":
        case "dragleave":
          Qr = null;
          break;
        case "mouseover":
        case "mouseout":
          Vo = null;
          break;
        case "pointerover":
        case "pointerout": {
          var f = i.pointerId;
          Ii.delete(f);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var v = i.pointerId;
          Wd.delete(v);
          break;
        }
      }
    }
    function Yd(o, i, f, v, w, T) {
      if (o === null || o.nativeEvent !== T) {
        var $ = Ms(i, f, v, w, T);
        if (i !== null) {
          var F = rf(i);
          F !== null && Op(F);
        }
        return $;
      }
      o.eventSystemFlags |= v;
      var W = o.targetContainers;
      return w !== null && W.indexOf(w) === -1 && W.push(w), o;
    }
    function Sx(o, i, f, v, w) {
      switch (i) {
        case "focusin": {
          var T = w;
          return $s = Yd($s, o, i, f, v, T), !0;
        }
        case "dragenter": {
          var $ = w;
          return Qr = Yd(Qr, o, i, f, v, $), !0;
        }
        case "mouseover": {
          var F = w;
          return Vo = Yd(Vo, o, i, f, v, F), !0;
        }
        case "pointerover": {
          var W = w, ie = W.pointerId;
          return Ii.set(ie, Yd(Ii.get(ie) || null, o, i, f, v, W)), !0;
        }
        case "gotpointercapture": {
          var ce = w, De = ce.pointerId;
          return Wd.set(De, Yd(Wd.get(De) || null, o, i, f, v, ce)), !0;
        }
      }
      return !1;
    }
    function Mg(o) {
      var i = Lp(o.target);
      if (i !== null) {
        var f = ii(i);
        if (f !== null) {
          var v = f.tag;
          if (v === R) {
            var w = lg(f);
            if (w !== null) {
              o.blockedOn = w, $g(o.priority, function() {
                gx(f);
              });
              return;
            }
          } else if (v === b) {
            var T = f.stateNode;
            if (Do(T)) {
              o.blockedOn = eh(f);
              return;
            }
          }
        }
      }
      o.blockedOn = null;
    }
    function Ex(o) {
      for (var i = Rp(), f = {
        blockedOn: null,
        target: o,
        priority: i
      }, v = 0; v < El.length && kg(i, El[v].priority); v++)
        ;
      El.splice(v, 0, f), v === 0 && Mg(f);
    }
    function Mh(o) {
      if (o.blockedOn !== null)
        return !1;
      for (var i = o.targetContainers; i.length > 0; ) {
        var f = i[0], v = Dc(o.domEventName, o.eventSystemFlags, f, o.nativeEvent);
        if (v === null) {
          var w = o.nativeEvent, T = new w.constructor(w.type, w);
          lp(T), w.target.dispatchEvent(T), B_();
        } else {
          var $ = rf(v);
          return $ !== null && Op($), o.blockedOn = v, !1;
        }
        i.shift();
      }
      return !0;
    }
    function kp(o, i, f) {
      Mh(o) && f.delete(i);
    }
    function Ng() {
      $h = !1, $s !== null && Mh($s) && ($s = null), Qr !== null && Mh(Qr) && (Qr = null), Vo !== null && Mh(Vo) && (Vo = null), Ii.forEach(kp), Wd.forEach(kp);
    }
    function fa(o, i) {
      o.blockedOn === i && (o.blockedOn = null, $h || ($h = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Ng)));
    }
    function Mn(o) {
      if (Hd.length > 0) {
        fa(Hd[0], o);
        for (var i = 1; i < Hd.length; i++) {
          var f = Hd[i];
          f.blockedOn === o && (f.blockedOn = null);
        }
      }
      $s !== null && fa($s, o), Qr !== null && fa(Qr, o), Vo !== null && fa(Vo, o);
      var v = function(F) {
        return fa(F, o);
      };
      Ii.forEach(v), Wd.forEach(v);
      for (var w = 0; w < El.length; w++) {
        var T = El[w];
        T.blockedOn === o && (T.blockedOn = null);
      }
      for (; El.length > 0; ) {
        var $ = El[0];
        if ($.blockedOn !== null)
          break;
        Mg($), $.blockedOn === null && El.shift();
      }
    }
    var ro = n.ReactCurrentBatchConfig, lo = !0;
    function Uo(o) {
      lo = !!o;
    }
    function ci() {
      return lo;
    }
    function qd(o, i, f) {
      var v = ba(i), w;
      switch (v) {
        case ca:
          w = $o;
          break;
        case Go:
          w = Dp;
          break;
        case Sl:
        default:
          w = Cl;
          break;
      }
      return w.bind(null, i, f, o);
    }
    function $o(o, i, f, v) {
      var w = Ni(), T = ro.transition;
      ro.transition = null;
      try {
        ko(ca), Cl(o, i, f, v);
      } finally {
        ko(w), ro.transition = T;
      }
    }
    function Dp(o, i, f, v) {
      var w = Ni(), T = ro.transition;
      ro.transition = null;
      try {
        ko(Go), Cl(o, i, f, v);
      } finally {
        ko(w), ro.transition = T;
      }
    }
    function Cl(o, i, f, v) {
      lo && Nh(o, i, f, v);
    }
    function Nh(o, i, f, v) {
      var w = Dc(o, i, f, v);
      if (w === null) {
        bO(o, i, v, Gd, f), xx(o, v);
        return;
      }
      if (Sx(w, o, i, f, v)) {
        v.stopPropagation();
        return;
      }
      if (xx(o, v), i & pc && wx(o)) {
        for (; w !== null; ) {
          var T = rf(w);
          T !== null && Bd(T);
          var $ = Dc(o, i, f, v);
          if ($ === null && bO(o, i, v, Gd, f), $ === w)
            break;
          w = $;
        }
        w !== null && v.stopPropagation();
        return;
      }
      bO(o, i, v, null, f);
    }
    var Gd = null;
    function Dc(o, i, f, v) {
      Gd = null;
      var w = Km(v), T = Lp(w);
      if (T !== null) {
        var $ = ii(T);
        if ($ === null)
          T = null;
        else {
          var F = $.tag;
          if (F === R) {
            var W = lg($);
            if (W !== null)
              return W;
            T = null;
          } else if (F === b) {
            var ie = $.stateNode;
            if (Do(ie))
              return eh($);
            T = null;
          } else
            $ !== T && (T = null);
        }
      }
      return Gd = T, null;
    }
    function ba(o) {
      switch (o) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ca;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Go;
        case "message": {
          var i = dg();
          switch (i) {
            case oh:
              return ca;
            case li:
              return Go;
            case ks:
            case ah:
              return Sl;
            case mu:
              return Cp;
            default:
              return Sl;
          }
        }
        default:
          return Sl;
      }
    }
    function Ig(o, i, f) {
      return o.addEventListener(i, f, !1), f;
    }
    function Kd(o, i, f) {
      return o.addEventListener(i, f, !0), f;
    }
    function Tl(o, i, f, v) {
      return o.addEventListener(i, f, {
        capture: !0,
        passive: v
      }), f;
    }
    function Ih(o, i, f, v) {
      return o.addEventListener(i, f, {
        passive: v
      }), f;
    }
    var $c = null, Ns = null, Eu = null;
    function Cu(o) {
      return $c = o, Ns = jh(), !0;
    }
    function Ah() {
      $c = null, Ns = null, Eu = null;
    }
    function Xd() {
      if (Eu)
        return Eu;
      var o, i = Ns, f = i.length, v, w = jh(), T = w.length;
      for (o = 0; o < f && i[o] === w[o]; o++)
        ;
      var $ = f - o;
      for (v = 1; v <= $ && i[f - v] === w[T - v]; v++)
        ;
      var F = v > 1 ? 1 - v : void 0;
      return Eu = w.slice(o, F), Eu;
    }
    function jh() {
      return "value" in $c ? $c.value : $c.textContent;
    }
    function Mc(o) {
      var i, f = o.keyCode;
      return "charCode" in o ? (i = o.charCode, i === 0 && f === 13 && (i = 13)) : i = f, i === 10 && (i = 13), i >= 32 || i === 13 ? i : 0;
    }
    function Nc() {
      return !0;
    }
    function pa() {
      return !1;
    }
    function xo(o) {
      function i(f, v, w, T, $) {
        this._reactName = f, this._targetInst = w, this.type = v, this.nativeEvent = T, this.target = $, this.currentTarget = null;
        for (var F in o)
          if (o.hasOwnProperty(F)) {
            var W = o[F];
            W ? this[F] = W(T) : this[F] = T[F];
          }
        var ie = T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1;
        return ie ? this.isDefaultPrevented = Nc : this.isDefaultPrevented = pa, this.isPropagationStopped = pa, this;
      }
      return On(i.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var f = this.nativeEvent;
          f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1), this.isDefaultPrevented = Nc);
        },
        stopPropagation: function() {
          var f = this.nativeEvent;
          f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0), this.isPropagationStopped = Nc);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Nc
      }), i;
    }
    var ma = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(o) {
        return o.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ha = xo(ma), Qd = On({}, ma, {
      view: 0,
      detail: 0
    }), Ag = xo(Qd), $p, jg, Ai;
    function Cx(o) {
      o !== Ai && (Ai && o.type === "mousemove" ? ($p = o.screenX - Ai.screenX, jg = o.screenY - Ai.screenY) : ($p = 0, jg = 0), Ai = o);
    }
    var Zd = On({}, Qd, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: zh,
      button: 0,
      buttons: 0,
      relatedTarget: function(o) {
        return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
      },
      movementX: function(o) {
        return "movementX" in o ? o.movementX : (Cx(o), $p);
      },
      movementY: function(o) {
        return "movementY" in o ? o.movementY : jg;
      }
    }), Tu = xo(Zd), Lg = On({}, Zd, {
      dataTransfer: 0
    }), Ic = xo(Lg), Tx = On({}, Qd, {
      relatedTarget: 0
    }), Lh = xo(Tx), Fg = On({}, ma, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Fh = xo(Fg), eO = On({}, ma, {
      clipboardData: function(o) {
        return "clipboardData" in o ? o.clipboardData : window.clipboardData;
      }
    }), tO = xo(eO), _x = On({}, ma, {
      data: 0
    }), zg = xo(_x), Ac = zg, nO = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Jd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Ox(o) {
      if (o.key) {
        var i = nO[o.key] || o.key;
        if (i !== "Unidentified")
          return i;
      }
      if (o.type === "keypress") {
        var f = Mc(o);
        return f === 13 ? "Enter" : String.fromCharCode(f);
      }
      return o.type === "keydown" || o.type === "keyup" ? Jd[o.keyCode] || "Unidentified" : "";
    }
    var uo = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function rO(o) {
      var i = this, f = i.nativeEvent;
      if (f.getModifierState)
        return f.getModifierState(o);
      var v = uo[o];
      return v ? !!f[v] : !1;
    }
    function zh(o) {
      return rO;
    }
    var oO = On({}, Qd, {
      key: Ox,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: zh,
      // Legacy Interface
      charCode: function(o) {
        return o.type === "keypress" ? Mc(o) : 0;
      },
      keyCode: function(o) {
        return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
      },
      which: function(o) {
        return o.type === "keypress" ? Mc(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
      }
    }), aO = xo(oO), Px = On({}, Zd, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Vg = xo(Px), iO = On({}, Qd, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: zh
    }), ji = xo(iO), Ug = On({}, ma, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), sO = xo(Ug), _u = On({}, Zd, {
      deltaX: function(o) {
        return "deltaX" in o ? o.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in o ? -o.wheelDeltaX : 0
        );
      },
      deltaY: function(o) {
        return "deltaY" in o ? o.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in o ? -o.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in o ? -o.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Vh = xo(_u), jc = [9, 13, 27, 32], Mp = 229, Np = Pe && "CompositionEvent" in window, Lc = null;
    Pe && "documentMode" in document && (Lc = document.documentMode);
    var lO = Pe && "TextEvent" in window && !Lc, Uh = Pe && (!Np || Lc && Lc > 8 && Lc <= 11), Rx = 32, Bg = String.fromCharCode(Rx);
    function kx() {
      Fe("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Fe("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Fe("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Fe("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Ip = !1;
    function Bh(o) {
      return (o.ctrlKey || o.altKey || o.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(o.ctrlKey && o.altKey);
    }
    function Dx(o) {
      switch (o) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Hg(o, i) {
      return o === "keydown" && i.keyCode === Mp;
    }
    function $x(o, i) {
      switch (o) {
        case "keyup":
          return jc.indexOf(i.keyCode) !== -1;
        case "keydown":
          return i.keyCode !== Mp;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Wg(o) {
      var i = o.detail;
      return typeof i == "object" && "data" in i ? i.data : null;
    }
    function Hh(o) {
      return o.locale === "ko";
    }
    var _l = !1;
    function Yg(o, i, f, v, w) {
      var T, $;
      if (Np ? T = Dx(i) : _l ? $x(i, v) && (T = "onCompositionEnd") : Hg(i, v) && (T = "onCompositionStart"), !T)
        return null;
      Uh && !Hh(v) && (!_l && T === "onCompositionStart" ? _l = Cu(w) : T === "onCompositionEnd" && _l && ($ = Xd()));
      var F = jx(f, T);
      if (F.length > 0) {
        var W = new zg(T, i, null, v, w);
        if (o.push({
          event: W,
          listeners: F
        }), $)
          W.data = $;
        else {
          var ie = Wg(v);
          ie !== null && (W.data = ie);
        }
      }
    }
    function Wh(o, i) {
      switch (o) {
        case "compositionend":
          return Wg(i);
        case "keypress":
          var f = i.which;
          return f !== Rx ? null : (Ip = !0, Bg);
        case "textInput":
          var v = i.data;
          return v === Bg && Ip ? null : v;
        default:
          return null;
      }
    }
    function Mx(o, i) {
      if (_l) {
        if (o === "compositionend" || !Np && $x(o, i)) {
          var f = Xd();
          return Ah(), _l = !1, f;
        }
        return null;
      }
      switch (o) {
        case "paste":
          return null;
        case "keypress":
          if (!Bh(i)) {
            if (i.char && i.char.length > 1)
              return i.char;
            if (i.which)
              return String.fromCharCode(i.which);
          }
          return null;
        case "compositionend":
          return Uh && !Hh(i) ? null : i.data;
        default:
          return null;
      }
    }
    function uO(o, i, f, v, w) {
      var T;
      if (lO ? T = Wh(i, v) : T = Mx(i, v), !T)
        return null;
      var $ = jx(f, "onBeforeInput");
      if ($.length > 0) {
        var F = new Ac("onBeforeInput", "beforeinput", null, v, w);
        o.push({
          event: F,
          listeners: $
        }), F.data = T;
      }
    }
    function Yh(o, i, f, v, w, T, $) {
      Yg(o, i, f, v, w), uO(o, i, f, v, w);
    }
    var cO = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function ef(o) {
      var i = o && o.nodeName && o.nodeName.toLowerCase();
      return i === "input" ? !!cO[o.type] : i === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function dO(o) {
      if (!Pe)
        return !1;
      var i = "on" + o, f = i in document;
      if (!f) {
        var v = document.createElement("div");
        v.setAttribute(i, "return;"), f = typeof v[i] == "function";
      }
      return f;
    }
    function qh() {
      Fe("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function u(o, i, f, v) {
      Xm(v);
      var w = jx(i, "onChange");
      if (w.length > 0) {
        var T = new ha("onChange", "change", null, f, v);
        o.push({
          event: T,
          listeners: w
        });
      }
    }
    var d = null, y = null;
    function S(o) {
      var i = o.nodeName && o.nodeName.toLowerCase();
      return i === "select" || i === "input" && o.type === "file";
    }
    function k(o) {
      var i = [];
      u(i, y, o, Km(o)), eg(A, i);
    }
    function A(o) {
      hI(o, 0);
    }
    function X(o) {
      var i = Jh(o);
      if (Ed(i))
        return o;
    }
    function ve(o, i) {
      if (o === "change")
        return i;
    }
    var _e = !1;
    Pe && (_e = dO("input") && (!document.documentMode || document.documentMode > 9));
    function Ye(o, i) {
      d = o, y = i, d.attachEvent("onpropertychange", ft);
    }
    function ut() {
      d && (d.detachEvent("onpropertychange", ft), d = null, y = null);
    }
    function ft(o) {
      o.propertyName === "value" && X(y) && k(o);
    }
    function lt(o, i, f) {
      o === "focusin" ? (ut(), Ye(i, f)) : o === "focusout" && ut();
    }
    function $t(o, i) {
      if (o === "selectionchange" || o === "keyup" || o === "keydown")
        return X(y);
    }
    function Yt(o) {
      var i = o.nodeName;
      return i && i.toLowerCase() === "input" && (o.type === "checkbox" || o.type === "radio");
    }
    function Zt(o, i) {
      if (o === "click")
        return X(i);
    }
    function po(o, i) {
      if (o === "input" || o === "change")
        return X(i);
    }
    function Le(o) {
      var i = o._wrapperState;
      !i || !i.controlled || o.type !== "number" || on(o, "number", o.value);
    }
    function ke(o, i, f, v, w, T, $) {
      var F = f ? Jh(f) : window, W, ie;
      if (S(F) ? W = ve : ef(F) ? _e ? W = po : (W = $t, ie = lt) : Yt(F) && (W = Zt), W) {
        var ce = W(i, f);
        if (ce) {
          u(o, ce, v, w);
          return;
        }
      }
      ie && ie(i, F, f), i === "focusout" && Le(F);
    }
    function Ue() {
      me("onMouseEnter", ["mouseout", "mouseover"]), me("onMouseLeave", ["mouseout", "mouseover"]), me("onPointerEnter", ["pointerout", "pointerover"]), me("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function gt(o, i, f, v, w, T, $) {
      var F = i === "mouseover" || i === "pointerover", W = i === "mouseout" || i === "pointerout";
      if (F && !Xw(v)) {
        var ie = v.relatedTarget || v.fromElement;
        if (ie && (Lp(ie) || ib(ie)))
          return;
      }
      if (!(!W && !F)) {
        var ce;
        if (w.window === w)
          ce = w;
        else {
          var De = w.ownerDocument;
          De ? ce = De.defaultView || De.parentWindow : ce = window;
        }
        var Re, Be;
        if (W) {
          var We = v.relatedTarget || v.toElement;
          if (Re = f, Be = We ? Lp(We) : null, Be !== null) {
            var Qe = ii(Be);
            (Be !== Qe || Be.tag !== E && Be.tag !== O) && (Be = null);
          }
        } else
          Re = null, Be = f;
        if (Re !== Be) {
          var It = Tu, rn = "onMouseLeave", en = "onMouseEnter", Vn = "mouse";
          (i === "pointerout" || i === "pointerover") && (It = Vg, rn = "onPointerLeave", en = "onPointerEnter", Vn = "pointer");
          var Nn = Re == null ? ce : Jh(Re), ze = Be == null ? ce : Jh(Be), Ze = new It(rn, Vn + "leave", Re, v, w);
          Ze.target = Nn, Ze.relatedTarget = ze;
          var Ve = null, mt = Lp(w);
          if (mt === f) {
            var At = new It(en, Vn + "enter", Be, v, w);
            At.target = ze, At.relatedTarget = Nn, Ve = At;
          }
          GG(o, Ze, Ve, Re, Be);
        }
      }
    }
    function Jt(o, i) {
      return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i;
    }
    var qt = typeof Object.is == "function" ? Object.is : Jt;
    function tn(o, i) {
      if (qt(o, i))
        return !0;
      if (typeof o != "object" || o === null || typeof i != "object" || i === null)
        return !1;
      var f = Object.keys(o), v = Object.keys(i);
      if (f.length !== v.length)
        return !1;
      for (var w = 0; w < f.length; w++) {
        var T = f[w];
        if (!Ee.call(i, T) || !qt(o[T], i[T]))
          return !1;
      }
      return !0;
    }
    function mn(o) {
      for (; o && o.firstChild; )
        o = o.firstChild;
      return o;
    }
    function Bo(o) {
      for (; o; ) {
        if (o.nextSibling)
          return o.nextSibling;
        o = o.parentNode;
      }
    }
    function Xn(o, i) {
      for (var f = mn(o), v = 0, w = 0; f; ) {
        if (f.nodeType === pl) {
          if (w = v + f.textContent.length, v <= i && w >= i)
            return {
              node: f,
              offset: i - v
            };
          v = w;
        }
        f = mn(Bo(f));
      }
    }
    function Ou(o) {
      var i = o.ownerDocument, f = i && i.defaultView || window, v = f.getSelection && f.getSelection();
      if (!v || v.rangeCount === 0)
        return null;
      var w = v.anchorNode, T = v.anchorOffset, $ = v.focusNode, F = v.focusOffset;
      try {
        w.nodeType, $.nodeType;
      } catch {
        return null;
      }
      return fO(o, w, T, $, F);
    }
    function fO(o, i, f, v, w) {
      var T = 0, $ = -1, F = -1, W = 0, ie = 0, ce = o, De = null;
      e:
        for (; ; ) {
          for (var Re = null; ce === i && (f === 0 || ce.nodeType === pl) && ($ = T + f), ce === v && (w === 0 || ce.nodeType === pl) && (F = T + w), ce.nodeType === pl && (T += ce.nodeValue.length), (Re = ce.firstChild) !== null; )
            De = ce, ce = Re;
          for (; ; ) {
            if (ce === o)
              break e;
            if (De === i && ++W === f && ($ = T), De === v && ++ie === w && (F = T), (Re = ce.nextSibling) !== null)
              break;
            ce = De, De = ce.parentNode;
          }
          ce = Re;
        }
      return $ === -1 || F === -1 ? null : {
        start: $,
        end: F
      };
    }
    function RG(o, i) {
      var f = o.ownerDocument || document, v = f && f.defaultView || window;
      if (v.getSelection) {
        var w = v.getSelection(), T = o.textContent.length, $ = Math.min(i.start, T), F = i.end === void 0 ? $ : Math.min(i.end, T);
        if (!w.extend && $ > F) {
          var W = F;
          F = $, $ = W;
        }
        var ie = Xn(o, $), ce = Xn(o, F);
        if (ie && ce) {
          if (w.rangeCount === 1 && w.anchorNode === ie.node && w.anchorOffset === ie.offset && w.focusNode === ce.node && w.focusOffset === ce.offset)
            return;
          var De = f.createRange();
          De.setStart(ie.node, ie.offset), w.removeAllRanges(), $ > F ? (w.addRange(De), w.extend(ce.node, ce.offset)) : (De.setEnd(ce.node, ce.offset), w.addRange(De));
        }
      }
    }
    function rI(o) {
      return o && o.nodeType === pl;
    }
    function oI(o, i) {
      return !o || !i ? !1 : o === i ? !0 : rI(o) ? !1 : rI(i) ? oI(o, i.parentNode) : "contains" in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1;
    }
    function kG(o) {
      return o && o.ownerDocument && oI(o.ownerDocument.documentElement, o);
    }
    function DG(o) {
      try {
        return typeof o.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function aI() {
      for (var o = window, i = iu(); i instanceof o.HTMLIFrameElement; ) {
        if (DG(i))
          o = i.contentWindow;
        else
          return i;
        i = iu(o.document);
      }
      return i;
    }
    function pO(o) {
      var i = o && o.nodeName && o.nodeName.toLowerCase();
      return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true");
    }
    function $G() {
      var o = aI();
      return {
        focusedElem: o,
        selectionRange: pO(o) ? NG(o) : null
      };
    }
    function MG(o) {
      var i = aI(), f = o.focusedElem, v = o.selectionRange;
      if (i !== f && kG(f)) {
        v !== null && pO(f) && IG(f, v);
        for (var w = [], T = f; T = T.parentNode; )
          T.nodeType === ja && w.push({
            element: T,
            left: T.scrollLeft,
            top: T.scrollTop
          });
        typeof f.focus == "function" && f.focus();
        for (var $ = 0; $ < w.length; $++) {
          var F = w[$];
          F.element.scrollLeft = F.left, F.element.scrollTop = F.top;
        }
      }
    }
    function NG(o) {
      var i;
      return "selectionStart" in o ? i = {
        start: o.selectionStart,
        end: o.selectionEnd
      } : i = Ou(o), i || {
        start: 0,
        end: 0
      };
    }
    function IG(o, i) {
      var f = i.start, v = i.end;
      v === void 0 && (v = f), "selectionStart" in o ? (o.selectionStart = f, o.selectionEnd = Math.min(v, o.value.length)) : RG(o, i);
    }
    var AG = Pe && "documentMode" in document && document.documentMode <= 11;
    function jG() {
      Fe("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Gh = null, mO = null, qg = null, hO = !1;
    function LG(o) {
      if ("selectionStart" in o && pO(o))
        return {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      var i = o.ownerDocument && o.ownerDocument.defaultView || window, f = i.getSelection();
      return {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      };
    }
    function FG(o) {
      return o.window === o ? o.document : o.nodeType === ss ? o : o.ownerDocument;
    }
    function iI(o, i, f) {
      var v = FG(f);
      if (!(hO || Gh == null || Gh !== iu(v))) {
        var w = LG(Gh);
        if (!qg || !tn(qg, w)) {
          qg = w;
          var T = jx(mO, "onSelect");
          if (T.length > 0) {
            var $ = new ha("onSelect", "select", null, i, f);
            o.push({
              event: $,
              listeners: T
            }), $.target = Gh;
          }
        }
      }
    }
    function zG(o, i, f, v, w, T, $) {
      var F = f ? Jh(f) : window;
      switch (i) {
        case "focusin":
          (ef(F) || F.contentEditable === "true") && (Gh = F, mO = f, qg = null);
          break;
        case "focusout":
          Gh = null, mO = null, qg = null;
          break;
        case "mousedown":
          hO = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          hO = !1, iI(o, v, w);
          break;
        case "selectionchange":
          if (AG)
            break;
        case "keydown":
        case "keyup":
          iI(o, v, w);
      }
    }
    function Nx(o, i) {
      var f = {};
      return f[o.toLowerCase()] = i.toLowerCase(), f["Webkit" + o] = "webkit" + i, f["Moz" + o] = "moz" + i, f;
    }
    var Kh = {
      animationend: Nx("Animation", "AnimationEnd"),
      animationiteration: Nx("Animation", "AnimationIteration"),
      animationstart: Nx("Animation", "AnimationStart"),
      transitionend: Nx("Transition", "TransitionEnd")
    }, vO = {}, sI = {};
    Pe && (sI = document.createElement("div").style, "AnimationEvent" in window || (delete Kh.animationend.animation, delete Kh.animationiteration.animation, delete Kh.animationstart.animation), "TransitionEvent" in window || delete Kh.transitionend.transition);
    function Ix(o) {
      if (vO[o])
        return vO[o];
      if (!Kh[o])
        return o;
      var i = Kh[o];
      for (var f in i)
        if (i.hasOwnProperty(f) && f in sI)
          return vO[o] = i[f];
      return o;
    }
    var lI = Ix("animationend"), uI = Ix("animationiteration"), cI = Ix("animationstart"), dI = Ix("transitionend"), fI = /* @__PURE__ */ new Map(), pI = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function tf(o, i) {
      fI.set(o, i), Fe(i, [o]);
    }
    function VG() {
      for (var o = 0; o < pI.length; o++) {
        var i = pI[o], f = i.toLowerCase(), v = i[0].toUpperCase() + i.slice(1);
        tf(f, "on" + v);
      }
      tf(lI, "onAnimationEnd"), tf(uI, "onAnimationIteration"), tf(cI, "onAnimationStart"), tf("dblclick", "onDoubleClick"), tf("focusin", "onFocus"), tf("focusout", "onBlur"), tf(dI, "onTransitionEnd");
    }
    function UG(o, i, f, v, w, T, $) {
      var F = fI.get(i);
      if (F !== void 0) {
        var W = ha, ie = i;
        switch (i) {
          case "keypress":
            if (Mc(v) === 0)
              return;
          case "keydown":
          case "keyup":
            W = aO;
            break;
          case "focusin":
            ie = "focus", W = Lh;
            break;
          case "focusout":
            ie = "blur", W = Lh;
            break;
          case "beforeblur":
          case "afterblur":
            W = Lh;
            break;
          case "click":
            if (v.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            W = Tu;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            W = Ic;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            W = ji;
            break;
          case lI:
          case uI:
          case cI:
            W = Fh;
            break;
          case dI:
            W = sO;
            break;
          case "scroll":
            W = Ag;
            break;
          case "wheel":
            W = Vh;
            break;
          case "copy":
          case "cut":
          case "paste":
            W = tO;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            W = Vg;
            break;
        }
        var ce = (T & pc) !== 0;
        {
          var De = !ce && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          i === "scroll", Re = YG(f, F, v.type, ce, De);
          if (Re.length > 0) {
            var Be = new W(F, ie, null, v, w);
            o.push({
              event: Be,
              listeners: Re
            });
          }
        }
      }
    }
    VG(), Ue(), qh(), jG(), kx();
    function BG(o, i, f, v, w, T, $) {
      UG(o, i, f, v, w, T);
      var F = (T & U_) === 0;
      F && (gt(o, i, f, v, w), ke(o, i, f, v, w), zG(o, i, f, v, w), Yh(o, i, f, v, w));
    }
    var Gg = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], yO = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Gg));
    function mI(o, i, f) {
      var v = o.type || "unknown-event";
      o.currentTarget = f, yl(v, i, void 0, o), o.currentTarget = null;
    }
    function HG(o, i, f) {
      var v;
      if (f)
        for (var w = i.length - 1; w >= 0; w--) {
          var T = i[w], $ = T.instance, F = T.currentTarget, W = T.listener;
          if ($ !== v && o.isPropagationStopped())
            return;
          mI(o, W, F), v = $;
        }
      else
        for (var ie = 0; ie < i.length; ie++) {
          var ce = i[ie], De = ce.instance, Re = ce.currentTarget, Be = ce.listener;
          if (De !== v && o.isPropagationStopped())
            return;
          mI(o, Be, Re), v = De;
        }
    }
    function hI(o, i) {
      for (var f = (i & pc) !== 0, v = 0; v < o.length; v++) {
        var w = o[v], T = w.event, $ = w.listeners;
        HG(T, $, f);
      }
      og();
    }
    function WG(o, i, f, v, w) {
      var T = Km(f), $ = [];
      BG($, o, v, f, T, i), hI($, i);
    }
    function oo(o, i) {
      yO.has(o) || l('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', o);
      var f = !1, v = xX(i), w = KG(o, f);
      v.has(w) || (vI(i, o, ip, f), v.add(w));
    }
    function gO(o, i, f) {
      yO.has(o) && !i && l('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', o);
      var v = 0;
      i && (v |= pc), vI(f, o, v, i);
    }
    var Ax = "_reactListening" + Math.random().toString(36).slice(2);
    function Kg(o) {
      if (!o[Ax]) {
        o[Ax] = !0, pe.forEach(function(f) {
          f !== "selectionchange" && (yO.has(f) || gO(f, !1, o), gO(f, !0, o));
        });
        var i = o.nodeType === ss ? o : o.ownerDocument;
        i !== null && (i[Ax] || (i[Ax] = !0, gO("selectionchange", !1, i)));
      }
    }
    function vI(o, i, f, v, w) {
      var T = qd(o, i, f), $ = void 0;
      dp && (i === "touchstart" || i === "touchmove" || i === "wheel") && ($ = !0), o = o, v ? $ !== void 0 ? Tl(o, i, T, $) : Kd(o, i, T) : $ !== void 0 ? Ih(o, i, T, $) : Ig(o, i, T);
    }
    function yI(o, i) {
      return o === i || o.nodeType === bo && o.parentNode === i;
    }
    function bO(o, i, f, v, w) {
      var T = v;
      if (!(i & hl) && !(i & ip)) {
        var $ = w;
        if (v !== null) {
          var F = v;
          e:
            for (; ; ) {
              if (F === null)
                return;
              var W = F.tag;
              if (W === b || W === x) {
                var ie = F.stateNode.containerInfo;
                if (yI(ie, $))
                  break;
                if (W === x)
                  for (var ce = F.return; ce !== null; ) {
                    var De = ce.tag;
                    if (De === b || De === x) {
                      var Re = ce.stateNode.containerInfo;
                      if (yI(Re, $))
                        return;
                    }
                    ce = ce.return;
                  }
                for (; ie !== null; ) {
                  var Be = Lp(ie);
                  if (Be === null)
                    return;
                  var We = Be.tag;
                  if (We === E || We === O) {
                    F = T = Be;
                    continue e;
                  }
                  ie = ie.parentNode;
                }
              }
              F = F.return;
            }
        }
      }
      eg(function() {
        return WG(o, i, f, T);
      });
    }
    function Xg(o, i, f) {
      return {
        instance: o,
        listener: i,
        currentTarget: f
      };
    }
    function YG(o, i, f, v, w, T) {
      for (var $ = i !== null ? i + "Capture" : null, F = v ? $ : i, W = [], ie = o, ce = null; ie !== null; ) {
        var De = ie, Re = De.stateNode, Be = De.tag;
        if (Be === E && Re !== null && (ce = Re, F !== null)) {
          var We = hc(ie, F);
          We != null && W.push(Xg(ie, We, ce));
        }
        if (w)
          break;
        ie = ie.return;
      }
      return W;
    }
    function jx(o, i) {
      for (var f = i + "Capture", v = [], w = o; w !== null; ) {
        var T = w, $ = T.stateNode, F = T.tag;
        if (F === E && $ !== null) {
          var W = $, ie = hc(w, f);
          ie != null && v.unshift(Xg(w, ie, W));
          var ce = hc(w, i);
          ce != null && v.push(Xg(w, ce, W));
        }
        w = w.return;
      }
      return v;
    }
    function Xh(o) {
      if (o === null)
        return null;
      do
        o = o.return;
      while (o && o.tag !== E);
      return o || null;
    }
    function qG(o, i) {
      for (var f = o, v = i, w = 0, T = f; T; T = Xh(T))
        w++;
      for (var $ = 0, F = v; F; F = Xh(F))
        $++;
      for (; w - $ > 0; )
        f = Xh(f), w--;
      for (; $ - w > 0; )
        v = Xh(v), $--;
      for (var W = w; W--; ) {
        if (f === v || v !== null && f === v.alternate)
          return f;
        f = Xh(f), v = Xh(v);
      }
      return null;
    }
    function gI(o, i, f, v, w) {
      for (var T = i._reactName, $ = [], F = f; F !== null && F !== v; ) {
        var W = F, ie = W.alternate, ce = W.stateNode, De = W.tag;
        if (ie !== null && ie === v)
          break;
        if (De === E && ce !== null) {
          var Re = ce;
          if (w) {
            var Be = hc(F, T);
            Be != null && $.unshift(Xg(F, Be, Re));
          } else if (!w) {
            var We = hc(F, T);
            We != null && $.push(Xg(F, We, Re));
          }
        }
        F = F.return;
      }
      $.length !== 0 && o.push({
        event: i,
        listeners: $
      });
    }
    function GG(o, i, f, v, w) {
      var T = v && w ? qG(v, w) : null;
      v !== null && gI(o, i, v, T, !1), w !== null && f !== null && gI(o, f, w, T, !0);
    }
    function KG(o, i) {
      return o + "__" + (i ? "capture" : "bubble");
    }
    var Li = !1, Qg = "dangerouslySetInnerHTML", Lx = "suppressContentEditableWarning", nf = "suppressHydrationWarning", bI = "autoFocus", Ap = "children", jp = "style", Fx = "__html", wO, zx, Zg, wI, Vx, xI, SI;
    wO = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, zx = function(o, i) {
      Gm(o, i), Ky(o, i), Kw(o, i, {
        registrationNameDependencies: ye,
        possibleRegistrationNames: Oe
      });
    }, xI = Pe && !document.documentMode, Zg = function(o, i, f) {
      if (!Li) {
        var v = Ux(f), w = Ux(i);
        w !== v && (Li = !0, l("Prop `%s` did not match. Server: %s Client: %s", o, JSON.stringify(w), JSON.stringify(v)));
      }
    }, wI = function(o) {
      if (!Li) {
        Li = !0;
        var i = [];
        o.forEach(function(f) {
          i.push(f);
        }), l("Extra attributes from the server: %s", i);
      }
    }, Vx = function(o, i) {
      i === !1 ? l("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", o, o, o) : l("Expected `%s` listener to be a function, instead got a value of `%s` type.", o, typeof i);
    }, SI = function(o, i) {
      var f = o.namespaceURI === fl ? o.ownerDocument.createElement(o.tagName) : o.ownerDocument.createElementNS(o.namespaceURI, o.tagName);
      return f.innerHTML = i, f.innerHTML;
    };
    var XG = /\r\n?/g, QG = /\u0000|\uFFFD/g;
    function Ux(o) {
      qe(o);
      var i = typeof o == "string" ? o : "" + o;
      return i.replace(XG, `
`).replace(QG, "");
    }
    function Bx(o, i, f, v) {
      var w = Ux(i), T = Ux(o);
      if (T !== w && (v && (Li || (Li = !0, l('Text content did not match. Server: "%s" Client: "%s"', T, w))), f && ne))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function EI(o) {
      return o.nodeType === ss ? o : o.ownerDocument;
    }
    function ZG() {
    }
    function Hx(o) {
      o.onclick = ZG;
    }
    function JG(o, i, f, v, w) {
      for (var T in v)
        if (v.hasOwnProperty(T)) {
          var $ = v[T];
          if (T === jp)
            $ && Object.freeze($), Fw(i, $);
          else if (T === Qg) {
            var F = $ ? $[Fx] : void 0;
            F != null && Pw(i, F);
          } else if (T === Ap)
            if (typeof $ == "string") {
              var W = o !== "textarea" || $ !== "";
              W && Hm(i, $);
            } else
              typeof $ == "number" && Hm(i, "" + $);
          else
            T === Lx || T === nf || T === bI || (ye.hasOwnProperty(T) ? $ != null && (typeof $ != "function" && Vx(T, $), T === "onScroll" && oo("scroll", i)) : $ != null && dr(i, T, $, w));
        }
    }
    function eK(o, i, f, v) {
      for (var w = 0; w < i.length; w += 2) {
        var T = i[w], $ = i[w + 1];
        T === jp ? Fw(o, $) : T === Qg ? Pw(o, $) : T === Ap ? Hm(o, $) : dr(o, T, $, v);
      }
    }
    function tK(o, i, f, v) {
      var w, T = EI(f), $, F = v;
      if (F === fl && (F = Um(o)), F === fl) {
        if (w = ml(o, i), !w && o !== o.toLowerCase() && l("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", o), o === "script") {
          var W = T.createElement("div");
          W.innerHTML = "<script><\/script>";
          var ie = W.firstChild;
          $ = W.removeChild(ie);
        } else if (typeof i.is == "string")
          $ = T.createElement(o, {
            is: i.is
          });
        else if ($ = T.createElement(o), o === "select") {
          var ce = $;
          i.multiple ? ce.multiple = !0 : i.size && (ce.size = i.size);
        }
      } else
        $ = T.createElementNS(F, o);
      return F === fl && !w && Object.prototype.toString.call($) === "[object HTMLUnknownElement]" && !Ee.call(wO, o) && (wO[o] = !0, l("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", o)), $;
    }
    function nK(o, i) {
      return EI(i).createTextNode(o);
    }
    function rK(o, i, f, v) {
      var w = ml(i, f);
      zx(i, f);
      var T;
      switch (i) {
        case "dialog":
          oo("cancel", o), oo("close", o), T = f;
          break;
        case "iframe":
        case "object":
        case "embed":
          oo("load", o), T = f;
          break;
        case "video":
        case "audio":
          for (var $ = 0; $ < Gg.length; $++)
            oo(Gg[$], o);
          T = f;
          break;
        case "source":
          oo("error", o), T = f;
          break;
        case "img":
        case "image":
        case "link":
          oo("error", o), oo("load", o), T = f;
          break;
        case "details":
          oo("toggle", o), T = f;
          break;
        case "input":
          xe(o, f), T = G(o, f), oo("invalid", o);
          break;
        case "option":
          yr(o, f), T = f;
          break;
        case "select":
          np(o, f), T = tp(o, f), oo("invalid", o);
          break;
        case "textarea":
          Tw(o, f), T = zy(o, f), oo("invalid", o);
          break;
        default:
          T = f;
      }
      switch (Ym(i, T), JG(i, o, v, T, w), i) {
        case "input":
          Ti(o), yt(o, f, !1);
          break;
        case "textarea":
          Ti(o), Ow(o);
          break;
        case "option":
          Mr(o, f);
          break;
        case "select":
          Ly(o, f);
          break;
        default:
          typeof T.onClick == "function" && Hx(o);
          break;
      }
    }
    function oK(o, i, f, v, w) {
      zx(i, v);
      var T = null, $, F;
      switch (i) {
        case "input":
          $ = G(o, f), F = G(o, v), T = [];
          break;
        case "select":
          $ = tp(o, f), F = tp(o, v), T = [];
          break;
        case "textarea":
          $ = zy(o, f), F = zy(o, v), T = [];
          break;
        default:
          $ = f, F = v, typeof $.onClick != "function" && typeof F.onClick == "function" && Hx(o);
          break;
      }
      Ym(i, F);
      var W, ie, ce = null;
      for (W in $)
        if (!(F.hasOwnProperty(W) || !$.hasOwnProperty(W) || $[W] == null))
          if (W === jp) {
            var De = $[W];
            for (ie in De)
              De.hasOwnProperty(ie) && (ce || (ce = {}), ce[ie] = "");
          } else
            W === Qg || W === Ap || W === Lx || W === nf || W === bI || (ye.hasOwnProperty(W) ? T || (T = []) : (T = T || []).push(W, null));
      for (W in F) {
        var Re = F[W], Be = $ != null ? $[W] : void 0;
        if (!(!F.hasOwnProperty(W) || Re === Be || Re == null && Be == null))
          if (W === jp)
            if (Re && Object.freeze(Re), Be) {
              for (ie in Be)
                Be.hasOwnProperty(ie) && (!Re || !Re.hasOwnProperty(ie)) && (ce || (ce = {}), ce[ie] = "");
              for (ie in Re)
                Re.hasOwnProperty(ie) && Be[ie] !== Re[ie] && (ce || (ce = {}), ce[ie] = Re[ie]);
            } else
              ce || (T || (T = []), T.push(W, ce)), ce = Re;
          else if (W === Qg) {
            var We = Re ? Re[Fx] : void 0, Qe = Be ? Be[Fx] : void 0;
            We != null && Qe !== We && (T = T || []).push(W, We);
          } else
            W === Ap ? (typeof Re == "string" || typeof Re == "number") && (T = T || []).push(W, "" + Re) : W === Lx || W === nf || (ye.hasOwnProperty(W) ? (Re != null && (typeof Re != "function" && Vx(W, Re), W === "onScroll" && oo("scroll", o)), !T && Be !== Re && (T = [])) : (T = T || []).push(W, Re));
      }
      return ce && (op(ce, F[jp]), (T = T || []).push(jp, ce)), T;
    }
    function aK(o, i, f, v, w) {
      f === "input" && w.type === "radio" && w.name != null && He(o, w);
      var T = ml(f, v), $ = ml(f, w);
      switch (eK(o, i, T, $), f) {
        case "input":
          Xe(o, w);
          break;
        case "textarea":
          _w(o, w);
          break;
        case "select":
          $_(o, w);
          break;
      }
    }
    function iK(o) {
      {
        var i = o.toLowerCase();
        return qm.hasOwnProperty(i) && qm[i] || null;
      }
    }
    function sK(o, i, f, v, w, T, $) {
      var F, W;
      switch (F = ml(i, f), zx(i, f), i) {
        case "dialog":
          oo("cancel", o), oo("close", o);
          break;
        case "iframe":
        case "object":
        case "embed":
          oo("load", o);
          break;
        case "video":
        case "audio":
          for (var ie = 0; ie < Gg.length; ie++)
            oo(Gg[ie], o);
          break;
        case "source":
          oo("error", o);
          break;
        case "img":
        case "image":
        case "link":
          oo("error", o), oo("load", o);
          break;
        case "details":
          oo("toggle", o);
          break;
        case "input":
          xe(o, f), oo("invalid", o);
          break;
        case "option":
          yr(o, f);
          break;
        case "select":
          np(o, f), oo("invalid", o);
          break;
        case "textarea":
          Tw(o, f), oo("invalid", o);
          break;
      }
      Ym(i, f);
      {
        W = /* @__PURE__ */ new Set();
        for (var ce = o.attributes, De = 0; De < ce.length; De++) {
          var Re = ce[De].name.toLowerCase();
          switch (Re) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              W.add(ce[De].name);
          }
        }
      }
      var Be = null;
      for (var We in f)
        if (f.hasOwnProperty(We)) {
          var Qe = f[We];
          if (We === Ap)
            typeof Qe == "string" ? o.textContent !== Qe && (f[nf] !== !0 && Bx(o.textContent, Qe, T, $), Be = [Ap, Qe]) : typeof Qe == "number" && o.textContent !== "" + Qe && (f[nf] !== !0 && Bx(o.textContent, Qe, T, $), Be = [Ap, "" + Qe]);
          else if (ye.hasOwnProperty(We))
            Qe != null && (typeof Qe != "function" && Vx(We, Qe), We === "onScroll" && oo("scroll", o));
          else if ($ && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof F == "boolean") {
            var It = void 0, rn = F && ue ? null : Pn(We);
            if (f[nf] !== !0) {
              if (!(We === Lx || We === nf || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              We === "value" || We === "checked" || We === "selected")) {
                if (We === Qg) {
                  var en = o.innerHTML, Vn = Qe ? Qe[Fx] : void 0;
                  if (Vn != null) {
                    var Nn = SI(o, Vn);
                    Nn !== en && Zg(We, en, Nn);
                  }
                } else if (We === jp) {
                  if (W.delete(We), xI) {
                    var ze = z_(Qe);
                    It = o.getAttribute("style"), ze !== It && Zg(We, It, ze);
                  }
                } else if (F && !ue)
                  W.delete(We.toLowerCase()), It = Jr(o, We, Qe), Qe !== It && Zg(We, It, Qe);
                else if (!Nt(We, rn, F) && !bt(We, Qe, rn, F)) {
                  var Ze = !1;
                  if (rn !== null)
                    W.delete(rn.attributeName), It = Yn(o, We, Qe, rn);
                  else {
                    var Ve = v;
                    if (Ve === fl && (Ve = Um(i)), Ve === fl)
                      W.delete(We.toLowerCase());
                    else {
                      var mt = iK(We);
                      mt !== null && mt !== We && (Ze = !0, W.delete(mt)), W.delete(We);
                    }
                    It = Jr(o, We, Qe);
                  }
                  var At = ue;
                  !At && Qe !== It && !Ze && Zg(We, It, Qe);
                }
              }
            }
          }
        }
      switch ($ && // $FlowFixMe - Should be inferred as not undefined.
      W.size > 0 && f[nf] !== !0 && wI(W), i) {
        case "input":
          Ti(o), yt(o, f, !0);
          break;
        case "textarea":
          Ti(o), Ow(o);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof f.onClick == "function" && Hx(o);
          break;
      }
      return Be;
    }
    function lK(o, i, f) {
      var v = o.nodeValue !== i;
      return v;
    }
    function xO(o, i) {
      {
        if (Li)
          return;
        Li = !0, l("Did not expect server HTML to contain a <%s> in <%s>.", i.nodeName.toLowerCase(), o.nodeName.toLowerCase());
      }
    }
    function SO(o, i) {
      {
        if (Li)
          return;
        Li = !0, l('Did not expect server HTML to contain the text node "%s" in <%s>.', i.nodeValue, o.nodeName.toLowerCase());
      }
    }
    function EO(o, i, f) {
      {
        if (Li)
          return;
        Li = !0, l("Expected server HTML to contain a matching <%s> in <%s>.", i, o.nodeName.toLowerCase());
      }
    }
    function CO(o, i) {
      {
        if (i === "" || Li)
          return;
        Li = !0, l('Expected server HTML to contain a matching text node for "%s" in <%s>.', i, o.nodeName.toLowerCase());
      }
    }
    function uK(o, i, f) {
      switch (i) {
        case "input":
          sn(o, f);
          return;
        case "textarea":
          Vy(o, f);
          return;
        case "select":
          M_(o, f);
          return;
      }
    }
    var Jg = function() {
    }, eb = function() {
    };
    {
      var cK = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], CI = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], dK = CI.concat(["button"]), fK = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], TI = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      eb = function(o, i) {
        var f = On({}, o || TI), v = {
          tag: i
        };
        return CI.indexOf(i) !== -1 && (f.aTagInScope = null, f.buttonTagInScope = null, f.nobrTagInScope = null), dK.indexOf(i) !== -1 && (f.pTagInButtonScope = null), cK.indexOf(i) !== -1 && i !== "address" && i !== "div" && i !== "p" && (f.listItemTagAutoclosing = null, f.dlItemTagAutoclosing = null), f.current = v, i === "form" && (f.formTag = v), i === "a" && (f.aTagInScope = v), i === "button" && (f.buttonTagInScope = v), i === "nobr" && (f.nobrTagInScope = v), i === "p" && (f.pTagInButtonScope = v), i === "li" && (f.listItemTagAutoclosing = v), (i === "dd" || i === "dt") && (f.dlItemTagAutoclosing = v), f;
      };
      var pK = function(o, i) {
        switch (i) {
          case "select":
            return o === "option" || o === "optgroup" || o === "#text";
          case "optgroup":
            return o === "option" || o === "#text";
          case "option":
            return o === "#text";
          case "tr":
            return o === "th" || o === "td" || o === "style" || o === "script" || o === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return o === "tr" || o === "style" || o === "script" || o === "template";
          case "colgroup":
            return o === "col" || o === "template";
          case "table":
            return o === "caption" || o === "colgroup" || o === "tbody" || o === "tfoot" || o === "thead" || o === "style" || o === "script" || o === "template";
          case "head":
            return o === "base" || o === "basefont" || o === "bgsound" || o === "link" || o === "meta" || o === "title" || o === "noscript" || o === "noframes" || o === "style" || o === "script" || o === "template";
          case "html":
            return o === "head" || o === "body" || o === "frameset";
          case "frameset":
            return o === "frame";
          case "#document":
            return o === "html";
        }
        switch (o) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return i !== "h1" && i !== "h2" && i !== "h3" && i !== "h4" && i !== "h5" && i !== "h6";
          case "rp":
          case "rt":
            return fK.indexOf(i) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return i == null;
        }
        return !0;
      }, mK = function(o, i) {
        switch (o) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return i.pTagInButtonScope;
          case "form":
            return i.formTag || i.pTagInButtonScope;
          case "li":
            return i.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return i.dlItemTagAutoclosing;
          case "button":
            return i.buttonTagInScope;
          case "a":
            return i.aTagInScope;
          case "nobr":
            return i.nobrTagInScope;
        }
        return null;
      }, _I = {};
      Jg = function(o, i, f) {
        f = f || TI;
        var v = f.current, w = v && v.tag;
        i != null && (o != null && l("validateDOMNesting: when childText is passed, childTag should be null"), o = "#text");
        var T = pK(o, w) ? null : v, $ = T ? null : mK(o, f), F = T || $;
        if (F) {
          var W = F.tag, ie = !!T + "|" + o + "|" + W;
          if (!_I[ie]) {
            _I[ie] = !0;
            var ce = o, De = "";
            if (o === "#text" ? /\S/.test(i) ? ce = "Text nodes" : (ce = "Whitespace text nodes", De = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ce = "<" + o + ">", T) {
              var Re = "";
              W === "table" && o === "tr" && (Re += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), l("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ce, W, De, Re);
            } else
              l("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ce, W);
          }
        }
      };
    }
    var Wx = "suppressHydrationWarning", Yx = "$", qx = "/$", tb = "$?", nb = "$!", hK = "style", TO = null, _O = null;
    function vK(o) {
      var i, f, v = o.nodeType;
      switch (v) {
        case ss:
        case dc: {
          i = v === ss ? "#document" : "#fragment";
          var w = o.documentElement;
          f = w ? w.namespaceURI : By(null, "");
          break;
        }
        default: {
          var T = v === bo ? o.parentNode : o, $ = T.namespaceURI || null;
          i = T.tagName, f = By($, i);
          break;
        }
      }
      {
        var F = i.toLowerCase(), W = eb(null, F);
        return {
          namespace: f,
          ancestorInfo: W
        };
      }
    }
    function yK(o, i, f) {
      {
        var v = o, w = By(v.namespace, i), T = eb(v.ancestorInfo, i);
        return {
          namespace: w,
          ancestorInfo: T
        };
      }
    }
    function uje(o) {
      return o;
    }
    function gK(o) {
      TO = ci(), _O = $G();
      var i = null;
      return Uo(!1), i;
    }
    function bK(o) {
      MG(_O), Uo(TO), TO = null, _O = null;
    }
    function wK(o, i, f, v, w) {
      var T;
      {
        var $ = v;
        if (Jg(o, null, $.ancestorInfo), typeof i.children == "string" || typeof i.children == "number") {
          var F = "" + i.children, W = eb($.ancestorInfo, o);
          Jg(null, F, W);
        }
        T = $.namespace;
      }
      var ie = tK(o, i, f, T);
      return ab(w, ie), NO(ie, i), ie;
    }
    function xK(o, i) {
      o.appendChild(i);
    }
    function SK(o, i, f, v, w) {
      switch (rK(o, i, f, v), i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!f.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function EK(o, i, f, v, w, T) {
      {
        var $ = T;
        if (typeof v.children != typeof f.children && (typeof v.children == "string" || typeof v.children == "number")) {
          var F = "" + v.children, W = eb($.ancestorInfo, i);
          Jg(null, F, W);
        }
      }
      return oK(o, i, f, v);
    }
    function OO(o, i) {
      return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
    }
    function CK(o, i, f, v) {
      {
        var w = f;
        Jg(null, o, w.ancestorInfo);
      }
      var T = nK(o, i);
      return ab(v, T), T;
    }
    function TK() {
      var o = window.event;
      return o === void 0 ? Sl : ba(o.type);
    }
    var PO = typeof setTimeout == "function" ? setTimeout : void 0, _K = typeof clearTimeout == "function" ? clearTimeout : void 0, RO = -1, OI = typeof Promise == "function" ? Promise : void 0, OK = typeof queueMicrotask == "function" ? queueMicrotask : typeof OI < "u" ? function(o) {
      return OI.resolve(null).then(o).catch(PK);
    } : PO;
    function PK(o) {
      setTimeout(function() {
        throw o;
      });
    }
    function RK(o, i, f, v) {
      switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          f.autoFocus && o.focus();
          return;
        case "img": {
          f.src && (o.src = f.src);
          return;
        }
      }
    }
    function kK(o, i, f, v, w, T) {
      aK(o, i, f, v, w), NO(o, w);
    }
    function PI(o) {
      Hm(o, "");
    }
    function DK(o, i, f) {
      o.nodeValue = f;
    }
    function $K(o, i) {
      o.appendChild(i);
    }
    function MK(o, i) {
      var f;
      o.nodeType === bo ? (f = o.parentNode, f.insertBefore(i, o)) : (f = o, f.appendChild(i));
      var v = o._reactRootContainer;
      v == null && f.onclick === null && Hx(f);
    }
    function NK(o, i, f) {
      o.insertBefore(i, f);
    }
    function IK(o, i, f) {
      o.nodeType === bo ? o.parentNode.insertBefore(i, f) : o.insertBefore(i, f);
    }
    function AK(o, i) {
      o.removeChild(i);
    }
    function jK(o, i) {
      o.nodeType === bo ? o.parentNode.removeChild(i) : o.removeChild(i);
    }
    function kO(o, i) {
      var f = i, v = 0;
      do {
        var w = f.nextSibling;
        if (o.removeChild(f), w && w.nodeType === bo) {
          var T = w.data;
          if (T === qx)
            if (v === 0) {
              o.removeChild(w), Mn(i);
              return;
            } else
              v--;
          else
            (T === Yx || T === tb || T === nb) && v++;
        }
        f = w;
      } while (f);
      Mn(i);
    }
    function LK(o, i) {
      o.nodeType === bo ? kO(o.parentNode, i) : o.nodeType === ja && kO(o, i), Mn(o);
    }
    function FK(o) {
      o = o;
      var i = o.style;
      typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none";
    }
    function zK(o) {
      o.nodeValue = "";
    }
    function VK(o, i) {
      o = o;
      var f = i[hK], v = f != null && f.hasOwnProperty("display") ? f.display : null;
      o.style.display = Wm("display", v);
    }
    function UK(o, i) {
      o.nodeValue = i;
    }
    function BK(o) {
      o.nodeType === ja ? o.textContent = "" : o.nodeType === ss && o.documentElement && o.removeChild(o.documentElement);
    }
    function HK(o, i, f) {
      return o.nodeType !== ja || i.toLowerCase() !== o.nodeName.toLowerCase() ? null : o;
    }
    function WK(o, i) {
      return i === "" || o.nodeType !== pl ? null : o;
    }
    function YK(o) {
      return o.nodeType !== bo ? null : o;
    }
    function RI(o) {
      return o.data === tb;
    }
    function DO(o) {
      return o.data === nb;
    }
    function qK(o) {
      var i = o.nextSibling && o.nextSibling.dataset, f, v, w;
      return i && (f = i.dgst, v = i.msg, w = i.stck), {
        message: v,
        digest: f,
        stack: w
      };
    }
    function GK(o, i) {
      o._reactRetry = i;
    }
    function Gx(o) {
      for (; o != null; o = o.nextSibling) {
        var i = o.nodeType;
        if (i === ja || i === pl)
          break;
        if (i === bo) {
          var f = o.data;
          if (f === Yx || f === nb || f === tb)
            break;
          if (f === qx)
            return null;
        }
      }
      return o;
    }
    function rb(o) {
      return Gx(o.nextSibling);
    }
    function KK(o) {
      return Gx(o.firstChild);
    }
    function XK(o) {
      return Gx(o.firstChild);
    }
    function QK(o) {
      return Gx(o.nextSibling);
    }
    function ZK(o, i, f, v, w, T, $) {
      ab(T, o), NO(o, f);
      var F;
      {
        var W = w;
        F = W.namespace;
      }
      var ie = (T.mode & kn) !== an;
      return sK(o, i, f, F, v, ie, $);
    }
    function JK(o, i, f, v) {
      return ab(f, o), f.mode & kn, lK(o, i);
    }
    function eX(o, i) {
      ab(i, o);
    }
    function tX(o) {
      for (var i = o.nextSibling, f = 0; i; ) {
        if (i.nodeType === bo) {
          var v = i.data;
          if (v === qx) {
            if (f === 0)
              return rb(i);
            f--;
          } else
            (v === Yx || v === nb || v === tb) && f++;
        }
        i = i.nextSibling;
      }
      return null;
    }
    function kI(o) {
      for (var i = o.previousSibling, f = 0; i; ) {
        if (i.nodeType === bo) {
          var v = i.data;
          if (v === Yx || v === nb || v === tb) {
            if (f === 0)
              return i;
            f--;
          } else
            v === qx && f++;
        }
        i = i.previousSibling;
      }
      return null;
    }
    function nX(o) {
      Mn(o);
    }
    function rX(o) {
      Mn(o);
    }
    function oX(o) {
      return o !== "head" && o !== "body";
    }
    function aX(o, i, f, v) {
      var w = !0;
      Bx(i.nodeValue, f, v, w);
    }
    function iX(o, i, f, v, w, T) {
      if (i[Wx] !== !0) {
        var $ = !0;
        Bx(v.nodeValue, w, T, $);
      }
    }
    function sX(o, i) {
      i.nodeType === ja ? xO(o, i) : i.nodeType === bo || SO(o, i);
    }
    function lX(o, i) {
      {
        var f = o.parentNode;
        f !== null && (i.nodeType === ja ? xO(f, i) : i.nodeType === bo || SO(f, i));
      }
    }
    function uX(o, i, f, v, w) {
      (w || i[Wx] !== !0) && (v.nodeType === ja ? xO(f, v) : v.nodeType === bo || SO(f, v));
    }
    function cX(o, i, f) {
      EO(o, i);
    }
    function dX(o, i) {
      CO(o, i);
    }
    function fX(o, i, f) {
      {
        var v = o.parentNode;
        v !== null && EO(v, i);
      }
    }
    function pX(o, i) {
      {
        var f = o.parentNode;
        f !== null && CO(f, i);
      }
    }
    function mX(o, i, f, v, w, T) {
      (T || i[Wx] !== !0) && EO(f, v);
    }
    function hX(o, i, f, v, w) {
      (w || i[Wx] !== !0) && CO(f, v);
    }
    function vX(o) {
      l("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", o.nodeName.toLowerCase());
    }
    function yX(o) {
      Kg(o);
    }
    var Qh = Math.random().toString(36).slice(2), Zh = "__reactFiber$" + Qh, $O = "__reactProps$" + Qh, ob = "__reactContainer$" + Qh, MO = "__reactEvents$" + Qh, gX = "__reactListeners$" + Qh, bX = "__reactHandles$" + Qh;
    function wX(o) {
      delete o[Zh], delete o[$O], delete o[MO], delete o[gX], delete o[bX];
    }
    function ab(o, i) {
      i[Zh] = o;
    }
    function Kx(o, i) {
      i[ob] = o;
    }
    function DI(o) {
      o[ob] = null;
    }
    function ib(o) {
      return !!o[ob];
    }
    function Lp(o) {
      var i = o[Zh];
      if (i)
        return i;
      for (var f = o.parentNode; f; ) {
        if (i = f[ob] || f[Zh], i) {
          var v = i.alternate;
          if (i.child !== null || v !== null && v.child !== null)
            for (var w = kI(o); w !== null; ) {
              var T = w[Zh];
              if (T)
                return T;
              w = kI(w);
            }
          return i;
        }
        o = f, f = o.parentNode;
      }
      return null;
    }
    function rf(o) {
      var i = o[Zh] || o[ob];
      return i && (i.tag === E || i.tag === O || i.tag === R || i.tag === b) ? i : null;
    }
    function Jh(o) {
      if (o.tag === E || o.tag === O)
        return o.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Xx(o) {
      return o[$O] || null;
    }
    function NO(o, i) {
      o[$O] = i;
    }
    function xX(o) {
      var i = o[MO];
      return i === void 0 && (i = o[MO] = /* @__PURE__ */ new Set()), i;
    }
    var $I = {}, MI = n.ReactDebugCurrentFrame;
    function Qx(o) {
      if (o) {
        var i = o._owner, f = _s(o.type, o._source, i ? i.type : null);
        MI.setExtraStackFrame(f);
      } else
        MI.setExtraStackFrame(null);
    }
    function Ol(o, i, f, v, w) {
      {
        var T = Function.call.bind(Ee);
        for (var $ in o)
          if (T(o, $)) {
            var F = void 0;
            try {
              if (typeof o[$] != "function") {
                var W = Error((v || "React class") + ": " + f + " type `" + $ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[$] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw W.name = "Invariant Violation", W;
              }
              F = o[$](i, $, v, f, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ie) {
              F = ie;
            }
            F && !(F instanceof Error) && (Qx(w), l("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", v || "React class", f, $, typeof F), Qx(null)), F instanceof Error && !(F.message in $I) && ($I[F.message] = !0, Qx(w), l("Failed %s type: %s", f, F.message), Qx(null));
          }
      }
    }
    var IO = [], Zx;
    Zx = [];
    var Fc = -1;
    function of(o) {
      return {
        current: o
      };
    }
    function Ya(o, i) {
      if (Fc < 0) {
        l("Unexpected pop.");
        return;
      }
      i !== Zx[Fc] && l("Unexpected Fiber popped."), o.current = IO[Fc], IO[Fc] = null, Zx[Fc] = null, Fc--;
    }
    function qa(o, i, f) {
      Fc++, IO[Fc] = o.current, Zx[Fc] = f, o.current = i;
    }
    var AO;
    AO = {};
    var fs = {};
    Object.freeze(fs);
    var zc = of(fs), Pu = of(!1), jO = fs;
    function ev(o, i, f) {
      return f && Ru(i) ? jO : zc.current;
    }
    function NI(o, i, f) {
      {
        var v = o.stateNode;
        v.__reactInternalMemoizedUnmaskedChildContext = i, v.__reactInternalMemoizedMaskedChildContext = f;
      }
    }
    function tv(o, i) {
      {
        var f = o.type, v = f.contextTypes;
        if (!v)
          return fs;
        var w = o.stateNode;
        if (w && w.__reactInternalMemoizedUnmaskedChildContext === i)
          return w.__reactInternalMemoizedMaskedChildContext;
        var T = {};
        for (var $ in v)
          T[$] = i[$];
        {
          var F = gn(o) || "Unknown";
          Ol(v, T, "context", F);
        }
        return w && NI(o, i, T), T;
      }
    }
    function Jx() {
      return Pu.current;
    }
    function Ru(o) {
      {
        var i = o.childContextTypes;
        return i != null;
      }
    }
    function eS(o) {
      Ya(Pu, o), Ya(zc, o);
    }
    function LO(o) {
      Ya(Pu, o), Ya(zc, o);
    }
    function II(o, i, f) {
      {
        if (zc.current !== fs)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        qa(zc, i, o), qa(Pu, f, o);
      }
    }
    function AI(o, i, f) {
      {
        var v = o.stateNode, w = i.childContextTypes;
        if (typeof v.getChildContext != "function") {
          {
            var T = gn(o) || "Unknown";
            AO[T] || (AO[T] = !0, l("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", T, T));
          }
          return f;
        }
        var $ = v.getChildContext();
        for (var F in $)
          if (!(F in w))
            throw new Error((gn(o) || "Unknown") + '.getChildContext(): key "' + F + '" is not defined in childContextTypes.');
        {
          var W = gn(o) || "Unknown";
          Ol(w, $, "child context", W);
        }
        return On({}, f, $);
      }
    }
    function tS(o) {
      {
        var i = o.stateNode, f = i && i.__reactInternalMemoizedMergedChildContext || fs;
        return jO = zc.current, qa(zc, f, o), qa(Pu, Pu.current, o), !0;
      }
    }
    function jI(o, i, f) {
      {
        var v = o.stateNode;
        if (!v)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (f) {
          var w = AI(o, i, jO);
          v.__reactInternalMemoizedMergedChildContext = w, Ya(Pu, o), Ya(zc, o), qa(zc, w, o), qa(Pu, f, o);
        } else
          Ya(Pu, o), qa(Pu, f, o);
      }
    }
    function SX(o) {
      {
        if (!ug(o) || o.tag !== h)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var i = o;
        do {
          switch (i.tag) {
            case b:
              return i.stateNode.context;
            case h: {
              var f = i.type;
              if (Ru(f))
                return i.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          i = i.return;
        } while (i !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var af = 0, nS = 1, Vc = null, FO = !1, zO = !1;
    function LI(o) {
      Vc === null ? Vc = [o] : Vc.push(o);
    }
    function EX(o) {
      FO = !0, LI(o);
    }
    function FI() {
      FO && sf();
    }
    function sf() {
      if (!zO && Vc !== null) {
        zO = !0;
        var o = 0, i = Ni();
        try {
          var f = !0, v = Vc;
          for (ko(ca); o < v.length; o++) {
            var w = v[o];
            do
              w = w(f);
            while (w !== null);
          }
          Vc = null, FO = !1;
        } catch (T) {
          throw Vc !== null && (Vc = Vc.slice(o + 1)), nh(oh, sf), T;
        } finally {
          ko(i), zO = !1;
        }
      }
      return null;
    }
    var nv = [], rv = 0, rS = null, oS = 0, Is = [], As = 0, Fp = null, Uc = 1, Bc = "";
    function CX(o) {
      return Vp(), (o.flags & ig) !== nn;
    }
    function TX(o) {
      return Vp(), oS;
    }
    function _X() {
      var o = Bc, i = Uc, f = i & ~OX(i);
      return f.toString(32) + o;
    }
    function zp(o, i) {
      Vp(), nv[rv++] = oS, nv[rv++] = rS, rS = o, oS = i;
    }
    function zI(o, i, f) {
      Vp(), Is[As++] = Uc, Is[As++] = Bc, Is[As++] = Fp, Fp = o;
      var v = Uc, w = Bc, T = aS(v) - 1, $ = v & ~(1 << T), F = f + 1, W = aS(i) + T;
      if (W > 30) {
        var ie = T - T % 5, ce = (1 << ie) - 1, De = ($ & ce).toString(32), Re = $ >> ie, Be = T - ie, We = aS(i) + Be, Qe = F << Be, It = Qe | Re, rn = De + w;
        Uc = 1 << We | It, Bc = rn;
      } else {
        var en = F << T, Vn = en | $, Nn = w;
        Uc = 1 << W | Vn, Bc = Nn;
      }
    }
    function VO(o) {
      Vp();
      var i = o.return;
      if (i !== null) {
        var f = 1, v = 0;
        zp(o, f), zI(o, f, v);
      }
    }
    function aS(o) {
      return 32 - ch(o);
    }
    function OX(o) {
      return 1 << aS(o) - 1;
    }
    function UO(o) {
      for (; o === rS; )
        rS = nv[--rv], nv[rv] = null, oS = nv[--rv], nv[rv] = null;
      for (; o === Fp; )
        Fp = Is[--As], Is[As] = null, Bc = Is[--As], Is[As] = null, Uc = Is[--As], Is[As] = null;
    }
    function PX() {
      return Vp(), Fp !== null ? {
        id: Uc,
        overflow: Bc
      } : null;
    }
    function RX(o, i) {
      Vp(), Is[As++] = Uc, Is[As++] = Bc, Is[As++] = Fp, Uc = i.id, Bc = i.overflow, Fp = o;
    }
    function Vp() {
      xa() || l("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var wa = null, js = null, Pl = !1, Up = !1, lf = null;
    function kX() {
      Pl && l("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function VI() {
      Up = !0;
    }
    function DX() {
      return Up;
    }
    function $X(o) {
      var i = o.stateNode.containerInfo;
      return js = XK(i), wa = o, Pl = !0, lf = null, Up = !1, !0;
    }
    function MX(o, i, f) {
      return js = QK(i), wa = o, Pl = !0, lf = null, Up = !1, f !== null && RX(o, f), !0;
    }
    function UI(o, i) {
      switch (o.tag) {
        case b: {
          sX(o.stateNode.containerInfo, i);
          break;
        }
        case E: {
          var f = (o.mode & kn) !== an;
          uX(
            o.type,
            o.memoizedProps,
            o.stateNode,
            i,
            // TODO: Delete this argument when we remove the legacy root API.
            f
          );
          break;
        }
        case R: {
          var v = o.memoizedState;
          v.dehydrated !== null && lX(v.dehydrated, i);
          break;
        }
      }
    }
    function BI(o, i) {
      UI(o, i);
      var f = AJ();
      f.stateNode = i, f.return = o;
      var v = o.deletions;
      v === null ? (o.deletions = [f], o.flags |= sr) : v.push(f);
    }
    function BO(o, i) {
      {
        if (Up)
          return;
        switch (o.tag) {
          case b: {
            var f = o.stateNode.containerInfo;
            switch (i.tag) {
              case E:
                var v = i.type;
                i.pendingProps, cX(f, v);
                break;
              case O:
                var w = i.pendingProps;
                dX(f, w);
                break;
            }
            break;
          }
          case E: {
            var T = o.type, $ = o.memoizedProps, F = o.stateNode;
            switch (i.tag) {
              case E: {
                var W = i.type, ie = i.pendingProps, ce = (o.mode & kn) !== an;
                mX(
                  T,
                  $,
                  F,
                  W,
                  ie,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ce
                );
                break;
              }
              case O: {
                var De = i.pendingProps, Re = (o.mode & kn) !== an;
                hX(
                  T,
                  $,
                  F,
                  De,
                  // TODO: Delete this argument when we remove the legacy root API.
                  Re
                );
                break;
              }
            }
            break;
          }
          case R: {
            var Be = o.memoizedState, We = Be.dehydrated;
            if (We !== null)
              switch (i.tag) {
                case E:
                  var Qe = i.type;
                  i.pendingProps, fX(We, Qe);
                  break;
                case O:
                  var It = i.pendingProps;
                  pX(We, It);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function HI(o, i) {
      i.flags = i.flags & ~Ri | Br, BO(o, i);
    }
    function WI(o, i) {
      switch (o.tag) {
        case E: {
          var f = o.type;
          o.pendingProps;
          var v = HK(i, f);
          return v !== null ? (o.stateNode = v, wa = o, js = KK(v), !0) : !1;
        }
        case O: {
          var w = o.pendingProps, T = WK(i, w);
          return T !== null ? (o.stateNode = T, wa = o, js = null, !0) : !1;
        }
        case R: {
          var $ = YK(i);
          if ($ !== null) {
            var F = {
              dehydrated: $,
              treeContext: PX(),
              retryLane: Ha
            };
            o.memoizedState = F;
            var W = jJ($);
            return W.return = o, o.child = W, wa = o, js = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function HO(o) {
      return (o.mode & kn) !== an && (o.flags & pn) === nn;
    }
    function WO(o) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function YO(o) {
      if (Pl) {
        var i = js;
        if (!i) {
          HO(o) && (BO(wa, o), WO()), HI(wa, o), Pl = !1, wa = o;
          return;
        }
        var f = i;
        if (!WI(o, i)) {
          HO(o) && (BO(wa, o), WO()), i = rb(f);
          var v = wa;
          if (!i || !WI(o, i)) {
            HI(wa, o), Pl = !1, wa = o;
            return;
          }
          BI(v, f);
        }
      }
    }
    function NX(o, i, f) {
      var v = o.stateNode, w = !Up, T = ZK(v, o.type, o.memoizedProps, i, f, o, w);
      return o.updateQueue = T, T !== null;
    }
    function IX(o) {
      var i = o.stateNode, f = o.memoizedProps, v = JK(i, f, o);
      if (v) {
        var w = wa;
        if (w !== null)
          switch (w.tag) {
            case b: {
              var T = w.stateNode.containerInfo, $ = (w.mode & kn) !== an;
              aX(
                T,
                i,
                f,
                // TODO: Delete this argument when we remove the legacy root API.
                $
              );
              break;
            }
            case E: {
              var F = w.type, W = w.memoizedProps, ie = w.stateNode, ce = (w.mode & kn) !== an;
              iX(
                F,
                W,
                ie,
                i,
                f,
                // TODO: Delete this argument when we remove the legacy root API.
                ce
              );
              break;
            }
          }
      }
      return v;
    }
    function AX(o) {
      var i = o.memoizedState, f = i !== null ? i.dehydrated : null;
      if (!f)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      eX(f, o);
    }
    function jX(o) {
      var i = o.memoizedState, f = i !== null ? i.dehydrated : null;
      if (!f)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return tX(f);
    }
    function YI(o) {
      for (var i = o.return; i !== null && i.tag !== E && i.tag !== b && i.tag !== R; )
        i = i.return;
      wa = i;
    }
    function iS(o) {
      if (o !== wa)
        return !1;
      if (!Pl)
        return YI(o), Pl = !0, !1;
      if (o.tag !== b && (o.tag !== E || oX(o.type) && !OO(o.type, o.memoizedProps))) {
        var i = js;
        if (i)
          if (HO(o))
            qI(o), WO();
          else
            for (; i; )
              BI(o, i), i = rb(i);
      }
      return YI(o), o.tag === R ? js = jX(o) : js = wa ? rb(o.stateNode) : null, !0;
    }
    function LX() {
      return Pl && js !== null;
    }
    function qI(o) {
      for (var i = js; i; )
        UI(o, i), i = rb(i);
    }
    function ov() {
      wa = null, js = null, Pl = !1, Up = !1;
    }
    function GI() {
      lf !== null && (U2(lf), lf = null);
    }
    function xa() {
      return Pl;
    }
    function qO(o) {
      lf === null ? lf = [o] : lf.push(o);
    }
    var FX = n.ReactCurrentBatchConfig, zX = null;
    function VX() {
      return FX.transition;
    }
    var Rl = {
      recordUnsafeLifecycleWarnings: function(o, i) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(o, i) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var UX = function(o) {
        for (var i = null, f = o; f !== null; )
          f.mode & no && (i = f), f = f.return;
        return i;
      }, Bp = function(o) {
        var i = [];
        return o.forEach(function(f) {
          i.push(f);
        }), i.sort().join(", ");
      }, sb = [], lb = [], ub = [], cb = [], db = [], fb = [], Hp = /* @__PURE__ */ new Set();
      Rl.recordUnsafeLifecycleWarnings = function(o, i) {
        Hp.has(o.type) || (typeof i.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        i.componentWillMount.__suppressDeprecationWarning !== !0 && sb.push(o), o.mode & no && typeof i.UNSAFE_componentWillMount == "function" && lb.push(o), typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ub.push(o), o.mode & no && typeof i.UNSAFE_componentWillReceiveProps == "function" && cb.push(o), typeof i.componentWillUpdate == "function" && i.componentWillUpdate.__suppressDeprecationWarning !== !0 && db.push(o), o.mode & no && typeof i.UNSAFE_componentWillUpdate == "function" && fb.push(o));
      }, Rl.flushPendingUnsafeLifecycleWarnings = function() {
        var o = /* @__PURE__ */ new Set();
        sb.length > 0 && (sb.forEach(function(Re) {
          o.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), sb = []);
        var i = /* @__PURE__ */ new Set();
        lb.length > 0 && (lb.forEach(function(Re) {
          i.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), lb = []);
        var f = /* @__PURE__ */ new Set();
        ub.length > 0 && (ub.forEach(function(Re) {
          f.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), ub = []);
        var v = /* @__PURE__ */ new Set();
        cb.length > 0 && (cb.forEach(function(Re) {
          v.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), cb = []);
        var w = /* @__PURE__ */ new Set();
        db.length > 0 && (db.forEach(function(Re) {
          w.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), db = []);
        var T = /* @__PURE__ */ new Set();
        if (fb.length > 0 && (fb.forEach(function(Re) {
          T.add(gn(Re) || "Component"), Hp.add(Re.type);
        }), fb = []), i.size > 0) {
          var $ = Bp(i);
          l(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, $);
        }
        if (v.size > 0) {
          var F = Bp(v);
          l(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, F);
        }
        if (T.size > 0) {
          var W = Bp(T);
          l(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, W);
        }
        if (o.size > 0) {
          var ie = Bp(o);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ie);
        }
        if (f.size > 0) {
          var ce = Bp(f);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ce);
        }
        if (w.size > 0) {
          var De = Bp(w);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, De);
        }
      };
      var sS = /* @__PURE__ */ new Map(), KI = /* @__PURE__ */ new Set();
      Rl.recordLegacyContextWarning = function(o, i) {
        var f = UX(o);
        if (f === null) {
          l("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!KI.has(o.type)) {
          var v = sS.get(f);
          (o.type.contextTypes != null || o.type.childContextTypes != null || i !== null && typeof i.getChildContext == "function") && (v === void 0 && (v = [], sS.set(f, v)), v.push(o));
        }
      }, Rl.flushLegacyContextWarning = function() {
        sS.forEach(function(o, i) {
          if (o.length !== 0) {
            var f = o[0], v = /* @__PURE__ */ new Set();
            o.forEach(function(T) {
              v.add(gn(T) || "Component"), KI.add(T.type);
            });
            var w = Bp(v);
            try {
              fr(f), l(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, w);
            } finally {
              io();
            }
          }
        });
      }, Rl.discardPendingWarnings = function() {
        sb = [], lb = [], ub = [], cb = [], db = [], fb = [], sS = /* @__PURE__ */ new Map();
      };
    }
    function kl(o, i) {
      if (o && o.defaultProps) {
        var f = On({}, i), v = o.defaultProps;
        for (var w in v)
          f[w] === void 0 && (f[w] = v[w]);
        return f;
      }
      return i;
    }
    var GO = of(null), KO;
    KO = {};
    var lS = null, av = null, XO = null, uS = !1;
    function cS() {
      lS = null, av = null, XO = null, uS = !1;
    }
    function XI() {
      uS = !0;
    }
    function QI() {
      uS = !1;
    }
    function ZI(o, i, f) {
      qa(GO, i._currentValue, o), i._currentValue = f, i._currentRenderer !== void 0 && i._currentRenderer !== null && i._currentRenderer !== KO && l("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), i._currentRenderer = KO;
    }
    function QO(o, i) {
      var f = GO.current;
      Ya(GO, i), o._currentValue = f;
    }
    function ZO(o, i, f) {
      for (var v = o; v !== null; ) {
        var w = v.alternate;
        if (Pc(v.childLanes, i) ? w !== null && !Pc(w.childLanes, i) && (w.childLanes = En(w.childLanes, i)) : (v.childLanes = En(v.childLanes, i), w !== null && (w.childLanes = En(w.childLanes, i))), v === f)
          break;
        v = v.return;
      }
      v !== f && l("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function BX(o, i, f) {
      HX(o, i, f);
    }
    function HX(o, i, f) {
      var v = o.child;
      for (v !== null && (v.return = o); v !== null; ) {
        var w = void 0, T = v.dependencies;
        if (T !== null) {
          w = v.child;
          for (var $ = T.firstContext; $ !== null; ) {
            if ($.context === i) {
              if (v.tag === h) {
                var F = Ro(f), W = Hc(Ir, F);
                W.tag = fS;
                var ie = v.updateQueue;
                if (ie !== null) {
                  var ce = ie.shared, De = ce.pending;
                  De === null ? W.next = W : (W.next = De.next, De.next = W), ce.pending = W;
                }
              }
              v.lanes = En(v.lanes, f);
              var Re = v.alternate;
              Re !== null && (Re.lanes = En(Re.lanes, f)), ZO(v.return, f, o), T.lanes = En(T.lanes, f);
              break;
            }
            $ = $.next;
          }
        } else if (v.tag === D)
          w = v.type === o.type ? null : v.child;
        else if (v.tag === H) {
          var Be = v.return;
          if (Be === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Be.lanes = En(Be.lanes, f);
          var We = Be.alternate;
          We !== null && (We.lanes = En(We.lanes, f)), ZO(Be, f, o), w = v.sibling;
        } else
          w = v.child;
        if (w !== null)
          w.return = v;
        else
          for (w = v; w !== null; ) {
            if (w === o) {
              w = null;
              break;
            }
            var Qe = w.sibling;
            if (Qe !== null) {
              Qe.return = w.return, w = Qe;
              break;
            }
            w = w.return;
          }
        v = w;
      }
    }
    function iv(o, i) {
      lS = o, av = null, XO = null;
      var f = o.dependencies;
      if (f !== null) {
        var v = f.firstContext;
        v !== null && (Wa(f.lanes, i) && _b(), f.firstContext = null);
      }
    }
    function Ho(o) {
      uS && l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var i = o._currentValue;
      if (XO !== o) {
        var f = {
          context: o,
          memoizedValue: i,
          next: null
        };
        if (av === null) {
          if (lS === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          av = f, lS.dependencies = {
            lanes: tt,
            firstContext: f
          };
        } else
          av = av.next = f;
      }
      return i;
    }
    var Wp = null;
    function JO(o) {
      Wp === null ? Wp = [o] : Wp.push(o);
    }
    function WX() {
      if (Wp !== null) {
        for (var o = 0; o < Wp.length; o++) {
          var i = Wp[o], f = i.interleaved;
          if (f !== null) {
            i.interleaved = null;
            var v = f.next, w = i.pending;
            if (w !== null) {
              var T = w.next;
              w.next = v, f.next = T;
            }
            i.pending = f;
          }
        }
        Wp = null;
      }
    }
    function JI(o, i, f, v) {
      var w = i.interleaved;
      return w === null ? (f.next = f, JO(i)) : (f.next = w.next, w.next = f), i.interleaved = f, dS(o, v);
    }
    function YX(o, i, f, v) {
      var w = i.interleaved;
      w === null ? (f.next = f, JO(i)) : (f.next = w.next, w.next = f), i.interleaved = f;
    }
    function qX(o, i, f, v) {
      var w = i.interleaved;
      return w === null ? (f.next = f, JO(i)) : (f.next = w.next, w.next = f), i.interleaved = f, dS(o, v);
    }
    function Fi(o, i) {
      return dS(o, i);
    }
    var GX = dS;
    function dS(o, i) {
      o.lanes = En(o.lanes, i);
      var f = o.alternate;
      f !== null && (f.lanes = En(f.lanes, i)), f === null && (o.flags & (Br | Ri)) !== nn && ej(o);
      for (var v = o, w = o.return; w !== null; )
        w.childLanes = En(w.childLanes, i), f = w.alternate, f !== null ? f.childLanes = En(f.childLanes, i) : (w.flags & (Br | Ri)) !== nn && ej(o), v = w, w = w.return;
      if (v.tag === b) {
        var T = v.stateNode;
        return T;
      } else
        return null;
    }
    var eA = 0, tA = 1, fS = 2, eP = 3, pS = !1, tP, mS;
    tP = !1, mS = null;
    function nP(o) {
      var i = {
        baseState: o.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: tt
        },
        effects: null
      };
      o.updateQueue = i;
    }
    function nA(o, i) {
      var f = i.updateQueue, v = o.updateQueue;
      if (f === v) {
        var w = {
          baseState: v.baseState,
          firstBaseUpdate: v.firstBaseUpdate,
          lastBaseUpdate: v.lastBaseUpdate,
          shared: v.shared,
          effects: v.effects
        };
        i.updateQueue = w;
      }
    }
    function Hc(o, i) {
      var f = {
        eventTime: o,
        lane: i,
        tag: eA,
        payload: null,
        callback: null,
        next: null
      };
      return f;
    }
    function uf(o, i, f) {
      var v = o.updateQueue;
      if (v === null)
        return null;
      var w = v.shared;
      if (mS === w && !tP && (l("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), tP = !0), GZ()) {
        var T = w.pending;
        return T === null ? i.next = i : (i.next = T.next, T.next = i), w.pending = i, GX(o, f);
      } else
        return qX(o, w, i, f);
    }
    function hS(o, i, f) {
      var v = i.updateQueue;
      if (v !== null) {
        var w = v.shared;
        if (Sg(f)) {
          var T = w.lanes;
          T = Cg(T, o.pendingLanes);
          var $ = En(T, f);
          w.lanes = $, Ud(o, $);
        }
      }
    }
    function rP(o, i) {
      var f = o.updateQueue, v = o.alternate;
      if (v !== null) {
        var w = v.updateQueue;
        if (f === w) {
          var T = null, $ = null, F = f.firstBaseUpdate;
          if (F !== null) {
            var W = F;
            do {
              var ie = {
                eventTime: W.eventTime,
                lane: W.lane,
                tag: W.tag,
                payload: W.payload,
                callback: W.callback,
                next: null
              };
              $ === null ? T = $ = ie : ($.next = ie, $ = ie), W = W.next;
            } while (W !== null);
            $ === null ? T = $ = i : ($.next = i, $ = i);
          } else
            T = $ = i;
          f = {
            baseState: w.baseState,
            firstBaseUpdate: T,
            lastBaseUpdate: $,
            shared: w.shared,
            effects: w.effects
          }, o.updateQueue = f;
          return;
        }
      }
      var ce = f.lastBaseUpdate;
      ce === null ? f.firstBaseUpdate = i : ce.next = i, f.lastBaseUpdate = i;
    }
    function KX(o, i, f, v, w, T) {
      switch (f.tag) {
        case tA: {
          var $ = f.payload;
          if (typeof $ == "function") {
            XI();
            var F = $.call(T, v, w);
            {
              if (o.mode & no) {
                Po(!0);
                try {
                  $.call(T, v, w);
                } finally {
                  Po(!1);
                }
              }
              QI();
            }
            return F;
          }
          return $;
        }
        case eP:
          o.flags = o.flags & ~Fo | pn;
        case eA: {
          var W = f.payload, ie;
          if (typeof W == "function") {
            XI(), ie = W.call(T, v, w);
            {
              if (o.mode & no) {
                Po(!0);
                try {
                  W.call(T, v, w);
                } finally {
                  Po(!1);
                }
              }
              QI();
            }
          } else
            ie = W;
          return ie == null ? v : On({}, v, ie);
        }
        case fS:
          return pS = !0, v;
      }
      return v;
    }
    function vS(o, i, f, v) {
      var w = o.updateQueue;
      pS = !1, mS = w.shared;
      var T = w.firstBaseUpdate, $ = w.lastBaseUpdate, F = w.shared.pending;
      if (F !== null) {
        w.shared.pending = null;
        var W = F, ie = W.next;
        W.next = null, $ === null ? T = ie : $.next = ie, $ = W;
        var ce = o.alternate;
        if (ce !== null) {
          var De = ce.updateQueue, Re = De.lastBaseUpdate;
          Re !== $ && (Re === null ? De.firstBaseUpdate = ie : Re.next = ie, De.lastBaseUpdate = W);
        }
      }
      if (T !== null) {
        var Be = w.baseState, We = tt, Qe = null, It = null, rn = null, en = T;
        do {
          var Vn = en.lane, Nn = en.eventTime;
          if (Pc(v, Vn)) {
            if (rn !== null) {
              var Ze = {
                eventTime: Nn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Fn,
                tag: en.tag,
                payload: en.payload,
                callback: en.callback,
                next: null
              };
              rn = rn.next = Ze;
            }
            Be = KX(o, w, en, Be, i, f);
            var Ve = en.callback;
            if (Ve !== null && // If the update was already committed, we should not queue its
            // callback again.
            en.lane !== Fn) {
              o.flags |= Rs;
              var mt = w.effects;
              mt === null ? w.effects = [en] : mt.push(en);
            }
          } else {
            var ze = {
              eventTime: Nn,
              lane: Vn,
              tag: en.tag,
              payload: en.payload,
              callback: en.callback,
              next: null
            };
            rn === null ? (It = rn = ze, Qe = Be) : rn = rn.next = ze, We = En(We, Vn);
          }
          if (en = en.next, en === null) {
            if (F = w.shared.pending, F === null)
              break;
            var At = F, Dt = At.next;
            At.next = null, en = Dt, w.lastBaseUpdate = At, w.shared.pending = null;
          }
        } while (!0);
        rn === null && (Qe = Be), w.baseState = Qe, w.firstBaseUpdate = It, w.lastBaseUpdate = rn;
        var dn = w.shared.interleaved;
        if (dn !== null) {
          var xn = dn;
          do
            We = En(We, xn.lane), xn = xn.next;
          while (xn !== dn);
        } else
          T === null && (w.shared.lanes = tt);
        Lb(We), o.lanes = We, o.memoizedState = Be;
      }
      mS = null;
    }
    function XX(o, i) {
      if (typeof o != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + o));
      o.call(i);
    }
    function rA() {
      pS = !1;
    }
    function yS() {
      return pS;
    }
    function oA(o, i, f) {
      var v = i.effects;
      if (i.effects = null, v !== null)
        for (var w = 0; w < v.length; w++) {
          var T = v[w], $ = T.callback;
          $ !== null && (T.callback = null, XX($, f));
        }
    }
    var oP = {}, aA = new e.Component().refs, aP, iP, sP, lP, uP, iA, gS, cP, dP, fP;
    {
      aP = /* @__PURE__ */ new Set(), iP = /* @__PURE__ */ new Set(), sP = /* @__PURE__ */ new Set(), lP = /* @__PURE__ */ new Set(), cP = /* @__PURE__ */ new Set(), uP = /* @__PURE__ */ new Set(), dP = /* @__PURE__ */ new Set(), fP = /* @__PURE__ */ new Set();
      var sA = /* @__PURE__ */ new Set();
      gS = function(o, i) {
        if (!(o === null || typeof o == "function")) {
          var f = i + "_" + o;
          sA.has(f) || (sA.add(f), l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", i, o));
        }
      }, iA = function(o, i) {
        if (i === void 0) {
          var f = qn(o) || "Component";
          uP.has(f) || (uP.add(f), l("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", f));
        }
      }, Object.defineProperty(oP, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(oP);
    }
    function pP(o, i, f, v) {
      var w = o.memoizedState, T = f(v, w);
      {
        if (o.mode & no) {
          Po(!0);
          try {
            T = f(v, w);
          } finally {
            Po(!1);
          }
        }
        iA(i, T);
      }
      var $ = T == null ? w : On({}, w, T);
      if (o.memoizedState = $, o.lanes === tt) {
        var F = o.updateQueue;
        F.baseState = $;
      }
    }
    var mP = {
      isMounted: si,
      enqueueSetState: function(o, i, f) {
        var v = Oi(o), w = pi(), T = yf(v), $ = Hc(w, T);
        $.payload = i, f != null && (gS(f, "setState"), $.callback = f);
        var F = uf(v, $, T);
        F !== null && (na(F, v, T, w), hS(F, v, T)), bu(v, T);
      },
      enqueueReplaceState: function(o, i, f) {
        var v = Oi(o), w = pi(), T = yf(v), $ = Hc(w, T);
        $.tag = tA, $.payload = i, f != null && (gS(f, "replaceState"), $.callback = f);
        var F = uf(v, $, T);
        F !== null && (na(F, v, T, w), hS(F, v, T)), bu(v, T);
      },
      enqueueForceUpdate: function(o, i) {
        var f = Oi(o), v = pi(), w = yf(f), T = Hc(v, w);
        T.tag = fS, i != null && (gS(i, "forceUpdate"), T.callback = i);
        var $ = uf(f, T, w);
        $ !== null && (na($, f, w, v), hS($, f, w)), gg(f, w);
      }
    };
    function lA(o, i, f, v, w, T, $) {
      var F = o.stateNode;
      if (typeof F.shouldComponentUpdate == "function") {
        var W = F.shouldComponentUpdate(v, T, $);
        {
          if (o.mode & no) {
            Po(!0);
            try {
              W = F.shouldComponentUpdate(v, T, $);
            } finally {
              Po(!1);
            }
          }
          W === void 0 && l("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", qn(i) || "Component");
        }
        return W;
      }
      return i.prototype && i.prototype.isPureReactComponent ? !tn(f, v) || !tn(w, T) : !0;
    }
    function QX(o, i, f) {
      var v = o.stateNode;
      {
        var w = qn(i) || "Component", T = v.render;
        T || (i.prototype && typeof i.prototype.render == "function" ? l("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", w) : l("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", w)), v.getInitialState && !v.getInitialState.isReactClassApproved && !v.state && l("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", w), v.getDefaultProps && !v.getDefaultProps.isReactClassApproved && l("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", w), v.propTypes && l("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", w), v.contextType && l("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", w), v.contextTypes && l("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", w), i.contextType && i.contextTypes && !dP.has(i) && (dP.add(i), l("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", w)), typeof v.componentShouldUpdate == "function" && l("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", w), i.prototype && i.prototype.isPureReactComponent && typeof v.shouldComponentUpdate < "u" && l("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", qn(i) || "A pure component"), typeof v.componentDidUnmount == "function" && l("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", w), typeof v.componentDidReceiveProps == "function" && l("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", w), typeof v.componentWillRecieveProps == "function" && l("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", w), typeof v.UNSAFE_componentWillRecieveProps == "function" && l("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", w);
        var $ = v.props !== f;
        v.props !== void 0 && $ && l("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", w, w), v.defaultProps && l("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", w, w), typeof v.getSnapshotBeforeUpdate == "function" && typeof v.componentDidUpdate != "function" && !sP.has(i) && (sP.add(i), l("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", qn(i))), typeof v.getDerivedStateFromProps == "function" && l("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", w), typeof v.getDerivedStateFromError == "function" && l("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", w), typeof i.getSnapshotBeforeUpdate == "function" && l("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", w);
        var F = v.state;
        F && (typeof F != "object" || jn(F)) && l("%s.state: must be set to an object or null", w), typeof v.getChildContext == "function" && typeof i.childContextTypes != "object" && l("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", w);
      }
    }
    function uA(o, i) {
      i.updater = mP, o.stateNode = i, $d(i, o), i._reactInternalInstance = oP;
    }
    function cA(o, i, f) {
      var v = !1, w = fs, T = fs, $ = i.contextType;
      if ("contextType" in i) {
        var F = (
          // Allow null for conditional declaration
          $ === null || $ !== void 0 && $.$$typeof === wt && $._context === void 0
        );
        if (!F && !fP.has(i)) {
          fP.add(i);
          var W = "";
          $ === void 0 ? W = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof $ != "object" ? W = " However, it is set to a " + typeof $ + "." : $.$$typeof === at ? W = " Did you accidentally pass the Context.Provider instead?" : $._context !== void 0 ? W = " Did you accidentally pass the Context.Consumer instead?" : W = " However, it is set to an object with keys {" + Object.keys($).join(", ") + "}.", l("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", qn(i) || "Component", W);
        }
      }
      if (typeof $ == "object" && $ !== null)
        T = Ho($);
      else {
        w = ev(o, i, !0);
        var ie = i.contextTypes;
        v = ie != null, T = v ? tv(o, w) : fs;
      }
      var ce = new i(f, T);
      if (o.mode & no) {
        Po(!0);
        try {
          ce = new i(f, T);
        } finally {
          Po(!1);
        }
      }
      var De = o.memoizedState = ce.state !== null && ce.state !== void 0 ? ce.state : null;
      uA(o, ce);
      {
        if (typeof i.getDerivedStateFromProps == "function" && De === null) {
          var Re = qn(i) || "Component";
          iP.has(Re) || (iP.add(Re), l("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Re, ce.state === null ? "null" : "undefined", Re));
        }
        if (typeof i.getDerivedStateFromProps == "function" || typeof ce.getSnapshotBeforeUpdate == "function") {
          var Be = null, We = null, Qe = null;
          if (typeof ce.componentWillMount == "function" && ce.componentWillMount.__suppressDeprecationWarning !== !0 ? Be = "componentWillMount" : typeof ce.UNSAFE_componentWillMount == "function" && (Be = "UNSAFE_componentWillMount"), typeof ce.componentWillReceiveProps == "function" && ce.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? We = "componentWillReceiveProps" : typeof ce.UNSAFE_componentWillReceiveProps == "function" && (We = "UNSAFE_componentWillReceiveProps"), typeof ce.componentWillUpdate == "function" && ce.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Qe = "componentWillUpdate" : typeof ce.UNSAFE_componentWillUpdate == "function" && (Qe = "UNSAFE_componentWillUpdate"), Be !== null || We !== null || Qe !== null) {
            var It = qn(i) || "Component", rn = typeof i.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            lP.has(It) || (lP.add(It), l(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, It, rn, Be !== null ? `
  ` + Be : "", We !== null ? `
  ` + We : "", Qe !== null ? `
  ` + Qe : ""));
          }
        }
      }
      return v && NI(o, w, T), ce;
    }
    function ZX(o, i) {
      var f = i.state;
      typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), f !== i.state && (l("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", gn(o) || "Component"), mP.enqueueReplaceState(i, i.state, null));
    }
    function dA(o, i, f, v) {
      var w = i.state;
      if (typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(f, v), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(f, v), i.state !== w) {
        {
          var T = gn(o) || "Component";
          aP.has(T) || (aP.add(T), l("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", T));
        }
        mP.enqueueReplaceState(i, i.state, null);
      }
    }
    function hP(o, i, f, v) {
      QX(o, i, f);
      var w = o.stateNode;
      w.props = f, w.state = o.memoizedState, w.refs = aA, nP(o);
      var T = i.contextType;
      if (typeof T == "object" && T !== null)
        w.context = Ho(T);
      else {
        var $ = ev(o, i, !0);
        w.context = tv(o, $);
      }
      {
        if (w.state === f) {
          var F = qn(i) || "Component";
          cP.has(F) || (cP.add(F), l("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", F));
        }
        o.mode & no && Rl.recordLegacyContextWarning(o, w), Rl.recordUnsafeLifecycleWarnings(o, w);
      }
      w.state = o.memoizedState;
      var W = i.getDerivedStateFromProps;
      if (typeof W == "function" && (pP(o, i, W, f), w.state = o.memoizedState), typeof i.getDerivedStateFromProps != "function" && typeof w.getSnapshotBeforeUpdate != "function" && (typeof w.UNSAFE_componentWillMount == "function" || typeof w.componentWillMount == "function") && (ZX(o, w), vS(o, f, w, v), w.state = o.memoizedState), typeof w.componentDidMount == "function") {
        var ie = Sn;
        ie |= Fa, (o.mode & $i) !== an && (ie |= za), o.flags |= ie;
      }
    }
    function JX(o, i, f, v) {
      var w = o.stateNode, T = o.memoizedProps;
      w.props = T;
      var $ = w.context, F = i.contextType, W = fs;
      if (typeof F == "object" && F !== null)
        W = Ho(F);
      else {
        var ie = ev(o, i, !0);
        W = tv(o, ie);
      }
      var ce = i.getDerivedStateFromProps, De = typeof ce == "function" || typeof w.getSnapshotBeforeUpdate == "function";
      !De && (typeof w.UNSAFE_componentWillReceiveProps == "function" || typeof w.componentWillReceiveProps == "function") && (T !== f || $ !== W) && dA(o, w, f, W), rA();
      var Re = o.memoizedState, Be = w.state = Re;
      if (vS(o, f, w, v), Be = o.memoizedState, T === f && Re === Be && !Jx() && !yS()) {
        if (typeof w.componentDidMount == "function") {
          var We = Sn;
          We |= Fa, (o.mode & $i) !== an && (We |= za), o.flags |= We;
        }
        return !1;
      }
      typeof ce == "function" && (pP(o, i, ce, f), Be = o.memoizedState);
      var Qe = yS() || lA(o, i, T, f, Re, Be, W);
      if (Qe) {
        if (!De && (typeof w.UNSAFE_componentWillMount == "function" || typeof w.componentWillMount == "function") && (typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()), typeof w.componentDidMount == "function") {
          var It = Sn;
          It |= Fa, (o.mode & $i) !== an && (It |= za), o.flags |= It;
        }
      } else {
        if (typeof w.componentDidMount == "function") {
          var rn = Sn;
          rn |= Fa, (o.mode & $i) !== an && (rn |= za), o.flags |= rn;
        }
        o.memoizedProps = f, o.memoizedState = Be;
      }
      return w.props = f, w.state = Be, w.context = W, Qe;
    }
    function eQ(o, i, f, v, w) {
      var T = i.stateNode;
      nA(o, i);
      var $ = i.memoizedProps, F = i.type === i.elementType ? $ : kl(i.type, $);
      T.props = F;
      var W = i.pendingProps, ie = T.context, ce = f.contextType, De = fs;
      if (typeof ce == "object" && ce !== null)
        De = Ho(ce);
      else {
        var Re = ev(i, f, !0);
        De = tv(i, Re);
      }
      var Be = f.getDerivedStateFromProps, We = typeof Be == "function" || typeof T.getSnapshotBeforeUpdate == "function";
      !We && (typeof T.UNSAFE_componentWillReceiveProps == "function" || typeof T.componentWillReceiveProps == "function") && ($ !== W || ie !== De) && dA(i, T, v, De), rA();
      var Qe = i.memoizedState, It = T.state = Qe;
      if (vS(i, v, T, w), It = i.memoizedState, $ === W && Qe === It && !Jx() && !yS() && !se)
        return typeof T.componentDidUpdate == "function" && ($ !== o.memoizedProps || Qe !== o.memoizedState) && (i.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && ($ !== o.memoizedProps || Qe !== o.memoizedState) && (i.flags |= Pi), !1;
      typeof Be == "function" && (pP(i, f, Be, v), It = i.memoizedState);
      var rn = yS() || lA(i, f, F, v, Qe, It, De) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      se;
      return rn ? (!We && (typeof T.UNSAFE_componentWillUpdate == "function" || typeof T.componentWillUpdate == "function") && (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(v, It, De), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(v, It, De)), typeof T.componentDidUpdate == "function" && (i.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && (i.flags |= Pi)) : (typeof T.componentDidUpdate == "function" && ($ !== o.memoizedProps || Qe !== o.memoizedState) && (i.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && ($ !== o.memoizedProps || Qe !== o.memoizedState) && (i.flags |= Pi), i.memoizedProps = v, i.memoizedState = It), T.props = v, T.state = It, T.context = De, rn;
    }
    var vP, yP, gP, bP, wP, fA = function(o, i) {
    };
    vP = !1, yP = !1, gP = {}, bP = {}, wP = {}, fA = function(o, i) {
      if (!(o === null || typeof o != "object") && !(!o._store || o._store.validated || o.key != null)) {
        if (typeof o._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        o._store.validated = !0;
        var f = gn(i) || "Component";
        bP[f] || (bP[f] = !0, l('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function pb(o, i, f) {
      var v = f.ref;
      if (v !== null && typeof v != "function" && typeof v != "object") {
        if ((o.mode & no || fe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(f._owner && f._self && f._owner.stateNode !== f._self)) {
          var w = gn(o) || "Component";
          gP[w] || (l('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', v), gP[w] = !0);
        }
        if (f._owner) {
          var T = f._owner, $;
          if (T) {
            var F = T;
            if (F.tag !== h)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            $ = F.stateNode;
          }
          if (!$)
            throw new Error("Missing owner for string ref " + v + ". This error is likely caused by a bug in React. Please file an issue.");
          var W = $;
          Ae(v, "ref");
          var ie = "" + v;
          if (i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === ie)
            return i.ref;
          var ce = function(De) {
            var Re = W.refs;
            Re === aA && (Re = W.refs = {}), De === null ? delete Re[ie] : Re[ie] = De;
          };
          return ce._stringRef = ie, ce;
        } else {
          if (typeof v != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!f._owner)
            throw new Error("Element ref was specified as a string (" + v + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return v;
    }
    function bS(o, i) {
      var f = Object.prototype.toString.call(i);
      throw new Error("Objects are not valid as a React child (found: " + (f === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : f) + "). If you meant to render a collection of children, use an array instead.");
    }
    function wS(o) {
      {
        var i = gn(o) || "Component";
        if (wP[i])
          return;
        wP[i] = !0, l("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function pA(o) {
      var i = o._payload, f = o._init;
      return f(i);
    }
    function mA(o) {
      function i(ze, Ze) {
        if (o) {
          var Ve = ze.deletions;
          Ve === null ? (ze.deletions = [Ze], ze.flags |= sr) : Ve.push(Ze);
        }
      }
      function f(ze, Ze) {
        if (!o)
          return null;
        for (var Ve = Ze; Ve !== null; )
          i(ze, Ve), Ve = Ve.sibling;
        return null;
      }
      function v(ze, Ze) {
        for (var Ve = /* @__PURE__ */ new Map(), mt = Ze; mt !== null; )
          mt.key !== null ? Ve.set(mt.key, mt) : Ve.set(mt.index, mt), mt = mt.sibling;
        return Ve;
      }
      function w(ze, Ze) {
        var Ve = Jp(ze, Ze);
        return Ve.index = 0, Ve.sibling = null, Ve;
      }
      function T(ze, Ze, Ve) {
        if (ze.index = Ve, !o)
          return ze.flags |= ig, Ze;
        var mt = ze.alternate;
        if (mt !== null) {
          var At = mt.index;
          return At < Ze ? (ze.flags |= Br, Ze) : At;
        } else
          return ze.flags |= Br, Ze;
      }
      function $(ze) {
        return o && ze.alternate === null && (ze.flags |= Br), ze;
      }
      function F(ze, Ze, Ve, mt) {
        if (Ze === null || Ze.tag !== O) {
          var At = qR(Ve, ze.mode, mt);
          return At.return = ze, At;
        } else {
          var Dt = w(Ze, Ve);
          return Dt.return = ze, Dt;
        }
      }
      function W(ze, Ze, Ve, mt) {
        var At = Ve.type;
        if (At === zr)
          return ce(ze, Ze, Ve.props.children, mt, Ve.key);
        if (Ze !== null && (Ze.elementType === At || // Keep this check inline so it only runs on the false path:
        oj(Ze, Ve) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof At == "object" && At !== null && At.$$typeof === $e && pA(At) === Ze.type)) {
          var Dt = w(Ze, Ve.props);
          return Dt.ref = pb(ze, Ze, Ve), Dt.return = ze, Dt._debugSource = Ve._source, Dt._debugOwner = Ve._owner, Dt;
        }
        var dn = YR(Ve, ze.mode, mt);
        return dn.ref = pb(ze, Ze, Ve), dn.return = ze, dn;
      }
      function ie(ze, Ze, Ve, mt) {
        if (Ze === null || Ze.tag !== x || Ze.stateNode.containerInfo !== Ve.containerInfo || Ze.stateNode.implementation !== Ve.implementation) {
          var At = GR(Ve, ze.mode, mt);
          return At.return = ze, At;
        } else {
          var Dt = w(Ze, Ve.children || []);
          return Dt.return = ze, Dt;
        }
      }
      function ce(ze, Ze, Ve, mt, At) {
        if (Ze === null || Ze.tag !== _) {
          var Dt = bf(Ve, ze.mode, mt, At);
          return Dt.return = ze, Dt;
        } else {
          var dn = w(Ze, Ve);
          return dn.return = ze, dn;
        }
      }
      function De(ze, Ze, Ve) {
        if (typeof Ze == "string" && Ze !== "" || typeof Ze == "number") {
          var mt = qR("" + Ze, ze.mode, Ve);
          return mt.return = ze, mt;
        }
        if (typeof Ze == "object" && Ze !== null) {
          switch (Ze.$$typeof) {
            case Dr: {
              var At = YR(Ze, ze.mode, Ve);
              return At.ref = pb(ze, null, Ze), At.return = ze, At;
            }
            case Fr: {
              var Dt = GR(Ze, ze.mode, Ve);
              return Dt.return = ze, Dt;
            }
            case $e: {
              var dn = Ze._payload, xn = Ze._init;
              return De(ze, xn(dn), Ve);
            }
          }
          if (jn(Ze) || $a(Ze)) {
            var Er = bf(Ze, ze.mode, Ve, null);
            return Er.return = ze, Er;
          }
          bS(ze, Ze);
        }
        return typeof Ze == "function" && wS(ze), null;
      }
      function Re(ze, Ze, Ve, mt) {
        var At = Ze !== null ? Ze.key : null;
        if (typeof Ve == "string" && Ve !== "" || typeof Ve == "number")
          return At !== null ? null : F(ze, Ze, "" + Ve, mt);
        if (typeof Ve == "object" && Ve !== null) {
          switch (Ve.$$typeof) {
            case Dr:
              return Ve.key === At ? W(ze, Ze, Ve, mt) : null;
            case Fr:
              return Ve.key === At ? ie(ze, Ze, Ve, mt) : null;
            case $e: {
              var Dt = Ve._payload, dn = Ve._init;
              return Re(ze, Ze, dn(Dt), mt);
            }
          }
          if (jn(Ve) || $a(Ve))
            return At !== null ? null : ce(ze, Ze, Ve, mt, null);
          bS(ze, Ve);
        }
        return typeof Ve == "function" && wS(ze), null;
      }
      function Be(ze, Ze, Ve, mt, At) {
        if (typeof mt == "string" && mt !== "" || typeof mt == "number") {
          var Dt = ze.get(Ve) || null;
          return F(Ze, Dt, "" + mt, At);
        }
        if (typeof mt == "object" && mt !== null) {
          switch (mt.$$typeof) {
            case Dr: {
              var dn = ze.get(mt.key === null ? Ve : mt.key) || null;
              return W(Ze, dn, mt, At);
            }
            case Fr: {
              var xn = ze.get(mt.key === null ? Ve : mt.key) || null;
              return ie(Ze, xn, mt, At);
            }
            case $e:
              var Er = mt._payload, nr = mt._init;
              return Be(ze, Ze, Ve, nr(Er), At);
          }
          if (jn(mt) || $a(mt)) {
            var Mo = ze.get(Ve) || null;
            return ce(Ze, Mo, mt, At, null);
          }
          bS(Ze, mt);
        }
        return typeof mt == "function" && wS(Ze), null;
      }
      function We(ze, Ze, Ve) {
        {
          if (typeof ze != "object" || ze === null)
            return Ze;
          switch (ze.$$typeof) {
            case Dr:
            case Fr:
              fA(ze, Ve);
              var mt = ze.key;
              if (typeof mt != "string")
                break;
              if (Ze === null) {
                Ze = /* @__PURE__ */ new Set(), Ze.add(mt);
                break;
              }
              if (!Ze.has(mt)) {
                Ze.add(mt);
                break;
              }
              l("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", mt);
              break;
            case $e:
              var At = ze._payload, Dt = ze._init;
              We(Dt(At), Ze, Ve);
              break;
          }
        }
        return Ze;
      }
      function Qe(ze, Ze, Ve, mt) {
        for (var At = null, Dt = 0; Dt < Ve.length; Dt++) {
          var dn = Ve[Dt];
          At = We(dn, At, ze);
        }
        for (var xn = null, Er = null, nr = Ze, Mo = 0, rr = 0, So = null; nr !== null && rr < Ve.length; rr++) {
          nr.index > rr ? (So = nr, nr = null) : So = nr.sibling;
          var Ka = Re(ze, nr, Ve[rr], mt);
          if (Ka === null) {
            nr === null && (nr = So);
            break;
          }
          o && nr && Ka.alternate === null && i(ze, nr), Mo = T(Ka, Mo, rr), Er === null ? xn = Ka : Er.sibling = Ka, Er = Ka, nr = So;
        }
        if (rr === Ve.length) {
          if (f(ze, nr), xa()) {
            var Pa = rr;
            zp(ze, Pa);
          }
          return xn;
        }
        if (nr === null) {
          for (; rr < Ve.length; rr++) {
            var ms = De(ze, Ve[rr], mt);
            ms !== null && (Mo = T(ms, Mo, rr), Er === null ? xn = ms : Er.sibling = ms, Er = ms);
          }
          if (xa()) {
            var mi = rr;
            zp(ze, mi);
          }
          return xn;
        }
        for (var hi = v(ze, nr); rr < Ve.length; rr++) {
          var Xa = Be(hi, ze, rr, Ve[rr], mt);
          Xa !== null && (o && Xa.alternate !== null && hi.delete(Xa.key === null ? rr : Xa.key), Mo = T(Xa, Mo, rr), Er === null ? xn = Xa : Er.sibling = Xa, Er = Xa);
        }
        if (o && hi.forEach(function(Ev) {
          return i(ze, Ev);
        }), xa()) {
          var Xc = rr;
          zp(ze, Xc);
        }
        return xn;
      }
      function It(ze, Ze, Ve, mt) {
        var At = $a(Ve);
        if (typeof At != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ve[Symbol.toStringTag] === "Generator" && (yP || l("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), yP = !0), Ve.entries === At && (vP || l("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), vP = !0);
          var Dt = At.call(Ve);
          if (Dt)
            for (var dn = null, xn = Dt.next(); !xn.done; xn = Dt.next()) {
              var Er = xn.value;
              dn = We(Er, dn, ze);
            }
        }
        var nr = At.call(Ve);
        if (nr == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Mo = null, rr = null, So = Ze, Ka = 0, Pa = 0, ms = null, mi = nr.next(); So !== null && !mi.done; Pa++, mi = nr.next()) {
          So.index > Pa ? (ms = So, So = null) : ms = So.sibling;
          var hi = Re(ze, So, mi.value, mt);
          if (hi === null) {
            So === null && (So = ms);
            break;
          }
          o && So && hi.alternate === null && i(ze, So), Ka = T(hi, Ka, Pa), rr === null ? Mo = hi : rr.sibling = hi, rr = hi, So = ms;
        }
        if (mi.done) {
          if (f(ze, So), xa()) {
            var Xa = Pa;
            zp(ze, Xa);
          }
          return Mo;
        }
        if (So === null) {
          for (; !mi.done; Pa++, mi = nr.next()) {
            var Xc = De(ze, mi.value, mt);
            Xc !== null && (Ka = T(Xc, Ka, Pa), rr === null ? Mo = Xc : rr.sibling = Xc, rr = Xc);
          }
          if (xa()) {
            var Ev = Pa;
            zp(ze, Ev);
          }
          return Mo;
        }
        for (var Bb = v(ze, So); !mi.done; Pa++, mi = nr.next()) {
          var ju = Be(Bb, ze, Pa, mi.value, mt);
          ju !== null && (o && ju.alternate !== null && Bb.delete(ju.key === null ? Pa : ju.key), Ka = T(ju, Ka, Pa), rr === null ? Mo = ju : rr.sibling = ju, rr = ju);
        }
        if (o && Bb.forEach(function(mee) {
          return i(ze, mee);
        }), xa()) {
          var pee = Pa;
          zp(ze, pee);
        }
        return Mo;
      }
      function rn(ze, Ze, Ve, mt) {
        if (Ze !== null && Ze.tag === O) {
          f(ze, Ze.sibling);
          var At = w(Ze, Ve);
          return At.return = ze, At;
        }
        f(ze, Ze);
        var Dt = qR(Ve, ze.mode, mt);
        return Dt.return = ze, Dt;
      }
      function en(ze, Ze, Ve, mt) {
        for (var At = Ve.key, Dt = Ze; Dt !== null; ) {
          if (Dt.key === At) {
            var dn = Ve.type;
            if (dn === zr) {
              if (Dt.tag === _) {
                f(ze, Dt.sibling);
                var xn = w(Dt, Ve.props.children);
                return xn.return = ze, xn._debugSource = Ve._source, xn._debugOwner = Ve._owner, xn;
              }
            } else if (Dt.elementType === dn || // Keep this check inline so it only runs on the false path:
            oj(Dt, Ve) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof dn == "object" && dn !== null && dn.$$typeof === $e && pA(dn) === Dt.type) {
              f(ze, Dt.sibling);
              var Er = w(Dt, Ve.props);
              return Er.ref = pb(ze, Dt, Ve), Er.return = ze, Er._debugSource = Ve._source, Er._debugOwner = Ve._owner, Er;
            }
            f(ze, Dt);
            break;
          } else
            i(ze, Dt);
          Dt = Dt.sibling;
        }
        if (Ve.type === zr) {
          var nr = bf(Ve.props.children, ze.mode, mt, Ve.key);
          return nr.return = ze, nr;
        } else {
          var Mo = YR(Ve, ze.mode, mt);
          return Mo.ref = pb(ze, Ze, Ve), Mo.return = ze, Mo;
        }
      }
      function Vn(ze, Ze, Ve, mt) {
        for (var At = Ve.key, Dt = Ze; Dt !== null; ) {
          if (Dt.key === At)
            if (Dt.tag === x && Dt.stateNode.containerInfo === Ve.containerInfo && Dt.stateNode.implementation === Ve.implementation) {
              f(ze, Dt.sibling);
              var dn = w(Dt, Ve.children || []);
              return dn.return = ze, dn;
            } else {
              f(ze, Dt);
              break;
            }
          else
            i(ze, Dt);
          Dt = Dt.sibling;
        }
        var xn = GR(Ve, ze.mode, mt);
        return xn.return = ze, xn;
      }
      function Nn(ze, Ze, Ve, mt) {
        var At = typeof Ve == "object" && Ve !== null && Ve.type === zr && Ve.key === null;
        if (At && (Ve = Ve.props.children), typeof Ve == "object" && Ve !== null) {
          switch (Ve.$$typeof) {
            case Dr:
              return $(en(ze, Ze, Ve, mt));
            case Fr:
              return $(Vn(ze, Ze, Ve, mt));
            case $e:
              var Dt = Ve._payload, dn = Ve._init;
              return Nn(ze, Ze, dn(Dt), mt);
          }
          if (jn(Ve))
            return Qe(ze, Ze, Ve, mt);
          if ($a(Ve))
            return It(ze, Ze, Ve, mt);
          bS(ze, Ve);
        }
        return typeof Ve == "string" && Ve !== "" || typeof Ve == "number" ? $(rn(ze, Ze, "" + Ve, mt)) : (typeof Ve == "function" && wS(ze), f(ze, Ze));
      }
      return Nn;
    }
    var sv = mA(!0), hA = mA(!1);
    function tQ(o, i) {
      if (o !== null && i.child !== o.child)
        throw new Error("Resuming work not yet implemented.");
      if (i.child !== null) {
        var f = i.child, v = Jp(f, f.pendingProps);
        for (i.child = v, v.return = i; f.sibling !== null; )
          f = f.sibling, v = v.sibling = Jp(f, f.pendingProps), v.return = i;
        v.sibling = null;
      }
    }
    function nQ(o, i) {
      for (var f = o.child; f !== null; )
        DJ(f, i), f = f.sibling;
    }
    var mb = {}, cf = of(mb), hb = of(mb), xS = of(mb);
    function SS(o) {
      if (o === mb)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return o;
    }
    function vA() {
      var o = SS(xS.current);
      return o;
    }
    function xP(o, i) {
      qa(xS, i, o), qa(hb, o, o), qa(cf, mb, o);
      var f = vK(i);
      Ya(cf, o), qa(cf, f, o);
    }
    function lv(o) {
      Ya(cf, o), Ya(hb, o), Ya(xS, o);
    }
    function SP() {
      var o = SS(cf.current);
      return o;
    }
    function yA(o) {
      SS(xS.current);
      var i = SS(cf.current), f = yK(i, o.type);
      i !== f && (qa(hb, o, o), qa(cf, f, o));
    }
    function EP(o) {
      hb.current === o && (Ya(cf, o), Ya(hb, o));
    }
    var rQ = 0, gA = 1, bA = 1, vb = 2, Dl = of(rQ);
    function CP(o, i) {
      return (o & i) !== 0;
    }
    function uv(o) {
      return o & gA;
    }
    function TP(o, i) {
      return o & gA | i;
    }
    function oQ(o, i) {
      return o | i;
    }
    function df(o, i) {
      qa(Dl, i, o);
    }
    function cv(o) {
      Ya(Dl, o);
    }
    function aQ(o, i) {
      var f = o.memoizedState;
      return f !== null ? f.dehydrated !== null : (o.memoizedProps, !0);
    }
    function ES(o) {
      for (var i = o; i !== null; ) {
        if (i.tag === R) {
          var f = i.memoizedState;
          if (f !== null) {
            var v = f.dehydrated;
            if (v === null || RI(v) || DO(v))
              return i;
          }
        } else if (i.tag === Z && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        i.memoizedProps.revealOrder !== void 0) {
          var w = (i.flags & pn) !== nn;
          if (w)
            return i;
        } else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === o)
          return null;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o)
            return null;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return null;
    }
    var zi = (
      /*   */
      0
    ), Ko = (
      /* */
      1
    ), ku = (
      /*  */
      2
    ), Xo = (
      /*    */
      4
    ), Sa = (
      /*   */
      8
    ), _P = [];
    function OP() {
      for (var o = 0; o < _P.length; o++) {
        var i = _P[o];
        i._workInProgressVersionPrimary = null;
      }
      _P.length = 0;
    }
    function iQ(o, i) {
      var f = i._getVersion, v = f(i._source);
      o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [i, v] : o.mutableSourceEagerHydrationData.push(i, v);
    }
    var Mt = n.ReactCurrentDispatcher, yb = n.ReactCurrentBatchConfig, PP, dv;
    PP = /* @__PURE__ */ new Set();
    var Yp = tt, Sr = null, Qo = null, Zo = null, CS = !1, gb = !1, bb = 0, sQ = 0, lQ = 25, rt = null, Ls = null, ff = -1, RP = !1;
    function mr() {
      {
        var o = rt;
        Ls === null ? Ls = [o] : Ls.push(o);
      }
    }
    function Ct() {
      {
        var o = rt;
        Ls !== null && (ff++, Ls[ff] !== o && uQ(o));
      }
    }
    function fv(o) {
      o != null && !jn(o) && l("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", rt, typeof o);
    }
    function uQ(o) {
      {
        var i = gn(Sr);
        if (!PP.has(i) && (PP.add(i), Ls !== null)) {
          for (var f = "", v = 30, w = 0; w <= ff; w++) {
            for (var T = Ls[w], $ = w === ff ? o : T, F = w + 1 + ". " + T; F.length < v; )
              F += " ";
            F += $ + `
`, f += F;
          }
          l(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, i, f);
        }
      }
    }
    function Ga() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function kP(o, i) {
      if (RP)
        return !1;
      if (i === null)
        return l("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", rt), !1;
      o.length !== i.length && l(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, rt, "[" + i.join(", ") + "]", "[" + o.join(", ") + "]");
      for (var f = 0; f < i.length && f < o.length; f++)
        if (!qt(o[f], i[f]))
          return !1;
      return !0;
    }
    function pv(o, i, f, v, w, T) {
      Yp = T, Sr = i, Ls = o !== null ? o._debugHookTypes : null, ff = -1, RP = o !== null && o.type !== i.type, i.memoizedState = null, i.updateQueue = null, i.lanes = tt, o !== null && o.memoizedState !== null ? Mt.current = VA : Ls !== null ? Mt.current = zA : Mt.current = FA;
      var $ = f(v, w);
      if (gb) {
        var F = 0;
        do {
          if (gb = !1, bb = 0, F >= lQ)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          F += 1, RP = !1, Qo = null, Zo = null, i.updateQueue = null, ff = -1, Mt.current = UA, $ = f(v, w);
        } while (gb);
      }
      Mt.current = jS, i._debugHookTypes = Ls;
      var W = Qo !== null && Qo.next !== null;
      if (Yp = tt, Sr = null, Qo = null, Zo = null, rt = null, Ls = null, ff = -1, o !== null && (o.flags & Yo) !== (i.flags & Yo) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (o.mode & kn) !== an && l("Internal React error: Expected static flag was missing. Please notify the React team."), CS = !1, W)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return $;
    }
    function mv() {
      var o = bb !== 0;
      return bb = 0, o;
    }
    function wA(o, i, f) {
      i.updateQueue = o.updateQueue, (i.mode & $i) !== an ? i.flags &= ~(gc | za | Xr | Sn) : i.flags &= ~(Xr | Sn), o.lanes = Vd(o.lanes, f);
    }
    function xA() {
      if (Mt.current = jS, CS) {
        for (var o = Sr.memoizedState; o !== null; ) {
          var i = o.queue;
          i !== null && (i.pending = null), o = o.next;
        }
        CS = !1;
      }
      Yp = tt, Sr = null, Qo = null, Zo = null, Ls = null, ff = -1, rt = null, NA = !1, gb = !1, bb = 0;
    }
    function Du() {
      var o = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Zo === null ? Sr.memoizedState = Zo = o : Zo = Zo.next = o, Zo;
    }
    function Fs() {
      var o;
      if (Qo === null) {
        var i = Sr.alternate;
        i !== null ? o = i.memoizedState : o = null;
      } else
        o = Qo.next;
      var f;
      if (Zo === null ? f = Sr.memoizedState : f = Zo.next, f !== null)
        Zo = f, f = Zo.next, Qo = o;
      else {
        if (o === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Qo = o;
        var v = {
          memoizedState: Qo.memoizedState,
          baseState: Qo.baseState,
          baseQueue: Qo.baseQueue,
          queue: Qo.queue,
          next: null
        };
        Zo === null ? Sr.memoizedState = Zo = v : Zo = Zo.next = v;
      }
      return Zo;
    }
    function SA() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function DP(o, i) {
      return typeof i == "function" ? i(o) : i;
    }
    function $P(o, i, f) {
      var v = Du(), w;
      f !== void 0 ? w = f(i) : w = i, v.memoizedState = v.baseState = w;
      var T = {
        pending: null,
        interleaved: null,
        lanes: tt,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: w
      };
      v.queue = T;
      var $ = T.dispatch = pQ.bind(null, Sr, T);
      return [v.memoizedState, $];
    }
    function MP(o, i, f) {
      var v = Fs(), w = v.queue;
      if (w === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      w.lastRenderedReducer = o;
      var T = Qo, $ = T.baseQueue, F = w.pending;
      if (F !== null) {
        if ($ !== null) {
          var W = $.next, ie = F.next;
          $.next = ie, F.next = W;
        }
        T.baseQueue !== $ && l("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), T.baseQueue = $ = F, w.pending = null;
      }
      if ($ !== null) {
        var ce = $.next, De = T.baseState, Re = null, Be = null, We = null, Qe = ce;
        do {
          var It = Qe.lane;
          if (Pc(Yp, It)) {
            if (We !== null) {
              var en = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Fn,
                action: Qe.action,
                hasEagerState: Qe.hasEagerState,
                eagerState: Qe.eagerState,
                next: null
              };
              We = We.next = en;
            }
            if (Qe.hasEagerState)
              De = Qe.eagerState;
            else {
              var Vn = Qe.action;
              De = o(De, Vn);
            }
          } else {
            var rn = {
              lane: It,
              action: Qe.action,
              hasEagerState: Qe.hasEagerState,
              eagerState: Qe.eagerState,
              next: null
            };
            We === null ? (Be = We = rn, Re = De) : We = We.next = rn, Sr.lanes = En(Sr.lanes, It), Lb(It);
          }
          Qe = Qe.next;
        } while (Qe !== null && Qe !== ce);
        We === null ? Re = De : We.next = Be, qt(De, v.memoizedState) || _b(), v.memoizedState = De, v.baseState = Re, v.baseQueue = We, w.lastRenderedState = De;
      }
      var Nn = w.interleaved;
      if (Nn !== null) {
        var ze = Nn;
        do {
          var Ze = ze.lane;
          Sr.lanes = En(Sr.lanes, Ze), Lb(Ze), ze = ze.next;
        } while (ze !== Nn);
      } else
        $ === null && (w.lanes = tt);
      var Ve = w.dispatch;
      return [v.memoizedState, Ve];
    }
    function NP(o, i, f) {
      var v = Fs(), w = v.queue;
      if (w === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      w.lastRenderedReducer = o;
      var T = w.dispatch, $ = w.pending, F = v.memoizedState;
      if ($ !== null) {
        w.pending = null;
        var W = $.next, ie = W;
        do {
          var ce = ie.action;
          F = o(F, ce), ie = ie.next;
        } while (ie !== W);
        qt(F, v.memoizedState) || _b(), v.memoizedState = F, v.baseQueue === null && (v.baseState = F), w.lastRenderedState = F;
      }
      return [F, T];
    }
    function cje(o, i, f) {
    }
    function dje(o, i, f) {
    }
    function IP(o, i, f) {
      var v = Sr, w = Du(), T, $ = xa();
      if ($) {
        if (f === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        T = f(), dv || T !== f() && (l("The result of getServerSnapshot should be cached to avoid an infinite loop"), dv = !0);
      } else {
        if (T = i(), !dv) {
          var F = i();
          qt(T, F) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), dv = !0);
        }
        var W = t1();
        if (W === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ep(W, Yp) || EA(v, i, T);
      }
      w.memoizedState = T;
      var ie = {
        value: T,
        getSnapshot: i
      };
      return w.queue = ie, RS(TA.bind(null, v, ie, o), [o]), v.flags |= Xr, wb(Ko | Sa, CA.bind(null, v, ie, T, i), void 0, null), T;
    }
    function TS(o, i, f) {
      var v = Sr, w = Fs(), T = i();
      if (!dv) {
        var $ = i();
        qt(T, $) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), dv = !0);
      }
      var F = w.memoizedState, W = !qt(F, T);
      W && (w.memoizedState = T, _b());
      var ie = w.queue;
      if (Sb(TA.bind(null, v, ie, o), [o]), ie.getSnapshot !== i || W || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Zo !== null && Zo.memoizedState.tag & Ko) {
        v.flags |= Xr, wb(Ko | Sa, CA.bind(null, v, ie, T, i), void 0, null);
        var ce = t1();
        if (ce === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ep(ce, Yp) || EA(v, i, T);
      }
      return T;
    }
    function EA(o, i, f) {
      o.flags |= mp;
      var v = {
        getSnapshot: i,
        value: f
      }, w = Sr.updateQueue;
      if (w === null)
        w = SA(), Sr.updateQueue = w, w.stores = [v];
      else {
        var T = w.stores;
        T === null ? w.stores = [v] : T.push(v);
      }
    }
    function CA(o, i, f, v) {
      i.value = f, i.getSnapshot = v, _A(i) && OA(o);
    }
    function TA(o, i, f) {
      var v = function() {
        _A(i) && OA(o);
      };
      return f(v);
    }
    function _A(o) {
      var i = o.getSnapshot, f = o.value;
      try {
        var v = i();
        return !qt(f, v);
      } catch {
        return !0;
      }
    }
    function OA(o) {
      var i = Fi(o, un);
      i !== null && na(i, o, un, Ir);
    }
    function _S(o) {
      var i = Du();
      typeof o == "function" && (o = o()), i.memoizedState = i.baseState = o;
      var f = {
        pending: null,
        interleaved: null,
        lanes: tt,
        dispatch: null,
        lastRenderedReducer: DP,
        lastRenderedState: o
      };
      i.queue = f;
      var v = f.dispatch = mQ.bind(null, Sr, f);
      return [i.memoizedState, v];
    }
    function AP(o) {
      return MP(DP);
    }
    function jP(o) {
      return NP(DP);
    }
    function wb(o, i, f, v) {
      var w = {
        tag: o,
        create: i,
        destroy: f,
        deps: v,
        // Circular
        next: null
      }, T = Sr.updateQueue;
      if (T === null)
        T = SA(), Sr.updateQueue = T, T.lastEffect = w.next = w;
      else {
        var $ = T.lastEffect;
        if ($ === null)
          T.lastEffect = w.next = w;
        else {
          var F = $.next;
          $.next = w, w.next = F, T.lastEffect = w;
        }
      }
      return w;
    }
    function LP(o) {
      var i = Du();
      {
        var f = {
          current: o
        };
        return i.memoizedState = f, f;
      }
    }
    function OS(o) {
      var i = Fs();
      return i.memoizedState;
    }
    function xb(o, i, f, v) {
      var w = Du(), T = v === void 0 ? null : v;
      Sr.flags |= o, w.memoizedState = wb(Ko | i, f, void 0, T);
    }
    function PS(o, i, f, v) {
      var w = Fs(), T = v === void 0 ? null : v, $ = void 0;
      if (Qo !== null) {
        var F = Qo.memoizedState;
        if ($ = F.destroy, T !== null) {
          var W = F.deps;
          if (kP(T, W)) {
            w.memoizedState = wb(i, f, $, T);
            return;
          }
        }
      }
      Sr.flags |= o, w.memoizedState = wb(Ko | i, f, $, T);
    }
    function RS(o, i) {
      return (Sr.mode & $i) !== an ? xb(gc | Xr | pu, Sa, o, i) : xb(Xr | pu, Sa, o, i);
    }
    function Sb(o, i) {
      return PS(Xr, Sa, o, i);
    }
    function FP(o, i) {
      return xb(Sn, ku, o, i);
    }
    function kS(o, i) {
      return PS(Sn, ku, o, i);
    }
    function zP(o, i) {
      var f = Sn;
      return f |= Fa, (Sr.mode & $i) !== an && (f |= za), xb(f, Xo, o, i);
    }
    function DS(o, i) {
      return PS(Sn, Xo, o, i);
    }
    function PA(o, i) {
      if (typeof i == "function") {
        var f = i, v = o();
        return f(v), function() {
          f(null);
        };
      } else if (i != null) {
        var w = i;
        w.hasOwnProperty("current") || l("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(w).join(", ") + "}");
        var T = o();
        return w.current = T, function() {
          w.current = null;
        };
      }
    }
    function VP(o, i, f) {
      typeof i != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", i !== null ? typeof i : "null");
      var v = f != null ? f.concat([o]) : null, w = Sn;
      return w |= Fa, (Sr.mode & $i) !== an && (w |= za), xb(w, Xo, PA.bind(null, i, o), v);
    }
    function $S(o, i, f) {
      typeof i != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", i !== null ? typeof i : "null");
      var v = f != null ? f.concat([o]) : null;
      return PS(Sn, Xo, PA.bind(null, i, o), v);
    }
    function cQ(o, i) {
    }
    var MS = cQ;
    function UP(o, i) {
      var f = Du(), v = i === void 0 ? null : i;
      return f.memoizedState = [o, v], o;
    }
    function NS(o, i) {
      var f = Fs(), v = i === void 0 ? null : i, w = f.memoizedState;
      if (w !== null && v !== null) {
        var T = w[1];
        if (kP(v, T))
          return w[0];
      }
      return f.memoizedState = [o, v], o;
    }
    function BP(o, i) {
      var f = Du(), v = i === void 0 ? null : i, w = o();
      return f.memoizedState = [w, v], w;
    }
    function IS(o, i) {
      var f = Fs(), v = i === void 0 ? null : i, w = f.memoizedState;
      if (w !== null && v !== null) {
        var T = w[1];
        if (kP(v, T))
          return w[0];
      }
      var $ = o();
      return f.memoizedState = [$, v], $;
    }
    function HP(o) {
      var i = Du();
      return i.memoizedState = o, o;
    }
    function RA(o) {
      var i = Fs(), f = Qo, v = f.memoizedState;
      return DA(i, v, o);
    }
    function kA(o) {
      var i = Fs();
      if (Qo === null)
        return i.memoizedState = o, o;
      var f = Qo.memoizedState;
      return DA(i, f, o);
    }
    function DA(o, i, f) {
      var v = !X_(Yp);
      if (v) {
        if (!qt(f, i)) {
          var w = Eg();
          Sr.lanes = En(Sr.lanes, w), Lb(w), o.baseState = !0;
        }
        return i;
      } else
        return o.baseState && (o.baseState = !1, _b()), o.memoizedState = f, f;
    }
    function dQ(o, i, f) {
      var v = Ni();
      ko(da(v, Go)), o(!0);
      var w = yb.transition;
      yb.transition = {};
      var T = yb.transition;
      yb.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        o(!1), i();
      } finally {
        if (ko(v), yb.transition = w, w === null && T._updatedFibers) {
          var $ = T._updatedFibers.size;
          $ > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), T._updatedFibers.clear();
        }
      }
    }
    function WP() {
      var o = _S(!1), i = o[0], f = o[1], v = dQ.bind(null, f), w = Du();
      return w.memoizedState = v, [i, v];
    }
    function $A() {
      var o = AP(), i = o[0], f = Fs(), v = f.memoizedState;
      return [i, v];
    }
    function MA() {
      var o = jP(), i = o[0], f = Fs(), v = f.memoizedState;
      return [i, v];
    }
    var NA = !1;
    function fQ() {
      return NA;
    }
    function YP() {
      var o = Du(), i = t1(), f = i.identifierPrefix, v;
      if (xa()) {
        var w = _X();
        v = ":" + f + "R" + w;
        var T = bb++;
        T > 0 && (v += "H" + T.toString(32)), v += ":";
      } else {
        var $ = sQ++;
        v = ":" + f + "r" + $.toString(32) + ":";
      }
      return o.memoizedState = v, v;
    }
    function AS() {
      var o = Fs(), i = o.memoizedState;
      return i;
    }
    function pQ(o, i, f) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var v = yf(o), w = {
        lane: v,
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IA(o))
        AA(i, w);
      else {
        var T = JI(o, i, w, v);
        if (T !== null) {
          var $ = pi();
          na(T, o, v, $), jA(T, i, v);
        }
      }
      LA(o, v);
    }
    function mQ(o, i, f) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var v = yf(o), w = {
        lane: v,
        action: f,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (IA(o))
        AA(i, w);
      else {
        var T = o.alternate;
        if (o.lanes === tt && (T === null || T.lanes === tt)) {
          var $ = i.lastRenderedReducer;
          if ($ !== null) {
            var F;
            F = Mt.current, Mt.current = $l;
            try {
              var W = i.lastRenderedState, ie = $(W, f);
              if (w.hasEagerState = !0, w.eagerState = ie, qt(ie, W)) {
                YX(o, i, w, v);
                return;
              }
            } catch {
            } finally {
              Mt.current = F;
            }
          }
        }
        var ce = JI(o, i, w, v);
        if (ce !== null) {
          var De = pi();
          na(ce, o, v, De), jA(ce, i, v);
        }
      }
      LA(o, v);
    }
    function IA(o) {
      var i = o.alternate;
      return o === Sr || i !== null && i === Sr;
    }
    function AA(o, i) {
      gb = CS = !0;
      var f = o.pending;
      f === null ? i.next = i : (i.next = f.next, f.next = i), o.pending = i;
    }
    function jA(o, i, f) {
      if (Sg(f)) {
        var v = i.lanes;
        v = Cg(v, o.pendingLanes);
        var w = En(v, f);
        i.lanes = w, Ud(o, w);
      }
    }
    function LA(o, i, f) {
      bu(o, i);
    }
    var jS = {
      readContext: Ho,
      useCallback: Ga,
      useContext: Ga,
      useEffect: Ga,
      useImperativeHandle: Ga,
      useInsertionEffect: Ga,
      useLayoutEffect: Ga,
      useMemo: Ga,
      useReducer: Ga,
      useRef: Ga,
      useState: Ga,
      useDebugValue: Ga,
      useDeferredValue: Ga,
      useTransition: Ga,
      useMutableSource: Ga,
      useSyncExternalStore: Ga,
      useId: Ga,
      unstable_isNewReconciler: ae
    }, FA = null, zA = null, VA = null, UA = null, $u = null, $l = null, LS = null;
    {
      var qP = function() {
        l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, bn = function() {
        l("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      FA = {
        readContext: function(o) {
          return Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", mr(), fv(i), UP(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", mr(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", mr(), fv(i), RS(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", mr(), fv(f), VP(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", mr(), fv(i), FP(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", mr(), fv(i), zP(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", mr(), fv(i);
          var f = Mt.current;
          Mt.current = $u;
          try {
            return BP(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", mr();
          var v = Mt.current;
          Mt.current = $u;
          try {
            return $P(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", mr(), LP(o);
        },
        useState: function(o) {
          rt = "useState", mr();
          var i = Mt.current;
          Mt.current = $u;
          try {
            return _S(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", mr(), void 0;
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", mr(), HP(o);
        },
        useTransition: function() {
          return rt = "useTransition", mr(), WP();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", mr(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", mr(), IP(o, i, f);
        },
        useId: function() {
          return rt = "useId", mr(), YP();
        },
        unstable_isNewReconciler: ae
      }, zA = {
        readContext: function(o) {
          return Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", Ct(), UP(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", Ct(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", Ct(), RS(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", Ct(), VP(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", Ct(), FP(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", Ct(), zP(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", Ct();
          var f = Mt.current;
          Mt.current = $u;
          try {
            return BP(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", Ct();
          var v = Mt.current;
          Mt.current = $u;
          try {
            return $P(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", Ct(), LP(o);
        },
        useState: function(o) {
          rt = "useState", Ct();
          var i = Mt.current;
          Mt.current = $u;
          try {
            return _S(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", Ct(), void 0;
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", Ct(), HP(o);
        },
        useTransition: function() {
          return rt = "useTransition", Ct(), WP();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", Ct(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", Ct(), IP(o, i, f);
        },
        useId: function() {
          return rt = "useId", Ct(), YP();
        },
        unstable_isNewReconciler: ae
      }, VA = {
        readContext: function(o) {
          return Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", Ct(), NS(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", Ct(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", Ct(), Sb(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", Ct(), $S(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", Ct(), kS(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", Ct(), DS(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", Ct();
          var f = Mt.current;
          Mt.current = $l;
          try {
            return IS(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", Ct();
          var v = Mt.current;
          Mt.current = $l;
          try {
            return MP(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", Ct(), OS();
        },
        useState: function(o) {
          rt = "useState", Ct();
          var i = Mt.current;
          Mt.current = $l;
          try {
            return AP(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", Ct(), MS();
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", Ct(), RA(o);
        },
        useTransition: function() {
          return rt = "useTransition", Ct(), $A();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", Ct(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", Ct(), TS(o, i);
        },
        useId: function() {
          return rt = "useId", Ct(), AS();
        },
        unstable_isNewReconciler: ae
      }, UA = {
        readContext: function(o) {
          return Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", Ct(), NS(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", Ct(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", Ct(), Sb(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", Ct(), $S(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", Ct(), kS(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", Ct(), DS(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", Ct();
          var f = Mt.current;
          Mt.current = LS;
          try {
            return IS(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", Ct();
          var v = Mt.current;
          Mt.current = LS;
          try {
            return NP(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", Ct(), OS();
        },
        useState: function(o) {
          rt = "useState", Ct();
          var i = Mt.current;
          Mt.current = LS;
          try {
            return jP(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", Ct(), MS();
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", Ct(), kA(o);
        },
        useTransition: function() {
          return rt = "useTransition", Ct(), MA();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", Ct(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", Ct(), TS(o, i);
        },
        useId: function() {
          return rt = "useId", Ct(), AS();
        },
        unstable_isNewReconciler: ae
      }, $u = {
        readContext: function(o) {
          return qP(), Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", bn(), mr(), UP(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", bn(), mr(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", bn(), mr(), RS(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", bn(), mr(), VP(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", bn(), mr(), FP(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", bn(), mr(), zP(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", bn(), mr();
          var f = Mt.current;
          Mt.current = $u;
          try {
            return BP(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", bn(), mr();
          var v = Mt.current;
          Mt.current = $u;
          try {
            return $P(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", bn(), mr(), LP(o);
        },
        useState: function(o) {
          rt = "useState", bn(), mr();
          var i = Mt.current;
          Mt.current = $u;
          try {
            return _S(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", bn(), mr(), void 0;
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", bn(), mr(), HP(o);
        },
        useTransition: function() {
          return rt = "useTransition", bn(), mr(), WP();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", bn(), mr(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", bn(), mr(), IP(o, i, f);
        },
        useId: function() {
          return rt = "useId", bn(), mr(), YP();
        },
        unstable_isNewReconciler: ae
      }, $l = {
        readContext: function(o) {
          return qP(), Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", bn(), Ct(), NS(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", bn(), Ct(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", bn(), Ct(), Sb(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", bn(), Ct(), $S(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", bn(), Ct(), kS(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", bn(), Ct(), DS(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", bn(), Ct();
          var f = Mt.current;
          Mt.current = $l;
          try {
            return IS(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", bn(), Ct();
          var v = Mt.current;
          Mt.current = $l;
          try {
            return MP(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", bn(), Ct(), OS();
        },
        useState: function(o) {
          rt = "useState", bn(), Ct();
          var i = Mt.current;
          Mt.current = $l;
          try {
            return AP(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", bn(), Ct(), MS();
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", bn(), Ct(), RA(o);
        },
        useTransition: function() {
          return rt = "useTransition", bn(), Ct(), $A();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", bn(), Ct(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", bn(), Ct(), TS(o, i);
        },
        useId: function() {
          return rt = "useId", bn(), Ct(), AS();
        },
        unstable_isNewReconciler: ae
      }, LS = {
        readContext: function(o) {
          return qP(), Ho(o);
        },
        useCallback: function(o, i) {
          return rt = "useCallback", bn(), Ct(), NS(o, i);
        },
        useContext: function(o) {
          return rt = "useContext", bn(), Ct(), Ho(o);
        },
        useEffect: function(o, i) {
          return rt = "useEffect", bn(), Ct(), Sb(o, i);
        },
        useImperativeHandle: function(o, i, f) {
          return rt = "useImperativeHandle", bn(), Ct(), $S(o, i, f);
        },
        useInsertionEffect: function(o, i) {
          return rt = "useInsertionEffect", bn(), Ct(), kS(o, i);
        },
        useLayoutEffect: function(o, i) {
          return rt = "useLayoutEffect", bn(), Ct(), DS(o, i);
        },
        useMemo: function(o, i) {
          rt = "useMemo", bn(), Ct();
          var f = Mt.current;
          Mt.current = $l;
          try {
            return IS(o, i);
          } finally {
            Mt.current = f;
          }
        },
        useReducer: function(o, i, f) {
          rt = "useReducer", bn(), Ct();
          var v = Mt.current;
          Mt.current = $l;
          try {
            return NP(o, i, f);
          } finally {
            Mt.current = v;
          }
        },
        useRef: function(o) {
          return rt = "useRef", bn(), Ct(), OS();
        },
        useState: function(o) {
          rt = "useState", bn(), Ct();
          var i = Mt.current;
          Mt.current = $l;
          try {
            return jP(o);
          } finally {
            Mt.current = i;
          }
        },
        useDebugValue: function(o, i) {
          return rt = "useDebugValue", bn(), Ct(), MS();
        },
        useDeferredValue: function(o) {
          return rt = "useDeferredValue", bn(), Ct(), kA(o);
        },
        useTransition: function() {
          return rt = "useTransition", bn(), Ct(), MA();
        },
        useMutableSource: function(o, i, f) {
          return rt = "useMutableSource", bn(), Ct(), void 0;
        },
        useSyncExternalStore: function(o, i, f) {
          return rt = "useSyncExternalStore", bn(), Ct(), TS(o, i);
        },
        useId: function() {
          return rt = "useId", bn(), Ct(), AS();
        },
        unstable_isNewReconciler: ae
      };
    }
    var pf = t.unstable_now, BA = 0, FS = -1, Eb = -1, zS = -1, GP = !1, VS = !1;
    function HA() {
      return GP;
    }
    function hQ() {
      VS = !0;
    }
    function vQ() {
      GP = !1, VS = !1;
    }
    function yQ() {
      GP = VS, VS = !1;
    }
    function WA() {
      return BA;
    }
    function YA() {
      BA = pf();
    }
    function KP(o) {
      Eb = pf(), o.actualStartTime < 0 && (o.actualStartTime = pf());
    }
    function qA(o) {
      Eb = -1;
    }
    function US(o, i) {
      if (Eb >= 0) {
        var f = pf() - Eb;
        o.actualDuration += f, i && (o.selfBaseDuration = f), Eb = -1;
      }
    }
    function Mu(o) {
      if (FS >= 0) {
        var i = pf() - FS;
        FS = -1;
        for (var f = o.return; f !== null; ) {
          switch (f.tag) {
            case b:
              var v = f.stateNode;
              v.effectDuration += i;
              return;
            case I:
              var w = f.stateNode;
              w.effectDuration += i;
              return;
          }
          f = f.return;
        }
      }
    }
    function XP(o) {
      if (zS >= 0) {
        var i = pf() - zS;
        zS = -1;
        for (var f = o.return; f !== null; ) {
          switch (f.tag) {
            case b:
              var v = f.stateNode;
              v !== null && (v.passiveEffectDuration += i);
              return;
            case I:
              var w = f.stateNode;
              w !== null && (w.passiveEffectDuration += i);
              return;
          }
          f = f.return;
        }
      }
    }
    function Nu() {
      FS = pf();
    }
    function QP() {
      zS = pf();
    }
    function ZP(o) {
      for (var i = o.child; i; )
        o.actualDuration += i.actualDuration, i = i.sibling;
    }
    function qp(o, i) {
      return {
        value: o,
        source: i,
        stack: bd(i),
        digest: null
      };
    }
    function JP(o, i, f) {
      return {
        value: o,
        source: null,
        stack: f ?? null,
        digest: i ?? null
      };
    }
    function gQ(o, i) {
      return !0;
    }
    function eR(o, i) {
      try {
        var f = gQ(o, i);
        if (f === !1)
          return;
        var v = i.value, w = i.source, T = i.stack, $ = T !== null ? T : "";
        if (v != null && v._suppressLogging) {
          if (o.tag === h)
            return;
          console.error(v);
        }
        var F = w ? gn(w) : null, W = F ? "The above error occurred in the <" + F + "> component:" : "The above error occurred in one of your React components:", ie;
        if (o.tag === b)
          ie = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ce = gn(o) || "Anonymous";
          ie = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ce + ".");
        }
        var De = W + `
` + $ + `

` + ("" + ie);
        console.error(De);
      } catch (Re) {
        setTimeout(function() {
          throw Re;
        });
      }
    }
    var bQ = typeof WeakMap == "function" ? WeakMap : Map;
    function GA(o, i, f) {
      var v = Hc(Ir, f);
      v.tag = eP, v.payload = {
        element: null
      };
      var w = i.value;
      return v.callback = function() {
        dJ(w), eR(o, i);
      }, v;
    }
    function tR(o, i, f) {
      var v = Hc(Ir, f);
      v.tag = eP;
      var w = o.type.getDerivedStateFromError;
      if (typeof w == "function") {
        var T = i.value;
        v.payload = function() {
          return w(T);
        }, v.callback = function() {
          aj(o), eR(o, i);
        };
      }
      var $ = o.stateNode;
      return $ !== null && typeof $.componentDidCatch == "function" && (v.callback = function() {
        aj(o), eR(o, i), typeof w != "function" && uJ(this);
        var W = i.value, ie = i.stack;
        this.componentDidCatch(W, {
          componentStack: ie !== null ? ie : ""
        }), typeof w != "function" && (Wa(o.lanes, un) || l("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", gn(o) || "Unknown"));
      }), v;
    }
    function KA(o, i, f) {
      var v = o.pingCache, w;
      if (v === null ? (v = o.pingCache = new bQ(), w = /* @__PURE__ */ new Set(), v.set(i, w)) : (w = v.get(i), w === void 0 && (w = /* @__PURE__ */ new Set(), v.set(i, w))), !w.has(f)) {
        w.add(f);
        var T = fJ.bind(null, o, i, f);
        qo && Fb(o, f), i.then(T, T);
      }
    }
    function wQ(o, i, f, v) {
      var w = o.updateQueue;
      if (w === null) {
        var T = /* @__PURE__ */ new Set();
        T.add(f), o.updateQueue = T;
      } else
        w.add(f);
    }
    function xQ(o, i) {
      var f = o.tag;
      if ((o.mode & kn) === an && (f === m || f === N || f === U)) {
        var v = o.alternate;
        v ? (o.updateQueue = v.updateQueue, o.memoizedState = v.memoizedState, o.lanes = v.lanes) : (o.updateQueue = null, o.memoizedState = null);
      }
    }
    function XA(o) {
      var i = o;
      do {
        if (i.tag === R && aQ(i))
          return i;
        i = i.return;
      } while (i !== null);
      return null;
    }
    function QA(o, i, f, v, w) {
      if ((o.mode & kn) === an) {
        if (o === i)
          o.flags |= Fo;
        else {
          if (o.flags |= pn, f.flags |= hp, f.flags &= ~(Jm | ai), f.tag === h) {
            var T = f.alternate;
            if (T === null)
              f.tag = J;
            else {
              var $ = Hc(Ir, un);
              $.tag = fS, uf(f, $, un);
            }
          }
          f.lanes = En(f.lanes, un);
        }
        return o;
      }
      return o.flags |= Fo, o.lanes = w, o;
    }
    function SQ(o, i, f, v, w) {
      if (f.flags |= ai, qo && Fb(o, w), v !== null && typeof v == "object" && typeof v.then == "function") {
        var T = v;
        xQ(f), xa() && f.mode & kn && VI();
        var $ = XA(i);
        if ($ !== null) {
          $.flags &= ~so, QA($, i, f, o, w), $.mode & kn && KA(o, T, w), wQ($, o, T);
          return;
        } else {
          if (!zd(w)) {
            KA(o, T, w), NR();
            return;
          }
          var F = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          v = F;
        }
      } else if (xa() && f.mode & kn) {
        VI();
        var W = XA(i);
        if (W !== null) {
          (W.flags & Fo) === nn && (W.flags |= so), QA(W, i, f, o, w), qO(qp(v, f));
          return;
        }
      }
      v = qp(v, f), tJ(v);
      var ie = i;
      do {
        switch (ie.tag) {
          case b: {
            var ce = v;
            ie.flags |= Fo;
            var De = Ro(w);
            ie.lanes = En(ie.lanes, De);
            var Re = GA(ie, ce, De);
            rP(ie, Re);
            return;
          }
          case h:
            var Be = v, We = ie.type, Qe = ie.stateNode;
            if ((ie.flags & pn) === nn && (typeof We.getDerivedStateFromError == "function" || Qe !== null && typeof Qe.componentDidCatch == "function" && !X2(Qe))) {
              ie.flags |= Fo;
              var It = Ro(w);
              ie.lanes = En(ie.lanes, It);
              var rn = tR(ie, Be, It);
              rP(ie, rn);
              return;
            }
            break;
        }
        ie = ie.return;
      } while (ie !== null);
    }
    function EQ() {
      return null;
    }
    var Cb = n.ReactCurrentOwner, Ml = !1, nR, Tb, rR, oR, aR, Gp, iR, BS;
    nR = {}, Tb = {}, rR = {}, oR = {}, aR = {}, Gp = !1, iR = {}, BS = {};
    function di(o, i, f, v) {
      o === null ? i.child = hA(i, null, f, v) : i.child = sv(i, o.child, f, v);
    }
    function CQ(o, i, f, v) {
      i.child = sv(i, o.child, null, v), i.child = sv(i, null, f, v);
    }
    function ZA(o, i, f, v, w) {
      if (i.type !== i.elementType) {
        var T = f.propTypes;
        T && Ol(
          T,
          v,
          // Resolved props
          "prop",
          qn(f)
        );
      }
      var $ = f.render, F = i.ref, W, ie;
      iv(i, w), gu(i);
      {
        if (Cb.current = i, Aa(!0), W = pv(o, i, $, v, F, w), ie = mv(), i.mode & no) {
          Po(!0);
          try {
            W = pv(o, i, $, v, F, w), ie = mv();
          } finally {
            Po(!1);
          }
        }
        Aa(!1);
      }
      return bc(), o !== null && !Ml ? (wA(o, i, w), Wc(o, i, w)) : (xa() && ie && VO(i), i.flags |= du, di(o, i, W, w), i.child);
    }
    function JA(o, i, f, v, w) {
      if (o === null) {
        var T = f.type;
        if (RJ(T) && f.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        f.defaultProps === void 0) {
          var $ = T;
          return $ = Sv(T), i.tag = U, i.type = $, uR(i, T), e2(o, i, $, v, w);
        }
        {
          var F = T.propTypes;
          F && Ol(
            F,
            v,
            // Resolved props
            "prop",
            qn(T)
          );
        }
        var W = WR(f.type, null, v, i, i.mode, w);
        return W.ref = i.ref, W.return = i, i.child = W, W;
      }
      {
        var ie = f.type, ce = ie.propTypes;
        ce && Ol(
          ce,
          v,
          // Resolved props
          "prop",
          qn(ie)
        );
      }
      var De = o.child, Re = hR(o, w);
      if (!Re) {
        var Be = De.memoizedProps, We = f.compare;
        if (We = We !== null ? We : tn, We(Be, v) && o.ref === i.ref)
          return Wc(o, i, w);
      }
      i.flags |= du;
      var Qe = Jp(De, v);
      return Qe.ref = i.ref, Qe.return = i, i.child = Qe, Qe;
    }
    function e2(o, i, f, v, w) {
      if (i.type !== i.elementType) {
        var T = i.elementType;
        if (T.$$typeof === $e) {
          var $ = T, F = $._payload, W = $._init;
          try {
            T = W(F);
          } catch {
            T = null;
          }
          var ie = T && T.propTypes;
          ie && Ol(
            ie,
            v,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            qn(T)
          );
        }
      }
      if (o !== null) {
        var ce = o.memoizedProps;
        if (tn(ce, v) && o.ref === i.ref && // Prevent bailout if the implementation changed due to hot reload.
        i.type === o.type)
          if (Ml = !1, i.pendingProps = v = ce, hR(o, w))
            (o.flags & hp) !== nn && (Ml = !0);
          else
            return i.lanes = o.lanes, Wc(o, i, w);
      }
      return sR(o, i, f, v, w);
    }
    function t2(o, i, f) {
      var v = i.pendingProps, w = v.children, T = o !== null ? o.memoizedState : null;
      if (v.mode === "hidden" || V)
        if ((i.mode & kn) === an) {
          var $ = {
            baseLanes: tt,
            cachePool: null,
            transitions: null
          };
          i.memoizedState = $, n1(i, f);
        } else if (Wa(f, Ha)) {
          var De = {
            baseLanes: tt,
            cachePool: null,
            transitions: null
          };
          i.memoizedState = De;
          var Re = T !== null ? T.baseLanes : f;
          n1(i, Re);
        } else {
          var F = null, W;
          if (T !== null) {
            var ie = T.baseLanes;
            W = En(ie, f);
          } else
            W = f;
          i.lanes = i.childLanes = Ha;
          var ce = {
            baseLanes: W,
            cachePool: F,
            transitions: null
          };
          return i.memoizedState = ce, i.updateQueue = null, n1(i, W), null;
        }
      else {
        var Be;
        T !== null ? (Be = En(T.baseLanes, f), i.memoizedState = null) : Be = f, n1(i, Be);
      }
      return di(o, i, w, f), i.child;
    }
    function TQ(o, i, f) {
      var v = i.pendingProps;
      return di(o, i, v, f), i.child;
    }
    function _Q(o, i, f) {
      var v = i.pendingProps.children;
      return di(o, i, v, f), i.child;
    }
    function OQ(o, i, f) {
      {
        i.flags |= Sn;
        {
          var v = i.stateNode;
          v.effectDuration = 0, v.passiveEffectDuration = 0;
        }
      }
      var w = i.pendingProps, T = w.children;
      return di(o, i, T, f), i.child;
    }
    function n2(o, i) {
      var f = i.ref;
      (o === null && f !== null || o !== null && o.ref !== f) && (i.flags |= La, i.flags |= sg);
    }
    function sR(o, i, f, v, w) {
      if (i.type !== i.elementType) {
        var T = f.propTypes;
        T && Ol(
          T,
          v,
          // Resolved props
          "prop",
          qn(f)
        );
      }
      var $;
      {
        var F = ev(i, f, !0);
        $ = tv(i, F);
      }
      var W, ie;
      iv(i, w), gu(i);
      {
        if (Cb.current = i, Aa(!0), W = pv(o, i, f, v, $, w), ie = mv(), i.mode & no) {
          Po(!0);
          try {
            W = pv(o, i, f, v, $, w), ie = mv();
          } finally {
            Po(!1);
          }
        }
        Aa(!1);
      }
      return bc(), o !== null && !Ml ? (wA(o, i, w), Wc(o, i, w)) : (xa() && ie && VO(i), i.flags |= du, di(o, i, W, w), i.child);
    }
    function r2(o, i, f, v, w) {
      {
        switch (HJ(i)) {
          case !1: {
            var T = i.stateNode, $ = i.type, F = new $(i.memoizedProps, T.context), W = F.state;
            T.updater.enqueueSetState(T, W, null);
            break;
          }
          case !0: {
            i.flags |= pn, i.flags |= Fo;
            var ie = new Error("Simulated error coming from DevTools"), ce = Ro(w);
            i.lanes = En(i.lanes, ce);
            var De = tR(i, qp(ie, i), ce);
            rP(i, De);
            break;
          }
        }
        if (i.type !== i.elementType) {
          var Re = f.propTypes;
          Re && Ol(
            Re,
            v,
            // Resolved props
            "prop",
            qn(f)
          );
        }
      }
      var Be;
      Ru(f) ? (Be = !0, tS(i)) : Be = !1, iv(i, w);
      var We = i.stateNode, Qe;
      We === null ? (WS(o, i), cA(i, f, v), hP(i, f, v, w), Qe = !0) : o === null ? Qe = JX(i, f, v, w) : Qe = eQ(o, i, f, v, w);
      var It = lR(o, i, f, Qe, Be, w);
      {
        var rn = i.stateNode;
        Qe && rn.props !== v && (Gp || l("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", gn(i) || "a component"), Gp = !0);
      }
      return It;
    }
    function lR(o, i, f, v, w, T) {
      n2(o, i);
      var $ = (i.flags & pn) !== nn;
      if (!v && !$)
        return w && jI(i, f, !1), Wc(o, i, T);
      var F = i.stateNode;
      Cb.current = i;
      var W;
      if ($ && typeof f.getDerivedStateFromError != "function")
        W = null, qA();
      else {
        gu(i);
        {
          if (Aa(!0), W = F.render(), i.mode & no) {
            Po(!0);
            try {
              F.render();
            } finally {
              Po(!1);
            }
          }
          Aa(!1);
        }
        bc();
      }
      return i.flags |= du, o !== null && $ ? CQ(o, i, W, T) : di(o, i, W, T), i.memoizedState = F.state, w && jI(i, f, !0), i.child;
    }
    function o2(o) {
      var i = o.stateNode;
      i.pendingContext ? II(o, i.pendingContext, i.pendingContext !== i.context) : i.context && II(o, i.context, !1), xP(o, i.containerInfo);
    }
    function PQ(o, i, f) {
      if (o2(i), o === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var v = i.pendingProps, w = i.memoizedState, T = w.element;
      nA(o, i), vS(i, v, null, f);
      var $ = i.memoizedState;
      i.stateNode;
      var F = $.element;
      if (w.isDehydrated) {
        var W = {
          element: F,
          isDehydrated: !1,
          cache: $.cache,
          pendingSuspenseBoundaries: $.pendingSuspenseBoundaries,
          transitions: $.transitions
        }, ie = i.updateQueue;
        if (ie.baseState = W, i.memoizedState = W, i.flags & so) {
          var ce = qp(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), i);
          return a2(o, i, F, f, ce);
        } else if (F !== T) {
          var De = qp(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), i);
          return a2(o, i, F, f, De);
        } else {
          $X(i);
          var Re = hA(i, null, F, f);
          i.child = Re;
          for (var Be = Re; Be; )
            Be.flags = Be.flags & ~Br | Ri, Be = Be.sibling;
        }
      } else {
        if (ov(), F === T)
          return Wc(o, i, f);
        di(o, i, F, f);
      }
      return i.child;
    }
    function a2(o, i, f, v, w) {
      return ov(), qO(w), i.flags |= so, di(o, i, f, v), i.child;
    }
    function RQ(o, i, f) {
      yA(i), o === null && YO(i);
      var v = i.type, w = i.pendingProps, T = o !== null ? o.memoizedProps : null, $ = w.children, F = OO(v, w);
      return F ? $ = null : T !== null && OO(v, T) && (i.flags |= pr), n2(o, i), di(o, i, $, f), i.child;
    }
    function kQ(o, i) {
      return o === null && YO(i), null;
    }
    function DQ(o, i, f, v) {
      WS(o, i);
      var w = i.pendingProps, T = f, $ = T._payload, F = T._init, W = F($);
      i.type = W;
      var ie = i.tag = kJ(W), ce = kl(W, w), De;
      switch (ie) {
        case m:
          return uR(i, W), i.type = W = Sv(W), De = sR(null, i, W, ce, v), De;
        case h:
          return i.type = W = FR(W), De = r2(null, i, W, ce, v), De;
        case N:
          return i.type = W = zR(W), De = ZA(null, i, W, ce, v), De;
        case j: {
          if (i.type !== i.elementType) {
            var Re = W.propTypes;
            Re && Ol(
              Re,
              ce,
              // Resolved for outer only
              "prop",
              qn(W)
            );
          }
          return De = JA(
            null,
            i,
            W,
            kl(W.type, ce),
            // The inner type can have defaults too
            v
          ), De;
        }
      }
      var Be = "";
      throw W !== null && typeof W == "object" && W.$$typeof === $e && (Be = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + W + ". " + ("Lazy element type must resolve to a class or function." + Be));
    }
    function $Q(o, i, f, v, w) {
      WS(o, i), i.tag = h;
      var T;
      return Ru(f) ? (T = !0, tS(i)) : T = !1, iv(i, w), cA(i, f, v), hP(i, f, v, w), lR(null, i, f, !0, T, w);
    }
    function MQ(o, i, f, v) {
      WS(o, i);
      var w = i.pendingProps, T;
      {
        var $ = ev(i, f, !1);
        T = tv(i, $);
      }
      iv(i, v);
      var F, W;
      gu(i);
      {
        if (f.prototype && typeof f.prototype.render == "function") {
          var ie = qn(f) || "Unknown";
          nR[ie] || (l("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ie, ie), nR[ie] = !0);
        }
        i.mode & no && Rl.recordLegacyContextWarning(i, null), Aa(!0), Cb.current = i, F = pv(null, i, f, w, T, v), W = mv(), Aa(!1);
      }
      if (bc(), i.flags |= du, typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0) {
        var ce = qn(f) || "Unknown";
        Tb[ce] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ce, ce, ce), Tb[ce] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof F == "object" && F !== null && typeof F.render == "function" && F.$$typeof === void 0
      ) {
        {
          var De = qn(f) || "Unknown";
          Tb[De] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", De, De, De), Tb[De] = !0);
        }
        i.tag = h, i.memoizedState = null, i.updateQueue = null;
        var Re = !1;
        return Ru(f) ? (Re = !0, tS(i)) : Re = !1, i.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null, nP(i), uA(i, F), hP(i, f, w, v), lR(null, i, f, !0, Re, v);
      } else {
        if (i.tag = m, i.mode & no) {
          Po(!0);
          try {
            F = pv(null, i, f, w, T, v), W = mv();
          } finally {
            Po(!1);
          }
        }
        return xa() && W && VO(i), di(null, i, F, v), uR(i, f), i.child;
      }
    }
    function uR(o, i) {
      {
        if (i && i.childContextTypes && l("%s(...): childContextTypes cannot be defined on a function component.", i.displayName || i.name || "Component"), o.ref !== null) {
          var f = "", v = ga();
          v && (f += `

Check the render method of \`` + v + "`.");
          var w = v || "", T = o._debugSource;
          T && (w = T.fileName + ":" + T.lineNumber), aR[w] || (aR[w] = !0, l("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", f));
        }
        if (typeof i.getDerivedStateFromProps == "function") {
          var $ = qn(i) || "Unknown";
          oR[$] || (l("%s: Function components do not support getDerivedStateFromProps.", $), oR[$] = !0);
        }
        if (typeof i.contextType == "object" && i.contextType !== null) {
          var F = qn(i) || "Unknown";
          rR[F] || (l("%s: Function components do not support contextType.", F), rR[F] = !0);
        }
      }
    }
    var cR = {
      dehydrated: null,
      treeContext: null,
      retryLane: Fn
    };
    function dR(o) {
      return {
        baseLanes: o,
        cachePool: EQ(),
        transitions: null
      };
    }
    function NQ(o, i) {
      var f = null;
      return {
        baseLanes: En(o.baseLanes, i),
        cachePool: f,
        transitions: o.transitions
      };
    }
    function IQ(o, i, f, v) {
      if (i !== null) {
        var w = i.memoizedState;
        if (w === null)
          return !1;
      }
      return CP(o, vb);
    }
    function AQ(o, i) {
      return Vd(o.childLanes, i);
    }
    function i2(o, i, f) {
      var v = i.pendingProps;
      WJ(i) && (i.flags |= pn);
      var w = Dl.current, T = !1, $ = (i.flags & pn) !== nn;
      if ($ || IQ(w, o) ? (T = !0, i.flags &= ~pn) : (o === null || o.memoizedState !== null) && (w = oQ(w, bA)), w = uv(w), df(i, w), o === null) {
        YO(i);
        var F = i.memoizedState;
        if (F !== null) {
          var W = F.dehydrated;
          if (W !== null)
            return VQ(i, W);
        }
        var ie = v.children, ce = v.fallback;
        if (T) {
          var De = jQ(i, ie, ce, f), Re = i.child;
          return Re.memoizedState = dR(f), i.memoizedState = cR, De;
        } else
          return fR(i, ie);
      } else {
        var Be = o.memoizedState;
        if (Be !== null) {
          var We = Be.dehydrated;
          if (We !== null)
            return UQ(o, i, $, v, We, Be, f);
        }
        if (T) {
          var Qe = v.fallback, It = v.children, rn = FQ(o, i, It, Qe, f), en = i.child, Vn = o.child.memoizedState;
          return en.memoizedState = Vn === null ? dR(f) : NQ(Vn, f), en.childLanes = AQ(o, f), i.memoizedState = cR, rn;
        } else {
          var Nn = v.children, ze = LQ(o, i, Nn, f);
          return i.memoizedState = null, ze;
        }
      }
    }
    function fR(o, i, f) {
      var v = o.mode, w = {
        mode: "visible",
        children: i
      }, T = pR(w, v);
      return T.return = o, o.child = T, T;
    }
    function jQ(o, i, f, v) {
      var w = o.mode, T = o.child, $ = {
        mode: "hidden",
        children: i
      }, F, W;
      return (w & kn) === an && T !== null ? (F = T, F.childLanes = tt, F.pendingProps = $, o.mode & ln && (F.actualDuration = 0, F.actualStartTime = -1, F.selfBaseDuration = 0, F.treeBaseDuration = 0), W = bf(f, w, v, null)) : (F = pR($, w), W = bf(f, w, v, null)), F.return = o, W.return = o, F.sibling = W, o.child = F, W;
    }
    function pR(o, i, f) {
      return sj(o, i, tt, null);
    }
    function s2(o, i) {
      return Jp(o, i);
    }
    function LQ(o, i, f, v) {
      var w = o.child, T = w.sibling, $ = s2(w, {
        mode: "visible",
        children: f
      });
      if ((i.mode & kn) === an && ($.lanes = v), $.return = i, $.sibling = null, T !== null) {
        var F = i.deletions;
        F === null ? (i.deletions = [T], i.flags |= sr) : F.push(T);
      }
      return i.child = $, $;
    }
    function FQ(o, i, f, v, w) {
      var T = i.mode, $ = o.child, F = $.sibling, W = {
        mode: "hidden",
        children: f
      }, ie;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (T & kn) === an && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        i.child !== $
      ) {
        var ce = i.child;
        ie = ce, ie.childLanes = tt, ie.pendingProps = W, i.mode & ln && (ie.actualDuration = 0, ie.actualStartTime = -1, ie.selfBaseDuration = $.selfBaseDuration, ie.treeBaseDuration = $.treeBaseDuration), i.deletions = null;
      } else
        ie = s2($, W), ie.subtreeFlags = $.subtreeFlags & Yo;
      var De;
      return F !== null ? De = Jp(F, v) : (De = bf(v, T, w, null), De.flags |= Br), De.return = i, ie.return = i, ie.sibling = De, i.child = ie, De;
    }
    function HS(o, i, f, v) {
      v !== null && qO(v), sv(i, o.child, null, f);
      var w = i.pendingProps, T = w.children, $ = fR(i, T);
      return $.flags |= Br, i.memoizedState = null, $;
    }
    function zQ(o, i, f, v, w) {
      var T = i.mode, $ = {
        mode: "visible",
        children: f
      }, F = pR($, T), W = bf(v, T, w, null);
      return W.flags |= Br, F.return = i, W.return = i, F.sibling = W, i.child = F, (i.mode & kn) !== an && sv(i, o.child, null, w), W;
    }
    function VQ(o, i, f) {
      return (o.mode & kn) === an ? (l("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), o.lanes = un) : DO(i) ? o.lanes = Sc : o.lanes = Ha, null;
    }
    function UQ(o, i, f, v, w, T, $) {
      if (f)
        if (i.flags & so) {
          i.flags &= ~so;
          var ze = JP(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return HS(o, i, $, ze);
        } else {
          if (i.memoizedState !== null)
            return i.child = o.child, i.flags |= pn, null;
          var Ze = v.children, Ve = v.fallback, mt = zQ(o, i, Ze, Ve, $), At = i.child;
          return At.memoizedState = dR($), i.memoizedState = cR, mt;
        }
      else {
        if (kX(), (i.mode & kn) === an)
          return HS(
            o,
            i,
            $,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (DO(w)) {
          var F, W, ie;
          {
            var ce = qK(w);
            F = ce.digest, W = ce.message, ie = ce.stack;
          }
          var De;
          W ? De = new Error(W) : De = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var Re = JP(De, F, ie);
          return HS(o, i, $, Re);
        }
        var Be = Wa($, o.childLanes);
        if (Ml || Be) {
          var We = t1();
          if (We !== null) {
            var Qe = Z_(We, $);
            if (Qe !== Fn && Qe !== T.retryLane) {
              T.retryLane = Qe;
              var It = Ir;
              Fi(o, Qe), na(We, o, Qe, It);
            }
          }
          NR();
          var rn = JP(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return HS(o, i, $, rn);
        } else if (RI(w)) {
          i.flags |= pn, i.child = o.child;
          var en = pJ.bind(null, o);
          return GK(w, en), null;
        } else {
          MX(i, w, T.treeContext);
          var Vn = v.children, Nn = fR(i, Vn);
          return Nn.flags |= Ri, Nn;
        }
      }
    }
    function l2(o, i, f) {
      o.lanes = En(o.lanes, i);
      var v = o.alternate;
      v !== null && (v.lanes = En(v.lanes, i)), ZO(o.return, i, f);
    }
    function BQ(o, i, f) {
      for (var v = i; v !== null; ) {
        if (v.tag === R) {
          var w = v.memoizedState;
          w !== null && l2(v, f, o);
        } else if (v.tag === Z)
          l2(v, f, o);
        else if (v.child !== null) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === o)
          return;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === o)
            return;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
    }
    function HQ(o) {
      for (var i = o, f = null; i !== null; ) {
        var v = i.alternate;
        v !== null && ES(v) === null && (f = i), i = i.sibling;
      }
      return f;
    }
    function WQ(o) {
      if (o !== void 0 && o !== "forwards" && o !== "backwards" && o !== "together" && !iR[o])
        if (iR[o] = !0, typeof o == "string")
          switch (o.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', o, o.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', o, o.toLowerCase());
              break;
            }
            default:
              l('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
              break;
          }
        else
          l('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
    }
    function YQ(o, i) {
      o !== void 0 && !BS[o] && (o !== "collapsed" && o !== "hidden" ? (BS[o] = !0, l('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', o)) : i !== "forwards" && i !== "backwards" && (BS[o] = !0, l('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', o)));
    }
    function u2(o, i) {
      {
        var f = jn(o), v = !f && typeof $a(o) == "function";
        if (f || v) {
          var w = f ? "array" : "iterable";
          return l("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", w, i, w), !1;
        }
      }
      return !0;
    }
    function qQ(o, i) {
      if ((i === "forwards" || i === "backwards") && o !== void 0 && o !== null && o !== !1)
        if (jn(o)) {
          for (var f = 0; f < o.length; f++)
            if (!u2(o[f], f))
              return;
        } else {
          var v = $a(o);
          if (typeof v == "function") {
            var w = v.call(o);
            if (w)
              for (var T = w.next(), $ = 0; !T.done; T = w.next()) {
                if (!u2(T.value, $))
                  return;
                $++;
              }
          } else
            l('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', i);
        }
    }
    function mR(o, i, f, v, w) {
      var T = o.memoizedState;
      T === null ? o.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: v,
        tail: f,
        tailMode: w
      } : (T.isBackwards = i, T.rendering = null, T.renderingStartTime = 0, T.last = v, T.tail = f, T.tailMode = w);
    }
    function c2(o, i, f) {
      var v = i.pendingProps, w = v.revealOrder, T = v.tail, $ = v.children;
      WQ(w), YQ(T, w), qQ($, w), di(o, i, $, f);
      var F = Dl.current, W = CP(F, vb);
      if (W)
        F = TP(F, vb), i.flags |= pn;
      else {
        var ie = o !== null && (o.flags & pn) !== nn;
        ie && BQ(i, i.child, f), F = uv(F);
      }
      if (df(i, F), (i.mode & kn) === an)
        i.memoizedState = null;
      else
        switch (w) {
          case "forwards": {
            var ce = HQ(i.child), De;
            ce === null ? (De = i.child, i.child = null) : (De = ce.sibling, ce.sibling = null), mR(
              i,
              !1,
              // isBackwards
              De,
              ce,
              T
            );
            break;
          }
          case "backwards": {
            var Re = null, Be = i.child;
            for (i.child = null; Be !== null; ) {
              var We = Be.alternate;
              if (We !== null && ES(We) === null) {
                i.child = Be;
                break;
              }
              var Qe = Be.sibling;
              Be.sibling = Re, Re = Be, Be = Qe;
            }
            mR(
              i,
              !0,
              // isBackwards
              Re,
              null,
              // last
              T
            );
            break;
          }
          case "together": {
            mR(
              i,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            i.memoizedState = null;
        }
      return i.child;
    }
    function GQ(o, i, f) {
      xP(i, i.stateNode.containerInfo);
      var v = i.pendingProps;
      return o === null ? i.child = sv(i, null, v, f) : di(o, i, v, f), i.child;
    }
    var d2 = !1;
    function KQ(o, i, f) {
      var v = i.type, w = v._context, T = i.pendingProps, $ = i.memoizedProps, F = T.value;
      {
        "value" in T || d2 || (d2 = !0, l("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var W = i.type.propTypes;
        W && Ol(W, T, "prop", "Context.Provider");
      }
      if (ZI(i, w, F), $ !== null) {
        var ie = $.value;
        if (qt(ie, F)) {
          if ($.children === T.children && !Jx())
            return Wc(o, i, f);
        } else
          BX(i, w, f);
      }
      var ce = T.children;
      return di(o, i, ce, f), i.child;
    }
    var f2 = !1;
    function XQ(o, i, f) {
      var v = i.type;
      v._context === void 0 ? v !== v.Consumer && (f2 || (f2 = !0, l("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : v = v._context;
      var w = i.pendingProps, T = w.children;
      typeof T != "function" && l("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), iv(i, f);
      var $ = Ho(v);
      gu(i);
      var F;
      return Cb.current = i, Aa(!0), F = T($), Aa(!1), bc(), i.flags |= du, di(o, i, F, f), i.child;
    }
    function _b() {
      Ml = !0;
    }
    function WS(o, i) {
      (i.mode & kn) === an && o !== null && (o.alternate = null, i.alternate = null, i.flags |= Br);
    }
    function Wc(o, i, f) {
      return o !== null && (i.dependencies = o.dependencies), qA(), Lb(i.lanes), Wa(f, i.childLanes) ? (tQ(o, i), i.child) : null;
    }
    function QQ(o, i, f) {
      {
        var v = i.return;
        if (v === null)
          throw new Error("Cannot swap the root fiber.");
        if (o.alternate = null, i.alternate = null, f.index = i.index, f.sibling = i.sibling, f.return = i.return, f.ref = i.ref, i === v.child)
          v.child = f;
        else {
          var w = v.child;
          if (w === null)
            throw new Error("Expected parent to have a child.");
          for (; w.sibling !== i; )
            if (w = w.sibling, w === null)
              throw new Error("Expected to find the previous sibling.");
          w.sibling = f;
        }
        var T = v.deletions;
        return T === null ? (v.deletions = [o], v.flags |= sr) : T.push(o), f.flags |= Br, f;
      }
    }
    function hR(o, i) {
      var f = o.lanes;
      return !!Wa(f, i);
    }
    function ZQ(o, i, f) {
      switch (i.tag) {
        case b:
          o2(i), i.stateNode, ov();
          break;
        case E:
          yA(i);
          break;
        case h: {
          var v = i.type;
          Ru(v) && tS(i);
          break;
        }
        case x:
          xP(i, i.stateNode.containerInfo);
          break;
        case D: {
          var w = i.memoizedProps.value, T = i.type._context;
          ZI(i, T, w);
          break;
        }
        case I:
          {
            var $ = Wa(f, i.childLanes);
            $ && (i.flags |= Sn);
            {
              var F = i.stateNode;
              F.effectDuration = 0, F.passiveEffectDuration = 0;
            }
          }
          break;
        case R: {
          var W = i.memoizedState;
          if (W !== null) {
            if (W.dehydrated !== null)
              return df(i, uv(Dl.current)), i.flags |= pn, null;
            var ie = i.child, ce = ie.childLanes;
            if (Wa(f, ce))
              return i2(o, i, f);
            df(i, uv(Dl.current));
            var De = Wc(o, i, f);
            return De !== null ? De.sibling : null;
          } else
            df(i, uv(Dl.current));
          break;
        }
        case Z: {
          var Re = (o.flags & pn) !== nn, Be = Wa(f, i.childLanes);
          if (Re) {
            if (Be)
              return c2(o, i, f);
            i.flags |= pn;
          }
          var We = i.memoizedState;
          if (We !== null && (We.rendering = null, We.tail = null, We.lastEffect = null), df(i, Dl.current), Be)
            break;
          return null;
        }
        case Y:
        case K:
          return i.lanes = tt, t2(o, i, f);
      }
      return Wc(o, i, f);
    }
    function p2(o, i, f) {
      if (i._debugNeedsRemount && o !== null)
        return QQ(o, i, WR(i.type, i.key, i.pendingProps, i._debugOwner || null, i.mode, i.lanes));
      if (o !== null) {
        var v = o.memoizedProps, w = i.pendingProps;
        if (v !== w || Jx() || // Force a re-render if the implementation changed due to hot reload:
        i.type !== o.type)
          Ml = !0;
        else {
          var T = hR(o, f);
          if (!T && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (i.flags & pn) === nn)
            return Ml = !1, ZQ(o, i, f);
          (o.flags & hp) !== nn ? Ml = !0 : Ml = !1;
        }
      } else if (Ml = !1, xa() && CX(i)) {
        var $ = i.index, F = TX();
        zI(i, F, $);
      }
      switch (i.lanes = tt, i.tag) {
        case g:
          return MQ(o, i, i.type, f);
        case q: {
          var W = i.elementType;
          return DQ(o, i, W, f);
        }
        case m: {
          var ie = i.type, ce = i.pendingProps, De = i.elementType === ie ? ce : kl(ie, ce);
          return sR(o, i, ie, De, f);
        }
        case h: {
          var Re = i.type, Be = i.pendingProps, We = i.elementType === Re ? Be : kl(Re, Be);
          return r2(o, i, Re, We, f);
        }
        case b:
          return PQ(o, i, f);
        case E:
          return RQ(o, i, f);
        case O:
          return kQ(o, i);
        case R:
          return i2(o, i, f);
        case x:
          return GQ(o, i, f);
        case N: {
          var Qe = i.type, It = i.pendingProps, rn = i.elementType === Qe ? It : kl(Qe, It);
          return ZA(o, i, Qe, rn, f);
        }
        case _:
          return TQ(o, i, f);
        case P:
          return _Q(o, i, f);
        case I:
          return OQ(o, i, f);
        case D:
          return KQ(o, i, f);
        case M:
          return XQ(o, i, f);
        case j: {
          var en = i.type, Vn = i.pendingProps, Nn = kl(en, Vn);
          if (i.type !== i.elementType) {
            var ze = en.propTypes;
            ze && Ol(
              ze,
              Nn,
              // Resolved for outer only
              "prop",
              qn(en)
            );
          }
          return Nn = kl(en.type, Nn), JA(o, i, en, Nn, f);
        }
        case U:
          return e2(o, i, i.type, i.pendingProps, f);
        case J: {
          var Ze = i.type, Ve = i.pendingProps, mt = i.elementType === Ze ? Ve : kl(Ze, Ve);
          return $Q(o, i, Ze, mt, f);
        }
        case Z:
          return c2(o, i, f);
        case re:
          break;
        case Y:
          return t2(o, i, f);
      }
      throw new Error("Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function hv(o) {
      o.flags |= Sn;
    }
    function m2(o) {
      o.flags |= La, o.flags |= sg;
    }
    var h2, vR, v2, y2;
    h2 = function(o, i, f, v) {
      for (var w = i.child; w !== null; ) {
        if (w.tag === E || w.tag === O)
          xK(o, w.stateNode);
        else if (w.tag !== x) {
          if (w.child !== null) {
            w.child.return = w, w = w.child;
            continue;
          }
        }
        if (w === i)
          return;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === i)
            return;
          w = w.return;
        }
        w.sibling.return = w.return, w = w.sibling;
      }
    }, vR = function(o, i) {
    }, v2 = function(o, i, f, v, w) {
      var T = o.memoizedProps;
      if (T !== v) {
        var $ = i.stateNode, F = SP(), W = EK($, f, T, v, w, F);
        i.updateQueue = W, W && hv(i);
      }
    }, y2 = function(o, i, f, v) {
      f !== v && hv(i);
    };
    function Ob(o, i) {
      if (!xa())
        switch (o.tailMode) {
          case "hidden": {
            for (var f = o.tail, v = null; f !== null; )
              f.alternate !== null && (v = f), f = f.sibling;
            v === null ? o.tail = null : v.sibling = null;
            break;
          }
          case "collapsed": {
            for (var w = o.tail, T = null; w !== null; )
              w.alternate !== null && (T = w), w = w.sibling;
            T === null ? !i && o.tail !== null ? o.tail.sibling = null : o.tail = null : T.sibling = null;
            break;
          }
        }
    }
    function Ea(o) {
      var i = o.alternate !== null && o.alternate.child === o.child, f = tt, v = nn;
      if (i) {
        if ((o.mode & ln) !== an) {
          for (var W = o.selfBaseDuration, ie = o.child; ie !== null; )
            f = En(f, En(ie.lanes, ie.childLanes)), v |= ie.subtreeFlags & Yo, v |= ie.flags & Yo, W += ie.treeBaseDuration, ie = ie.sibling;
          o.treeBaseDuration = W;
        } else
          for (var ce = o.child; ce !== null; )
            f = En(f, En(ce.lanes, ce.childLanes)), v |= ce.subtreeFlags & Yo, v |= ce.flags & Yo, ce.return = o, ce = ce.sibling;
        o.subtreeFlags |= v;
      } else {
        if ((o.mode & ln) !== an) {
          for (var w = o.actualDuration, T = o.selfBaseDuration, $ = o.child; $ !== null; )
            f = En(f, En($.lanes, $.childLanes)), v |= $.subtreeFlags, v |= $.flags, w += $.actualDuration, T += $.treeBaseDuration, $ = $.sibling;
          o.actualDuration = w, o.treeBaseDuration = T;
        } else
          for (var F = o.child; F !== null; )
            f = En(f, En(F.lanes, F.childLanes)), v |= F.subtreeFlags, v |= F.flags, F.return = o, F = F.sibling;
        o.subtreeFlags |= v;
      }
      return o.childLanes = f, i;
    }
    function JQ(o, i, f) {
      if (LX() && (i.mode & kn) !== an && (i.flags & pn) === nn)
        return qI(i), ov(), i.flags |= so | ai | Fo, !1;
      var v = iS(i);
      if (f !== null && f.dehydrated !== null)
        if (o === null) {
          if (!v)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (AX(i), Ea(i), (i.mode & ln) !== an) {
            var w = f !== null;
            if (w) {
              var T = i.child;
              T !== null && (i.treeBaseDuration -= T.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (ov(), (i.flags & pn) === nn && (i.memoizedState = null), i.flags |= Sn, Ea(i), (i.mode & ln) !== an) {
            var $ = f !== null;
            if ($) {
              var F = i.child;
              F !== null && (i.treeBaseDuration -= F.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return GI(), !0;
    }
    function g2(o, i, f) {
      var v = i.pendingProps;
      switch (UO(i), i.tag) {
        case g:
        case q:
        case U:
        case m:
        case N:
        case _:
        case P:
        case I:
        case M:
        case j:
          return Ea(i), null;
        case h: {
          var w = i.type;
          return Ru(w) && eS(i), Ea(i), null;
        }
        case b: {
          var T = i.stateNode;
          if (lv(i), LO(i), OP(), T.pendingContext && (T.context = T.pendingContext, T.pendingContext = null), o === null || o.child === null) {
            var $ = iS(i);
            if ($)
              hv(i);
            else if (o !== null) {
              var F = o.memoizedState;
              // Check if this is a client root
              (!F.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (i.flags & so) !== nn) && (i.flags |= Pi, GI());
            }
          }
          return vR(o, i), Ea(i), null;
        }
        case E: {
          EP(i);
          var W = vA(), ie = i.type;
          if (o !== null && i.stateNode != null)
            v2(o, i, ie, v, W), o.ref !== i.ref && m2(i);
          else {
            if (!v) {
              if (i.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Ea(i), null;
            }
            var ce = SP(), De = iS(i);
            if (De)
              NX(i, W, ce) && hv(i);
            else {
              var Re = wK(ie, v, W, ce, i);
              h2(Re, i, !1, !1), i.stateNode = Re, SK(Re, ie, v, W) && hv(i);
            }
            i.ref !== null && m2(i);
          }
          return Ea(i), null;
        }
        case O: {
          var Be = v;
          if (o && i.stateNode != null) {
            var We = o.memoizedProps;
            y2(o, i, We, Be);
          } else {
            if (typeof Be != "string" && i.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Qe = vA(), It = SP(), rn = iS(i);
            rn ? IX(i) && hv(i) : i.stateNode = CK(Be, Qe, It, i);
          }
          return Ea(i), null;
        }
        case R: {
          cv(i);
          var en = i.memoizedState;
          if (o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
            var Vn = JQ(o, i, en);
            if (!Vn)
              return i.flags & Fo ? i : null;
          }
          if ((i.flags & pn) !== nn)
            return i.lanes = f, (i.mode & ln) !== an && ZP(i), i;
          var Nn = en !== null, ze = o !== null && o.memoizedState !== null;
          if (Nn !== ze && Nn) {
            var Ze = i.child;
            if (Ze.flags |= fu, (i.mode & kn) !== an) {
              var Ve = o === null && (i.memoizedProps.unstable_avoidThisFallback !== !0 || !ee);
              Ve || CP(Dl.current, bA) ? eJ() : NR();
            }
          }
          var mt = i.updateQueue;
          if (mt !== null && (i.flags |= Sn), Ea(i), (i.mode & ln) !== an && Nn) {
            var At = i.child;
            At !== null && (i.treeBaseDuration -= At.treeBaseDuration);
          }
          return null;
        }
        case x:
          return lv(i), vR(o, i), o === null && yX(i.stateNode.containerInfo), Ea(i), null;
        case D:
          var Dt = i.type._context;
          return QO(Dt, i), Ea(i), null;
        case J: {
          var dn = i.type;
          return Ru(dn) && eS(i), Ea(i), null;
        }
        case Z: {
          cv(i);
          var xn = i.memoizedState;
          if (xn === null)
            return Ea(i), null;
          var Er = (i.flags & pn) !== nn, nr = xn.rendering;
          if (nr === null)
            if (Er)
              Ob(xn, !1);
            else {
              var Mo = nJ() && (o === null || (o.flags & pn) === nn);
              if (!Mo)
                for (var rr = i.child; rr !== null; ) {
                  var So = ES(rr);
                  if (So !== null) {
                    Er = !0, i.flags |= pn, Ob(xn, !1);
                    var Ka = So.updateQueue;
                    return Ka !== null && (i.updateQueue = Ka, i.flags |= Sn), i.subtreeFlags = nn, nQ(i, f), df(i, TP(Dl.current, vb)), i.child;
                  }
                  rr = rr.sibling;
                }
              xn.tail !== null && to() > F2() && (i.flags |= pn, Er = !0, Ob(xn, !1), i.lanes = wg);
            }
          else {
            if (!Er) {
              var Pa = ES(nr);
              if (Pa !== null) {
                i.flags |= pn, Er = !0;
                var ms = Pa.updateQueue;
                if (ms !== null && (i.updateQueue = ms, i.flags |= Sn), Ob(xn, !0), xn.tail === null && xn.tailMode === "hidden" && !nr.alternate && !xa())
                  return Ea(i), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                to() * 2 - xn.renderingStartTime > F2() && f !== Ha && (i.flags |= pn, Er = !0, Ob(xn, !1), i.lanes = wg);
            }
            if (xn.isBackwards)
              nr.sibling = i.child, i.child = nr;
            else {
              var mi = xn.last;
              mi !== null ? mi.sibling = nr : i.child = nr, xn.last = nr;
            }
          }
          if (xn.tail !== null) {
            var hi = xn.tail;
            xn.rendering = hi, xn.tail = hi.sibling, xn.renderingStartTime = to(), hi.sibling = null;
            var Xa = Dl.current;
            return Er ? Xa = TP(Xa, vb) : Xa = uv(Xa), df(i, Xa), hi;
          }
          return Ea(i), null;
        }
        case re:
          break;
        case Y:
        case K: {
          MR(i);
          var Xc = i.memoizedState, Ev = Xc !== null;
          if (o !== null) {
            var Bb = o.memoizedState, ju = Bb !== null;
            ju !== Ev && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !V && (i.flags |= fu);
          }
          return !Ev || (i.mode & kn) === an ? Ea(i) : Wa(Au, Ha) && (Ea(i), i.subtreeFlags & (Br | Sn) && (i.flags |= fu)), null;
        }
        case Q:
          return null;
        case te:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function eZ(o, i, f) {
      switch (UO(i), i.tag) {
        case h: {
          var v = i.type;
          Ru(v) && eS(i);
          var w = i.flags;
          return w & Fo ? (i.flags = w & ~Fo | pn, (i.mode & ln) !== an && ZP(i), i) : null;
        }
        case b: {
          i.stateNode, lv(i), LO(i), OP();
          var T = i.flags;
          return (T & Fo) !== nn && (T & pn) === nn ? (i.flags = T & ~Fo | pn, i) : null;
        }
        case E:
          return EP(i), null;
        case R: {
          cv(i);
          var $ = i.memoizedState;
          if ($ !== null && $.dehydrated !== null) {
            if (i.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            ov();
          }
          var F = i.flags;
          return F & Fo ? (i.flags = F & ~Fo | pn, (i.mode & ln) !== an && ZP(i), i) : null;
        }
        case Z:
          return cv(i), null;
        case x:
          return lv(i), null;
        case D:
          var W = i.type._context;
          return QO(W, i), null;
        case Y:
        case K:
          return MR(i), null;
        case Q:
          return null;
        default:
          return null;
      }
    }
    function b2(o, i, f) {
      switch (UO(i), i.tag) {
        case h: {
          var v = i.type.childContextTypes;
          v != null && eS(i);
          break;
        }
        case b: {
          i.stateNode, lv(i), LO(i), OP();
          break;
        }
        case E: {
          EP(i);
          break;
        }
        case x:
          lv(i);
          break;
        case R:
          cv(i);
          break;
        case Z:
          cv(i);
          break;
        case D:
          var w = i.type._context;
          QO(w, i);
          break;
        case Y:
        case K:
          MR(i);
          break;
      }
    }
    var w2 = null;
    w2 = /* @__PURE__ */ new Set();
    var YS = !1, Ca = !1, tZ = typeof WeakSet == "function" ? WeakSet : Set, Gt = null, vv = null, yv = null;
    function nZ(o) {
      yc(null, function() {
        throw o;
      }), ag();
    }
    var rZ = function(o, i) {
      if (i.props = o.memoizedProps, i.state = o.memoizedState, o.mode & ln)
        try {
          Nu(), i.componentWillUnmount();
        } finally {
          Mu(o);
        }
      else
        i.componentWillUnmount();
    };
    function x2(o, i) {
      try {
        mf(Xo, o);
      } catch (f) {
        qr(o, i, f);
      }
    }
    function yR(o, i, f) {
      try {
        rZ(o, f);
      } catch (v) {
        qr(o, i, v);
      }
    }
    function oZ(o, i, f) {
      try {
        f.componentDidMount();
      } catch (v) {
        qr(o, i, v);
      }
    }
    function S2(o, i) {
      try {
        C2(o);
      } catch (f) {
        qr(o, i, f);
      }
    }
    function gv(o, i) {
      var f = o.ref;
      if (f !== null)
        if (typeof f == "function") {
          var v;
          try {
            if (Se && Te && o.mode & ln)
              try {
                Nu(), v = f(null);
              } finally {
                Mu(o);
              }
            else
              v = f(null);
          } catch (w) {
            qr(o, i, w);
          }
          typeof v == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gn(o));
        } else
          f.current = null;
    }
    function qS(o, i, f) {
      try {
        f();
      } catch (v) {
        qr(o, i, v);
      }
    }
    var E2 = !1;
    function aZ(o, i) {
      gK(o.containerInfo), Gt = i, iZ();
      var f = E2;
      return E2 = !1, f;
    }
    function iZ() {
      for (; Gt !== null; ) {
        var o = Gt, i = o.child;
        (o.subtreeFlags & Md) !== nn && i !== null ? (i.return = o, Gt = i) : sZ();
      }
    }
    function sZ() {
      for (; Gt !== null; ) {
        var o = Gt;
        fr(o);
        try {
          lZ(o);
        } catch (f) {
          qr(o, o.return, f);
        }
        io();
        var i = o.sibling;
        if (i !== null) {
          i.return = o.return, Gt = i;
          return;
        }
        Gt = o.return;
      }
    }
    function lZ(o) {
      var i = o.alternate, f = o.flags;
      if ((f & Pi) !== nn) {
        switch (fr(o), o.tag) {
          case m:
          case N:
          case U:
            break;
          case h: {
            if (i !== null) {
              var v = i.memoizedProps, w = i.memoizedState, T = o.stateNode;
              o.type === o.elementType && !Gp && (T.props !== o.memoizedProps && l("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gn(o) || "instance"), T.state !== o.memoizedState && l("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gn(o) || "instance"));
              var $ = T.getSnapshotBeforeUpdate(o.elementType === o.type ? v : kl(o.type, v), w);
              {
                var F = w2;
                $ === void 0 && !F.has(o.type) && (F.add(o.type), l("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", gn(o)));
              }
              T.__reactInternalSnapshotBeforeUpdate = $;
            }
            break;
          }
          case b: {
            {
              var W = o.stateNode;
              BK(W.containerInfo);
            }
            break;
          }
          case E:
          case O:
          case x:
          case J:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        io();
      }
    }
    function Nl(o, i, f) {
      var v = i.updateQueue, w = v !== null ? v.lastEffect : null;
      if (w !== null) {
        var T = w.next, $ = T;
        do {
          if (($.tag & o) === o) {
            var F = $.destroy;
            $.destroy = void 0, F !== void 0 && ((o & Sa) !== zi ? sh(i) : (o & Xo) !== zi && lh(i), (o & ku) !== zi && zb(!0), qS(i, f, F), (o & ku) !== zi && zb(!1), (o & Sa) !== zi ? ax() : (o & Xo) !== zi && Nd());
          }
          $ = $.next;
        } while ($ !== T);
      }
    }
    function mf(o, i) {
      var f = i.updateQueue, v = f !== null ? f.lastEffect : null;
      if (v !== null) {
        var w = v.next, T = w;
        do {
          if ((T.tag & o) === o) {
            (o & Sa) !== zi ? ox(i) : (o & Xo) !== zi && ix(i);
            var $ = T.create;
            (o & ku) !== zi && zb(!0), T.destroy = $(), (o & ku) !== zi && zb(!1), (o & Sa) !== zi ? yg() : (o & Xo) !== zi && sx();
            {
              var F = T.destroy;
              if (F !== void 0 && typeof F != "function") {
                var W = void 0;
                (T.tag & Xo) !== nn ? W = "useLayoutEffect" : (T.tag & ku) !== nn ? W = "useInsertionEffect" : W = "useEffect";
                var ie = void 0;
                F === null ? ie = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof F.then == "function" ? ie = `

It looks like you wrote ` + W + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + W + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : ie = " You returned: " + F, l("%s must not return anything besides a function, which is used for clean-up.%s", W, ie);
              }
            }
          }
          T = T.next;
        } while (T !== w);
      }
    }
    function uZ(o, i) {
      if ((i.flags & Sn) !== nn)
        switch (i.tag) {
          case I: {
            var f = i.stateNode.passiveEffectDuration, v = i.memoizedProps, w = v.id, T = v.onPostCommit, $ = WA(), F = i.alternate === null ? "mount" : "update";
            HA() && (F = "nested-update"), typeof T == "function" && T(w, F, f, $);
            var W = i.return;
            e:
              for (; W !== null; ) {
                switch (W.tag) {
                  case b:
                    var ie = W.stateNode;
                    ie.passiveEffectDuration += f;
                    break e;
                  case I:
                    var ce = W.stateNode;
                    ce.passiveEffectDuration += f;
                    break e;
                }
                W = W.return;
              }
            break;
          }
        }
    }
    function cZ(o, i, f, v) {
      if ((f.flags & ua) !== nn)
        switch (f.tag) {
          case m:
          case N:
          case U: {
            if (!Ca)
              if (f.mode & ln)
                try {
                  Nu(), mf(Xo | Ko, f);
                } finally {
                  Mu(f);
                }
              else
                mf(Xo | Ko, f);
            break;
          }
          case h: {
            var w = f.stateNode;
            if (f.flags & Sn && !Ca)
              if (i === null)
                if (f.type === f.elementType && !Gp && (w.props !== f.memoizedProps && l("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gn(f) || "instance"), w.state !== f.memoizedState && l("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gn(f) || "instance")), f.mode & ln)
                  try {
                    Nu(), w.componentDidMount();
                  } finally {
                    Mu(f);
                  }
                else
                  w.componentDidMount();
              else {
                var T = f.elementType === f.type ? i.memoizedProps : kl(f.type, i.memoizedProps), $ = i.memoizedState;
                if (f.type === f.elementType && !Gp && (w.props !== f.memoizedProps && l("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gn(f) || "instance"), w.state !== f.memoizedState && l("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gn(f) || "instance")), f.mode & ln)
                  try {
                    Nu(), w.componentDidUpdate(T, $, w.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Mu(f);
                  }
                else
                  w.componentDidUpdate(T, $, w.__reactInternalSnapshotBeforeUpdate);
              }
            var F = f.updateQueue;
            F !== null && (f.type === f.elementType && !Gp && (w.props !== f.memoizedProps && l("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gn(f) || "instance"), w.state !== f.memoizedState && l("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gn(f) || "instance")), oA(f, F, w));
            break;
          }
          case b: {
            var W = f.updateQueue;
            if (W !== null) {
              var ie = null;
              if (f.child !== null)
                switch (f.child.tag) {
                  case E:
                    ie = f.child.stateNode;
                    break;
                  case h:
                    ie = f.child.stateNode;
                    break;
                }
              oA(f, W, ie);
            }
            break;
          }
          case E: {
            var ce = f.stateNode;
            if (i === null && f.flags & Sn) {
              var De = f.type, Re = f.memoizedProps;
              RK(ce, De, Re);
            }
            break;
          }
          case O:
            break;
          case x:
            break;
          case I: {
            {
              var Be = f.memoizedProps, We = Be.onCommit, Qe = Be.onRender, It = f.stateNode.effectDuration, rn = WA(), en = i === null ? "mount" : "update";
              HA() && (en = "nested-update"), typeof Qe == "function" && Qe(f.memoizedProps.id, en, f.actualDuration, f.treeBaseDuration, f.actualStartTime, rn);
              {
                typeof We == "function" && We(f.memoizedProps.id, en, It, rn), sJ(f);
                var Vn = f.return;
                e:
                  for (; Vn !== null; ) {
                    switch (Vn.tag) {
                      case b:
                        var Nn = Vn.stateNode;
                        Nn.effectDuration += It;
                        break e;
                      case I:
                        var ze = Vn.stateNode;
                        ze.effectDuration += It;
                        break e;
                    }
                    Vn = Vn.return;
                  }
              }
            }
            break;
          }
          case R: {
            gZ(o, f);
            break;
          }
          case Z:
          case J:
          case re:
          case Y:
          case K:
          case te:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ca || f.flags & La && C2(f);
    }
    function dZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          if (o.mode & ln)
            try {
              Nu(), x2(o, o.return);
            } finally {
              Mu(o);
            }
          else
            x2(o, o.return);
          break;
        }
        case h: {
          var i = o.stateNode;
          typeof i.componentDidMount == "function" && oZ(o, o.return, i), S2(o, o.return);
          break;
        }
        case E: {
          S2(o, o.return);
          break;
        }
      }
    }
    function fZ(o, i) {
      for (var f = null, v = o; ; ) {
        if (v.tag === E) {
          if (f === null) {
            f = v;
            try {
              var w = v.stateNode;
              i ? FK(w) : VK(v.stateNode, v.memoizedProps);
            } catch ($) {
              qr(o, o.return, $);
            }
          }
        } else if (v.tag === O) {
          if (f === null)
            try {
              var T = v.stateNode;
              i ? zK(T) : UK(T, v.memoizedProps);
            } catch ($) {
              qr(o, o.return, $);
            }
        } else if (!((v.tag === Y || v.tag === K) && v.memoizedState !== null && v !== o)) {
          if (v.child !== null) {
            v.child.return = v, v = v.child;
            continue;
          }
        }
        if (v === o)
          return;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === o)
            return;
          f === v && (f = null), v = v.return;
        }
        f === v && (f = null), v.sibling.return = v.return, v = v.sibling;
      }
    }
    function C2(o) {
      var i = o.ref;
      if (i !== null) {
        var f = o.stateNode, v;
        switch (o.tag) {
          case E:
            v = f;
            break;
          default:
            v = f;
        }
        if (typeof i == "function") {
          var w;
          if (o.mode & ln)
            try {
              Nu(), w = i(v);
            } finally {
              Mu(o);
            }
          else
            w = i(v);
          typeof w == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gn(o));
        } else
          i.hasOwnProperty("current") || l("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", gn(o)), i.current = v;
      }
    }
    function pZ(o) {
      var i = o.alternate;
      i !== null && (i.return = null), o.return = null;
    }
    function T2(o) {
      var i = o.alternate;
      i !== null && (o.alternate = null, T2(i));
      {
        if (o.child = null, o.deletions = null, o.sibling = null, o.tag === E) {
          var f = o.stateNode;
          f !== null && wX(f);
        }
        o.stateNode = null, o._debugOwner = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
      }
    }
    function mZ(o) {
      for (var i = o.return; i !== null; ) {
        if (_2(i))
          return i;
        i = i.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function _2(o) {
      return o.tag === E || o.tag === b || o.tag === x;
    }
    function O2(o) {
      var i = o;
      e:
        for (; ; ) {
          for (; i.sibling === null; ) {
            if (i.return === null || _2(i.return))
              return null;
            i = i.return;
          }
          for (i.sibling.return = i.return, i = i.sibling; i.tag !== E && i.tag !== O && i.tag !== H; ) {
            if (i.flags & Br || i.child === null || i.tag === x)
              continue e;
            i.child.return = i, i = i.child;
          }
          if (!(i.flags & Br))
            return i.stateNode;
        }
    }
    function hZ(o) {
      var i = mZ(o);
      switch (i.tag) {
        case E: {
          var f = i.stateNode;
          i.flags & pr && (PI(f), i.flags &= ~pr);
          var v = O2(o);
          bR(o, v, f);
          break;
        }
        case b:
        case x: {
          var w = i.stateNode.containerInfo, T = O2(o);
          gR(o, T, w);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function gR(o, i, f) {
      var v = o.tag, w = v === E || v === O;
      if (w) {
        var T = o.stateNode;
        i ? IK(f, T, i) : MK(f, T);
      } else if (v !== x) {
        var $ = o.child;
        if ($ !== null) {
          gR($, i, f);
          for (var F = $.sibling; F !== null; )
            gR(F, i, f), F = F.sibling;
        }
      }
    }
    function bR(o, i, f) {
      var v = o.tag, w = v === E || v === O;
      if (w) {
        var T = o.stateNode;
        i ? NK(f, T, i) : $K(f, T);
      } else if (v !== x) {
        var $ = o.child;
        if ($ !== null) {
          bR($, i, f);
          for (var F = $.sibling; F !== null; )
            bR(F, i, f), F = F.sibling;
        }
      }
    }
    var Ta = null, Il = !1;
    function vZ(o, i, f) {
      {
        var v = i;
        e:
          for (; v !== null; ) {
            switch (v.tag) {
              case E: {
                Ta = v.stateNode, Il = !1;
                break e;
              }
              case b: {
                Ta = v.stateNode.containerInfo, Il = !0;
                break e;
              }
              case x: {
                Ta = v.stateNode.containerInfo, Il = !0;
                break e;
              }
            }
            v = v.return;
          }
        if (Ta === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        P2(o, i, f), Ta = null, Il = !1;
      }
      pZ(f);
    }
    function hf(o, i, f) {
      for (var v = f.child; v !== null; )
        P2(o, i, v), v = v.sibling;
    }
    function P2(o, i, f) {
      switch (hg(f), f.tag) {
        case E:
          Ca || gv(f, i);
        case O: {
          {
            var v = Ta, w = Il;
            Ta = null, hf(o, i, f), Ta = v, Il = w, Ta !== null && (Il ? jK(Ta, f.stateNode) : AK(Ta, f.stateNode));
          }
          return;
        }
        case H: {
          Ta !== null && (Il ? LK(Ta, f.stateNode) : kO(Ta, f.stateNode));
          return;
        }
        case x: {
          {
            var T = Ta, $ = Il;
            Ta = f.stateNode.containerInfo, Il = !0, hf(o, i, f), Ta = T, Il = $;
          }
          return;
        }
        case m:
        case N:
        case j:
        case U: {
          if (!Ca) {
            var F = f.updateQueue;
            if (F !== null) {
              var W = F.lastEffect;
              if (W !== null) {
                var ie = W.next, ce = ie;
                do {
                  var De = ce, Re = De.destroy, Be = De.tag;
                  Re !== void 0 && ((Be & ku) !== zi ? qS(f, i, Re) : (Be & Xo) !== zi && (lh(f), f.mode & ln ? (Nu(), qS(f, i, Re), Mu(f)) : qS(f, i, Re), Nd())), ce = ce.next;
                } while (ce !== ie);
              }
            }
          }
          hf(o, i, f);
          return;
        }
        case h: {
          if (!Ca) {
            gv(f, i);
            var We = f.stateNode;
            typeof We.componentWillUnmount == "function" && yR(f, i, We);
          }
          hf(o, i, f);
          return;
        }
        case re: {
          hf(o, i, f);
          return;
        }
        case Y: {
          if (
            // TODO: Remove this dead flag
            f.mode & kn
          ) {
            var Qe = Ca;
            Ca = Qe || f.memoizedState !== null, hf(o, i, f), Ca = Qe;
          } else
            hf(o, i, f);
          break;
        }
        default: {
          hf(o, i, f);
          return;
        }
      }
    }
    function yZ(o) {
      o.memoizedState;
    }
    function gZ(o, i) {
      var f = i.memoizedState;
      if (f === null) {
        var v = i.alternate;
        if (v !== null) {
          var w = v.memoizedState;
          if (w !== null) {
            var T = w.dehydrated;
            T !== null && rX(T);
          }
        }
      }
    }
    function R2(o) {
      var i = o.updateQueue;
      if (i !== null) {
        o.updateQueue = null;
        var f = o.stateNode;
        f === null && (f = o.stateNode = new tZ()), i.forEach(function(v) {
          var w = mJ.bind(null, o, v);
          if (!f.has(v)) {
            if (f.add(v), qo)
              if (vv !== null && yv !== null)
                Fb(yv, vv);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            v.then(w, w);
          }
        });
      }
    }
    function bZ(o, i, f) {
      vv = f, yv = o, fr(i), k2(i, o), fr(i), vv = null, yv = null;
    }
    function Al(o, i, f) {
      var v = i.deletions;
      if (v !== null)
        for (var w = 0; w < v.length; w++) {
          var T = v[w];
          try {
            vZ(o, i, T);
          } catch (W) {
            qr(T, i, W);
          }
        }
      var $ = Fm();
      if (i.subtreeFlags & Va)
        for (var F = i.child; F !== null; )
          fr(F), k2(F, o), F = F.sibling;
      fr($);
    }
    function k2(o, i, f) {
      var v = o.alternate, w = o.flags;
      switch (o.tag) {
        case m:
        case N:
        case j:
        case U: {
          if (Al(i, o), Iu(o), w & Sn) {
            try {
              Nl(ku | Ko, o, o.return), mf(ku | Ko, o);
            } catch (dn) {
              qr(o, o.return, dn);
            }
            if (o.mode & ln) {
              try {
                Nu(), Nl(Xo | Ko, o, o.return);
              } catch (dn) {
                qr(o, o.return, dn);
              }
              Mu(o);
            } else
              try {
                Nl(Xo | Ko, o, o.return);
              } catch (dn) {
                qr(o, o.return, dn);
              }
          }
          return;
        }
        case h: {
          Al(i, o), Iu(o), w & La && v !== null && gv(v, v.return);
          return;
        }
        case E: {
          Al(i, o), Iu(o), w & La && v !== null && gv(v, v.return);
          {
            if (o.flags & pr) {
              var T = o.stateNode;
              try {
                PI(T);
              } catch (dn) {
                qr(o, o.return, dn);
              }
            }
            if (w & Sn) {
              var $ = o.stateNode;
              if ($ != null) {
                var F = o.memoizedProps, W = v !== null ? v.memoizedProps : F, ie = o.type, ce = o.updateQueue;
                if (o.updateQueue = null, ce !== null)
                  try {
                    kK($, ce, ie, W, F, o);
                  } catch (dn) {
                    qr(o, o.return, dn);
                  }
              }
            }
          }
          return;
        }
        case O: {
          if (Al(i, o), Iu(o), w & Sn) {
            if (o.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var De = o.stateNode, Re = o.memoizedProps, Be = v !== null ? v.memoizedProps : Re;
            try {
              DK(De, Be, Re);
            } catch (dn) {
              qr(o, o.return, dn);
            }
          }
          return;
        }
        case b: {
          if (Al(i, o), Iu(o), w & Sn && v !== null) {
            var We = v.memoizedState;
            if (We.isDehydrated)
              try {
                nX(i.containerInfo);
              } catch (dn) {
                qr(o, o.return, dn);
              }
          }
          return;
        }
        case x: {
          Al(i, o), Iu(o);
          return;
        }
        case R: {
          Al(i, o), Iu(o);
          var Qe = o.child;
          if (Qe.flags & fu) {
            var It = Qe.stateNode, rn = Qe.memoizedState, en = rn !== null;
            if (It.isHidden = en, en) {
              var Vn = Qe.alternate !== null && Qe.alternate.memoizedState !== null;
              Vn || JZ();
            }
          }
          if (w & Sn) {
            try {
              yZ(o);
            } catch (dn) {
              qr(o, o.return, dn);
            }
            R2(o);
          }
          return;
        }
        case Y: {
          var Nn = v !== null && v.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            o.mode & kn
          ) {
            var ze = Ca;
            Ca = ze || Nn, Al(i, o), Ca = ze;
          } else
            Al(i, o);
          if (Iu(o), w & fu) {
            var Ze = o.stateNode, Ve = o.memoizedState, mt = Ve !== null, At = o;
            if (Ze.isHidden = mt, mt && !Nn && (At.mode & kn) !== an) {
              Gt = At;
              for (var Dt = At.child; Dt !== null; )
                Gt = Dt, xZ(Dt), Dt = Dt.sibling;
            }
            fZ(At, mt);
          }
          return;
        }
        case Z: {
          Al(i, o), Iu(o), w & Sn && R2(o);
          return;
        }
        case re:
          return;
        default: {
          Al(i, o), Iu(o);
          return;
        }
      }
    }
    function Iu(o) {
      var i = o.flags;
      if (i & Br) {
        try {
          hZ(o);
        } catch (f) {
          qr(o, o.return, f);
        }
        o.flags &= ~Br;
      }
      i & Ri && (o.flags &= ~Ri);
    }
    function wZ(o, i, f) {
      vv = f, yv = i, Gt = o, D2(o, i, f), vv = null, yv = null;
    }
    function D2(o, i, f) {
      for (var v = (o.mode & kn) !== an; Gt !== null; ) {
        var w = Gt, T = w.child;
        if (w.tag === Y && v) {
          var $ = w.memoizedState !== null, F = $ || YS;
          if (F) {
            wR(o, i, f);
            continue;
          } else {
            var W = w.alternate, ie = W !== null && W.memoizedState !== null, ce = ie || Ca, De = YS, Re = Ca;
            YS = F, Ca = ce, Ca && !Re && (Gt = w, SZ(w));
            for (var Be = T; Be !== null; )
              Gt = Be, D2(
                Be,
                // New root; bubble back up to here and stop.
                i,
                f
              ), Be = Be.sibling;
            Gt = w, YS = De, Ca = Re, wR(o, i, f);
            continue;
          }
        }
        (w.subtreeFlags & ua) !== nn && T !== null ? (T.return = w, Gt = T) : wR(o, i, f);
      }
    }
    function wR(o, i, f) {
      for (; Gt !== null; ) {
        var v = Gt;
        if ((v.flags & ua) !== nn) {
          var w = v.alternate;
          fr(v);
          try {
            cZ(i, w, v, f);
          } catch ($) {
            qr(v, v.return, $);
          }
          io();
        }
        if (v === o) {
          Gt = null;
          return;
        }
        var T = v.sibling;
        if (T !== null) {
          T.return = v.return, Gt = T;
          return;
        }
        Gt = v.return;
      }
    }
    function xZ(o) {
      for (; Gt !== null; ) {
        var i = Gt, f = i.child;
        switch (i.tag) {
          case m:
          case N:
          case j:
          case U: {
            if (i.mode & ln)
              try {
                Nu(), Nl(Xo, i, i.return);
              } finally {
                Mu(i);
              }
            else
              Nl(Xo, i, i.return);
            break;
          }
          case h: {
            gv(i, i.return);
            var v = i.stateNode;
            typeof v.componentWillUnmount == "function" && yR(i, i.return, v);
            break;
          }
          case E: {
            gv(i, i.return);
            break;
          }
          case Y: {
            var w = i.memoizedState !== null;
            if (w) {
              $2(o);
              continue;
            }
            break;
          }
        }
        f !== null ? (f.return = i, Gt = f) : $2(o);
      }
    }
    function $2(o) {
      for (; Gt !== null; ) {
        var i = Gt;
        if (i === o) {
          Gt = null;
          return;
        }
        var f = i.sibling;
        if (f !== null) {
          f.return = i.return, Gt = f;
          return;
        }
        Gt = i.return;
      }
    }
    function SZ(o) {
      for (; Gt !== null; ) {
        var i = Gt, f = i.child;
        if (i.tag === Y) {
          var v = i.memoizedState !== null;
          if (v) {
            M2(o);
            continue;
          }
        }
        f !== null ? (f.return = i, Gt = f) : M2(o);
      }
    }
    function M2(o) {
      for (; Gt !== null; ) {
        var i = Gt;
        fr(i);
        try {
          dZ(i);
        } catch (v) {
          qr(i, i.return, v);
        }
        if (io(), i === o) {
          Gt = null;
          return;
        }
        var f = i.sibling;
        if (f !== null) {
          f.return = i.return, Gt = f;
          return;
        }
        Gt = i.return;
      }
    }
    function EZ(o, i, f, v) {
      Gt = i, CZ(i, o, f, v);
    }
    function CZ(o, i, f, v) {
      for (; Gt !== null; ) {
        var w = Gt, T = w.child;
        (w.subtreeFlags & ki) !== nn && T !== null ? (T.return = w, Gt = T) : TZ(o, i, f, v);
      }
    }
    function TZ(o, i, f, v) {
      for (; Gt !== null; ) {
        var w = Gt;
        if ((w.flags & Xr) !== nn) {
          fr(w);
          try {
            _Z(i, w, f, v);
          } catch ($) {
            qr(w, w.return, $);
          }
          io();
        }
        if (w === o) {
          Gt = null;
          return;
        }
        var T = w.sibling;
        if (T !== null) {
          T.return = w.return, Gt = T;
          return;
        }
        Gt = w.return;
      }
    }
    function _Z(o, i, f, v) {
      switch (i.tag) {
        case m:
        case N:
        case U: {
          if (i.mode & ln) {
            QP();
            try {
              mf(Sa | Ko, i);
            } finally {
              XP(i);
            }
          } else
            mf(Sa | Ko, i);
          break;
        }
      }
    }
    function OZ(o) {
      Gt = o, PZ();
    }
    function PZ() {
      for (; Gt !== null; ) {
        var o = Gt, i = o.child;
        if ((Gt.flags & sr) !== nn) {
          var f = o.deletions;
          if (f !== null) {
            for (var v = 0; v < f.length; v++) {
              var w = f[v];
              Gt = w, DZ(w, o);
            }
            {
              var T = o.alternate;
              if (T !== null) {
                var $ = T.child;
                if ($ !== null) {
                  T.child = null;
                  do {
                    var F = $.sibling;
                    $.sibling = null, $ = F;
                  } while ($ !== null);
                }
              }
            }
            Gt = o;
          }
        }
        (o.subtreeFlags & ki) !== nn && i !== null ? (i.return = o, Gt = i) : RZ();
      }
    }
    function RZ() {
      for (; Gt !== null; ) {
        var o = Gt;
        (o.flags & Xr) !== nn && (fr(o), kZ(o), io());
        var i = o.sibling;
        if (i !== null) {
          i.return = o.return, Gt = i;
          return;
        }
        Gt = o.return;
      }
    }
    function kZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          o.mode & ln ? (QP(), Nl(Sa | Ko, o, o.return), XP(o)) : Nl(Sa | Ko, o, o.return);
          break;
        }
      }
    }
    function DZ(o, i) {
      for (; Gt !== null; ) {
        var f = Gt;
        fr(f), MZ(f, i), io();
        var v = f.child;
        v !== null ? (v.return = f, Gt = v) : $Z(o);
      }
    }
    function $Z(o) {
      for (; Gt !== null; ) {
        var i = Gt, f = i.sibling, v = i.return;
        if (T2(i), i === o) {
          Gt = null;
          return;
        }
        if (f !== null) {
          f.return = v, Gt = f;
          return;
        }
        Gt = v;
      }
    }
    function MZ(o, i) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          o.mode & ln ? (QP(), Nl(Sa, o, i), XP(o)) : Nl(Sa, o, i);
          break;
        }
      }
    }
    function NZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          try {
            mf(Xo | Ko, o);
          } catch (f) {
            qr(o, o.return, f);
          }
          break;
        }
        case h: {
          var i = o.stateNode;
          try {
            i.componentDidMount();
          } catch (f) {
            qr(o, o.return, f);
          }
          break;
        }
      }
    }
    function IZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          try {
            mf(Sa | Ko, o);
          } catch (i) {
            qr(o, o.return, i);
          }
          break;
        }
      }
    }
    function AZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U: {
          try {
            Nl(Xo | Ko, o, o.return);
          } catch (f) {
            qr(o, o.return, f);
          }
          break;
        }
        case h: {
          var i = o.stateNode;
          typeof i.componentWillUnmount == "function" && yR(o, o.return, i);
          break;
        }
      }
    }
    function jZ(o) {
      switch (o.tag) {
        case m:
        case N:
        case U:
          try {
            Nl(Sa | Ko, o, o.return);
          } catch (i) {
            qr(o, o.return, i);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Pb = Symbol.for;
      Pb("selector.component"), Pb("selector.has_pseudo_class"), Pb("selector.role"), Pb("selector.test_id"), Pb("selector.text");
    }
    var LZ = [];
    function FZ() {
      LZ.forEach(function(o) {
        return o();
      });
    }
    var zZ = n.ReactCurrentActQueue;
    function VZ(o) {
      {
        var i = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), f = typeof jest < "u";
        return f && i !== !1;
      }
    }
    function N2() {
      {
        var o = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !o && zZ.current !== null && l("The current testing environment is not configured to support act(...)"), o;
      }
    }
    var UZ = Math.ceil, xR = n.ReactCurrentDispatcher, SR = n.ReactCurrentOwner, _a = n.ReactCurrentBatchConfig, jl = n.ReactCurrentActQueue, Jo = (
      /*             */
      0
    ), I2 = (
      /*               */
      1
    ), Oa = (
      /*                */
      2
    ), zs = (
      /*                */
      4
    ), Yc = 0, Rb = 1, Kp = 2, GS = 3, kb = 4, A2 = 5, ER = 6, zn = Jo, fi = null, mo = null, ea = tt, Au = tt, CR = of(tt), ta = Yc, Db = null, KS = tt, $b = tt, XS = tt, Mb = null, Vi = null, TR = 0, j2 = 500, L2 = 1 / 0, BZ = 500, qc = null;
    function Nb() {
      L2 = to() + BZ;
    }
    function F2() {
      return L2;
    }
    var QS = !1, _R = null, bv = null, Xp = !1, vf = null, Ib = tt, OR = [], PR = null, HZ = 50, Ab = 0, RR = null, kR = !1, ZS = !1, WZ = 50, wv = 0, JS = null, jb = Ir, e1 = tt, z2 = !1;
    function t1() {
      return fi;
    }
    function pi() {
      return (zn & (Oa | zs)) !== Jo ? to() : (jb !== Ir || (jb = to()), jb);
    }
    function yf(o) {
      var i = o.mode;
      if ((i & kn) === an)
        return un;
      if ((zn & Oa) !== Jo && ea !== tt)
        return Ro(ea);
      var f = VX() !== zX;
      if (f) {
        if (_a.transition !== null) {
          var v = _a.transition;
          v._updatedFibers || (v._updatedFibers = /* @__PURE__ */ new Set()), v._updatedFibers.add(o);
        }
        return e1 === Fn && (e1 = Eg()), e1;
      }
      var w = Ni();
      if (w !== Fn)
        return w;
      var T = TK();
      return T;
    }
    function YZ(o) {
      var i = o.mode;
      return (i & kn) === an ? un : Q_();
    }
    function na(o, i, f, v) {
      vJ(), z2 && l("useInsertionEffect must not schedule updates."), kR && (ZS = !0), Rc(o, f, v), (zn & Oa) !== tt && o === fi ? bJ(i) : (qo && Pg(o, i, f), wJ(i), o === fi && ((zn & Oa) === Jo && ($b = En($b, f)), ta === kb && gf(o, ea)), Ui(o, v), f === un && zn === Jo && (i.mode & kn) === an && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !jl.isBatchingLegacy && (Nb(), FI()));
    }
    function qZ(o, i, f) {
      var v = o.current;
      v.lanes = i, Rc(o, i, f), Ui(o, f);
    }
    function GZ(o) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (zn & Oa) !== Jo
      );
    }
    function Ui(o, i) {
      var f = o.callbackNode;
      G_(o, i);
      var v = xp(o, o === fi ? ea : tt);
      if (v === tt) {
        f !== null && nj(f), o.callbackNode = null, o.callbackPriority = Fn;
        return;
      }
      var w = wo(v), T = o.callbackPriority;
      if (T === w && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(jl.current !== null && f !== jR)) {
        f == null && T !== un && l("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      f != null && nj(f);
      var $;
      if (w === un)
        o.tag === af ? (jl.isBatchingLegacy !== null && (jl.didScheduleLegacyUpdate = !0), EX(B2.bind(null, o))) : LI(B2.bind(null, o)), jl.current !== null ? jl.current.push(sf) : OK(function() {
          (zn & (Oa | zs)) === Jo && sf();
        }), $ = null;
      else {
        var F;
        switch (_p(v)) {
          case ca:
            F = oh;
            break;
          case Go:
            F = li;
            break;
          case Sl:
            F = ks;
            break;
          case Cp:
            F = mu;
            break;
          default:
            F = ks;
            break;
        }
        $ = LR(F, V2.bind(null, o));
      }
      o.callbackPriority = w, o.callbackNode = $;
    }
    function V2(o, i) {
      if (vQ(), jb = Ir, e1 = tt, (zn & (Oa | zs)) !== Jo)
        throw new Error("Should not already be working.");
      var f = o.callbackNode, v = Kc();
      if (v && o.callbackNode !== f)
        return null;
      var w = xp(o, o === fi ? ea : tt);
      if (w === tt)
        return null;
      var T = !Ep(o, w) && !px(o, w) && !i, $ = T ? oJ(o, w) : r1(o, w);
      if ($ !== Yc) {
        if ($ === Kp) {
          var F = xg(o);
          F !== tt && (w = F, $ = DR(o, F));
        }
        if ($ === Rb) {
          var W = Db;
          throw Qp(o, tt), gf(o, w), Ui(o, to()), W;
        }
        if ($ === ER)
          gf(o, w);
        else {
          var ie = !Ep(o, w), ce = o.current.alternate;
          if (ie && !XZ(ce)) {
            if ($ = r1(o, w), $ === Kp) {
              var De = xg(o);
              De !== tt && (w = De, $ = DR(o, De));
            }
            if ($ === Rb) {
              var Re = Db;
              throw Qp(o, tt), gf(o, w), Ui(o, to()), Re;
            }
          }
          o.finishedWork = ce, o.finishedLanes = w, KZ(o, $, w);
        }
      }
      return Ui(o, to()), o.callbackNode === f ? V2.bind(null, o) : null;
    }
    function DR(o, i) {
      var f = Mb;
      if (Do(o)) {
        var v = Qp(o, i);
        v.flags |= so, vX(o.containerInfo);
      }
      var w = r1(o, i);
      if (w !== Kp) {
        var T = Vi;
        Vi = f, T !== null && U2(T);
      }
      return w;
    }
    function U2(o) {
      Vi === null ? Vi = o : Vi.push.apply(Vi, o);
    }
    function KZ(o, i, f) {
      switch (i) {
        case Yc:
        case Rb:
          throw new Error("Root did not complete. This is a bug in React.");
        case Kp: {
          Zp(o, Vi, qc);
          break;
        }
        case GS: {
          if (gf(o, f), Ph(f) && // do not delay if we're inside an act() scope
          !rj()) {
            var v = TR + j2 - to();
            if (v > 10) {
              var w = xp(o, tt);
              if (w !== tt)
                break;
              var T = o.suspendedLanes;
              if (!Pc(T, f)) {
                pi(), _g(o, T);
                break;
              }
              o.timeoutHandle = PO(Zp.bind(null, o, Vi, qc), v);
              break;
            }
          }
          Zp(o, Vi, qc);
          break;
        }
        case kb: {
          if (gf(o, f), fx(f))
            break;
          if (!rj()) {
            var $ = dx(o, f), F = $, W = to() - F, ie = hJ(W) - W;
            if (ie > 10) {
              o.timeoutHandle = PO(Zp.bind(null, o, Vi, qc), ie);
              break;
            }
          }
          Zp(o, Vi, qc);
          break;
        }
        case A2: {
          Zp(o, Vi, qc);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function XZ(o) {
      for (var i = o; ; ) {
        if (i.flags & mp) {
          var f = i.updateQueue;
          if (f !== null) {
            var v = f.stores;
            if (v !== null)
              for (var w = 0; w < v.length; w++) {
                var T = v[w], $ = T.getSnapshot, F = T.value;
                try {
                  if (!qt($(), F))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var W = i.child;
        if (i.subtreeFlags & mp && W !== null) {
          W.return = i, i = W;
          continue;
        }
        if (i === o)
          return !0;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === o)
            return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return !0;
    }
    function gf(o, i) {
      i = Vd(i, XS), i = Vd(i, $b), Tg(o, i);
    }
    function B2(o) {
      if (yQ(), (zn & (Oa | zs)) !== Jo)
        throw new Error("Should not already be working.");
      Kc();
      var i = xp(o, tt);
      if (!Wa(i, un))
        return Ui(o, to()), null;
      var f = r1(o, i);
      if (o.tag !== af && f === Kp) {
        var v = xg(o);
        v !== tt && (i = v, f = DR(o, v));
      }
      if (f === Rb) {
        var w = Db;
        throw Qp(o, tt), gf(o, i), Ui(o, to()), w;
      }
      if (f === ER)
        throw new Error("Root did not complete. This is a bug in React.");
      var T = o.current.alternate;
      return o.finishedWork = T, o.finishedLanes = i, Zp(o, Vi, qc), Ui(o, to()), null;
    }
    function QZ(o, i) {
      i !== tt && (Ud(o, En(i, un)), Ui(o, to()), (zn & (Oa | zs)) === Jo && (Nb(), sf()));
    }
    function $R(o, i) {
      var f = zn;
      zn |= I2;
      try {
        return o(i);
      } finally {
        zn = f, zn === Jo && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !jl.isBatchingLegacy && (Nb(), FI());
      }
    }
    function ZZ(o, i, f, v, w) {
      var T = Ni(), $ = _a.transition;
      try {
        return _a.transition = null, ko(ca), o(i, f, v, w);
      } finally {
        ko(T), _a.transition = $, zn === Jo && Nb();
      }
    }
    function Gc(o) {
      vf !== null && vf.tag === af && (zn & (Oa | zs)) === Jo && Kc();
      var i = zn;
      zn |= I2;
      var f = _a.transition, v = Ni();
      try {
        return _a.transition = null, ko(ca), o ? o() : void 0;
      } finally {
        ko(v), _a.transition = f, zn = i, (zn & (Oa | zs)) === Jo && sf();
      }
    }
    function H2() {
      return (zn & (Oa | zs)) !== Jo;
    }
    function n1(o, i) {
      qa(CR, Au, o), Au = En(Au, i);
    }
    function MR(o) {
      Au = CR.current, Ya(CR, o);
    }
    function Qp(o, i) {
      o.finishedWork = null, o.finishedLanes = tt;
      var f = o.timeoutHandle;
      if (f !== RO && (o.timeoutHandle = RO, _K(f)), mo !== null)
        for (var v = mo.return; v !== null; ) {
          var w = v.alternate;
          b2(w, v), v = v.return;
        }
      fi = o;
      var T = Jp(o.current, null);
      return mo = T, ea = Au = i, ta = Yc, Db = null, KS = tt, $b = tt, XS = tt, Mb = null, Vi = null, WX(), Rl.discardPendingWarnings(), T;
    }
    function W2(o, i) {
      do {
        var f = mo;
        try {
          if (cS(), xA(), io(), SR.current = null, f === null || f.return === null) {
            ta = Rb, Db = i, mo = null;
            return;
          }
          if (Se && f.mode & ln && US(f, !0), Ce)
            if (bc(), i !== null && typeof i == "object" && typeof i.then == "function") {
              var v = i;
              lx(f, v, ea);
            } else
              uh(f, i, ea);
          SQ(o, f.return, f, i, ea), K2(f);
        } catch (w) {
          i = w, mo === f && f !== null ? (f = f.return, mo = f) : f = mo;
          continue;
        }
        return;
      } while (!0);
    }
    function Y2() {
      var o = xR.current;
      return xR.current = jS, o === null ? jS : o;
    }
    function q2(o) {
      xR.current = o;
    }
    function JZ() {
      TR = to();
    }
    function Lb(o) {
      KS = En(o, KS);
    }
    function eJ() {
      ta === Yc && (ta = GS);
    }
    function NR() {
      (ta === Yc || ta === GS || ta === Kp) && (ta = kb), fi !== null && (Sp(KS) || Sp($b)) && gf(fi, ea);
    }
    function tJ(o) {
      ta !== kb && (ta = Kp), Mb === null ? Mb = [o] : Mb.push(o);
    }
    function nJ() {
      return ta === Yc;
    }
    function r1(o, i) {
      var f = zn;
      zn |= Oa;
      var v = Y2();
      if (fi !== o || ea !== i) {
        if (qo) {
          var w = o.memoizedUpdaters;
          w.size > 0 && (Fb(o, ea), w.clear()), Dh(o, i);
        }
        qc = Rg(), Qp(o, i);
      }
      cs(i);
      do
        try {
          rJ();
          break;
        } catch (T) {
          W2(o, T);
        }
      while (!0);
      if (cS(), zn = f, q2(v), mo !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Ad(), fi = null, ea = tt, ta;
    }
    function rJ() {
      for (; mo !== null; )
        G2(mo);
    }
    function oJ(o, i) {
      var f = zn;
      zn |= Oa;
      var v = Y2();
      if (fi !== o || ea !== i) {
        if (qo) {
          var w = o.memoizedUpdaters;
          w.size > 0 && (Fb(o, ea), w.clear()), Dh(o, i);
        }
        qc = Rg(), Nb(), Qp(o, i);
      }
      cs(i);
      do
        try {
          aJ();
          break;
        } catch (T) {
          W2(o, T);
        }
      while (!0);
      return cS(), q2(v), zn = f, mo !== null ? (yp(), Yc) : (Ad(), fi = null, ea = tt, ta);
    }
    function aJ() {
      for (; mo !== null && !rh(); )
        G2(mo);
    }
    function G2(o) {
      var i = o.alternate;
      fr(o);
      var f;
      (o.mode & ln) !== an ? (KP(o), f = IR(i, o, Au), US(o, !0)) : f = IR(i, o, Au), io(), o.memoizedProps = o.pendingProps, f === null ? K2(o) : mo = f, SR.current = null;
    }
    function K2(o) {
      var i = o;
      do {
        var f = i.alternate, v = i.return;
        if ((i.flags & ai) === nn) {
          fr(i);
          var w = void 0;
          if ((i.mode & ln) === an ? w = g2(f, i, Au) : (KP(i), w = g2(f, i, Au), US(i, !1)), io(), w !== null) {
            mo = w;
            return;
          }
        } else {
          var T = eZ(f, i);
          if (T !== null) {
            T.flags &= Jw, mo = T;
            return;
          }
          if ((i.mode & ln) !== an) {
            US(i, !1);
            for (var $ = i.actualDuration, F = i.child; F !== null; )
              $ += F.actualDuration, F = F.sibling;
            i.actualDuration = $;
          }
          if (v !== null)
            v.flags |= ai, v.subtreeFlags = nn, v.deletions = null;
          else {
            ta = ER, mo = null;
            return;
          }
        }
        var W = i.sibling;
        if (W !== null) {
          mo = W;
          return;
        }
        i = v, mo = i;
      } while (i !== null);
      ta === Yc && (ta = A2);
    }
    function Zp(o, i, f) {
      var v = Ni(), w = _a.transition;
      try {
        _a.transition = null, ko(ca), iJ(o, i, f, v);
      } finally {
        _a.transition = w, ko(v);
      }
      return null;
    }
    function iJ(o, i, f, v) {
      do
        Kc();
      while (vf !== null);
      if (yJ(), (zn & (Oa | zs)) !== Jo)
        throw new Error("Should not already be working.");
      var w = o.finishedWork, T = o.finishedLanes;
      if (ih(T), w === null)
        return vg(), null;
      if (T === tt && l("root.finishedLanes should not be empty during a commit. This is a bug in React."), o.finishedWork = null, o.finishedLanes = tt, w === o.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      o.callbackNode = null, o.callbackPriority = Fn;
      var $ = En(w.lanes, w.childLanes);
      Og(o, $), o === fi && (fi = null, mo = null, ea = tt), ((w.subtreeFlags & ki) !== nn || (w.flags & ki) !== nn) && (Xp || (Xp = !0, PR = f, LR(ks, function() {
        return Kc(), null;
      })));
      var F = (w.subtreeFlags & (Md | Va | ua | ki)) !== nn, W = (w.flags & (Md | Va | ua | ki)) !== nn;
      if (F || W) {
        var ie = _a.transition;
        _a.transition = null;
        var ce = Ni();
        ko(ca);
        var De = zn;
        zn |= zs, SR.current = null, aZ(o, w), YA(), bZ(o, w, T), bK(o.containerInfo), o.current = w, ux(T), wZ(w, o, T), Id(), nx(), zn = De, ko(ce), _a.transition = ie;
      } else
        o.current = w, YA();
      var Re = Xp;
      if (Xp ? (Xp = !1, vf = o, Ib = T) : (wv = 0, JS = null), $ = o.pendingLanes, $ === tt && (bv = null), Re || J2(o.current, !1), bl(w.stateNode, v), qo && o.memoizedUpdaters.clear(), FZ(), Ui(o, to()), i !== null)
        for (var Be = o.onRecoverableError, We = 0; We < i.length; We++) {
          var Qe = i[We], It = Qe.stack, rn = Qe.digest;
          Be(Qe.value, {
            componentStack: It,
            digest: rn
          });
        }
      if (QS) {
        QS = !1;
        var en = _R;
        throw _R = null, en;
      }
      return Wa(Ib, un) && o.tag !== af && Kc(), $ = o.pendingLanes, Wa($, un) ? (hQ(), o === RR ? Ab++ : (Ab = 0, RR = o)) : Ab = 0, sf(), vg(), null;
    }
    function Kc() {
      if (vf !== null) {
        var o = _p(Ib), i = J_(Sl, o), f = _a.transition, v = Ni();
        try {
          return _a.transition = null, ko(i), lJ();
        } finally {
          ko(v), _a.transition = f;
        }
      }
      return !1;
    }
    function sJ(o) {
      OR.push(o), Xp || (Xp = !0, LR(ks, function() {
        return Kc(), null;
      }));
    }
    function lJ() {
      if (vf === null)
        return !1;
      var o = PR;
      PR = null;
      var i = vf, f = Ib;
      if (vf = null, Ib = tt, (zn & (Oa | zs)) !== Jo)
        throw new Error("Cannot flush passive effects while already rendering.");
      kR = !0, ZS = !1, cx(f);
      var v = zn;
      zn |= zs, OZ(i.current), EZ(i, i.current, f, o);
      {
        var w = OR;
        OR = [];
        for (var T = 0; T < w.length; T++) {
          var $ = w[T];
          uZ(i, $);
        }
      }
      vp(), J2(i.current, !0), zn = v, sf(), ZS ? i === JS ? wv++ : (wv = 0, JS = i) : wv = 0, kR = !1, ZS = !1, vu(i);
      {
        var F = i.current.stateNode;
        F.effectDuration = 0, F.passiveEffectDuration = 0;
      }
      return !0;
    }
    function X2(o) {
      return bv !== null && bv.has(o);
    }
    function uJ(o) {
      bv === null ? bv = /* @__PURE__ */ new Set([o]) : bv.add(o);
    }
    function cJ(o) {
      QS || (QS = !0, _R = o);
    }
    var dJ = cJ;
    function Q2(o, i, f) {
      var v = qp(f, i), w = GA(o, v, un), T = uf(o, w, un), $ = pi();
      T !== null && (Rc(T, un, $), Ui(T, $));
    }
    function qr(o, i, f) {
      if (nZ(f), zb(!1), o.tag === b) {
        Q2(o, o, f);
        return;
      }
      var v = null;
      for (v = i; v !== null; ) {
        if (v.tag === b) {
          Q2(v, o, f);
          return;
        } else if (v.tag === h) {
          var w = v.type, T = v.stateNode;
          if (typeof w.getDerivedStateFromError == "function" || typeof T.componentDidCatch == "function" && !X2(T)) {
            var $ = qp(f, o), F = tR(v, $, un), W = uf(v, F, un), ie = pi();
            W !== null && (Rc(W, un, ie), Ui(W, ie));
            return;
          }
        }
        v = v.return;
      }
      l(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, f);
    }
    function fJ(o, i, f) {
      var v = o.pingCache;
      v !== null && v.delete(i);
      var w = pi();
      _g(o, f), xJ(o), fi === o && Pc(ea, f) && (ta === kb || ta === GS && Ph(ea) && to() - TR < j2 ? Qp(o, tt) : XS = En(XS, f)), Ui(o, w);
    }
    function Z2(o, i) {
      i === Fn && (i = YZ(o));
      var f = pi(), v = Fi(o, i);
      v !== null && (Rc(v, i, f), Ui(v, f));
    }
    function pJ(o) {
      var i = o.memoizedState, f = Fn;
      i !== null && (f = i.retryLane), Z2(o, f);
    }
    function mJ(o, i) {
      var f = Fn, v;
      switch (o.tag) {
        case R:
          v = o.stateNode;
          var w = o.memoizedState;
          w !== null && (f = w.retryLane);
          break;
        case Z:
          v = o.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      v !== null && v.delete(i), Z2(o, f);
    }
    function hJ(o) {
      return o < 120 ? 120 : o < 480 ? 480 : o < 1080 ? 1080 : o < 1920 ? 1920 : o < 3e3 ? 3e3 : o < 4320 ? 4320 : UZ(o / 1960) * 1960;
    }
    function vJ() {
      if (Ab > HZ)
        throw Ab = 0, RR = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      wv > WZ && (wv = 0, JS = null, l("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function yJ() {
      Rl.flushLegacyContextWarning(), Rl.flushPendingUnsafeLifecycleWarnings();
    }
    function J2(o, i) {
      fr(o), o1(o, za, AZ), i && o1(o, gc, jZ), o1(o, za, NZ), i && o1(o, gc, IZ), io();
    }
    function o1(o, i, f) {
      for (var v = o, w = null; v !== null; ) {
        var T = v.subtreeFlags & i;
        v !== w && v.child !== null && T !== nn ? v = v.child : ((v.flags & i) !== nn && f(v), v.sibling !== null ? v = v.sibling : v = w = v.return);
      }
    }
    var a1 = null;
    function ej(o) {
      {
        if ((zn & Oa) !== Jo || !(o.mode & kn))
          return;
        var i = o.tag;
        if (i !== g && i !== b && i !== h && i !== m && i !== N && i !== j && i !== U)
          return;
        var f = gn(o) || "ReactComponent";
        if (a1 !== null) {
          if (a1.has(f))
            return;
          a1.add(f);
        } else
          a1 = /* @__PURE__ */ new Set([f]);
        var v = eo;
        try {
          fr(o), l("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          v ? fr(o) : io();
        }
      }
    }
    var IR;
    {
      var gJ = null;
      IR = function(o, i, f) {
        var v = lj(gJ, i);
        try {
          return p2(o, i, f);
        } catch (T) {
          if (DX() || T !== null && typeof T == "object" && typeof T.then == "function")
            throw T;
          if (cS(), xA(), b2(o, i), lj(i, v), i.mode & ln && KP(i), yc(null, p2, null, o, i, f), Y_()) {
            var w = ag();
            typeof w == "object" && w !== null && w._suppressLogging && typeof T == "object" && T !== null && !T._suppressLogging && (T._suppressLogging = !0);
          }
          throw T;
        }
      };
    }
    var tj = !1, AR;
    AR = /* @__PURE__ */ new Set();
    function bJ(o) {
      if (Ia && !fQ())
        switch (o.tag) {
          case m:
          case N:
          case U: {
            var i = mo && gn(mo) || "Unknown", f = i;
            if (!AR.has(f)) {
              AR.add(f);
              var v = gn(o) || "Unknown";
              l("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", v, i, i);
            }
            break;
          }
          case h: {
            tj || (l("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), tj = !0);
            break;
          }
        }
    }
    function Fb(o, i) {
      if (qo) {
        var f = o.memoizedUpdaters;
        f.forEach(function(v) {
          Pg(o, v, i);
        });
      }
    }
    var jR = {};
    function LR(o, i) {
      {
        var f = jl.current;
        return f !== null ? (f.push(i), jR) : nh(o, i);
      }
    }
    function nj(o) {
      if (o !== jR)
        return tx(o);
    }
    function rj() {
      return jl.current !== null;
    }
    function wJ(o) {
      {
        if (o.mode & kn) {
          if (!N2())
            return;
        } else if (!VZ() || zn !== Jo || o.tag !== m && o.tag !== N && o.tag !== U)
          return;
        if (jl.current === null) {
          var i = eo;
          try {
            fr(o), l(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, gn(o));
          } finally {
            i ? fr(o) : io();
          }
        }
      }
    }
    function xJ(o) {
      o.tag !== af && N2() && jl.current === null && l(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function zb(o) {
      z2 = o;
    }
    var Vs = null, xv = null, SJ = function(o) {
      Vs = o;
    };
    function Sv(o) {
      {
        if (Vs === null)
          return o;
        var i = Vs(o);
        return i === void 0 ? o : i.current;
      }
    }
    function FR(o) {
      return Sv(o);
    }
    function zR(o) {
      {
        if (Vs === null)
          return o;
        var i = Vs(o);
        if (i === void 0) {
          if (o != null && typeof o.render == "function") {
            var f = Sv(o.render);
            if (o.render !== f) {
              var v = {
                $$typeof: Tt,
                render: f
              };
              return o.displayName !== void 0 && (v.displayName = o.displayName), v;
            }
          }
          return o;
        }
        return i.current;
      }
    }
    function oj(o, i) {
      {
        if (Vs === null)
          return !1;
        var f = o.elementType, v = i.type, w = !1, T = typeof v == "object" && v !== null ? v.$$typeof : null;
        switch (o.tag) {
          case h: {
            typeof v == "function" && (w = !0);
            break;
          }
          case m: {
            (typeof v == "function" || T === $e) && (w = !0);
            break;
          }
          case N: {
            (T === Tt || T === $e) && (w = !0);
            break;
          }
          case j:
          case U: {
            (T === ge || T === $e) && (w = !0);
            break;
          }
          default:
            return !1;
        }
        if (w) {
          var $ = Vs(f);
          if ($ !== void 0 && $ === Vs(v))
            return !0;
        }
        return !1;
      }
    }
    function aj(o) {
      {
        if (Vs === null || typeof WeakSet != "function")
          return;
        xv === null && (xv = /* @__PURE__ */ new WeakSet()), xv.add(o);
      }
    }
    var EJ = function(o, i) {
      {
        if (Vs === null)
          return;
        var f = i.staleFamilies, v = i.updatedFamilies;
        Kc(), Gc(function() {
          VR(o.current, v, f);
        });
      }
    }, CJ = function(o, i) {
      {
        if (o.context !== fs)
          return;
        Kc(), Gc(function() {
          Vb(i, o, null, null);
        });
      }
    };
    function VR(o, i, f) {
      {
        var v = o.alternate, w = o.child, T = o.sibling, $ = o.tag, F = o.type, W = null;
        switch ($) {
          case m:
          case U:
          case h:
            W = F;
            break;
          case N:
            W = F.render;
            break;
        }
        if (Vs === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var ie = !1, ce = !1;
        if (W !== null) {
          var De = Vs(W);
          De !== void 0 && (f.has(De) ? ce = !0 : i.has(De) && ($ === h ? ce = !0 : ie = !0));
        }
        if (xv !== null && (xv.has(o) || v !== null && xv.has(v)) && (ce = !0), ce && (o._debugNeedsRemount = !0), ce || ie) {
          var Re = Fi(o, un);
          Re !== null && na(Re, o, un, Ir);
        }
        w !== null && !ce && VR(w, i, f), T !== null && VR(T, i, f);
      }
    }
    var TJ = function(o, i) {
      {
        var f = /* @__PURE__ */ new Set(), v = new Set(i.map(function(w) {
          return w.current;
        }));
        return UR(o.current, v, f), f;
      }
    };
    function UR(o, i, f) {
      {
        var v = o.child, w = o.sibling, T = o.tag, $ = o.type, F = null;
        switch (T) {
          case m:
          case U:
          case h:
            F = $;
            break;
          case N:
            F = $.render;
            break;
        }
        var W = !1;
        F !== null && i.has(F) && (W = !0), W ? _J(o, f) : v !== null && UR(v, i, f), w !== null && UR(w, i, f);
      }
    }
    function _J(o, i) {
      {
        var f = OJ(o, i);
        if (f)
          return;
        for (var v = o; ; ) {
          switch (v.tag) {
            case E:
              i.add(v.stateNode);
              return;
            case x:
              i.add(v.stateNode.containerInfo);
              return;
            case b:
              i.add(v.stateNode.containerInfo);
              return;
          }
          if (v.return === null)
            throw new Error("Expected to reach root first.");
          v = v.return;
        }
      }
    }
    function OJ(o, i) {
      for (var f = o, v = !1; ; ) {
        if (f.tag === E)
          v = !0, i.add(f.stateNode);
        else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === o)
          return v;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === o)
            return v;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return !1;
    }
    var BR;
    {
      BR = !1;
      try {
        var ij = Object.preventExtensions({});
      } catch {
        BR = !0;
      }
    }
    function PJ(o, i, f, v) {
      this.tag = o, this.key = f, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = i, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = v, this.flags = nn, this.subtreeFlags = nn, this.deletions = null, this.lanes = tt, this.childLanes = tt, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !BR && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ps = function(o, i, f, v) {
      return new PJ(o, i, f, v);
    };
    function HR(o) {
      var i = o.prototype;
      return !!(i && i.isReactComponent);
    }
    function RJ(o) {
      return typeof o == "function" && !HR(o) && o.defaultProps === void 0;
    }
    function kJ(o) {
      if (typeof o == "function")
        return HR(o) ? h : m;
      if (o != null) {
        var i = o.$$typeof;
        if (i === Tt)
          return N;
        if (i === ge)
          return j;
      }
      return g;
    }
    function Jp(o, i) {
      var f = o.alternate;
      f === null ? (f = ps(o.tag, i, o.key, o.mode), f.elementType = o.elementType, f.type = o.type, f.stateNode = o.stateNode, f._debugSource = o._debugSource, f._debugOwner = o._debugOwner, f._debugHookTypes = o._debugHookTypes, f.alternate = o, o.alternate = f) : (f.pendingProps = i, f.type = o.type, f.flags = nn, f.subtreeFlags = nn, f.deletions = null, f.actualDuration = 0, f.actualStartTime = -1), f.flags = o.flags & Yo, f.childLanes = o.childLanes, f.lanes = o.lanes, f.child = o.child, f.memoizedProps = o.memoizedProps, f.memoizedState = o.memoizedState, f.updateQueue = o.updateQueue;
      var v = o.dependencies;
      switch (f.dependencies = v === null ? null : {
        lanes: v.lanes,
        firstContext: v.firstContext
      }, f.sibling = o.sibling, f.index = o.index, f.ref = o.ref, f.selfBaseDuration = o.selfBaseDuration, f.treeBaseDuration = o.treeBaseDuration, f._debugNeedsRemount = o._debugNeedsRemount, f.tag) {
        case g:
        case m:
        case U:
          f.type = Sv(o.type);
          break;
        case h:
          f.type = FR(o.type);
          break;
        case N:
          f.type = zR(o.type);
          break;
      }
      return f;
    }
    function DJ(o, i) {
      o.flags &= Yo | Br;
      var f = o.alternate;
      if (f === null)
        o.childLanes = tt, o.lanes = i, o.child = null, o.subtreeFlags = nn, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null, o.selfBaseDuration = 0, o.treeBaseDuration = 0;
      else {
        o.childLanes = f.childLanes, o.lanes = f.lanes, o.child = f.child, o.subtreeFlags = nn, o.deletions = null, o.memoizedProps = f.memoizedProps, o.memoizedState = f.memoizedState, o.updateQueue = f.updateQueue, o.type = f.type;
        var v = f.dependencies;
        o.dependencies = v === null ? null : {
          lanes: v.lanes,
          firstContext: v.firstContext
        }, o.selfBaseDuration = f.selfBaseDuration, o.treeBaseDuration = f.treeBaseDuration;
      }
      return o;
    }
    function $J(o, i, f) {
      var v;
      return o === nS ? (v = kn, i === !0 && (v |= no, v |= $i)) : v = an, qo && (v |= ln), ps(b, null, null, v);
    }
    function WR(o, i, f, v, w, T) {
      var $ = g, F = o;
      if (typeof o == "function")
        HR(o) ? ($ = h, F = FR(F)) : F = Sv(F);
      else if (typeof o == "string")
        $ = E;
      else
        e:
          switch (o) {
            case zr:
              return bf(f.children, w, T, i);
            case Vr:
              $ = P, w |= no, (w & kn) !== an && (w |= $i);
              break;
            case be:
              return MJ(f, w, T, i);
            case it:
              return NJ(f, w, T, i);
            case nt:
              return IJ(f, w, T, i);
            case fn:
              return sj(f, w, T, i);
            case er:
            case dt:
            case In:
            case An:
            case Ft:
            default: {
              if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                  case at:
                    $ = D;
                    break e;
                  case wt:
                    $ = M;
                    break e;
                  case Tt:
                    $ = N, F = zR(F);
                    break e;
                  case ge:
                    $ = j;
                    break e;
                  case $e:
                    $ = q, F = null;
                    break e;
                }
              var W = "";
              {
                (o === void 0 || typeof o == "object" && o !== null && Object.keys(o).length === 0) && (W += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var ie = v ? gn(v) : null;
                ie && (W += `

Check the render method of \`` + ie + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (o == null ? o : typeof o) + "." + W));
            }
          }
      var ce = ps($, f, i, w);
      return ce.elementType = o, ce.type = F, ce.lanes = T, ce._debugOwner = v, ce;
    }
    function YR(o, i, f) {
      var v = null;
      v = o._owner;
      var w = o.type, T = o.key, $ = o.props, F = WR(w, T, $, v, i, f);
      return F._debugSource = o._source, F._debugOwner = o._owner, F;
    }
    function bf(o, i, f, v) {
      var w = ps(_, o, v, i);
      return w.lanes = f, w;
    }
    function MJ(o, i, f, v) {
      typeof o.id != "string" && l('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof o.id);
      var w = ps(I, o, v, i | ln);
      return w.elementType = be, w.lanes = f, w.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, w;
    }
    function NJ(o, i, f, v) {
      var w = ps(R, o, v, i);
      return w.elementType = it, w.lanes = f, w;
    }
    function IJ(o, i, f, v) {
      var w = ps(Z, o, v, i);
      return w.elementType = nt, w.lanes = f, w;
    }
    function sj(o, i, f, v) {
      var w = ps(Y, o, v, i);
      w.elementType = fn, w.lanes = f;
      var T = {
        isHidden: !1
      };
      return w.stateNode = T, w;
    }
    function qR(o, i, f) {
      var v = ps(O, o, null, i);
      return v.lanes = f, v;
    }
    function AJ() {
      var o = ps(E, null, null, an);
      return o.elementType = "DELETED", o;
    }
    function jJ(o) {
      var i = ps(H, null, null, an);
      return i.stateNode = o, i;
    }
    function GR(o, i, f) {
      var v = o.children !== null ? o.children : [], w = ps(x, v, o.key, i);
      return w.lanes = f, w.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: o.implementation
      }, w;
    }
    function lj(o, i) {
      return o === null && (o = ps(g, null, null, an)), o.tag = i.tag, o.key = i.key, o.elementType = i.elementType, o.type = i.type, o.stateNode = i.stateNode, o.return = i.return, o.child = i.child, o.sibling = i.sibling, o.index = i.index, o.ref = i.ref, o.pendingProps = i.pendingProps, o.memoizedProps = i.memoizedProps, o.updateQueue = i.updateQueue, o.memoizedState = i.memoizedState, o.dependencies = i.dependencies, o.mode = i.mode, o.flags = i.flags, o.subtreeFlags = i.subtreeFlags, o.deletions = i.deletions, o.lanes = i.lanes, o.childLanes = i.childLanes, o.alternate = i.alternate, o.actualDuration = i.actualDuration, o.actualStartTime = i.actualStartTime, o.selfBaseDuration = i.selfBaseDuration, o.treeBaseDuration = i.treeBaseDuration, o._debugSource = i._debugSource, o._debugOwner = i._debugOwner, o._debugNeedsRemount = i._debugNeedsRemount, o._debugHookTypes = i._debugHookTypes, o;
    }
    function LJ(o, i, f, v, w) {
      this.tag = i, this.containerInfo = o, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = RO, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Fn, this.eventTimes = kh(tt), this.expirationTimes = kh(Ir), this.pendingLanes = tt, this.suspendedLanes = tt, this.pingedLanes = tt, this.expiredLanes = tt, this.mutableReadLanes = tt, this.finishedLanes = tt, this.entangledLanes = tt, this.entanglements = kh(tt), this.identifierPrefix = v, this.onRecoverableError = w, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var T = this.pendingUpdatersLaneMap = [], $ = 0; $ < Wr; $++)
          T.push(/* @__PURE__ */ new Set());
      }
      switch (i) {
        case nS:
          this._debugRootType = f ? "hydrateRoot()" : "createRoot()";
          break;
        case af:
          this._debugRootType = f ? "hydrate()" : "render()";
          break;
      }
    }
    function uj(o, i, f, v, w, T, $, F, W, ie) {
      var ce = new LJ(o, i, f, F, W), De = $J(i, T);
      ce.current = De, De.stateNode = ce;
      {
        var Re = {
          element: v,
          isDehydrated: f,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        De.memoizedState = Re;
      }
      return nP(De), ce;
    }
    var KR = "18.2.0";
    function FJ(o, i, f) {
      var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Me(v), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Fr,
        key: v == null ? null : "" + v,
        children: o,
        containerInfo: i,
        implementation: f
      };
    }
    var XR, QR;
    XR = !1, QR = {};
    function cj(o) {
      if (!o)
        return fs;
      var i = Oi(o), f = SX(i);
      if (i.tag === h) {
        var v = i.type;
        if (Ru(v))
          return AI(i, v, f);
      }
      return f;
    }
    function zJ(o, i) {
      {
        var f = Oi(o);
        if (f === void 0) {
          if (typeof o.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var v = Object.keys(o).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + v);
        }
        var w = Di(f);
        if (w === null)
          return null;
        if (w.mode & no) {
          var T = gn(f) || "Component";
          if (!QR[T]) {
            QR[T] = !0;
            var $ = eo;
            try {
              fr(w), f.mode & no ? l("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", i, i, T) : l("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", i, i, T);
            } finally {
              $ ? fr($) : io();
            }
          }
        }
        return w.stateNode;
      }
    }
    function dj(o, i, f, v, w, T, $, F) {
      var W = !1, ie = null;
      return uj(o, i, W, ie, f, v, w, T, $);
    }
    function fj(o, i, f, v, w, T, $, F, W, ie) {
      var ce = !0, De = uj(f, v, ce, o, w, T, $, F, W);
      De.context = cj(null);
      var Re = De.current, Be = pi(), We = yf(Re), Qe = Hc(Be, We);
      return Qe.callback = i ?? null, uf(Re, Qe, We), qZ(De, We, Be), De;
    }
    function Vb(o, i, f, v) {
      rx(i, o);
      var w = i.current, T = pi(), $ = yf(w);
      wc($);
      var F = cj(f);
      i.context === null ? i.context = F : i.pendingContext = F, Ia && eo !== null && !XR && (XR = !0, l(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, gn(eo) || "Unknown"));
      var W = Hc(T, $);
      W.payload = {
        element: o
      }, v = v === void 0 ? null : v, v !== null && (typeof v != "function" && l("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", v), W.callback = v);
      var ie = uf(w, W, $);
      return ie !== null && (na(ie, w, $, T), hS(ie, w, $)), $;
    }
    function i1(o) {
      var i = o.current;
      if (!i.child)
        return null;
      switch (i.child.tag) {
        case E:
          return i.child.stateNode;
        default:
          return i.child.stateNode;
      }
    }
    function VJ(o) {
      switch (o.tag) {
        case b: {
          var i = o.stateNode;
          if (Do(i)) {
            var f = K_(i);
            QZ(i, f);
          }
          break;
        }
        case R: {
          Gc(function() {
            var w = Fi(o, un);
            if (w !== null) {
              var T = pi();
              na(w, o, un, T);
            }
          });
          var v = un;
          ZR(o, v);
          break;
        }
      }
    }
    function pj(o, i) {
      var f = o.memoizedState;
      f !== null && f.dehydrated !== null && (f.retryLane = hx(f.retryLane, i));
    }
    function ZR(o, i) {
      pj(o, i);
      var f = o.alternate;
      f && pj(f, i);
    }
    function UJ(o) {
      if (o.tag === R) {
        var i = jd, f = Fi(o, i);
        if (f !== null) {
          var v = pi();
          na(f, o, i, v);
        }
        ZR(o, i);
      }
    }
    function BJ(o) {
      if (o.tag === R) {
        var i = yf(o), f = Fi(o, i);
        if (f !== null) {
          var v = pi();
          na(f, o, i, v);
        }
        ZR(o, i);
      }
    }
    function mj(o) {
      var i = ex(o);
      return i === null ? null : i.stateNode;
    }
    var hj = function(o) {
      return null;
    };
    function HJ(o) {
      return hj(o);
    }
    var vj = function(o) {
      return !1;
    };
    function WJ(o) {
      return vj(o);
    }
    var yj = null, gj = null, bj = null, wj = null, xj = null, Sj = null, Ej = null, Cj = null, Tj = null;
    {
      var _j = function(o, i, f) {
        var v = i[f], w = jn(o) ? o.slice() : On({}, o);
        return f + 1 === i.length ? (jn(w) ? w.splice(v, 1) : delete w[v], w) : (w[v] = _j(o[v], i, f + 1), w);
      }, Oj = function(o, i) {
        return _j(o, i, 0);
      }, Pj = function(o, i, f, v) {
        var w = i[v], T = jn(o) ? o.slice() : On({}, o);
        if (v + 1 === i.length) {
          var $ = f[v];
          T[$] = T[w], jn(T) ? T.splice(w, 1) : delete T[w];
        } else
          T[w] = Pj(
            // $FlowFixMe number or string is fine here
            o[w],
            i,
            f,
            v + 1
          );
        return T;
      }, Rj = function(o, i, f) {
        if (i.length !== f.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var v = 0; v < f.length - 1; v++)
            if (i[v] !== f[v]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return Pj(o, i, f, 0);
      }, kj = function(o, i, f, v) {
        if (f >= i.length)
          return v;
        var w = i[f], T = jn(o) ? o.slice() : On({}, o);
        return T[w] = kj(o[w], i, f + 1, v), T;
      }, Dj = function(o, i, f) {
        return kj(o, i, 0, f);
      }, JR = function(o, i) {
        for (var f = o.memoizedState; f !== null && i > 0; )
          f = f.next, i--;
        return f;
      };
      yj = function(o, i, f, v) {
        var w = JR(o, i);
        if (w !== null) {
          var T = Dj(w.memoizedState, f, v);
          w.memoizedState = T, w.baseState = T, o.memoizedProps = On({}, o.memoizedProps);
          var $ = Fi(o, un);
          $ !== null && na($, o, un, Ir);
        }
      }, gj = function(o, i, f) {
        var v = JR(o, i);
        if (v !== null) {
          var w = Oj(v.memoizedState, f);
          v.memoizedState = w, v.baseState = w, o.memoizedProps = On({}, o.memoizedProps);
          var T = Fi(o, un);
          T !== null && na(T, o, un, Ir);
        }
      }, bj = function(o, i, f, v) {
        var w = JR(o, i);
        if (w !== null) {
          var T = Rj(w.memoizedState, f, v);
          w.memoizedState = T, w.baseState = T, o.memoizedProps = On({}, o.memoizedProps);
          var $ = Fi(o, un);
          $ !== null && na($, o, un, Ir);
        }
      }, wj = function(o, i, f) {
        o.pendingProps = Dj(o.memoizedProps, i, f), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var v = Fi(o, un);
        v !== null && na(v, o, un, Ir);
      }, xj = function(o, i) {
        o.pendingProps = Oj(o.memoizedProps, i), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var f = Fi(o, un);
        f !== null && na(f, o, un, Ir);
      }, Sj = function(o, i, f) {
        o.pendingProps = Rj(o.memoizedProps, i, f), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var v = Fi(o, un);
        v !== null && na(v, o, un, Ir);
      }, Ej = function(o) {
        var i = Fi(o, un);
        i !== null && na(i, o, un, Ir);
      }, Cj = function(o) {
        hj = o;
      }, Tj = function(o) {
        vj = o;
      };
    }
    function YJ(o) {
      var i = Di(o);
      return i === null ? null : i.stateNode;
    }
    function qJ(o) {
      return null;
    }
    function GJ() {
      return eo;
    }
    function KJ(o) {
      var i = o.findFiberByHostInstance, f = n.ReactCurrentDispatcher;
      return mg({
        bundleType: o.bundleType,
        version: o.version,
        rendererPackageName: o.rendererPackageName,
        rendererConfig: o.rendererConfig,
        overrideHookState: yj,
        overrideHookStateDeletePath: gj,
        overrideHookStateRenamePath: bj,
        overrideProps: wj,
        overridePropsDeletePath: xj,
        overridePropsRenamePath: Sj,
        setErrorHandler: Cj,
        setSuspenseHandler: Tj,
        scheduleUpdate: Ej,
        currentDispatcherRef: f,
        findHostInstanceByFiber: YJ,
        findFiberByHostInstance: i || qJ,
        // React Refresh
        findHostInstancesForRefresh: TJ,
        scheduleRefresh: EJ,
        scheduleRoot: CJ,
        setRefreshHandler: SJ,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: GJ,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: KR
      });
    }
    var $j = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(o) {
      console.error(o);
    };
    function ek(o) {
      this._internalRoot = o;
    }
    s1.prototype.render = ek.prototype.render = function(o) {
      var i = this._internalRoot;
      if (i === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? l("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : l1(arguments[1]) ? l("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && l("You passed a second argument to root.render(...) but it only accepts one argument.");
        var f = i.containerInfo;
        if (f.nodeType !== bo) {
          var v = mj(i.current);
          v && v.parentNode !== f && l("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Vb(o, i, null, null);
    }, s1.prototype.unmount = ek.prototype.unmount = function() {
      typeof arguments[0] == "function" && l("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var o = this._internalRoot;
      if (o !== null) {
        this._internalRoot = null;
        var i = o.containerInfo;
        H2() && l("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Gc(function() {
          Vb(null, o, null, null);
        }), DI(i);
      }
    };
    function XJ(o, i) {
      if (!l1(o))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      Mj(o);
      var f = !1, v = !1, w = "", T = $j;
      i != null && (i.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof i == "object" && i !== null && i.$$typeof === Dr && l(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), i.unstable_strictMode === !0 && (f = !0), i.identifierPrefix !== void 0 && (w = i.identifierPrefix), i.onRecoverableError !== void 0 && (T = i.onRecoverableError), i.transitionCallbacks !== void 0 && i.transitionCallbacks);
      var $ = dj(o, nS, null, f, v, w, T);
      Kx($.current, o);
      var F = o.nodeType === bo ? o.parentNode : o;
      return Kg(F), new ek($);
    }
    function s1(o) {
      this._internalRoot = o;
    }
    function QJ(o) {
      o && Ex(o);
    }
    s1.prototype.unstable_scheduleHydration = QJ;
    function ZJ(o, i, f) {
      if (!l1(o))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      Mj(o), i === void 0 && l("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var v = f ?? null, w = f != null && f.hydratedSources || null, T = !1, $ = !1, F = "", W = $j;
      f != null && (f.unstable_strictMode === !0 && (T = !0), f.identifierPrefix !== void 0 && (F = f.identifierPrefix), f.onRecoverableError !== void 0 && (W = f.onRecoverableError));
      var ie = fj(i, null, o, nS, v, T, $, F, W);
      if (Kx(ie.current, o), Kg(o), w)
        for (var ce = 0; ce < w.length; ce++) {
          var De = w[ce];
          iQ(ie, De);
        }
      return new s1(ie);
    }
    function l1(o) {
      return !!(o && (o.nodeType === ja || o.nodeType === ss || o.nodeType === dc || !he));
    }
    function Ub(o) {
      return !!(o && (o.nodeType === ja || o.nodeType === ss || o.nodeType === dc || o.nodeType === bo && o.nodeValue === " react-mount-point-unstable "));
    }
    function Mj(o) {
      o.nodeType === ja && o.tagName && o.tagName.toUpperCase() === "BODY" && l("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), ib(o) && (o._reactRootContainer ? l("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : l("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var JJ = n.ReactCurrentOwner, Nj;
    Nj = function(o) {
      if (o._reactRootContainer && o.nodeType !== bo) {
        var i = mj(o._reactRootContainer.current);
        i && i.parentNode !== o && l("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var f = !!o._reactRootContainer, v = tk(o), w = !!(v && rf(v));
      w && !f && l("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), o.nodeType === ja && o.tagName && o.tagName.toUpperCase() === "BODY" && l("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function tk(o) {
      return o ? o.nodeType === ss ? o.documentElement : o.firstChild : null;
    }
    function Ij() {
    }
    function eee(o, i, f, v, w) {
      if (w) {
        if (typeof v == "function") {
          var T = v;
          v = function() {
            var Re = i1($);
            T.call(Re);
          };
        }
        var $ = fj(
          i,
          v,
          o,
          af,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Ij
        );
        o._reactRootContainer = $, Kx($.current, o);
        var F = o.nodeType === bo ? o.parentNode : o;
        return Kg(F), Gc(), $;
      } else {
        for (var W; W = o.lastChild; )
          o.removeChild(W);
        if (typeof v == "function") {
          var ie = v;
          v = function() {
            var Re = i1(ce);
            ie.call(Re);
          };
        }
        var ce = dj(
          o,
          af,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Ij
        );
        o._reactRootContainer = ce, Kx(ce.current, o);
        var De = o.nodeType === bo ? o.parentNode : o;
        return Kg(De), Gc(function() {
          Vb(i, ce, f, v);
        }), ce;
      }
    }
    function tee(o, i) {
      o !== null && typeof o != "function" && l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", i, o);
    }
    function u1(o, i, f, v, w) {
      Nj(f), tee(w === void 0 ? null : w, "render");
      var T = f._reactRootContainer, $;
      if (!T)
        $ = eee(f, i, o, w, v);
      else {
        if ($ = T, typeof w == "function") {
          var F = w;
          w = function() {
            var W = i1($);
            F.call(W);
          };
        }
        Vb(i, $, o, w);
      }
      return i1($);
    }
    function nee(o) {
      {
        var i = JJ.current;
        if (i !== null && i.stateNode !== null) {
          var f = i.stateNode._warnedAboutRefsInRender;
          f || l("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", qn(i.type) || "A component"), i.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return o == null ? null : o.nodeType === ja ? o : zJ(o, "findDOMNode");
    }
    function ree(o, i, f) {
      if (l("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ub(i))
        throw new Error("Target container is not a DOM element.");
      {
        var v = ib(i) && i._reactRootContainer === void 0;
        v && l("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return u1(null, o, i, !0, f);
    }
    function oee(o, i, f) {
      if (l("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ub(i))
        throw new Error("Target container is not a DOM element.");
      {
        var v = ib(i) && i._reactRootContainer === void 0;
        v && l("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return u1(null, o, i, !1, f);
    }
    function aee(o, i, f, v) {
      if (l("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ub(f))
        throw new Error("Target container is not a DOM element.");
      if (o == null || !pp(o))
        throw new Error("parentComponent must be a valid React Component");
      return u1(o, i, f, !1, v);
    }
    function iee(o) {
      if (!Ub(o))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var i = ib(o) && o._reactRootContainer === void 0;
        i && l("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (o._reactRootContainer) {
        {
          var f = tk(o), v = f && !rf(f);
          v && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Gc(function() {
          u1(null, null, o, !1, function() {
            o._reactRootContainer = null, DI(o);
          });
        }), !0;
      } else {
        {
          var w = tk(o), T = !!(w && rf(w)), $ = o.nodeType === ja && Ub(o.parentNode) && !!o.parentNode._reactRootContainer;
          T && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", $ ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Vt(VJ), yx(UJ), Pp(BJ), Dg(Ni), bx(Tp), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && l("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Qw(uK), Qm($R, ZZ, Gc);
    function see(o, i) {
      var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!l1(i))
        throw new Error("Target container is not a DOM element.");
      return FJ(o, i, null, f);
    }
    function lee(o, i, f, v) {
      return aee(o, i, f, v);
    }
    var nk = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [rf, Jh, Xx, Xm, cp, $R]
    };
    function uee(o, i) {
      return nk.usingClientEntryPoint || l('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), XJ(o, i);
    }
    function cee(o, i, f) {
      return nk.usingClientEntryPoint || l('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), ZJ(o, i, f);
    }
    function dee(o) {
      return H2() && l("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Gc(o);
    }
    var fee = KJ({
      findFiberByHostInstance: Lp,
      bundleType: 1,
      version: KR,
      rendererPackageName: "react-dom"
    });
    if (!fee && Pe && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var Aj = window.location.protocol;
      /^(https?|file):$/.test(Aj) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (Aj === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Hi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nk, Hi.createPortal = see, Hi.createRoot = uee, Hi.findDOMNode = nee, Hi.flushSync = dee, Hi.hydrate = ree, Hi.hydrateRoot = cee, Hi.render = oee, Hi.unmountComponentAtNode = iee, Hi.unstable_batchedUpdates = $R, Hi.unstable_renderSubtreeIntoContainer = lee, Hi.version = KR, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Hi;
}
function _4() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(_4);
    } catch (e) {
      console.error(e);
    }
  }
}
process.env.NODE_ENV === "production" ? (_4(), AD.exports = ese()) : AD.exports = tse();
var Py = AD.exports;
const h1 = /* @__PURE__ */ Uf(Py);
var nse = Object.defineProperty, rse = Object.defineProperties, ose = Object.getOwnPropertyDescriptors, SF = Object.getOwnPropertySymbols, ase = Object.prototype.hasOwnProperty, ise = Object.prototype.propertyIsEnumerable, EF = (e, t, n) => t in e ? nse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, O4 = (e, t) => {
  for (var n in t || (t = {}))
    ase.call(t, n) && EF(e, n, t[n]);
  if (SF)
    for (var n of SF(t))
      ise.call(t, n) && EF(e, n, t[n]);
  return e;
}, sse = (e, t) => rse(e, ose(t));
const g0 = {
  xs: 18,
  sm: 22,
  md: 28,
  lg: 34,
  xl: 44
};
function lse({ variant: e, theme: t, color: n, gradient: r }) {
  const a = t.fn.variant({ color: n, variant: e, gradient: r });
  return e === "gradient" ? {
    border: 0,
    backgroundImage: a.background,
    color: a.color,
    "&:hover": t.fn.hover({
      backgroundSize: "200%"
    })
  } : O4({
    border: `1px solid ${a.border}`,
    backgroundColor: a.background,
    color: a.color
  }, t.fn.hover({
    backgroundColor: a.hover
  }));
}
var use = yn((e, { color: t, size: n, radius: r, variant: a, gradient: s }) => ({
  root: sse(O4({}, lse({ variant: a, theme: e, color: t, gradient: s })), {
    position: "relative",
    height: e.fn.size({ size: n, sizes: g0 }),
    minHeight: e.fn.size({ size: n, sizes: g0 }),
    width: e.fn.size({ size: n, sizes: g0 }),
    minWidth: e.fn.size({ size: n, sizes: g0 }),
    borderRadius: e.fn.radius(r),
    padding: 0,
    lineHeight: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    "&:active": e.activeStyles,
    "&:disabled, &[data-disabled]": {
      color: e.colors.gray[e.colorScheme === "dark" ? 6 : 4],
      cursor: "not-allowed",
      backgroundColor: a === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
      borderColor: a === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
      backgroundImage: "none",
      pointerEvents: "none",
      "&:active": {
        transform: "none"
      }
    },
    "&[data-loading]": {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        top: -1,
        left: -1,
        right: -1,
        bottom: -1,
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], 0.5) : "rgba(255, 255, 255, .5)",
        borderRadius: e.fn.radius(r),
        cursor: "not-allowed"
      }
    }
  })
}));
const cse = use;
var dse = Object.defineProperty, wE = Object.getOwnPropertySymbols, P4 = Object.prototype.hasOwnProperty, R4 = Object.prototype.propertyIsEnumerable, CF = (e, t, n) => t in e ? dse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, fse = (e, t) => {
  for (var n in t || (t = {}))
    P4.call(t, n) && CF(e, n, t[n]);
  if (wE)
    for (var n of wE(t))
      R4.call(t, n) && CF(e, n, t[n]);
  return e;
}, pse = (e, t) => {
  var n = {};
  for (var r in e)
    P4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && wE)
    for (var r of wE(e))
      t.indexOf(r) < 0 && R4.call(e, r) && (n[r] = e[r]);
  return n;
};
function mse(e) {
  var t = e, { size: n, color: r } = t, a = pse(t, ["size", "color"]);
  return /* @__PURE__ */ le.createElement("svg", fse({
    viewBox: "0 0 135 140",
    xmlns: "http://www.w3.org/2000/svg",
    fill: r,
    width: `${n}px`
  }, a), /* @__PURE__ */ le.createElement("rect", {
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "height",
    begin: "0.5s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "y",
    begin: "0.5s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("rect", {
    x: "30",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "height",
    begin: "0.25s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "y",
    begin: "0.25s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("rect", {
    x: "60",
    width: "15",
    height: "140",
    rx: "6"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "height",
    begin: "0s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "y",
    begin: "0s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("rect", {
    x: "90",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "height",
    begin: "0.25s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "y",
    begin: "0.25s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("rect", {
    x: "120",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "height",
    begin: "0.5s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "y",
    begin: "0.5s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })));
}
var hse = Object.defineProperty, xE = Object.getOwnPropertySymbols, k4 = Object.prototype.hasOwnProperty, D4 = Object.prototype.propertyIsEnumerable, TF = (e, t, n) => t in e ? hse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, vse = (e, t) => {
  for (var n in t || (t = {}))
    k4.call(t, n) && TF(e, n, t[n]);
  if (xE)
    for (var n of xE(t))
      D4.call(t, n) && TF(e, n, t[n]);
  return e;
}, yse = (e, t) => {
  var n = {};
  for (var r in e)
    k4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && xE)
    for (var r of xE(e))
      t.indexOf(r) < 0 && D4.call(e, r) && (n[r] = e[r]);
  return n;
};
function gse(e) {
  var t = e, { size: n, color: r } = t, a = yse(t, ["size", "color"]);
  return /* @__PURE__ */ le.createElement("svg", vse({
    width: `${n}px`,
    height: `${n}px`,
    viewBox: "0 0 38 38",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: r
  }, a), /* @__PURE__ */ le.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ le.createElement("g", {
    transform: "translate(2.5 2.5)",
    strokeWidth: "5"
  }, /* @__PURE__ */ le.createElement("circle", {
    strokeOpacity: ".5",
    cx: "16",
    cy: "16",
    r: "16"
  }), /* @__PURE__ */ le.createElement("path", {
    d: "M32 16c0-9.94-8.06-16-16-16"
  }, /* @__PURE__ */ le.createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    from: "0 16 16",
    to: "360 16 16",
    dur: "1s",
    repeatCount: "indefinite"
  })))));
}
var bse = Object.defineProperty, SE = Object.getOwnPropertySymbols, $4 = Object.prototype.hasOwnProperty, M4 = Object.prototype.propertyIsEnumerable, _F = (e, t, n) => t in e ? bse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, wse = (e, t) => {
  for (var n in t || (t = {}))
    $4.call(t, n) && _F(e, n, t[n]);
  if (SE)
    for (var n of SE(t))
      M4.call(t, n) && _F(e, n, t[n]);
  return e;
}, xse = (e, t) => {
  var n = {};
  for (var r in e)
    $4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && SE)
    for (var r of SE(e))
      t.indexOf(r) < 0 && M4.call(e, r) && (n[r] = e[r]);
  return n;
};
function Sse(e) {
  var t = e, { size: n, color: r } = t, a = xse(t, ["size", "color"]);
  return /* @__PURE__ */ le.createElement("svg", wse({
    width: `${n}px`,
    height: `${n / 4}px`,
    viewBox: "0 0 120 30",
    xmlns: "http://www.w3.org/2000/svg",
    fill: r
  }, a), /* @__PURE__ */ le.createElement("circle", {
    cx: "15",
    cy: "15",
    r: "15"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "r",
    from: "15",
    to: "15",
    begin: "0s",
    dur: "0.8s",
    values: "15;9;15",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "fill-opacity",
    from: "1",
    to: "1",
    begin: "0s",
    dur: "0.8s",
    values: "1;.5;1",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("circle", {
    cx: "60",
    cy: "15",
    r: "9",
    fillOpacity: "0.3"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "r",
    from: "9",
    to: "9",
    begin: "0s",
    dur: "0.8s",
    values: "9;15;9",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "fill-opacity",
    from: "0.5",
    to: "0.5",
    begin: "0s",
    dur: "0.8s",
    values: ".5;1;.5",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ le.createElement("circle", {
    cx: "105",
    cy: "15",
    r: "15"
  }, /* @__PURE__ */ le.createElement("animate", {
    attributeName: "r",
    from: "15",
    to: "15",
    begin: "0s",
    dur: "0.8s",
    values: "15;9;15",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ le.createElement("animate", {
    attributeName: "fill-opacity",
    from: "1",
    to: "1",
    begin: "0s",
    dur: "0.8s",
    values: "1;.5;1",
    calcMode: "linear",
    repeatCount: "indefinite"
  })));
}
var Ese = Object.defineProperty, EE = Object.getOwnPropertySymbols, N4 = Object.prototype.hasOwnProperty, I4 = Object.prototype.propertyIsEnumerable, OF = (e, t, n) => t in e ? Ese(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Cse = (e, t) => {
  for (var n in t || (t = {}))
    N4.call(t, n) && OF(e, n, t[n]);
  if (EE)
    for (var n of EE(t))
      I4.call(t, n) && OF(e, n, t[n]);
  return e;
}, Tse = (e, t) => {
  var n = {};
  for (var r in e)
    N4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && EE)
    for (var r of EE(e))
      t.indexOf(r) < 0 && I4.call(e, r) && (n[r] = e[r]);
  return n;
};
const vk = {
  bars: mse,
  oval: gse,
  dots: Sse
}, _se = {
  xs: 18,
  sm: 22,
  md: 36,
  lg: 44,
  xl: 58
}, Ose = {
  size: "md"
};
function NT(e) {
  const t = vn("Loader", Ose, e), { size: n, color: r, variant: a } = t, s = Tse(t, ["size", "color", "variant"]), l = Da(), p = a in vk ? a : l.loader;
  return /* @__PURE__ */ le.createElement(hn, Cse({
    role: "presentation",
    component: vk[p] || vk.bars,
    size: l.fn.size({ size: n, sizes: _se }),
    color: l.fn.variant({
      variant: "filled",
      primaryFallback: !1,
      color: r || l.primaryColor
    }).background
  }, s));
}
NT.displayName = "@mantine/core/Loader";
var Pse = Object.defineProperty, CE = Object.getOwnPropertySymbols, A4 = Object.prototype.hasOwnProperty, j4 = Object.prototype.propertyIsEnumerable, PF = (e, t, n) => t in e ? Pse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, RF = (e, t) => {
  for (var n in t || (t = {}))
    A4.call(t, n) && PF(e, n, t[n]);
  if (CE)
    for (var n of CE(t))
      j4.call(t, n) && PF(e, n, t[n]);
  return e;
}, Rse = (e, t) => {
  var n = {};
  for (var r in e)
    A4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && CE)
    for (var r of CE(e))
      t.indexOf(r) < 0 && j4.call(e, r) && (n[r] = e[r]);
  return n;
};
const kse = {
  color: "gray",
  size: "md",
  variant: "subtle",
  loading: !1
}, L4 = C.forwardRef((e, t) => {
  const n = vn("ActionIcon", kse, e), {
    className: r,
    color: a,
    children: s,
    radius: l,
    size: p,
    variant: m,
    gradient: h,
    disabled: g,
    loaderProps: b,
    loading: x,
    unstyled: E
  } = n, O = Rse(n, [
    "className",
    "color",
    "children",
    "radius",
    "size",
    "variant",
    "gradient",
    "disabled",
    "loaderProps",
    "loading",
    "unstyled"
  ]), { classes: _, cx: P, theme: M } = cse({ size: p, radius: l, color: a, variant: m, gradient: h }, { name: "ActionIcon", unstyled: E }), D = M.fn.variant({ color: a, variant: m }), N = /* @__PURE__ */ le.createElement(NT, RF({
    color: D.color,
    size: M.fn.size({ size: p, sizes: g0 }) - 12
  }, b));
  return /* @__PURE__ */ le.createElement(MT, RF({
    className: P(_.root, r),
    ref: t,
    disabled: g,
    "data-disabled": g || void 0,
    "data-loading": x || void 0,
    unstyled: E
  }, O), x ? N : s);
});
L4.displayName = "@mantine/core/ActionIcon";
const qs = L4;
function F4(e) {
  const { children: t, target: n, className: r } = vn("Portal", {}, e), a = Da(), [s, l] = C.useState(!1), p = C.useRef();
  return c4(() => (l(!0), p.current = n ? typeof n == "string" ? document.querySelector(n) : n : document.createElement("div"), n || document.body.appendChild(p.current), () => {
    !n && document.body.removeChild(p.current);
  }), [n]), s ? Py.createPortal(/* @__PURE__ */ le.createElement("div", {
    className: r,
    dir: a.dir
  }, t), p.current) : null;
}
F4.displayName = "@mantine/core/Portal";
var Dse = Object.defineProperty, TE = Object.getOwnPropertySymbols, z4 = Object.prototype.hasOwnProperty, V4 = Object.prototype.propertyIsEnumerable, kF = (e, t, n) => t in e ? Dse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, $se = (e, t) => {
  for (var n in t || (t = {}))
    z4.call(t, n) && kF(e, n, t[n]);
  if (TE)
    for (var n of TE(t))
      V4.call(t, n) && kF(e, n, t[n]);
  return e;
}, Mse = (e, t) => {
  var n = {};
  for (var r in e)
    z4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && TE)
    for (var r of TE(e))
      t.indexOf(r) < 0 && V4.call(e, r) && (n[r] = e[r]);
  return n;
};
function dw(e) {
  var t = e, { withinPortal: n = !0, children: r } = t, a = Mse(t, ["withinPortal", "children"]);
  return n ? /* @__PURE__ */ le.createElement(F4, $se({}, a), r) : /* @__PURE__ */ le.createElement(le.Fragment, null, r);
}
dw.displayName = "@mantine/core/OptionalPortal";
var Nse = Object.defineProperty, DF = Object.getOwnPropertySymbols, Ise = Object.prototype.hasOwnProperty, Ase = Object.prototype.propertyIsEnumerable, $F = (e, t, n) => t in e ? Nse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, jse = (e, t) => {
  for (var n in t || (t = {}))
    Ise.call(t, n) && $F(e, n, t[n]);
  if (DF)
    for (var n of DF(t))
      Ase.call(t, n) && $F(e, n, t[n]);
  return e;
};
function U4(e) {
  return /* @__PURE__ */ le.createElement("svg", jse({
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e), /* @__PURE__ */ le.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
U4.displayName = "@mantine/core/CloseIcon";
var Lse = Object.defineProperty, _E = Object.getOwnPropertySymbols, B4 = Object.prototype.hasOwnProperty, H4 = Object.prototype.propertyIsEnumerable, MF = (e, t, n) => t in e ? Lse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Fse = (e, t) => {
  for (var n in t || (t = {}))
    B4.call(t, n) && MF(e, n, t[n]);
  if (_E)
    for (var n of _E(t))
      H4.call(t, n) && MF(e, n, t[n]);
  return e;
}, zse = (e, t) => {
  var n = {};
  for (var r in e)
    B4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && _E)
    for (var r of _E(e))
      t.indexOf(r) < 0 && H4.call(e, r) && (n[r] = e[r]);
  return n;
};
const Vse = {
  xs: 12,
  sm: 14,
  md: 16,
  lg: 20,
  xl: 24
}, Use = {
  size: "md"
}, W4 = C.forwardRef((e, t) => {
  const n = vn("CloseButton", Use, e), {
    iconSize: r,
    size: a = "md"
  } = n, s = zse(n, [
    "iconSize",
    "size"
  ]), l = Da(), p = r || l.fn.size({ size: a, sizes: Vse });
  return /* @__PURE__ */ le.createElement(qs, Fse({
    size: a,
    ref: t
  }, s), /* @__PURE__ */ le.createElement(U4, {
    width: p,
    height: p
  }));
});
W4.displayName = "@mantine/core/CloseButton";
const IT = W4;
var Bse = Object.defineProperty, Hse = Object.defineProperties, Wse = Object.getOwnPropertyDescriptors, NF = Object.getOwnPropertySymbols, Yse = Object.prototype.hasOwnProperty, qse = Object.prototype.propertyIsEnumerable, IF = (e, t, n) => t in e ? Bse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Zb = (e, t) => {
  for (var n in t || (t = {}))
    Yse.call(t, n) && IF(e, n, t[n]);
  if (NF)
    for (var n of NF(t))
      qse.call(t, n) && IF(e, n, t[n]);
  return e;
}, Gse = (e, t) => Hse(e, Wse(t));
function Kse({
  underline: e,
  strikethrough: t
}) {
  const n = [];
  return e && n.push("underline"), t && n.push("line-through"), n.length > 0 ? n.join(" ") : "none";
}
function Xse({ theme: e, color: t, variant: n }) {
  return t === "dimmed" ? e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6] : typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? e.fn.variant({ variant: "filled", color: t }).background : n === "link" ? e.colors[e.primaryColor][e.colorScheme === "dark" ? 4 : 7] : t || "inherit";
}
function Qse(e) {
  return typeof e == "number" ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    display: "-webkit-box",
    WebkitLineClamp: e,
    WebkitBoxOrient: "vertical"
  } : null;
}
function Zse({ theme: e, truncate: t }) {
  return t === "start" ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    direction: e.dir === "ltr" ? "rtl" : "ltr",
    textAlign: e.dir === "ltr" ? "right" : "left"
  } : t ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  } : null;
}
var Jse = yn((e, {
  color: t,
  variant: n,
  size: r,
  lineClamp: a,
  truncate: s,
  inline: l,
  inherit: p,
  underline: m,
  gradient: h,
  weight: g,
  transform: b,
  align: x,
  strikethrough: E,
  italic: O
}) => {
  const _ = e.fn.variant({ variant: "gradient", gradient: h });
  return {
    root: Zb(Gse(Zb(Zb(Zb(Zb({}, e.fn.fontStyles()), e.fn.focusStyles()), Qse(a)), Zse({ theme: e, truncate: s })), {
      color: Xse({ color: t, theme: e, variant: n }),
      fontFamily: p ? "inherit" : e.fontFamily,
      fontSize: p || r === void 0 ? "inherit" : e.fn.size({ size: r, sizes: e.fontSizes }),
      lineHeight: p ? "inherit" : l ? 1 : e.lineHeight,
      textDecoration: Kse({ underline: m, strikethrough: E }),
      WebkitTapHighlightColor: "transparent",
      fontWeight: p ? "inherit" : g,
      textTransform: b,
      textAlign: x,
      fontStyle: O ? "italic" : void 0
    }), e.fn.hover(n === "link" && m === void 0 ? {
      textDecoration: "underline"
    } : void 0)),
    gradient: {
      backgroundImage: _.background,
      WebkitBackgroundClip: "text",
      WebkitTextFillColor: "transparent"
    }
  };
});
const ele = Jse;
var tle = Object.defineProperty, OE = Object.getOwnPropertySymbols, Y4 = Object.prototype.hasOwnProperty, q4 = Object.prototype.propertyIsEnumerable, AF = (e, t, n) => t in e ? tle(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, nle = (e, t) => {
  for (var n in t || (t = {}))
    Y4.call(t, n) && AF(e, n, t[n]);
  if (OE)
    for (var n of OE(t))
      q4.call(t, n) && AF(e, n, t[n]);
  return e;
}, rle = (e, t) => {
  var n = {};
  for (var r in e)
    Y4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && OE)
    for (var r of OE(e))
      t.indexOf(r) < 0 && q4.call(e, r) && (n[r] = e[r]);
  return n;
};
const ole = {
  variant: "text"
}, G4 = C.forwardRef((e, t) => {
  const n = vn("Text", ole, e), {
    className: r,
    size: a,
    weight: s,
    transform: l,
    color: p,
    align: m,
    variant: h,
    lineClamp: g,
    truncate: b,
    gradient: x,
    inline: E,
    inherit: O,
    underline: _,
    strikethrough: P,
    italic: M,
    classNames: D,
    styles: N,
    unstyled: I,
    span: R
  } = n, j = rle(n, [
    "className",
    "size",
    "weight",
    "transform",
    "color",
    "align",
    "variant",
    "lineClamp",
    "truncate",
    "gradient",
    "inline",
    "inherit",
    "underline",
    "strikethrough",
    "italic",
    "classNames",
    "styles",
    "unstyled",
    "span"
  ]), { classes: U, cx: q } = ele({
    variant: h,
    color: p,
    size: a,
    lineClamp: g,
    truncate: b,
    inline: E,
    inherit: O,
    underline: _,
    strikethrough: P,
    italic: M,
    weight: s,
    transform: l,
    align: m,
    gradient: x
  }, { unstyled: I, name: "Text" });
  return /* @__PURE__ */ le.createElement(hn, nle({
    ref: t,
    className: q(U.root, { [U.gradient]: h === "gradient" }, r),
    component: R ? "span" : "div"
  }, j));
});
G4.displayName = "@mantine/core/Text";
const Gi = G4, v1 = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};
function y1(e, t) {
  const n = e.fn.variant({ variant: "outline", color: t }).border;
  return typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? n : t === void 0 ? e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4] : t;
}
var ale = yn((e, { size: t, variant: n, color: r }) => ({
  root: {},
  withLabel: {
    borderTop: "0 !important"
  },
  left: {
    "&::before": {
      display: "none"
    }
  },
  right: {
    "&::after": {
      display: "none"
    }
  },
  label: {
    display: "flex",
    alignItems: "center",
    "&::before": {
      content: '""',
      flex: 1,
      height: 1,
      borderTop: `${e.fn.size({ size: t, sizes: v1 })}px ${n} ${y1(e, r)}`,
      marginRight: e.spacing.xs
    },
    "&::after": {
      content: '""',
      flex: 1,
      borderTop: `${e.fn.size({ size: t, sizes: v1 })}px ${n} ${y1(e, r)}`,
      marginLeft: e.spacing.xs
    }
  },
  labelDefaultStyles: {
    color: r === "dark" ? e.colors.dark[1] : e.fn.themeColor(r, e.colorScheme === "dark" ? 5 : e.fn.primaryShade(), !1)
  },
  horizontal: {
    border: 0,
    borderTopWidth: e.fn.size({ size: t, sizes: v1 }),
    borderTopColor: y1(e, r),
    borderTopStyle: n,
    margin: 0
  },
  vertical: {
    border: 0,
    alignSelf: "stretch",
    height: "auto",
    borderLeftWidth: e.fn.size({ size: t, sizes: v1 }),
    borderLeftColor: y1(e, r),
    borderLeftStyle: n
  }
}));
const ile = ale;
var sle = Object.defineProperty, lle = Object.defineProperties, ule = Object.getOwnPropertyDescriptors, PE = Object.getOwnPropertySymbols, K4 = Object.prototype.hasOwnProperty, X4 = Object.prototype.propertyIsEnumerable, jF = (e, t, n) => t in e ? sle(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, LF = (e, t) => {
  for (var n in t || (t = {}))
    K4.call(t, n) && jF(e, n, t[n]);
  if (PE)
    for (var n of PE(t))
      X4.call(t, n) && jF(e, n, t[n]);
  return e;
}, cle = (e, t) => lle(e, ule(t)), dle = (e, t) => {
  var n = {};
  for (var r in e)
    K4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && PE)
    for (var r of PE(e))
      t.indexOf(r) < 0 && X4.call(e, r) && (n[r] = e[r]);
  return n;
};
const fle = {
  orientation: "horizontal",
  size: "xs",
  labelPosition: "left",
  variant: "solid"
}, H0 = C.forwardRef((e, t) => {
  const n = vn("Divider", fle, e), {
    className: r,
    color: a,
    orientation: s,
    size: l,
    label: p,
    labelPosition: m,
    labelProps: h,
    variant: g,
    styles: b,
    classNames: x,
    unstyled: E
  } = n, O = dle(n, [
    "className",
    "color",
    "orientation",
    "size",
    "label",
    "labelPosition",
    "labelProps",
    "variant",
    "styles",
    "classNames",
    "unstyled"
  ]), { classes: _, cx: P } = ile({ color: a, size: l, variant: g }, { classNames: x, styles: b, unstyled: E, name: "Divider" }), M = s === "vertical", D = s === "horizontal", N = !!p && D, I = !(h != null && h.color);
  return /* @__PURE__ */ le.createElement(hn, LF({
    ref: t,
    className: P(_.root, {
      [_.vertical]: M,
      [_.horizontal]: D,
      [_.withLabel]: N
    }, r),
    role: "separator"
  }, O), N && /* @__PURE__ */ le.createElement(Gi, cle(LF({}, h), {
    size: (h == null ? void 0 : h.size) || "xs",
    sx: { marginTop: 2 },
    className: P(_.label, _[m], {
      [_.labelDefaultStyles]: I
    })
  }), p));
});
H0.displayName = "@mantine/core/Divider";
var ple = Object.defineProperty, mle = Object.defineProperties, hle = Object.getOwnPropertyDescriptors, FF = Object.getOwnPropertySymbols, vle = Object.prototype.hasOwnProperty, yle = Object.prototype.propertyIsEnumerable, zF = (e, t, n) => t in e ? ple(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, VF = (e, t) => {
  for (var n in t || (t = {}))
    vle.call(t, n) && zF(e, n, t[n]);
  if (FF)
    for (var n of FF(t))
      yle.call(t, n) && zF(e, n, t[n]);
  return e;
}, gle = (e, t) => mle(e, hle(t)), ble = yn((e, { size: t }) => ({
  item: gle(VF({}, e.fn.fontStyles()), {
    boxSizing: "border-box",
    textAlign: "left",
    width: "100%",
    padding: `${e.fn.size({ size: t, sizes: e.spacing }) / 1.5}px ${e.fn.size({
      size: t,
      sizes: e.spacing
    })}px`,
    cursor: "pointer",
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    borderRadius: e.fn.radius(),
    "&[data-hovered]": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[1]
    },
    "&[data-selected]": VF({
      backgroundColor: e.fn.variant({ variant: "filled" }).background,
      color: e.fn.variant({ variant: "filled" }).color
    }, e.fn.hover({ backgroundColor: e.fn.variant({ variant: "filled" }).hover })),
    "&[data-disabled]": {
      cursor: "default",
      color: e.colors.dark[2]
    }
  }),
  nothingFound: {
    boxSizing: "border-box",
    color: e.colors.gray[6],
    paddingTop: e.fn.size({ size: t, sizes: e.spacing }) / 2,
    paddingBottom: e.fn.size({ size: t, sizes: e.spacing }) / 2,
    textAlign: "center"
  },
  separator: {
    boxSizing: "border-box",
    textAlign: "left",
    width: "100%",
    padding: `${e.fn.size({ size: t, sizes: e.spacing }) / 1.5}px ${e.fn.size({
      size: t,
      sizes: e.spacing
    })}px`
  },
  separatorLabel: {
    color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
  }
}));
const wle = ble;
var xle = Object.defineProperty, UF = Object.getOwnPropertySymbols, Sle = Object.prototype.hasOwnProperty, Ele = Object.prototype.propertyIsEnumerable, BF = (e, t, n) => t in e ? xle(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Cle = (e, t) => {
  for (var n in t || (t = {}))
    Sle.call(t, n) && BF(e, n, t[n]);
  if (UF)
    for (var n of UF(t))
      Ele.call(t, n) && BF(e, n, t[n]);
  return e;
};
function nM({
  data: e,
  hovered: t,
  classNames: n,
  styles: r,
  isItemSelected: a,
  uuid: s,
  __staticSelector: l,
  onItemHover: p,
  onItemSelect: m,
  itemsRefs: h,
  itemComponent: g,
  size: b,
  nothingFound: x,
  creatable: E,
  createLabel: O,
  unstyled: _
}) {
  const { classes: P } = wle({ size: b }, { classNames: n, styles: r, unstyled: _, name: l }), M = [], D = [];
  let N = null;
  const I = (j, U) => {
    const q = typeof a == "function" ? a(j.value) : !1;
    return /* @__PURE__ */ le.createElement(g, Cle({
      key: j.value,
      className: P.item,
      "data-disabled": j.disabled || void 0,
      "data-hovered": !j.disabled && t === U || void 0,
      "data-selected": !j.disabled && q || void 0,
      selected: q,
      onMouseEnter: () => p(U),
      id: `${s}-${U}`,
      role: "option",
      tabIndex: -1,
      "aria-selected": t === U,
      ref: (J) => {
        h && h.current && (h.current[j.value] = J);
      },
      onMouseDown: j.disabled ? null : (J) => {
        J.preventDefault(), m(j);
      },
      disabled: j.disabled
    }, j));
  };
  let R = null;
  if (e.forEach((j, U) => {
    j.creatable ? N = U : j.group ? (R !== j.group && (R = j.group, D.push(/* @__PURE__ */ le.createElement("div", {
      className: P.separator,
      key: `__mantine-divider-${U}`
    }, /* @__PURE__ */ le.createElement(H0, {
      classNames: { label: P.separatorLabel },
      label: j.group
    })))), D.push(I(j, U))) : M.push(I(j, U));
  }), E) {
    const j = e[N];
    M.push(/* @__PURE__ */ le.createElement("div", {
      key: xie(),
      className: P.item,
      "data-hovered": t === N || void 0,
      onMouseEnter: () => p(N),
      onMouseDown: (U) => {
        U.preventDefault(), m(j);
      },
      tabIndex: -1,
      ref: (U) => {
        h && h.current && (h.current[j.value] = U);
      }
    }, O));
  }
  return D.length > 0 && M.length > 0 && M.unshift(/* @__PURE__ */ le.createElement("div", {
    className: P.separator,
    key: "empty-group-separator"
  }, /* @__PURE__ */ le.createElement(H0, null))), D.length > 0 || M.length > 0 ? /* @__PURE__ */ le.createElement(le.Fragment, null, D, M) : /* @__PURE__ */ le.createElement(Gi, {
    size: b,
    unstyled: _,
    className: P.nothingFound
  }, x);
}
nM.displayName = "@mantine/core/SelectItems";
var Tle = Object.defineProperty, RE = Object.getOwnPropertySymbols, Q4 = Object.prototype.hasOwnProperty, Z4 = Object.prototype.propertyIsEnumerable, HF = (e, t, n) => t in e ? Tle(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _le = (e, t) => {
  for (var n in t || (t = {}))
    Q4.call(t, n) && HF(e, n, t[n]);
  if (RE)
    for (var n of RE(t))
      Z4.call(t, n) && HF(e, n, t[n]);
  return e;
}, Ole = (e, t) => {
  var n = {};
  for (var r in e)
    Q4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && RE)
    for (var r of RE(e))
      t.indexOf(r) < 0 && Z4.call(e, r) && (n[r] = e[r]);
  return n;
};
const rM = C.forwardRef((e, t) => {
  var n = e, { label: r, value: a } = n, s = Ole(n, ["label", "value"]);
  return /* @__PURE__ */ le.createElement("div", _le({
    ref: t
  }, s), r || a);
});
rM.displayName = "@mantine/core/DefaultItem";
function Ple(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function J4(...e) {
  return (t) => e.forEach(
    (n) => Ple(n, t)
  );
}
function km(...e) {
  return C.useCallback(J4(...e), e);
}
const e6 = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { children: n, ...r } = e, a = C.Children.toArray(n), s = a.find(kle);
  if (s) {
    const l = s.props.children, p = a.map((m) => m === s ? C.Children.count(l) > 1 ? C.Children.only(null) : /* @__PURE__ */ C.isValidElement(l) ? l.props.children : null : m);
    return /* @__PURE__ */ C.createElement(jD, B({}, r, {
      ref: t
    }), /* @__PURE__ */ C.isValidElement(l) ? /* @__PURE__ */ C.cloneElement(l, void 0, p) : null);
  }
  return /* @__PURE__ */ C.createElement(jD, B({}, r, {
    ref: t
  }), n);
});
e6.displayName = "Slot";
const jD = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ C.isValidElement(n) ? /* @__PURE__ */ C.cloneElement(n, {
    ...Dle(r, n.props),
    ref: J4(t, n.ref)
  }) : C.Children.count(n) > 1 ? C.Children.only(null) : null;
});
jD.displayName = "SlotClone";
const Rle = ({ children: e }) => /* @__PURE__ */ C.createElement(C.Fragment, null, e);
function kle(e) {
  return /* @__PURE__ */ C.isValidElement(e) && e.type === Rle;
}
function Dle(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const a = e[r], s = t[r];
    /^on[A-Z]/.test(r) ? a && s ? n[r] = (...p) => {
      s(...p), a(...p);
    } : a && (n[r] = a) : r === "style" ? n[r] = {
      ...a,
      ...s
    } : r === "className" && (n[r] = [
      a,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const $le = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], fw = $le.reduce((e, t) => {
  const n = /* @__PURE__ */ C.forwardRef((r, a) => {
    const { asChild: s, ...l } = r, p = s ? e6 : t;
    return C.useEffect(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ C.createElement(p, B({}, l, {
      ref: a
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {}), LD = globalThis != null && globalThis.document ? C.useLayoutEffect : () => {
};
function Mle(e, t) {
  return C.useReducer((n, r) => {
    const a = t[n][r];
    return a ?? n;
  }, e);
}
const pw = (e) => {
  const { present: t, children: n } = e, r = Nle(t), a = typeof n == "function" ? n({
    present: r.isPresent
  }) : C.Children.only(n), s = km(r.ref, a.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ C.cloneElement(a, {
    ref: s
  }) : null;
};
pw.displayName = "Presence";
function Nle(e) {
  const [t, n] = C.useState(), r = C.useRef({}), a = C.useRef(e), s = C.useRef("none"), l = e ? "mounted" : "unmounted", [p, m] = Mle(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return C.useEffect(() => {
    const h = g1(r.current);
    s.current = p === "mounted" ? h : "none";
  }, [
    p
  ]), LD(() => {
    const h = r.current, g = a.current;
    if (g !== e) {
      const x = s.current, E = g1(h);
      e ? m("MOUNT") : E === "none" || (h == null ? void 0 : h.display) === "none" ? m("UNMOUNT") : m(g && x !== E ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [
    e,
    m
  ]), LD(() => {
    if (t) {
      const h = (b) => {
        const E = g1(r.current).includes(b.animationName);
        b.target === t && E && Py.flushSync(
          () => m("ANIMATION_END")
        );
      }, g = (b) => {
        b.target === t && (s.current = g1(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      m("ANIMATION_END");
  }, [
    t,
    m
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(p),
    ref: C.useCallback((h) => {
      h && (r.current = getComputedStyle(h)), n(h);
    }, [])
  };
}
function g1(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Ile(e, t = []) {
  let n = [];
  function r(s, l) {
    const p = /* @__PURE__ */ C.createContext(l), m = n.length;
    n = [
      ...n,
      l
    ];
    function h(b) {
      const { scope: x, children: E, ...O } = b, _ = (x == null ? void 0 : x[e][m]) || p, P = C.useMemo(
        () => O,
        Object.values(O)
      );
      return /* @__PURE__ */ C.createElement(_.Provider, {
        value: P
      }, E);
    }
    function g(b, x) {
      const E = (x == null ? void 0 : x[e][m]) || p, O = C.useContext(E);
      if (O)
        return O;
      if (l !== void 0)
        return l;
      throw new Error(`\`${b}\` must be used within \`${s}\``);
    }
    return h.displayName = s + "Provider", [
      h,
      g
    ];
  }
  const a = () => {
    const s = n.map((l) => /* @__PURE__ */ C.createContext(l));
    return function(p) {
      const m = (p == null ? void 0 : p[e]) || s;
      return C.useMemo(
        () => ({
          [`__scope${e}`]: {
            ...p,
            [e]: m
          }
        }),
        [
          p,
          m
        ]
      );
    };
  };
  return a.scopeName = e, [
    r,
    Ale(a, ...t)
  ];
}
function Ale(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const n = () => {
    const r = e.map(
      (a) => ({
        useScope: a(),
        scopeName: a.scopeName
      })
    );
    return function(s) {
      const l = r.reduce((p, { useScope: m, scopeName: h }) => {
        const b = m(s)[`__scope${h}`];
        return {
          ...p,
          ...b
        };
      }, {});
      return C.useMemo(
        () => ({
          [`__scope${t.scopeName}`]: l
        }),
        [
          l
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function cm(e) {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }), C.useMemo(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
const jle = /* @__PURE__ */ C.createContext(void 0);
function Lle(e) {
  const t = C.useContext(jle);
  return e || t || "ltr";
}
function Fle(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function hm(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(a) {
    if (e == null || e(a), n === !1 || !a.defaultPrevented)
      return t == null ? void 0 : t(a);
  };
}
function zle(e, t) {
  return C.useReducer((n, r) => {
    const a = t[n][r];
    return a ?? n;
  }, e);
}
const t6 = "ScrollArea", [n6, fje] = Ile(t6), [Vle, sl] = n6(t6), Ule = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, type: r = "hover", dir: a, scrollHideDelay: s = 600, ...l } = e, [p, m] = C.useState(null), [h, g] = C.useState(null), [b, x] = C.useState(null), [E, O] = C.useState(null), [_, P] = C.useState(null), [M, D] = C.useState(0), [N, I] = C.useState(0), [R, j] = C.useState(!1), [U, q] = C.useState(!1), J = km(
    t,
    (Z) => m(Z)
  ), H = Lle(a);
  return /* @__PURE__ */ C.createElement(Vle, {
    scope: n,
    type: r,
    dir: H,
    scrollHideDelay: s,
    scrollArea: p,
    viewport: h,
    onViewportChange: g,
    content: b,
    onContentChange: x,
    scrollbarX: E,
    onScrollbarXChange: O,
    scrollbarXEnabled: R,
    onScrollbarXEnabledChange: j,
    scrollbarY: _,
    onScrollbarYChange: P,
    scrollbarYEnabled: U,
    onScrollbarYEnabledChange: q,
    onCornerWidthChange: D,
    onCornerHeightChange: I
  }, /* @__PURE__ */ C.createElement(fw.div, B({
    dir: H
  }, l, {
    ref: J,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      ["--radix-scroll-area-corner-width"]: M + "px",
      ["--radix-scroll-area-corner-height"]: N + "px",
      ...e.style
    }
  })));
}), Ble = "ScrollAreaViewport", Hle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, children: r, ...a } = e, s = sl(Ble, n), l = C.useRef(null), p = km(t, l, s.onViewportChange);
  return /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ C.createElement(fw.div, B({
    "data-radix-scroll-area-viewport": ""
  }, a, {
    ref: p,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: s.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: s.scrollbarYEnabled ? "scroll" : "hidden",
      ...e.style
    }
  }), /* @__PURE__ */ C.createElement("div", {
    ref: s.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, r)));
}), pd = "ScrollAreaScrollbar", Wle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, a = sl(pd, e.__scopeScrollArea), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: l } = a, p = e.orientation === "horizontal";
  return C.useEffect(() => (p ? s(!0) : l(!0), () => {
    p ? s(!1) : l(!1);
  }), [
    p,
    s,
    l
  ]), a.type === "hover" ? /* @__PURE__ */ C.createElement(Yle, B({}, r, {
    ref: t,
    forceMount: n
  })) : a.type === "scroll" ? /* @__PURE__ */ C.createElement(qle, B({}, r, {
    ref: t,
    forceMount: n
  })) : a.type === "auto" ? /* @__PURE__ */ C.createElement(r6, B({}, r, {
    ref: t,
    forceMount: n
  })) : a.type === "always" ? /* @__PURE__ */ C.createElement(oM, B({}, r, {
    ref: t
  })) : null;
}), Yle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, a = sl(pd, e.__scopeScrollArea), [s, l] = C.useState(!1);
  return C.useEffect(() => {
    const p = a.scrollArea;
    let m = 0;
    if (p) {
      const h = () => {
        window.clearTimeout(m), l(!0);
      }, g = () => {
        m = window.setTimeout(
          () => l(!1),
          a.scrollHideDelay
        );
      };
      return p.addEventListener("pointerenter", h), p.addEventListener("pointerleave", g), () => {
        window.clearTimeout(m), p.removeEventListener("pointerenter", h), p.removeEventListener("pointerleave", g);
      };
    }
  }, [
    a.scrollArea,
    a.scrollHideDelay
  ]), /* @__PURE__ */ C.createElement(pw, {
    present: n || s
  }, /* @__PURE__ */ C.createElement(r6, B({
    "data-state": s ? "visible" : "hidden"
  }, r, {
    ref: t
  })));
}), qle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, a = sl(pd, e.__scopeScrollArea), s = e.orientation === "horizontal", l = jT(
    () => m("SCROLL_END"),
    100
  ), [p, m] = zle("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return C.useEffect(() => {
    if (p === "idle") {
      const h = window.setTimeout(
        () => m("HIDE"),
        a.scrollHideDelay
      );
      return () => window.clearTimeout(h);
    }
  }, [
    p,
    a.scrollHideDelay,
    m
  ]), C.useEffect(() => {
    const h = a.viewport, g = s ? "scrollLeft" : "scrollTop";
    if (h) {
      let b = h[g];
      const x = () => {
        const E = h[g];
        b !== E && (m("SCROLL"), l()), b = E;
      };
      return h.addEventListener("scroll", x), () => h.removeEventListener("scroll", x);
    }
  }, [
    a.viewport,
    s,
    m,
    l
  ]), /* @__PURE__ */ C.createElement(pw, {
    present: n || p !== "hidden"
  }, /* @__PURE__ */ C.createElement(oM, B({
    "data-state": p === "hidden" ? "hidden" : "visible"
  }, r, {
    ref: t,
    onPointerEnter: hm(
      e.onPointerEnter,
      () => m("POINTER_ENTER")
    ),
    onPointerLeave: hm(
      e.onPointerLeave,
      () => m("POINTER_LEAVE")
    )
  })));
}), r6 = /* @__PURE__ */ C.forwardRef((e, t) => {
  const n = sl(pd, e.__scopeScrollArea), { forceMount: r, ...a } = e, [s, l] = C.useState(!1), p = e.orientation === "horizontal", m = jT(() => {
    if (n.viewport) {
      const h = n.viewport.offsetWidth < n.viewport.scrollWidth, g = n.viewport.offsetHeight < n.viewport.scrollHeight;
      l(p ? h : g);
    }
  }, 10);
  return fy(n.viewport, m), fy(n.content, m), /* @__PURE__ */ C.createElement(pw, {
    present: r || s
  }, /* @__PURE__ */ C.createElement(oM, B({
    "data-state": s ? "visible" : "hidden"
  }, a, {
    ref: t
  })));
}), oM = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...r } = e, a = sl(pd, e.__scopeScrollArea), s = C.useRef(null), l = C.useRef(0), [p, m] = C.useState({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), h = s6(p.viewport, p.content), g = {
    ...r,
    sizes: p,
    onSizesChange: m,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (x) => s.current = x,
    onThumbPointerUp: () => l.current = 0,
    onThumbPointerDown: (x) => l.current = x
  };
  function b(x, E) {
    return tue(x, l.current, p, E);
  }
  return n === "horizontal" ? /* @__PURE__ */ C.createElement(Gle, B({}, g, {
    ref: t,
    onThumbPositionChange: () => {
      if (a.viewport && s.current) {
        const x = a.viewport.scrollLeft, E = WF(x, p, a.dir);
        s.current.style.transform = `translate3d(${E}px, 0, 0)`;
      }
    },
    onWheelScroll: (x) => {
      a.viewport && (a.viewport.scrollLeft = x);
    },
    onDragScroll: (x) => {
      a.viewport && (a.viewport.scrollLeft = b(x, a.dir));
    }
  })) : n === "vertical" ? /* @__PURE__ */ C.createElement(Kle, B({}, g, {
    ref: t,
    onThumbPositionChange: () => {
      if (a.viewport && s.current) {
        const x = a.viewport.scrollTop, E = WF(x, p);
        s.current.style.transform = `translate3d(0, ${E}px, 0)`;
      }
    },
    onWheelScroll: (x) => {
      a.viewport && (a.viewport.scrollTop = x);
    },
    onDragScroll: (x) => {
      a.viewport && (a.viewport.scrollTop = b(x));
    }
  })) : null;
}), Gle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...a } = e, s = sl(pd, e.__scopeScrollArea), [l, p] = C.useState(), m = C.useRef(null), h = km(t, m, s.onScrollbarXChange);
  return C.useEffect(() => {
    m.current && p(getComputedStyle(m.current));
  }, [
    m
  ]), /* @__PURE__ */ C.createElement(a6, B({
    "data-orientation": "horizontal"
  }, a, {
    ref: h,
    sizes: n,
    style: {
      bottom: 0,
      left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      ["--radix-scroll-area-thumb-width"]: AT(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (g) => e.onThumbPointerDown(g.x),
    onDragScroll: (g) => e.onDragScroll(g.x),
    onWheelScroll: (g, b) => {
      if (s.viewport) {
        const x = s.viewport.scrollLeft + g.deltaX;
        e.onWheelScroll(x), u6(x, b) && g.preventDefault();
      }
    },
    onResize: () => {
      m.current && s.viewport && l && r({
        content: s.viewport.scrollWidth,
        viewport: s.viewport.offsetWidth,
        scrollbar: {
          size: m.current.clientWidth,
          paddingStart: kE(l.paddingLeft),
          paddingEnd: kE(l.paddingRight)
        }
      });
    }
  }));
}), Kle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...a } = e, s = sl(pd, e.__scopeScrollArea), [l, p] = C.useState(), m = C.useRef(null), h = km(t, m, s.onScrollbarYChange);
  return C.useEffect(() => {
    m.current && p(getComputedStyle(m.current));
  }, [
    m
  ]), /* @__PURE__ */ C.createElement(a6, B({
    "data-orientation": "vertical"
  }, a, {
    ref: h,
    sizes: n,
    style: {
      top: 0,
      right: s.dir === "ltr" ? 0 : void 0,
      left: s.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      ["--radix-scroll-area-thumb-height"]: AT(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (g) => e.onThumbPointerDown(g.y),
    onDragScroll: (g) => e.onDragScroll(g.y),
    onWheelScroll: (g, b) => {
      if (s.viewport) {
        const x = s.viewport.scrollTop + g.deltaY;
        e.onWheelScroll(x), u6(x, b) && g.preventDefault();
      }
    },
    onResize: () => {
      m.current && s.viewport && l && r({
        content: s.viewport.scrollHeight,
        viewport: s.viewport.offsetHeight,
        scrollbar: {
          size: m.current.clientHeight,
          paddingStart: kE(l.paddingTop),
          paddingEnd: kE(l.paddingBottom)
        }
      });
    }
  }));
}), [Xle, o6] = n6(pd), a6 = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, sizes: r, hasThumb: a, onThumbChange: s, onThumbPointerUp: l, onThumbPointerDown: p, onThumbPositionChange: m, onDragScroll: h, onWheelScroll: g, onResize: b, ...x } = e, E = sl(pd, n), [O, _] = C.useState(null), P = km(
    t,
    (J) => _(J)
  ), M = C.useRef(null), D = C.useRef(""), N = E.viewport, I = r.content - r.viewport, R = cm(g), j = cm(m), U = jT(b, 10);
  function q(J) {
    if (M.current) {
      const H = J.clientX - M.current.left, Z = J.clientY - M.current.top;
      h({
        x: H,
        y: Z
      });
    }
  }
  return C.useEffect(() => {
    const J = (H) => {
      const Z = H.target;
      (O == null ? void 0 : O.contains(Z)) && R(H, I);
    };
    return document.addEventListener("wheel", J, {
      passive: !1
    }), () => document.removeEventListener("wheel", J, {
      passive: !1
    });
  }, [
    N,
    O,
    I,
    R
  ]), C.useEffect(j, [
    r,
    j
  ]), fy(O, U), fy(E.content, U), /* @__PURE__ */ C.createElement(Xle, {
    scope: n,
    scrollbar: O,
    hasThumb: a,
    onThumbChange: cm(s),
    onThumbPointerUp: cm(l),
    onThumbPositionChange: j,
    onThumbPointerDown: cm(p)
  }, /* @__PURE__ */ C.createElement(fw.div, B({}, x, {
    ref: P,
    style: {
      position: "absolute",
      ...x.style
    },
    onPointerDown: hm(e.onPointerDown, (J) => {
      J.button === 0 && (J.target.setPointerCapture(J.pointerId), M.current = O.getBoundingClientRect(), D.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", q(J));
    }),
    onPointerMove: hm(e.onPointerMove, q),
    onPointerUp: hm(e.onPointerUp, (J) => {
      const H = J.target;
      H.hasPointerCapture(J.pointerId) && H.releasePointerCapture(J.pointerId), document.body.style.webkitUserSelect = D.current, M.current = null;
    })
  })));
}), FD = "ScrollAreaThumb", Qle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, a = o6(FD, e.__scopeScrollArea);
  return /* @__PURE__ */ C.createElement(pw, {
    present: n || a.hasThumb
  }, /* @__PURE__ */ C.createElement(Zle, B({
    ref: t
  }, r)));
}), Zle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, style: r, ...a } = e, s = sl(FD, n), l = o6(FD, n), { onThumbPositionChange: p } = l, m = km(
    t,
    (b) => l.onThumbChange(b)
  ), h = C.useRef(), g = jT(() => {
    h.current && (h.current(), h.current = void 0);
  }, 100);
  return C.useEffect(() => {
    const b = s.viewport;
    if (b) {
      const x = () => {
        if (g(), !h.current) {
          const E = nue(b, p);
          h.current = E, p();
        }
      };
      return p(), b.addEventListener("scroll", x), () => b.removeEventListener("scroll", x);
    }
  }, [
    s.viewport,
    g,
    p
  ]), /* @__PURE__ */ C.createElement(fw.div, B({
    "data-state": l.hasThumb ? "visible" : "hidden"
  }, a, {
    ref: m,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...r
    },
    onPointerDownCapture: hm(e.onPointerDownCapture, (b) => {
      const E = b.target.getBoundingClientRect(), O = b.clientX - E.left, _ = b.clientY - E.top;
      l.onThumbPointerDown({
        x: O,
        y: _
      });
    }),
    onPointerUp: hm(e.onPointerUp, l.onThumbPointerUp)
  }));
}), i6 = "ScrollAreaCorner", Jle = /* @__PURE__ */ C.forwardRef((e, t) => {
  const n = sl(i6, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
  return n.type !== "scroll" && r ? /* @__PURE__ */ C.createElement(eue, B({}, e, {
    ref: t
  })) : null;
}), eue = /* @__PURE__ */ C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, a = sl(i6, n), [s, l] = C.useState(0), [p, m] = C.useState(0), h = !!(s && p);
  return fy(a.scrollbarX, () => {
    var g;
    const b = ((g = a.scrollbarX) === null || g === void 0 ? void 0 : g.offsetHeight) || 0;
    a.onCornerHeightChange(b), m(b);
  }), fy(a.scrollbarY, () => {
    var g;
    const b = ((g = a.scrollbarY) === null || g === void 0 ? void 0 : g.offsetWidth) || 0;
    a.onCornerWidthChange(b), l(b);
  }), h ? /* @__PURE__ */ C.createElement(fw.div, B({}, r, {
    ref: t,
    style: {
      width: s,
      height: p,
      position: "absolute",
      right: a.dir === "ltr" ? 0 : void 0,
      left: a.dir === "rtl" ? 0 : void 0,
      bottom: 0,
      ...e.style
    }
  })) : null;
});
function kE(e) {
  return e ? parseInt(e, 10) : 0;
}
function s6(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function AT(e) {
  const t = s6(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function tue(e, t, n, r = "ltr") {
  const a = AT(n), s = a / 2, l = t || s, p = a - l, m = n.scrollbar.paddingStart + l, h = n.scrollbar.size - n.scrollbar.paddingEnd - p, g = n.content - n.viewport, b = r === "ltr" ? [
    0,
    g
  ] : [
    g * -1,
    0
  ];
  return l6([
    m,
    h
  ], b)(e);
}
function WF(e, t, n = "ltr") {
  const r = AT(t), a = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - a, l = t.content - t.viewport, p = s - r, m = n === "ltr" ? [
    0,
    l
  ] : [
    l * -1,
    0
  ], h = Fle(e, m);
  return l6([
    0,
    l
  ], [
    0,
    p
  ])(h);
}
function l6(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function u6(e, t) {
  return e > 0 && e < t;
}
const nue = (e, t = () => {
}) => {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, r = 0;
  return function a() {
    const s = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, l = n.left !== s.left, p = n.top !== s.top;
    (l || p) && t(), n = s, r = window.requestAnimationFrame(a);
  }(), () => window.cancelAnimationFrame(r);
};
function jT(e, t) {
  const n = cm(e), r = C.useRef(0);
  return C.useEffect(
    () => () => window.clearTimeout(r.current),
    []
  ), C.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [
    n,
    t
  ]);
}
function fy(e, t) {
  const n = cm(t);
  LD(() => {
    let r = 0;
    if (e) {
      const a = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return a.observe(e), () => {
        window.cancelAnimationFrame(r), a.unobserve(e);
      };
    }
  }, [
    e,
    n
  ]);
}
const rue = Ule, oue = Hle, YF = Wle, qF = Qle, aue = Jle;
var iue = yn((e, { scrollbarSize: t, offsetScrollbars: n, scrollbarHovered: r, hidden: a }, s) => ({
  root: {
    overflow: "hidden"
  },
  viewport: {
    width: "100%",
    height: "100%",
    paddingRight: n ? t : void 0,
    paddingBottom: n ? t : void 0
  },
  scrollbar: {
    display: a ? "none" : "flex",
    userSelect: "none",
    touchAction: "none",
    boxSizing: "border-box",
    padding: t / 5,
    transition: "background-color 150ms ease, opacity 150ms ease",
    "&:hover": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[0],
      [`& .${s("thumb")}`]: {
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, 0.5) : e.fn.rgba(e.black, 0.5)
      }
    },
    '&[data-orientation="vertical"]': {
      width: t
    },
    '&[data-orientation="horizontal"]': {
      flexDirection: "column",
      height: t
    },
    '&[data-state="hidden"]': {
      display: "none",
      opacity: 0
    }
  },
  thumb: {
    ref: s("thumb"),
    flex: 1,
    backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, 0.4) : e.fn.rgba(e.black, 0.4),
    borderRadius: t,
    position: "relative",
    transition: "background-color 150ms ease",
    display: a ? "none" : void 0,
    overflow: "hidden",
    "&::before": {
      content: '""',
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: "100%",
      height: "100%",
      minWidth: 44,
      minHeight: 44
    }
  },
  corner: {
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
    transition: "opacity 150ms ease",
    opacity: r ? 1 : 0,
    display: a ? "none" : void 0
  }
}));
const sue = iue;
var lue = Object.defineProperty, uue = Object.defineProperties, cue = Object.getOwnPropertyDescriptors, DE = Object.getOwnPropertySymbols, c6 = Object.prototype.hasOwnProperty, d6 = Object.prototype.propertyIsEnumerable, GF = (e, t, n) => t in e ? lue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, zD = (e, t) => {
  for (var n in t || (t = {}))
    c6.call(t, n) && GF(e, n, t[n]);
  if (DE)
    for (var n of DE(t))
      d6.call(t, n) && GF(e, n, t[n]);
  return e;
}, f6 = (e, t) => uue(e, cue(t)), p6 = (e, t) => {
  var n = {};
  for (var r in e)
    c6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && DE)
    for (var r of DE(e))
      t.indexOf(r) < 0 && d6.call(e, r) && (n[r] = e[r]);
  return n;
};
const m6 = {
  scrollbarSize: 12,
  scrollHideDelay: 1e3,
  type: "hover",
  offsetScrollbars: !1
}, LT = C.forwardRef((e, t) => {
  const n = vn("ScrollArea", m6, e), {
    children: r,
    className: a,
    classNames: s,
    styles: l,
    scrollbarSize: p,
    scrollHideDelay: m,
    type: h,
    dir: g,
    offsetScrollbars: b,
    viewportRef: x,
    onScrollPositionChange: E,
    unstyled: O,
    viewportProps: _
  } = n, P = p6(n, [
    "children",
    "className",
    "classNames",
    "styles",
    "scrollbarSize",
    "scrollHideDelay",
    "type",
    "dir",
    "offsetScrollbars",
    "viewportRef",
    "onScrollPositionChange",
    "unstyled",
    "viewportProps"
  ]), [M, D] = C.useState(!1), N = Da(), { classes: I, cx: R } = sue({ scrollbarSize: p, offsetScrollbars: b, scrollbarHovered: M, hidden: h === "never" }, { name: "ScrollArea", classNames: s, styles: l, unstyled: O });
  return /* @__PURE__ */ le.createElement(rue, {
    type: h === "never" ? "always" : h,
    scrollHideDelay: m,
    dir: g || N.dir,
    ref: t,
    asChild: !0
  }, /* @__PURE__ */ le.createElement(hn, zD({
    className: R(I.root, a)
  }, P), /* @__PURE__ */ le.createElement(oue, f6(zD({}, _), {
    className: I.viewport,
    ref: x,
    onScroll: typeof E == "function" ? ({ currentTarget: j }) => E({
      x: j.scrollLeft,
      y: j.scrollTop
    }) : void 0
  }), r), /* @__PURE__ */ le.createElement(YF, {
    orientation: "horizontal",
    className: I.scrollbar,
    forceMount: !0,
    onMouseEnter: () => D(!0),
    onMouseLeave: () => D(!1)
  }, /* @__PURE__ */ le.createElement(qF, {
    className: I.thumb
  })), /* @__PURE__ */ le.createElement(YF, {
    orientation: "vertical",
    className: I.scrollbar,
    forceMount: !0,
    onMouseEnter: () => D(!0),
    onMouseLeave: () => D(!1)
  }, /* @__PURE__ */ le.createElement(qF, {
    className: I.thumb
  })), /* @__PURE__ */ le.createElement(aue, {
    className: I.corner
  })));
}), h6 = C.forwardRef((e, t) => {
  const n = vn("ScrollAreaAutosize", m6, e), {
    maxHeight: r,
    children: a,
    classNames: s,
    styles: l,
    scrollbarSize: p,
    scrollHideDelay: m,
    type: h,
    dir: g,
    offsetScrollbars: b,
    viewportRef: x,
    onScrollPositionChange: E,
    unstyled: O,
    sx: _
  } = n, P = p6(n, [
    "maxHeight",
    "children",
    "classNames",
    "styles",
    "scrollbarSize",
    "scrollHideDelay",
    "type",
    "dir",
    "offsetScrollbars",
    "viewportRef",
    "onScrollPositionChange",
    "unstyled",
    "sx"
  ]);
  return /* @__PURE__ */ le.createElement(hn, f6(zD({}, P), {
    ref: t,
    sx: [{ display: "flex", maxHeight: r }, ...B0(_)]
  }), /* @__PURE__ */ le.createElement(hn, {
    sx: { display: "flex", flexDirection: "column", flex: 1 }
  }, /* @__PURE__ */ le.createElement(LT, {
    classNames: s,
    styles: l,
    scrollHideDelay: m,
    scrollbarSize: p,
    type: h,
    dir: g,
    offsetScrollbars: b,
    viewportRef: x,
    onScrollPositionChange: E,
    unstyled: O
  }, a)));
});
h6.displayName = "@mantine/core/ScrollAreaAutosize";
LT.displayName = "@mantine/core/ScrollArea";
LT.Autosize = h6;
const due = LT;
var fue = Object.defineProperty, pue = Object.defineProperties, mue = Object.getOwnPropertyDescriptors, $E = Object.getOwnPropertySymbols, v6 = Object.prototype.hasOwnProperty, y6 = Object.prototype.propertyIsEnumerable, KF = (e, t, n) => t in e ? fue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, XF = (e, t) => {
  for (var n in t || (t = {}))
    v6.call(t, n) && KF(e, n, t[n]);
  if ($E)
    for (var n of $E(t))
      y6.call(t, n) && KF(e, n, t[n]);
  return e;
}, hue = (e, t) => pue(e, mue(t)), vue = (e, t) => {
  var n = {};
  for (var r in e)
    v6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && $E)
    for (var r of $E(e))
      t.indexOf(r) < 0 && y6.call(e, r) && (n[r] = e[r]);
  return n;
};
const FT = C.forwardRef((e, t) => {
  var n = e, { style: r } = n, a = vue(n, ["style"]);
  return /* @__PURE__ */ le.createElement(due, hue(XF({}, a), {
    style: XF({ width: "100%" }, r),
    viewportRef: t
  }), a.children);
});
FT.displayName = "@mantine/core/SelectScrollArea";
var yue = yn(() => ({
  dropdown: {},
  itemsWrapper: {
    padding: 4,
    display: "flex",
    width: "100%",
    boxSizing: "border-box"
  }
}));
const gue = yue;
function Ry(e) {
  return e.split("-")[1];
}
function aM(e) {
  return e === "y" ? "height" : "width";
}
function Hl(e) {
  return e.split("-")[0];
}
function Yf(e) {
  return ["top", "bottom"].includes(Hl(e)) ? "x" : "y";
}
function QF(e, t, n) {
  let { reference: r, floating: a } = e;
  const s = r.x + r.width / 2 - a.width / 2, l = r.y + r.height / 2 - a.height / 2, p = Yf(t), m = aM(p), h = r[m] / 2 - a[m] / 2, g = p === "x";
  let b;
  switch (Hl(t)) {
    case "top":
      b = { x: s, y: r.y - a.height };
      break;
    case "bottom":
      b = { x: s, y: r.y + r.height };
      break;
    case "right":
      b = { x: r.x + r.width, y: l };
      break;
    case "left":
      b = { x: r.x - a.width, y: l };
      break;
    default:
      b = { x: r.x, y: r.y };
  }
  switch (Ry(t)) {
    case "start":
      b[p] -= h * (n && g ? -1 : 1);
      break;
    case "end":
      b[p] += h * (n && g ? -1 : 1);
  }
  return b;
}
const bue = async (e, t, n) => {
  const { placement: r = "bottom", strategy: a = "absolute", middleware: s = [], platform: l } = n, p = s.filter(Boolean), m = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let h = await l.getElementRects({ reference: e, floating: t, strategy: a }), { x: g, y: b } = QF(h, r, m), x = r, E = {}, O = 0;
  for (let _ = 0; _ < p.length; _++) {
    const { name: P, fn: M } = p[_], { x: D, y: N, data: I, reset: R } = await M({ x: g, y: b, initialPlacement: r, placement: x, strategy: a, middlewareData: E, rects: h, platform: l, elements: { reference: e, floating: t } });
    g = D ?? g, b = N ?? b, E = { ...E, [P]: { ...E[P], ...I } }, R && O <= 50 && (O++, typeof R == "object" && (R.placement && (x = R.placement), R.rects && (h = R.rects === !0 ? await l.getElementRects({ reference: e, floating: t, strategy: a }) : R.rects), { x: g, y: b } = QF(h, x, m)), _ = -1);
  }
  return { x: g, y: b, placement: x, strategy: a, middlewareData: E };
};
function ad(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function iM(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function py(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function sM(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: a, platform: s, rects: l, elements: p, strategy: m } = e, { boundary: h = "clippingAncestors", rootBoundary: g = "viewport", elementContext: b = "floating", altBoundary: x = !1, padding: E = 0 } = ad(t, e), O = iM(E), _ = p[x ? b === "floating" ? "reference" : "floating" : b], P = py(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(_))) == null || n ? _ : _.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(p.floating)), boundary: h, rootBoundary: g, strategy: m })), M = b === "floating" ? { ...l.floating, x: r, y: a } : l.reference, D = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(p.floating)), N = await (s.isElement == null ? void 0 : s.isElement(D)) && await (s.getScale == null ? void 0 : s.getScale(D)) || { x: 1, y: 1 }, I = py(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: M, offsetParent: D, strategy: m }) : M);
  return { top: (P.top - I.top + O.top) / N.y, bottom: (I.bottom - P.bottom + O.bottom) / N.y, left: (P.left - I.left + O.left) / N.x, right: (I.right - P.right + O.right) / N.x };
}
const Lf = Math.min, zu = Math.max;
function VD(e, t, n) {
  return zu(e, Lf(t, n));
}
const ZF = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { x: n, y: r, placement: a, rects: s, platform: l, elements: p } = t, { element: m, padding: h = 0 } = ad(e, t) || {};
  if (m == null)
    return {};
  const g = iM(h), b = { x: n, y: r }, x = Yf(a), E = aM(x), O = await l.getDimensions(m), _ = x === "y", P = _ ? "top" : "left", M = _ ? "bottom" : "right", D = _ ? "clientHeight" : "clientWidth", N = s.reference[E] + s.reference[x] - b[x] - s.floating[E], I = b[x] - s.reference[x], R = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(m));
  let j = R ? R[D] : 0;
  j && await (l.isElement == null ? void 0 : l.isElement(R)) || (j = p.floating[D] || s.floating[E]);
  const U = N / 2 - I / 2, q = j / 2 - O[E] / 2 - 1, J = Lf(g[P], q), H = Lf(g[M], q), Z = J, re = j - O[E] - H, Y = j / 2 - O[E] / 2 + U, K = VD(Z, Y, re), Q = Ry(a) != null && Y != K && s.reference[E] / 2 - (Y < Z ? J : H) - O[E] / 2 < 0;
  return { [x]: b[x] - (Q ? Y < Z ? Z - Y : re - Y : 0), data: { [x]: K, centerOffset: Y - K } };
} }), wue = ["top", "right", "bottom", "left"];
wue.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const xue = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ME(e) {
  return e.replace(/left|right|bottom|top/g, (t) => xue[t]);
}
function Sue(e, t, n) {
  n === void 0 && (n = !1);
  const r = Ry(e), a = Yf(e), s = aM(a);
  let l = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = ME(l)), { main: l, cross: ME(l) };
}
const Eue = { start: "end", end: "start" };
function yk(e) {
  return e.replace(/start|end/g, (t) => Eue[t]);
}
const g6 = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: r, middlewareData: a, rects: s, initialPlacement: l, platform: p, elements: m } = t, { mainAxis: h = !0, crossAxis: g = !0, fallbackPlacements: b, fallbackStrategy: x = "bestFit", fallbackAxisSideDirection: E = "none", flipAlignment: O = !0, ..._ } = ad(e, t), P = Hl(r), M = Hl(l) === l, D = await (p.isRTL == null ? void 0 : p.isRTL(m.floating)), N = b || (M || !O ? [ME(l)] : function(Z) {
      const re = ME(Z);
      return [yk(Z), re, yk(re)];
    }(l));
    b || E === "none" || N.push(...function(Z, re, Y, K) {
      const Q = Ry(Z);
      let te = function(ne, ae, se) {
        const V = ["left", "right"], ee = ["right", "left"], he = ["top", "bottom"], ue = ["bottom", "top"];
        switch (ne) {
          case "top":
          case "bottom":
            return se ? ae ? ee : V : ae ? V : ee;
          case "left":
          case "right":
            return ae ? he : ue;
          default:
            return [];
        }
      }(Hl(Z), Y === "start", K);
      return Q && (te = te.map((ne) => ne + "-" + Q), re && (te = te.concat(te.map(yk)))), te;
    }(l, O, E, D));
    const I = [l, ...N], R = await sM(t, _), j = [];
    let U = ((n = a.flip) == null ? void 0 : n.overflows) || [];
    if (h && j.push(R[P]), g) {
      const { main: Z, cross: re } = Sue(r, s, D);
      j.push(R[Z], R[re]);
    }
    if (U = [...U, { placement: r, overflows: j }], !j.every((Z) => Z <= 0)) {
      var q, J;
      const Z = (((q = a.flip) == null ? void 0 : q.index) || 0) + 1, re = I[Z];
      if (re)
        return { data: { index: Z, overflows: U }, reset: { placement: re } };
      let Y = (J = U.filter((K) => K.overflows[0] <= 0).sort((K, Q) => K.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : J.placement;
      if (!Y)
        switch (x) {
          case "bestFit": {
            var H;
            const K = (H = U.map((Q) => [Q.placement, Q.overflows.filter((te) => te > 0).reduce((te, ne) => te + ne, 0)]).sort((Q, te) => Q[1] - te[1])[0]) == null ? void 0 : H[0];
            K && (Y = K);
            break;
          }
          case "initialPlacement":
            Y = l;
        }
      if (r !== Y)
        return { reset: { placement: Y } };
    }
    return {};
  } };
};
function JF(e) {
  const t = Lf(...e.map((r) => r.left)), n = Lf(...e.map((r) => r.top));
  return { x: t, y: n, width: zu(...e.map((r) => r.right)) - t, height: zu(...e.map((r) => r.bottom)) - n };
}
const b6 = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: n, elements: r, rects: a, platform: s, strategy: l } = t, { padding: p = 2, x: m, y: h } = ad(e, t), g = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(r.reference)) || []), b = function(_) {
      const P = _.slice().sort((N, I) => N.y - I.y), M = [];
      let D = null;
      for (let N = 0; N < P.length; N++) {
        const I = P[N];
        !D || I.y - D.y > D.height / 2 ? M.push([I]) : M[M.length - 1].push(I), D = I;
      }
      return M.map((N) => py(JF(N)));
    }(g), x = py(JF(g)), E = iM(p), O = await s.getElementRects({ reference: { getBoundingClientRect: function() {
      if (b.length === 2 && b[0].left > b[1].right && m != null && h != null)
        return b.find((_) => m > _.left - E.left && m < _.right + E.right && h > _.top - E.top && h < _.bottom + E.bottom) || x;
      if (b.length >= 2) {
        if (Yf(n) === "x") {
          const R = b[0], j = b[b.length - 1], U = Hl(n) === "top", q = R.top, J = j.bottom, H = U ? R.left : j.left, Z = U ? R.right : j.right;
          return { top: q, bottom: J, left: H, right: Z, width: Z - H, height: J - q, x: H, y: q };
        }
        const _ = Hl(n) === "left", P = zu(...b.map((R) => R.right)), M = Lf(...b.map((R) => R.left)), D = b.filter((R) => _ ? R.left === M : R.right === P), N = D[0].top, I = D[D.length - 1].bottom;
        return { top: N, bottom: I, left: M, right: P, width: P - M, height: I - N, x: M, y: N };
      }
      return x;
    } }, floating: r.floating, strategy: l });
    return a.reference.x !== O.reference.x || a.reference.y !== O.reference.y || a.reference.width !== O.reference.width || a.reference.height !== O.reference.height ? { reset: { rects: O } } : {};
  } };
}, w6 = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: r } = t, a = await async function(s, l) {
      const { placement: p, platform: m, elements: h } = s, g = await (m.isRTL == null ? void 0 : m.isRTL(h.floating)), b = Hl(p), x = Ry(p), E = Yf(p) === "x", O = ["left", "top"].includes(b) ? -1 : 1, _ = g && E ? -1 : 1, P = ad(l, s);
      let { mainAxis: M, crossAxis: D, alignmentAxis: N } = typeof P == "number" ? { mainAxis: P, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...P };
      return x && typeof N == "number" && (D = x === "end" ? -1 * N : N), E ? { x: D * _, y: M * O } : { x: M * O, y: D * _ };
    }(t, e);
    return { x: n + a.x, y: r + a.y, data: a };
  } };
};
function x6(e) {
  return e === "x" ? "y" : "x";
}
const lM = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: r, placement: a } = t, { mainAxis: s = !0, crossAxis: l = !1, limiter: p = { fn: (P) => {
      let { x: M, y: D } = P;
      return { x: M, y: D };
    } }, ...m } = ad(e, t), h = { x: n, y: r }, g = await sM(t, m), b = Yf(Hl(a)), x = x6(b);
    let E = h[b], O = h[x];
    if (s) {
      const P = b === "y" ? "bottom" : "right";
      E = VD(E + g[b === "y" ? "top" : "left"], E, E - g[P]);
    }
    if (l) {
      const P = x === "y" ? "bottom" : "right";
      O = VD(O + g[x === "y" ? "top" : "left"], O, O - g[P]);
    }
    const _ = p.fn({ ...t, [b]: E, [x]: O });
    return { ..._, data: { x: _.x - n, y: _.y - r } };
  } };
}, Cue = function(e) {
  return e === void 0 && (e = {}), { options: e, fn(t) {
    const { x: n, y: r, placement: a, rects: s, middlewareData: l } = t, { offset: p = 0, mainAxis: m = !0, crossAxis: h = !0 } = ad(e, t), g = { x: n, y: r }, b = Yf(a), x = x6(b);
    let E = g[b], O = g[x];
    const _ = ad(p, t), P = typeof _ == "number" ? { mainAxis: _, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ..._ };
    if (m) {
      const N = b === "y" ? "height" : "width", I = s.reference[b] - s.floating[N] + P.mainAxis, R = s.reference[b] + s.reference[N] - P.mainAxis;
      E < I ? E = I : E > R && (E = R);
    }
    if (h) {
      var M, D;
      const N = b === "y" ? "width" : "height", I = ["top", "left"].includes(Hl(a)), R = s.reference[x] - s.floating[N] + (I && ((M = l.offset) == null ? void 0 : M[x]) || 0) + (I ? 0 : P.crossAxis), j = s.reference[x] + s.reference[N] + (I ? 0 : ((D = l.offset) == null ? void 0 : D[x]) || 0) - (I ? P.crossAxis : 0);
      O < R ? O = R : O > j && (O = j);
    }
    return { [b]: E, [x]: O };
  } };
}, Tue = function(e) {
  return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) {
    const { placement: n, rects: r, platform: a, elements: s } = t, { apply: l = () => {
    }, ...p } = ad(e, t), m = await sM(t, p), h = Hl(n), g = Ry(n), b = Yf(n) === "x", { width: x, height: E } = r.floating;
    let O, _;
    h === "top" || h === "bottom" ? (O = h, _ = g === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (_ = h, O = g === "end" ? "top" : "bottom");
    const P = E - m[O], M = x - m[_], D = !t.middlewareData.shift;
    let N = P, I = M;
    if (b) {
      const j = x - m.left - m.right;
      I = g || D ? Lf(M, j) : j;
    } else {
      const j = E - m.top - m.bottom;
      N = g || D ? Lf(P, j) : j;
    }
    if (D && !g) {
      const j = zu(m.left, 0), U = zu(m.right, 0), q = zu(m.top, 0), J = zu(m.bottom, 0);
      b ? I = x - 2 * (j !== 0 || U !== 0 ? j + U : zu(m.left, m.right)) : N = E - 2 * (q !== 0 || J !== 0 ? q + J : zu(m.top, m.bottom));
    }
    await l({ ...t, availableWidth: I, availableHeight: N });
    const R = await a.getDimensions(s.floating);
    return x !== R.width || E !== R.height ? { reset: { rects: !0 } } : {};
  } };
};
function Qs(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Wl(e) {
  return Qs(e).getComputedStyle(e);
}
function S6(e) {
  return e instanceof Qs(e).Node;
}
function Ff(e) {
  return S6(e) ? (e.nodeName || "").toLowerCase() : "";
}
function ql(e) {
  return e instanceof Qs(e).HTMLElement;
}
function gs(e) {
  return e instanceof Qs(e).Element;
}
function ez(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Qs(e).ShadowRoot || e instanceof ShadowRoot;
}
function W0(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: a } = Wl(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(a);
}
function _ue(e) {
  return ["table", "td", "th"].includes(Ff(e));
}
function UD(e) {
  const t = uM(), n = Wl(e);
  return n.transform !== "none" || n.perspective !== "none" || !t && !!n.backdropFilter && n.backdropFilter !== "none" || !t && !!n.filter && n.filter !== "none" || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function uM() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function zT(e) {
  return ["html", "body", "#document"].includes(Ff(e));
}
const tz = Math.min, P0 = Math.max, NE = Math.round;
function E6(e) {
  const t = Wl(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const a = ql(e), s = a ? e.offsetWidth : n, l = a ? e.offsetHeight : r, p = NE(n) !== s || NE(r) !== l;
  return p && (n = s, r = l), { width: n, height: r, fallback: p };
}
function C6(e) {
  return gs(e) ? e : e.contextElement;
}
const T6 = { x: 1, y: 1 };
function ey(e) {
  const t = C6(e);
  if (!ql(t))
    return T6;
  const n = t.getBoundingClientRect(), { width: r, height: a, fallback: s } = E6(t);
  let l = (s ? NE(n.width) : n.width) / r, p = (s ? NE(n.height) : n.height) / a;
  return l && Number.isFinite(l) || (l = 1), p && Number.isFinite(p) || (p = 1), { x: l, y: p };
}
const nz = { x: 0, y: 0 };
function _6(e, t, n) {
  var r, a;
  if (t === void 0 && (t = !0), !uM())
    return nz;
  const s = e ? Qs(e) : window;
  return !n || t && n !== s ? nz : { x: ((r = s.visualViewport) == null ? void 0 : r.offsetLeft) || 0, y: ((a = s.visualViewport) == null ? void 0 : a.offsetTop) || 0 };
}
function Cm(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), s = C6(e);
  let l = T6;
  t && (r ? gs(r) && (l = ey(r)) : l = ey(e));
  const p = _6(s, n, r);
  let m = (a.left + p.x) / l.x, h = (a.top + p.y) / l.y, g = a.width / l.x, b = a.height / l.y;
  if (s) {
    const x = Qs(s), E = r && gs(r) ? Qs(r) : r;
    let O = x.frameElement;
    for (; O && r && E !== x; ) {
      const _ = ey(O), P = O.getBoundingClientRect(), M = getComputedStyle(O);
      P.x += (O.clientLeft + parseFloat(M.paddingLeft)) * _.x, P.y += (O.clientTop + parseFloat(M.paddingTop)) * _.y, m *= _.x, h *= _.y, g *= _.x, b *= _.y, m += P.x, h += P.y, O = Qs(O).frameElement;
    }
  }
  return py({ width: g, height: b, x: m, y: h });
}
function Mf(e) {
  return ((S6(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function VT(e) {
  return gs(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function O6(e) {
  return Cm(Mf(e)).left + VT(e).scrollLeft;
}
function my(e) {
  if (Ff(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || ez(e) && e.host || Mf(e);
  return ez(t) ? t.host : t;
}
function P6(e) {
  const t = my(e);
  return zT(t) ? t.ownerDocument.body : ql(t) && W0(t) ? t : P6(t);
}
function ed(e, t) {
  var n;
  t === void 0 && (t = []);
  const r = P6(e), a = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Qs(r);
  return a ? t.concat(s, s.visualViewport || [], W0(r) ? r : []) : t.concat(r, ed(r));
}
function rz(e, t, n) {
  let r;
  if (t === "viewport")
    r = function(a, s) {
      const l = Qs(a), p = Mf(a), m = l.visualViewport;
      let h = p.clientWidth, g = p.clientHeight, b = 0, x = 0;
      if (m) {
        h = m.width, g = m.height;
        const E = uM();
        (!E || E && s === "fixed") && (b = m.offsetLeft, x = m.offsetTop);
      }
      return { width: h, height: g, x: b, y: x };
    }(e, n);
  else if (t === "document")
    r = function(a) {
      const s = Mf(a), l = VT(a), p = a.ownerDocument.body, m = P0(s.scrollWidth, s.clientWidth, p.scrollWidth, p.clientWidth), h = P0(s.scrollHeight, s.clientHeight, p.scrollHeight, p.clientHeight);
      let g = -l.scrollLeft + O6(a);
      const b = -l.scrollTop;
      return Wl(p).direction === "rtl" && (g += P0(s.clientWidth, p.clientWidth) - m), { width: m, height: h, x: g, y: b };
    }(Mf(e));
  else if (gs(t))
    r = function(a, s) {
      const l = Cm(a, !0, s === "fixed"), p = l.top + a.clientTop, m = l.left + a.clientLeft, h = ql(a) ? ey(a) : { x: 1, y: 1 };
      return { width: a.clientWidth * h.x, height: a.clientHeight * h.y, x: m * h.x, y: p * h.y };
    }(t, n);
  else {
    const a = _6(e);
    r = { ...t, x: t.x - a.x, y: t.y - a.y };
  }
  return py(r);
}
function R6(e, t) {
  const n = my(e);
  return !(n === t || !gs(n) || zT(n)) && (Wl(n).position === "fixed" || R6(n, t));
}
function oz(e, t) {
  return ql(e) && Wl(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function az(e, t) {
  const n = Qs(e);
  if (!ql(e))
    return n;
  let r = oz(e, t);
  for (; r && _ue(r) && Wl(r).position === "static"; )
    r = oz(r, t);
  return r && (Ff(r) === "html" || Ff(r) === "body" && Wl(r).position === "static" && !UD(r)) ? n : r || function(a) {
    let s = my(a);
    for (; ql(s) && !zT(s); ) {
      if (UD(s))
        return s;
      s = my(s);
    }
    return null;
  }(e) || n;
}
function Oue(e, t, n) {
  const r = ql(t), a = Mf(t), s = n === "fixed", l = Cm(e, !0, s, t);
  let p = { scrollLeft: 0, scrollTop: 0 };
  const m = { x: 0, y: 0 };
  if (r || !r && !s)
    if ((Ff(t) !== "body" || W0(a)) && (p = VT(t)), ql(t)) {
      const h = Cm(t, !0, s, t);
      m.x = h.x + t.clientLeft, m.y = h.y + t.clientTop;
    } else
      a && (m.x = O6(a));
  return { x: l.left + p.scrollLeft - m.x, y: l.top + p.scrollTop - m.y, width: l.width, height: l.height };
}
const Pue = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: a } = e;
  const s = n === "clippingAncestors" ? function(h, g) {
    const b = g.get(h);
    if (b)
      return b;
    let x = ed(h).filter((P) => gs(P) && Ff(P) !== "body"), E = null;
    const O = Wl(h).position === "fixed";
    let _ = O ? my(h) : h;
    for (; gs(_) && !zT(_); ) {
      const P = Wl(_), M = UD(_);
      M || P.position !== "fixed" || (E = null), (O ? !M && !E : !M && P.position === "static" && E && ["absolute", "fixed"].includes(E.position) || W0(_) && !M && R6(h, _)) ? x = x.filter((D) => D !== _) : E = P, _ = my(_);
    }
    return g.set(h, x), x;
  }(t, this._c) : [].concat(n), l = [...s, r], p = l[0], m = l.reduce((h, g) => {
    const b = rz(t, g, a);
    return h.top = P0(b.top, h.top), h.right = tz(b.right, h.right), h.bottom = tz(b.bottom, h.bottom), h.left = P0(b.left, h.left), h;
  }, rz(t, p, a));
  return { width: m.right - m.left, height: m.bottom - m.top, x: m.left, y: m.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: r } = e;
  const a = ql(n), s = Mf(n);
  if (n === s)
    return t;
  let l = { scrollLeft: 0, scrollTop: 0 }, p = { x: 1, y: 1 };
  const m = { x: 0, y: 0 };
  if ((a || !a && r !== "fixed") && ((Ff(n) !== "body" || W0(s)) && (l = VT(n)), ql(n))) {
    const h = Cm(n);
    p = ey(n), m.x = h.x + n.clientLeft, m.y = h.y + n.clientTop;
  }
  return { width: t.width * p.x, height: t.height * p.y, x: t.x * p.x - l.scrollLeft * p.x + m.x, y: t.y * p.y - l.scrollTop * p.y + m.y };
}, isElement: gs, getDimensions: function(e) {
  return E6(e);
}, getOffsetParent: az, getDocumentElement: Mf, getScale: ey, async getElementRects(e) {
  let { reference: t, floating: n, strategy: r } = e;
  const a = this.getOffsetParent || az, s = this.getDimensions;
  return { reference: Oue(t, await a(n), r), floating: { x: 0, y: 0, ...await s(n) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Wl(e).direction === "rtl" };
function Rue(e, t, n, r) {
  r === void 0 && (r = {});
  const { ancestorScroll: a = !0, ancestorResize: s = !0, elementResize: l = !0, animationFrame: p = !1 } = r, m = a || s ? [...gs(e) ? ed(e) : e.contextElement ? ed(e.contextElement) : [], ...ed(t)] : [];
  m.forEach((x) => {
    const E = !gs(x) && x.toString().includes("V");
    !a || p && !E || x.addEventListener("scroll", n, { passive: !0 }), s && x.addEventListener("resize", n);
  });
  let h, g = null;
  l && (g = new ResizeObserver(() => {
    n();
  }), gs(e) && !p && g.observe(e), gs(e) || !e.contextElement || p || g.observe(e.contextElement), g.observe(t));
  let b = p ? Cm(e) : null;
  return p && function x() {
    const E = Cm(e);
    !b || E.x === b.x && E.y === b.y && E.width === b.width && E.height === b.height || n(), b = E, h = requestAnimationFrame(x);
  }(), n(), () => {
    var x;
    m.forEach((E) => {
      a && E.removeEventListener("scroll", n), s && E.removeEventListener("resize", n);
    }), (x = g) == null || x.disconnect(), g = null, p && cancelAnimationFrame(h);
  };
}
const kue = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), a = { platform: Pue, ...n }, s = { ...a.platform, _c: r };
  return bue(e, t, { ...a, platform: s });
}, k6 = (e) => {
  const {
    element: t,
    padding: n
  } = e;
  function r(a) {
    return Object.prototype.hasOwnProperty.call(a, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(a) {
      return r(t) ? t.current != null ? ZF({
        element: t.current,
        padding: n
      }).fn(a) : {} : t ? ZF({
        element: t,
        padding: n
      }).fn(a) : {};
    }
  };
};
var J1 = typeof document < "u" ? C.useLayoutEffect : C.useEffect;
function IE(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!IE(e[r], t[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && e.$$typeof) && !IE(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function iz(e) {
  const t = C.useRef(e);
  return J1(() => {
    t.current = e;
  }), t;
}
function Due(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    whileElementsMounted: s,
    open: l
  } = e, [p, m] = C.useState({
    x: null,
    y: null,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, g] = C.useState(r);
  IE(h, r) || g(r);
  const b = C.useRef(null), x = C.useRef(null), E = C.useRef(p), O = iz(s), _ = iz(a), [P, M] = C.useState(null), [D, N] = C.useState(null), I = C.useCallback((H) => {
    b.current !== H && (b.current = H, M(H));
  }, []), R = C.useCallback((H) => {
    x.current !== H && (x.current = H, N(H));
  }, []), j = C.useCallback(() => {
    if (!b.current || !x.current)
      return;
    const H = {
      placement: t,
      strategy: n,
      middleware: h
    };
    _.current && (H.platform = _.current), kue(b.current, x.current, H).then((Z) => {
      const re = {
        ...Z,
        isPositioned: !0
      };
      U.current && !IE(E.current, re) && (E.current = re, Py.flushSync(() => {
        m(re);
      }));
    });
  }, [h, t, n, _]);
  J1(() => {
    l === !1 && E.current.isPositioned && (E.current.isPositioned = !1, m((H) => ({
      ...H,
      isPositioned: !1
    })));
  }, [l]);
  const U = C.useRef(!1);
  J1(() => (U.current = !0, () => {
    U.current = !1;
  }), []), J1(() => {
    if (P && D) {
      if (O.current)
        return O.current(P, D, j);
      j();
    }
  }, [P, D, j, O]);
  const q = C.useMemo(() => ({
    reference: b,
    floating: x,
    setReference: I,
    setFloating: R
  }), [I, R]), J = C.useMemo(() => ({
    reference: P,
    floating: D
  }), [P, D]);
  return C.useMemo(() => ({
    ...p,
    update: j,
    refs: q,
    elements: J,
    reference: I,
    floating: R
  }), [p, j, q, J, I, R]);
}
var hy = typeof document < "u" ? C.useLayoutEffect : C.useEffect;
let gk = !1, $ue = 0;
const sz = () => "floating-ui-" + $ue++;
function Mue() {
  const [e, t] = C.useState(() => gk ? sz() : void 0);
  return hy(() => {
    e == null && t(sz());
  }, []), C.useEffect(() => {
    gk || (gk = !0);
  }, []), e;
}
const Nue = iy[/* @__PURE__ */ "useId".toString()], lz = Nue || Mue;
function Iue() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((a) => a(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      e.set(t, (e.get(t) || []).filter((r) => r !== n));
    }
  };
}
const Aue = /* @__PURE__ */ C.createContext(null), jue = /* @__PURE__ */ C.createContext(null), D6 = () => {
  var e;
  return ((e = C.useContext(Aue)) == null ? void 0 : e.id) || null;
}, cM = () => C.useContext(jue);
function Rf(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Lue() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function Fue() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function dM(e) {
  return Rf(e).defaultView || window;
}
function qu(e) {
  return e ? e instanceof dM(e).Element : !1;
}
function $6(e) {
  return e ? e instanceof dM(e).HTMLElement : !1;
}
function zue(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  const t = dM(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function Vue(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(Lue()) || t.test(Fue())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function Uue(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function M6(e, t) {
  const n = ["mouse", "pen"];
  return t || n.push("", void 0), n.includes(e);
}
function uz(e) {
  const t = C.useRef(e);
  return hy(() => {
    t.current = e;
  }), t;
}
const cz = "data-floating-ui-safe-polygon";
function eE(e, t, n) {
  return n && !M6(n) ? 0 : typeof e == "number" ? e : e == null ? void 0 : e[t];
}
const Bue = function(e, t) {
  let {
    enabled: n = !0,
    delay: r = 0,
    handleClose: a = null,
    mouseOnly: s = !1,
    restMs: l = 0,
    move: p = !0
  } = t === void 0 ? {} : t;
  const {
    open: m,
    onOpenChange: h,
    dataRef: g,
    events: b,
    elements: {
      domReference: x,
      floating: E
    },
    refs: O
  } = e, _ = cM(), P = D6(), M = uz(a), D = uz(r), N = C.useRef(), I = C.useRef(), R = C.useRef(), j = C.useRef(), U = C.useRef(!0), q = C.useRef(!1), J = C.useRef(() => {
  }), H = C.useCallback(() => {
    var K;
    const Q = (K = g.current.openEvent) == null ? void 0 : K.type;
    return (Q == null ? void 0 : Q.includes("mouse")) && Q !== "mousedown";
  }, [g]);
  C.useEffect(() => {
    if (!n)
      return;
    function K() {
      clearTimeout(I.current), clearTimeout(j.current), U.current = !0;
    }
    return b.on("dismiss", K), () => {
      b.off("dismiss", K);
    };
  }, [n, b]), C.useEffect(() => {
    if (!n || !M.current || !m)
      return;
    function K() {
      H() && h(!1);
    }
    const Q = Rf(E).documentElement;
    return Q.addEventListener("mouseleave", K), () => {
      Q.removeEventListener("mouseleave", K);
    };
  }, [E, m, h, n, M, g, H]);
  const Z = C.useCallback(function(K) {
    K === void 0 && (K = !0);
    const Q = eE(D.current, "close", N.current);
    Q && !R.current ? (clearTimeout(I.current), I.current = setTimeout(() => h(!1), Q)) : K && (clearTimeout(I.current), h(!1));
  }, [D, h]), re = C.useCallback(() => {
    J.current(), R.current = void 0;
  }, []), Y = C.useCallback(() => {
    if (q.current) {
      const K = Rf(O.floating.current).body;
      K.style.pointerEvents = "", K.removeAttribute(cz), q.current = !1;
    }
  }, [O]);
  return C.useEffect(() => {
    if (!n)
      return;
    function K() {
      return g.current.openEvent ? ["click", "mousedown"].includes(g.current.openEvent.type) : !1;
    }
    function Q(ae) {
      if (clearTimeout(I.current), U.current = !1, s && !M6(N.current) || l > 0 && eE(D.current, "open") === 0)
        return;
      g.current.openEvent = ae;
      const se = eE(D.current, "open", N.current);
      se ? I.current = setTimeout(() => {
        h(!0);
      }, se) : h(!0);
    }
    function te(ae) {
      if (K())
        return;
      J.current();
      const se = Rf(E);
      if (clearTimeout(j.current), M.current) {
        m || clearTimeout(I.current), R.current = M.current({
          ...e,
          tree: _,
          x: ae.clientX,
          y: ae.clientY,
          onClose() {
            Y(), re(), Z();
          }
        });
        const V = R.current;
        se.addEventListener("mousemove", V), J.current = () => {
          se.removeEventListener("mousemove", V);
        };
        return;
      }
      Z();
    }
    function ne(ae) {
      K() || M.current == null || M.current({
        ...e,
        tree: _,
        x: ae.clientX,
        y: ae.clientY,
        onClose() {
          Y(), re(), Z();
        }
      })(ae);
    }
    if (qu(x)) {
      const ae = x;
      return m && ae.addEventListener("mouseleave", ne), E == null || E.addEventListener("mouseleave", ne), p && ae.addEventListener("mousemove", Q, {
        once: !0
      }), ae.addEventListener("mouseenter", Q), ae.addEventListener("mouseleave", te), () => {
        m && ae.removeEventListener("mouseleave", ne), E == null || E.removeEventListener("mouseleave", ne), p && ae.removeEventListener("mousemove", Q), ae.removeEventListener("mouseenter", Q), ae.removeEventListener("mouseleave", te);
      };
    }
  }, [x, E, n, e, s, l, p, Z, re, Y, h, m, _, D, M, g]), hy(() => {
    var K;
    if (n && m && (K = M.current) != null && K.__options.blockPointerEvents && H()) {
      const ne = Rf(E).body;
      if (ne.setAttribute(cz, ""), ne.style.pointerEvents = "none", q.current = !0, qu(x) && E) {
        var Q, te;
        const ae = x, se = _ == null || (Q = _.nodesRef.current.find((V) => V.id === P)) == null || (te = Q.context) == null ? void 0 : te.elements.floating;
        return se && (se.style.pointerEvents = ""), ae.style.pointerEvents = "auto", E.style.pointerEvents = "auto", () => {
          ae.style.pointerEvents = "", E.style.pointerEvents = "";
        };
      }
    }
  }, [n, m, P, E, x, _, M, g, H]), hy(() => {
    m || (N.current = void 0, re(), Y());
  }, [m, re, Y]), C.useEffect(() => () => {
    re(), clearTimeout(I.current), clearTimeout(j.current), Y();
  }, [n, re, Y]), C.useMemo(() => {
    if (!n)
      return {};
    function K(Q) {
      N.current = Q.pointerType;
    }
    return {
      reference: {
        onPointerDown: K,
        onPointerEnter: K,
        onMouseMove() {
          m || l === 0 || (clearTimeout(j.current), j.current = setTimeout(() => {
            U.current || h(!0);
          }, l));
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(I.current);
        },
        onMouseLeave() {
          b.emit("dismiss", {
            type: "mouseLeave",
            data: {
              returnFocus: !1
            }
          }), Z(!1);
        }
      }
    };
  }, [b, n, l, m, h, Z]);
}, N6 = /* @__PURE__ */ C.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  },
  isInstantPhase: !1
}), I6 = () => C.useContext(N6), Hue = (e) => {
  let {
    children: t,
    delay: n,
    timeoutMs: r = 0
  } = e;
  const [a, s] = C.useReducer((m, h) => ({
    ...m,
    ...h
  }), {
    delay: n,
    timeoutMs: r,
    initialDelay: n,
    currentId: null,
    isInstantPhase: !1
  }), l = C.useRef(null), p = C.useCallback((m) => {
    s({
      currentId: m
    });
  }, []);
  return hy(() => {
    a.currentId ? l.current === null ? l.current = a.currentId : s({
      isInstantPhase: !0
    }) : (s({
      isInstantPhase: !1
    }), l.current = null);
  }, [a.currentId]), /* @__PURE__ */ C.createElement(N6.Provider, {
    value: C.useMemo(() => ({
      ...a,
      setState: s,
      setCurrentId: p
    }), [a, s, p])
  }, t);
}, Wue = (e, t) => {
  let {
    open: n,
    onOpenChange: r
  } = e, {
    id: a
  } = t;
  const {
    currentId: s,
    setCurrentId: l,
    initialDelay: p,
    setState: m,
    timeoutMs: h
  } = I6();
  C.useEffect(() => {
    s && (m({
      delay: {
        open: 1,
        close: eE(p, "close")
      }
    }), s !== a && r(!1));
  }, [a, r, m, s, p]), C.useEffect(() => {
    function g() {
      r(!1), m({
        delay: p,
        currentId: null
      });
    }
    if (!n && s === a)
      if (h) {
        const b = window.setTimeout(g, h);
        return () => {
          clearTimeout(b);
        };
      } else
        g();
  }, [n, m, s, a, r, p, h]), C.useEffect(() => {
    n && l(a);
  }, [n, l, a]);
};
function Yue(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function dz(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && zue(n)) {
    let r = t;
    do {
      if (r && e === r)
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function bk(e, t) {
  let n = e.filter((a) => {
    var s;
    return a.parentId === t && ((s = a.context) == null ? void 0 : s.open);
  }) || [], r = n;
  for (; r.length; )
    r = e.filter((a) => {
      var s;
      return (s = r) == null ? void 0 : s.some((l) => {
        var p;
        return a.parentId === l.id && ((p = a.context) == null ? void 0 : p.open);
      });
    }) || [], n = n.concat(r);
  return n;
}
function que(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const Gue = iy[/* @__PURE__ */ "useInsertionEffect".toString()], Kue = Gue || ((e) => e());
function A6(e) {
  const t = C.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return Kue(() => {
    t.current = e;
  }), C.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++)
      r[a] = arguments[a];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function tE(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
const Xue = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, Que = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, Zue = function(e) {
  var t, n;
  return e === void 0 && (e = !0), {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e.escapeKey) != null ? t : !0,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e.outsidePress) != null ? n : !0
  };
}, Jue = function(e, t) {
  let {
    open: n,
    onOpenChange: r,
    events: a,
    nodeId: s,
    elements: {
      reference: l,
      domReference: p,
      floating: m
    },
    dataRef: h
  } = e, {
    enabled: g = !0,
    escapeKey: b = !0,
    outsidePress: x = !0,
    outsidePressEvent: E = "pointerdown",
    referencePress: O = !1,
    referencePressEvent: _ = "pointerdown",
    ancestorScroll: P = !1,
    bubbles: M = !0
  } = t === void 0 ? {} : t;
  const D = cM(), N = D6() != null, I = A6(typeof x == "function" ? x : () => !1), R = typeof x == "function" ? I : x, j = C.useRef(!1), {
    escapeKeyBubbles: U,
    outsidePressBubbles: q
  } = Zue(M);
  return C.useEffect(() => {
    if (!n || !g)
      return;
    h.current.__escapeKeyBubbles = U, h.current.__outsidePressBubbles = q;
    function J(K) {
      if (K.key === "Escape") {
        const Q = D ? bk(D.nodesRef.current, s) : [];
        if (Q.length > 0) {
          let te = !0;
          if (Q.forEach((ne) => {
            var ae;
            if ((ae = ne.context) != null && ae.open && !ne.context.dataRef.current.__escapeKeyBubbles) {
              te = !1;
              return;
            }
          }), !te)
            return;
        }
        a.emit("dismiss", {
          type: "escapeKey",
          data: {
            returnFocus: {
              preventScroll: !1
            }
          }
        }), r(!1);
      }
    }
    function H(K) {
      const Q = j.current;
      if (j.current = !1, Q || typeof R == "function" && !R(K))
        return;
      const te = que(K);
      if ($6(te) && m) {
        const se = m.ownerDocument.defaultView || window, V = te.scrollWidth > te.clientWidth, ee = te.scrollHeight > te.clientHeight;
        let he = ee && K.offsetX > te.clientWidth;
        if (ee && se.getComputedStyle(te).direction === "rtl" && (he = K.offsetX <= te.offsetWidth - te.clientWidth), he || V && K.offsetY > te.clientHeight)
          return;
      }
      const ne = D && bk(D.nodesRef.current, s).some((se) => {
        var V;
        return tE(K, (V = se.context) == null ? void 0 : V.elements.floating);
      });
      if (tE(K, m) || tE(K, p) || ne)
        return;
      const ae = D ? bk(D.nodesRef.current, s) : [];
      if (ae.length > 0) {
        let se = !0;
        if (ae.forEach((V) => {
          var ee;
          if ((ee = V.context) != null && ee.open && !V.context.dataRef.current.__outsidePressBubbles) {
            se = !1;
            return;
          }
        }), !se)
          return;
      }
      a.emit("dismiss", {
        type: "outsidePress",
        data: {
          returnFocus: N ? {
            preventScroll: !0
          } : Vue(K) || Uue(K)
        }
      }), r(!1);
    }
    function Z() {
      r(!1);
    }
    const re = Rf(m);
    b && re.addEventListener("keydown", J), R && re.addEventListener(E, H);
    let Y = [];
    return P && (qu(p) && (Y = ed(p)), qu(m) && (Y = Y.concat(ed(m))), !qu(l) && l && l.contextElement && (Y = Y.concat(ed(l.contextElement)))), Y = Y.filter((K) => {
      var Q;
      return K !== ((Q = re.defaultView) == null ? void 0 : Q.visualViewport);
    }), Y.forEach((K) => {
      K.addEventListener("scroll", Z, {
        passive: !0
      });
    }), () => {
      b && re.removeEventListener("keydown", J), R && re.removeEventListener(E, H), Y.forEach((K) => {
        K.removeEventListener("scroll", Z);
      });
    };
  }, [h, m, p, l, b, R, E, a, D, s, n, r, P, g, U, q, N]), C.useEffect(() => {
    j.current = !1;
  }, [R, E]), C.useMemo(() => g ? {
    reference: {
      [Xue[_]]: () => {
        O && (a.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1));
      }
    },
    floating: {
      [Que[E]]: () => {
        j.current = !0;
      }
    }
  } : {}, [g, a, O, E, _, r]);
}, ece = function(e, t) {
  let {
    open: n,
    onOpenChange: r,
    dataRef: a,
    events: s,
    refs: l,
    elements: {
      floating: p,
      domReference: m
    }
  } = e, {
    enabled: h = !0,
    keyboardOnly: g = !0
  } = t === void 0 ? {} : t;
  const b = C.useRef(""), x = C.useRef(!1), E = C.useRef();
  return C.useEffect(() => {
    if (!h)
      return;
    const _ = Rf(p).defaultView || window;
    function P() {
      !n && $6(m) && m === Yue(Rf(m)) && (x.current = !0);
    }
    return _.addEventListener("blur", P), () => {
      _.removeEventListener("blur", P);
    };
  }, [p, m, n, h]), C.useEffect(() => {
    if (!h)
      return;
    function O(_) {
      (_.type === "referencePress" || _.type === "escapeKey") && (x.current = !0);
    }
    return s.on("dismiss", O), () => {
      s.off("dismiss", O);
    };
  }, [s, h]), C.useEffect(() => () => {
    clearTimeout(E.current);
  }, []), C.useMemo(() => h ? {
    reference: {
      onPointerDown(O) {
        let {
          pointerType: _
        } = O;
        b.current = _, x.current = !!(_ && g);
      },
      onMouseLeave() {
        x.current = !1;
      },
      onFocus(O) {
        var _;
        x.current || O.type === "focus" && ((_ = a.current.openEvent) == null ? void 0 : _.type) === "mousedown" && a.current.openEvent && tE(a.current.openEvent, m) || (a.current.openEvent = O.nativeEvent, r(!0));
      },
      onBlur(O) {
        x.current = !1;
        const _ = O.relatedTarget, P = qu(_) && _.hasAttribute("data-floating-ui-focus-guard") && _.getAttribute("data-type") === "outside";
        E.current = setTimeout(() => {
          dz(l.floating.current, _) || dz(m, _) || P || r(!1);
        });
      }
    }
  } : {}, [h, g, m, l, a, r]);
}, tce = function(e, t) {
  let {
    open: n
  } = e, {
    enabled: r = !0,
    role: a = "dialog"
  } = t === void 0 ? {} : t;
  const s = lz(), l = lz();
  return C.useMemo(() => {
    const p = {
      id: s,
      role: a
    };
    return r ? a === "tooltip" ? {
      reference: {
        "aria-describedby": n ? s : void 0
      },
      floating: p
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": a === "alertdialog" ? "dialog" : a,
        "aria-controls": n ? s : void 0,
        ...a === "listbox" && {
          role: "combobox"
        },
        ...a === "menu" && {
          id: l
        }
      },
      floating: {
        ...p,
        ...a === "menu" && {
          "aria-labelledby": l
        }
      }
    } : {};
  }, [r, a, n, s, l]);
};
function fM(e) {
  e === void 0 && (e = {});
  const {
    open: t = !1,
    onOpenChange: n,
    nodeId: r
  } = e, a = Due(e), s = cM(), l = C.useRef(null), p = C.useRef({}), m = C.useState(() => Iue())[0], [h, g] = C.useState(null), b = C.useCallback((M) => {
    const D = qu(M) ? {
      getBoundingClientRect: () => M.getBoundingClientRect(),
      contextElement: M
    } : M;
    a.refs.setReference(D);
  }, [a.refs]), x = C.useCallback((M) => {
    (qu(M) || M === null) && (l.current = M, g(M)), (qu(a.refs.reference.current) || a.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    M !== null && !qu(M)) && a.refs.setReference(M);
  }, [a.refs]), E = C.useMemo(() => ({
    ...a.refs,
    setReference: x,
    setPositionReference: b,
    domReference: l
  }), [a.refs, x, b]), O = C.useMemo(() => ({
    ...a.elements,
    domReference: h
  }), [a.elements, h]), _ = A6(n), P = C.useMemo(() => ({
    ...a,
    refs: E,
    elements: O,
    dataRef: p,
    nodeId: r,
    events: m,
    open: t,
    onOpenChange: _
  }), [a, r, m, t, _, E, O]);
  return hy(() => {
    const M = s == null ? void 0 : s.nodesRef.current.find((D) => D.id === r);
    M && (M.context = P);
  }), C.useMemo(() => ({
    ...a,
    context: P,
    refs: E,
    reference: x,
    positionReference: b
  }), [a, E, P, x, b]);
}
function wk(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((a) => a ? a[n] : null).concat(e).reduce((a, s) => (s && Object.entries(s).forEach((l) => {
      let [p, m] = l;
      if (p.indexOf("on") === 0) {
        if (r.has(p) || r.set(p, []), typeof m == "function") {
          var h;
          (h = r.get(p)) == null || h.push(m), a[p] = function() {
            for (var g, b = arguments.length, x = new Array(b), E = 0; E < b; E++)
              x[E] = arguments[E];
            (g = r.get(p)) == null || g.forEach((O) => O(...x));
          };
        }
      } else
        a[p] = m;
    }), a), {})
  };
}
const nce = function(e) {
  e === void 0 && (e = []);
  const t = e, n = C.useCallback(
    (s) => wk(s, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = C.useCallback(
    (s) => wk(s, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), a = C.useCallback(
    (s) => wk(s, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((s) => s == null ? void 0 : s.item)
  );
  return C.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: a
  }), [n, r, a]);
};
function j6({ opened: e, floating: t, positionDependencies: n }) {
  const [r, a] = C.useState(0);
  C.useEffect(() => {
    if (t.refs.reference.current && t.refs.floating.current)
      return Rue(t.refs.reference.current, t.refs.floating.current, t.update);
  }, [t.refs.reference.current, t.refs.floating.current, e, r]), Xs(() => {
    t.update();
  }, n), Xs(() => {
    a((s) => s + 1);
  }, [e]);
}
function rce(e) {
  const t = [w6(e.offset)];
  return e.middlewares.shift && t.push(lM({ limiter: Cue() })), e.middlewares.flip && t.push(g6()), e.middlewares.inline && t.push(b6()), t.push(k6({ element: e.arrowRef, padding: e.arrowOffset })), t;
}
function oce(e) {
  const [t, n] = Ju({
    value: e.opened,
    defaultValue: e.defaultOpened,
    finalValue: !1,
    onChange: e.onChange
  }), r = () => {
    var l;
    (l = e.onClose) == null || l.call(e), n(!1);
  }, a = () => {
    var l, p;
    t ? ((l = e.onClose) == null || l.call(e), n(!1)) : ((p = e.onOpen) == null || p.call(e), n(!0));
  }, s = fM({
    placement: e.position,
    middleware: [
      ...rce(e),
      ...e.width === "target" ? [
        Tue({
          apply({ rects: l }) {
            var p, m;
            Object.assign((m = (p = s.refs.floating.current) == null ? void 0 : p.style) != null ? m : {}, {
              width: `${l.reference.width}px`
            });
          }
        })
      ] : []
    ]
  });
  return j6({
    opened: e.opened,
    positionDependencies: e.positionDependencies,
    floating: s
  }), Xs(() => {
    var l;
    (l = e.onPositionChange) == null || l.call(e, s.placement);
  }, [s.placement]), {
    floating: s,
    controlled: typeof e.opened == "boolean",
    opened: t,
    onClose: r,
    onToggle: a
  };
}
const L6 = {
  context: "Popover component was not found in the tree",
  children: "Popover.Target component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
}, [ace, F6] = $T(L6.context);
var ice = Object.defineProperty, sce = Object.defineProperties, lce = Object.getOwnPropertyDescriptors, AE = Object.getOwnPropertySymbols, z6 = Object.prototype.hasOwnProperty, V6 = Object.prototype.propertyIsEnumerable, fz = (e, t, n) => t in e ? ice(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, b1 = (e, t) => {
  for (var n in t || (t = {}))
    z6.call(t, n) && fz(e, n, t[n]);
  if (AE)
    for (var n of AE(t))
      V6.call(t, n) && fz(e, n, t[n]);
  return e;
}, uce = (e, t) => sce(e, lce(t)), cce = (e, t) => {
  var n = {};
  for (var r in e)
    z6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && AE)
    for (var r of AE(e))
      t.indexOf(r) < 0 && V6.call(e, r) && (n[r] = e[r]);
  return n;
};
const dce = {
  refProp: "ref",
  popupType: "dialog"
}, U6 = C.forwardRef((e, t) => {
  const n = vn("PopoverTarget", dce, e), { children: r, refProp: a, popupType: s } = n, l = cce(n, ["children", "refProp", "popupType"]);
  if (!uw(r))
    throw new Error(L6.children);
  const p = l, m = F6(), h = Wf(m.reference, r.ref, t), g = m.withRoles ? {
    "aria-haspopup": s,
    "aria-expanded": m.opened,
    "aria-controls": m.getDropdownId(),
    id: m.getTargetId()
  } : {};
  return C.cloneElement(r, b1(uce(b1(b1(b1({}, p), g), m.targetProps), {
    className: t4(m.targetProps.className, p.className, r.props.className),
    [a]: h
  }), m.controlled ? null : { onClick: m.onToggle }));
});
U6.displayName = "@mantine/core/PopoverTarget";
var fce = yn((e, { radius: t, shadow: n }) => ({
  dropdown: {
    position: "absolute",
    backgroundColor: e.white,
    background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`,
    padding: `${e.spacing.sm}px ${e.spacing.md}px`,
    boxShadow: e.shadows[n] || n || "none",
    borderRadius: e.fn.radius(t),
    "&:focus": {
      outline: 0
    }
  },
  arrow: {
    backgroundColor: "inherit",
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`,
    zIndex: 1
  }
}));
const pce = fce;
var mce = Object.defineProperty, pz = Object.getOwnPropertySymbols, hce = Object.prototype.hasOwnProperty, vce = Object.prototype.propertyIsEnumerable, mz = (e, t, n) => t in e ? mce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, kv = (e, t) => {
  for (var n in t || (t = {}))
    hce.call(t, n) && mz(e, n, t[n]);
  if (pz)
    for (var n of pz(t))
      vce.call(t, n) && mz(e, n, t[n]);
  return e;
};
const hz = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function B6({
  transition: e,
  state: t,
  duration: n,
  timingFunction: r
}) {
  const a = {
    transitionDuration: `${n}ms`,
    transitionTimingFunction: r
  };
  return typeof e == "string" ? e in p1 ? kv(kv(kv({
    transitionProperty: p1[e].transitionProperty
  }, a), p1[e].common), p1[e][hz[t]]) : null : kv(kv(kv({
    transitionProperty: e.transitionProperty
  }, a), e.common), e[hz[t]]);
}
function H6({
  duration: e,
  exitDuration: t,
  timingFunction: n,
  mounted: r,
  onEnter: a,
  onExit: s,
  onEntered: l,
  onExited: p
}) {
  const m = Da(), h = v4(), g = m.respectReducedMotion ? h : !1, [b, x] = C.useState(r ? "entered" : "exited");
  let E = g ? 0 : e;
  const O = C.useRef(-1), _ = (P) => {
    const M = P ? a : s, D = P ? l : p;
    if (x(P ? "pre-entering" : "pre-exiting"), window.clearTimeout(O.current), E = g ? 0 : P ? e : t, E === 0)
      typeof M == "function" && M(), typeof D == "function" && D(), x(P ? "entered" : "exited");
    else {
      const N = window.setTimeout(() => {
        typeof M == "function" && M(), x(P ? "entering" : "exiting");
      }, 10);
      O.current = window.setTimeout(() => {
        window.clearTimeout(N), typeof D == "function" && D(), x(P ? "entered" : "exited");
      }, E);
    }
  };
  return Xs(() => {
    _(r);
  }, [r]), C.useEffect(() => () => window.clearTimeout(O.current), []), {
    transitionDuration: E,
    transitionStatus: b,
    transitionTimingFunction: n || m.transitionTimingFunction
  };
}
function UT({
  transition: e,
  duration: t = 250,
  exitDuration: n = t,
  mounted: r,
  children: a,
  timingFunction: s,
  onExit: l,
  onEntered: p,
  onEnter: m,
  onExited: h
}) {
  const { transitionDuration: g, transitionStatus: b, transitionTimingFunction: x } = H6({
    mounted: r,
    exitDuration: n,
    duration: t,
    timingFunction: s,
    onExit: l,
    onEntered: p,
    onEnter: m,
    onExited: h
  });
  return g === 0 ? r ? /* @__PURE__ */ le.createElement(le.Fragment, null, a({})) : null : b === "exited" ? null : /* @__PURE__ */ le.createElement(le.Fragment, null, a(B6({
    transition: e,
    duration: g,
    state: b,
    timingFunction: x
  })));
}
UT.displayName = "@mantine/core/Transition";
function W6({
  children: e,
  active: t = !0,
  refProp: n = "ref"
}) {
  const r = h4(t), a = Wf(r, e == null ? void 0 : e.ref);
  return uw(e) ? C.cloneElement(e, { [n]: a }) : e;
}
W6.displayName = "@mantine/core/FocusTrap";
var yce = Object.defineProperty, gce = Object.defineProperties, bce = Object.getOwnPropertyDescriptors, vz = Object.getOwnPropertySymbols, wce = Object.prototype.hasOwnProperty, xce = Object.prototype.propertyIsEnumerable, yz = (e, t, n) => t in e ? yce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, wf = (e, t) => {
  for (var n in t || (t = {}))
    wce.call(t, n) && yz(e, n, t[n]);
  if (vz)
    for (var n of vz(t))
      xce.call(t, n) && yz(e, n, t[n]);
  return e;
}, w1 = (e, t) => gce(e, bce(t));
function gz(e, t, n, r) {
  return e === "center" || r === "center" ? { top: t } : e === "end" ? { bottom: n } : e === "start" ? { top: n } : {};
}
function bz(e, t, n, r, a) {
  return e === "center" || r === "center" ? { left: t } : e === "end" ? { [a === "ltr" ? "right" : "left"]: n } : e === "start" ? { [a === "ltr" ? "left" : "right"]: n } : {};
}
const Sce = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function Ece({
  position: e,
  withBorder: t,
  arrowSize: n,
  arrowOffset: r,
  arrowRadius: a,
  arrowPosition: s,
  arrowX: l,
  arrowY: p,
  dir: m
}) {
  const [h, g = "center"] = e.split("-"), b = {
    width: n,
    height: n,
    transform: "rotate(45deg)",
    position: "absolute",
    [Sce[h]]: a
  }, x = t ? -n / 2 - 1 : -n / 2;
  return h === "left" ? w1(wf(wf({}, b), gz(g, p, r, s)), {
    right: x,
    borderLeft: 0,
    borderBottom: 0
  }) : h === "right" ? w1(wf(wf({}, b), gz(g, p, r, s)), {
    left: x,
    borderRight: 0,
    borderTop: 0
  }) : h === "top" ? w1(wf(wf({}, b), bz(g, l, r, s, m)), {
    bottom: x,
    borderTop: 0,
    borderLeft: 0
  }) : h === "bottom" ? w1(wf(wf({}, b), bz(g, l, r, s, m)), {
    top: x,
    borderBottom: 0,
    borderRight: 0
  }) : {};
}
var Cce = Object.defineProperty, Tce = Object.defineProperties, _ce = Object.getOwnPropertyDescriptors, jE = Object.getOwnPropertySymbols, Y6 = Object.prototype.hasOwnProperty, q6 = Object.prototype.propertyIsEnumerable, wz = (e, t, n) => t in e ? Cce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Oce = (e, t) => {
  for (var n in t || (t = {}))
    Y6.call(t, n) && wz(e, n, t[n]);
  if (jE)
    for (var n of jE(t))
      q6.call(t, n) && wz(e, n, t[n]);
  return e;
}, Pce = (e, t) => Tce(e, _ce(t)), Rce = (e, t) => {
  var n = {};
  for (var r in e)
    Y6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && jE)
    for (var r of jE(e))
      t.indexOf(r) < 0 && q6.call(e, r) && (n[r] = e[r]);
  return n;
};
const pM = C.forwardRef((e, t) => {
  var n = e, {
    withBorder: r,
    position: a,
    arrowSize: s,
    arrowOffset: l,
    arrowRadius: p,
    arrowPosition: m,
    visible: h,
    arrowX: g,
    arrowY: b
  } = n, x = Rce(n, [
    "withBorder",
    "position",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "visible",
    "arrowX",
    "arrowY"
  ]);
  const E = Da();
  return h ? /* @__PURE__ */ le.createElement("div", Pce(Oce({}, x), {
    ref: t,
    style: Ece({
      withBorder: r,
      position: a,
      arrowSize: s,
      arrowOffset: l,
      arrowRadius: p,
      arrowPosition: m,
      dir: E.dir,
      arrowX: g,
      arrowY: b
    })
  })) : null;
});
pM.displayName = "@mantine/core/FloatingArrow";
var kce = Object.defineProperty, Dce = Object.defineProperties, $ce = Object.getOwnPropertyDescriptors, LE = Object.getOwnPropertySymbols, G6 = Object.prototype.hasOwnProperty, K6 = Object.prototype.propertyIsEnumerable, xz = (e, t, n) => t in e ? kce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, x1 = (e, t) => {
  for (var n in t || (t = {}))
    G6.call(t, n) && xz(e, n, t[n]);
  if (LE)
    for (var n of LE(t))
      K6.call(t, n) && xz(e, n, t[n]);
  return e;
}, Sz = (e, t) => Dce(e, $ce(t)), Mce = (e, t) => {
  var n = {};
  for (var r in e)
    G6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && LE)
    for (var r of LE(e))
      t.indexOf(r) < 0 && K6.call(e, r) && (n[r] = e[r]);
  return n;
};
const Nce = {};
function X6(e) {
  const t = vn("PopoverDropdown", Nce, e), { style: n, className: r, children: a, onKeyDownCapture: s } = t, l = Mce(t, ["style", "className", "children", "onKeyDownCapture"]), p = F6(), { classes: m, cx: h } = pce({ radius: p.radius, shadow: p.shadow }, {
    name: p.__staticSelector,
    classNames: p.classNames,
    styles: p.styles,
    unstyled: p.unstyled
  }), g = d4({
    opened: p.opened,
    shouldReturnFocus: p.returnFocus
  }), b = p.withRoles ? {
    "aria-labelledby": p.getTargetId(),
    id: p.getDropdownId(),
    role: "dialog"
  } : {};
  return p.disabled ? null : /* @__PURE__ */ le.createElement(dw, {
    withinPortal: p.withinPortal
  }, /* @__PURE__ */ le.createElement(UT, {
    mounted: p.opened,
    transition: p.transition,
    duration: p.transitionDuration,
    exitDuration: typeof p.exitTransitionDuration == "number" ? p.exitTransitionDuration : p.transitionDuration
  }, (x) => {
    var E, O;
    return /* @__PURE__ */ le.createElement(W6, {
      active: p.trapFocus
    }, /* @__PURE__ */ le.createElement(hn, x1(Sz(x1({}, b), {
      tabIndex: -1,
      key: p.placement,
      ref: p.floating,
      style: Sz(x1(x1({}, n), x), {
        zIndex: p.zIndex,
        top: (E = p.y) != null ? E : 0,
        left: (O = p.x) != null ? O : 0,
        width: p.width === "target" ? void 0 : p.width
      }),
      className: h(m.dropdown, r),
      onKeyDownCapture: Roe(p.onClose, {
        active: p.closeOnEscape,
        onTrigger: g,
        onKeyDown: s
      }),
      "data-position": p.placement
    }), l), a, /* @__PURE__ */ le.createElement(pM, {
      ref: p.arrowRef,
      arrowX: p.arrowX,
      arrowY: p.arrowY,
      visible: p.withArrow,
      withBorder: !0,
      position: p.placement,
      arrowSize: p.arrowSize,
      arrowRadius: p.arrowRadius,
      arrowOffset: p.arrowOffset,
      arrowPosition: p.arrowPosition,
      className: m.arrow
    })));
  }));
}
X6.displayName = "@mantine/core/PopoverDropdown";
function Q6(e, t) {
  if (e === "rtl" && (t.includes("right") || t.includes("left"))) {
    const [n, r] = t.split("-"), a = n === "right" ? "left" : "right";
    return r === void 0 ? a : `${a}-${r}`;
  }
  return t;
}
var Ez = Object.getOwnPropertySymbols, Ice = Object.prototype.hasOwnProperty, Ace = Object.prototype.propertyIsEnumerable, jce = (e, t) => {
  var n = {};
  for (var r in e)
    Ice.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && Ez)
    for (var r of Ez(e))
      t.indexOf(r) < 0 && Ace.call(e, r) && (n[r] = e[r]);
  return n;
};
const Lce = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transition: "fade",
  transitionDuration: 150,
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !1,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: fd("popover"),
  __staticSelector: "Popover",
  width: "max-content"
};
function Zs(e) {
  var t, n, r, a, s, l;
  const p = C.useRef(null), m = vn("Popover", Lce, e), {
    children: h,
    position: g,
    offset: b,
    onPositionChange: x,
    positionDependencies: E,
    opened: O,
    transition: _,
    transitionDuration: P,
    width: M,
    middlewares: D,
    withArrow: N,
    arrowSize: I,
    arrowOffset: R,
    arrowRadius: j,
    arrowPosition: U,
    unstyled: q,
    classNames: J,
    styles: H,
    closeOnClickOutside: Z,
    withinPortal: re,
    closeOnEscape: Y,
    clickOutsideEvents: K,
    trapFocus: Q,
    onClose: te,
    onOpen: ne,
    onChange: ae,
    zIndex: se,
    radius: V,
    shadow: ee,
    id: he,
    defaultOpened: ue,
    exitTransitionDuration: fe,
    __staticSelector: Ce,
    withRoles: Se,
    disabled: Te,
    returnFocus: pe
  } = m, ye = jce(m, [
    "children",
    "position",
    "offset",
    "onPositionChange",
    "positionDependencies",
    "opened",
    "transition",
    "transitionDuration",
    "width",
    "middlewares",
    "withArrow",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "unstyled",
    "classNames",
    "styles",
    "closeOnClickOutside",
    "withinPortal",
    "closeOnEscape",
    "clickOutsideEvents",
    "trapFocus",
    "onClose",
    "onOpen",
    "onChange",
    "zIndex",
    "radius",
    "shadow",
    "id",
    "defaultOpened",
    "exitTransitionDuration",
    "__staticSelector",
    "withRoles",
    "disabled",
    "returnFocus"
  ]), [Oe, Fe] = C.useState(null), [me, Pe] = C.useState(null), Ee = Hf(he), Ke = Da(), oe = oce({
    middlewares: D,
    width: M,
    position: Q6(Ke.dir, g),
    offset: b + (N ? I / 2 : 0),
    arrowRef: p,
    arrowOffset: R,
    onPositionChange: x,
    positionDependencies: E,
    opened: O,
    defaultOpened: ue,
    onChange: ae,
    onOpen: ne,
    onClose: te
  });
  Kae(() => Z && oe.onClose(), K, [
    Oe,
    me
  ]);
  const de = C.useCallback((Me) => {
    Fe(Me), oe.floating.reference(Me);
  }, [oe.floating.reference]), we = C.useCallback((Me) => {
    Pe(Me), oe.floating.floating(Me);
  }, [oe.floating.floating]);
  return /* @__PURE__ */ le.createElement(ace, {
    value: {
      returnFocus: pe,
      disabled: Te,
      controlled: oe.controlled,
      reference: de,
      floating: we,
      x: oe.floating.x,
      y: oe.floating.y,
      arrowX: (r = (n = (t = oe.floating) == null ? void 0 : t.middlewareData) == null ? void 0 : n.arrow) == null ? void 0 : r.x,
      arrowY: (l = (s = (a = oe.floating) == null ? void 0 : a.middlewareData) == null ? void 0 : s.arrow) == null ? void 0 : l.y,
      opened: oe.opened,
      arrowRef: p,
      transition: _,
      transitionDuration: P,
      exitTransitionDuration: fe,
      width: M,
      withArrow: N,
      arrowSize: I,
      arrowOffset: R,
      arrowRadius: j,
      arrowPosition: U,
      placement: oe.floating.placement,
      trapFocus: Q,
      withinPortal: re,
      zIndex: se,
      radius: V,
      shadow: ee,
      closeOnEscape: Y,
      onClose: oe.onClose,
      onToggle: oe.onToggle,
      getTargetId: () => `${Ee}-target`,
      getDropdownId: () => `${Ee}-dropdown`,
      withRoles: Se,
      targetProps: ye,
      __staticSelector: Ce,
      classNames: J,
      styles: H,
      unstyled: q
    }
  }, h);
}
Zs.Target = U6;
Zs.Dropdown = X6;
Zs.displayName = "@mantine/core/Popover";
var Fce = Object.defineProperty, FE = Object.getOwnPropertySymbols, Z6 = Object.prototype.hasOwnProperty, J6 = Object.prototype.propertyIsEnumerable, Cz = (e, t, n) => t in e ? Fce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, zce = (e, t) => {
  for (var n in t || (t = {}))
    Z6.call(t, n) && Cz(e, n, t[n]);
  if (FE)
    for (var n of FE(t))
      J6.call(t, n) && Cz(e, n, t[n]);
  return e;
}, Vce = (e, t) => {
  var n = {};
  for (var r in e)
    Z6.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && FE)
    for (var r of FE(e))
      t.indexOf(r) < 0 && J6.call(e, r) && (n[r] = e[r]);
  return n;
};
function Uce(e) {
  var t = e, {
    children: n,
    component: r = "div",
    maxHeight: a = 220,
    direction: s = "column",
    id: l,
    innerRef: p,
    __staticSelector: m,
    styles: h,
    classNames: g,
    unstyled: b
  } = t, x = Vce(t, [
    "children",
    "component",
    "maxHeight",
    "direction",
    "id",
    "innerRef",
    "__staticSelector",
    "styles",
    "classNames",
    "unstyled"
  ]);
  const { classes: E } = gue(null, { name: m, styles: h, classNames: g, unstyled: b });
  return /* @__PURE__ */ le.createElement(Zs.Dropdown, zce({
    p: 0,
    onMouseDown: (O) => O.preventDefault()
  }, x), /* @__PURE__ */ le.createElement("div", {
    style: { maxHeight: a, display: "flex" }
  }, /* @__PURE__ */ le.createElement(hn, {
    component: r || "div",
    id: `${l}-items`,
    "aria-labelledby": `${l}-label`,
    role: "listbox",
    onMouseDown: (O) => O.preventDefault(),
    style: { flex: 1, overflowY: r !== FT ? "auto" : void 0 },
    "data-combobox-popover": !0,
    ref: p
  }, /* @__PURE__ */ le.createElement("div", {
    className: E.itemsWrapper,
    style: { flexDirection: s }
  }, n))));
}
function Nf({
  opened: e,
  transition: t = "fade",
  transitionDuration: n = 0,
  shadow: r,
  withinPortal: a,
  children: s,
  __staticSelector: l,
  onDirectionChange: p,
  switchDirectionOnFlip: m,
  zIndex: h,
  dropdownPosition: g,
  positionDependencies: b = [],
  classNames: x,
  styles: E,
  unstyled: O,
  readOnly: _
}) {
  return /* @__PURE__ */ le.createElement(Zs, {
    unstyled: O,
    classNames: x,
    styles: E,
    width: "target",
    withRoles: !1,
    opened: e,
    middlewares: { flip: g === "flip", shift: !1 },
    position: g === "flip" ? "bottom" : g,
    positionDependencies: b,
    zIndex: h,
    __staticSelector: l,
    withinPortal: a,
    transition: t,
    transitionDuration: n,
    shadow: r,
    disabled: _,
    onPositionChange: (P) => m && (p == null ? void 0 : p(P === "top" ? "column-reverse" : "column"))
  }, s);
}
Nf.Target = Zs.Target;
Nf.Dropdown = Uce;
var Bce = Object.defineProperty, Hce = Object.defineProperties, Wce = Object.getOwnPropertyDescriptors, zE = Object.getOwnPropertySymbols, eH = Object.prototype.hasOwnProperty, tH = Object.prototype.propertyIsEnumerable, Tz = (e, t, n) => t in e ? Bce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, S1 = (e, t) => {
  for (var n in t || (t = {}))
    eH.call(t, n) && Tz(e, n, t[n]);
  if (zE)
    for (var n of zE(t))
      tH.call(t, n) && Tz(e, n, t[n]);
  return e;
}, Yce = (e, t) => Hce(e, Wce(t)), qce = (e, t) => {
  var n = {};
  for (var r in e)
    eH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && zE)
    for (var r of zE(e))
      t.indexOf(r) < 0 && tH.call(e, r) && (n[r] = e[r]);
  return n;
};
function nH(e, t, n) {
  const r = vn(e, t, n), {
    label: a,
    description: s,
    error: l,
    required: p,
    classNames: m,
    styles: h,
    className: g,
    unstyled: b,
    __staticSelector: x,
    sx: E,
    errorProps: O,
    labelProps: _,
    descriptionProps: P,
    wrapperProps: M,
    id: D,
    size: N,
    style: I,
    inputContainer: R,
    inputWrapperOrder: j,
    withAsterisk: U
  } = r, q = qce(r, [
    "label",
    "description",
    "error",
    "required",
    "classNames",
    "styles",
    "className",
    "unstyled",
    "__staticSelector",
    "sx",
    "errorProps",
    "labelProps",
    "descriptionProps",
    "wrapperProps",
    "id",
    "size",
    "style",
    "inputContainer",
    "inputWrapperOrder",
    "withAsterisk"
  ]), J = Hf(D), { systemStyles: H, rest: Z } = Oy(q), re = S1({
    label: a,
    description: s,
    error: l,
    required: p,
    classNames: m,
    className: g,
    __staticSelector: x,
    sx: E,
    errorProps: O,
    labelProps: _,
    descriptionProps: P,
    unstyled: b,
    styles: h,
    id: J,
    size: N,
    style: I,
    inputContainer: R,
    inputWrapperOrder: j,
    withAsterisk: U
  }, M);
  return Yce(S1({}, Z), {
    classNames: m,
    styles: h,
    unstyled: b,
    wrapperProps: S1(S1({}, re), H),
    inputProps: {
      required: p,
      classNames: m,
      styles: h,
      unstyled: b,
      id: J,
      size: N,
      __staticSelector: x,
      invalid: !!l
    }
  });
}
var Gce = yn((e, { size: t }) => ({
  label: {
    display: "inline-block",
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    fontWeight: 500,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[9],
    wordBreak: "break-word",
    cursor: "default",
    WebkitTapHighlightColor: "transparent"
  },
  required: {
    color: e.fn.variant({ variant: "filled", color: "red" }).background
  }
}));
const Kce = Gce;
var Xce = Object.defineProperty, VE = Object.getOwnPropertySymbols, rH = Object.prototype.hasOwnProperty, oH = Object.prototype.propertyIsEnumerable, _z = (e, t, n) => t in e ? Xce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Qce = (e, t) => {
  for (var n in t || (t = {}))
    rH.call(t, n) && _z(e, n, t[n]);
  if (VE)
    for (var n of VE(t))
      oH.call(t, n) && _z(e, n, t[n]);
  return e;
}, Zce = (e, t) => {
  var n = {};
  for (var r in e)
    rH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && VE)
    for (var r of VE(e))
      t.indexOf(r) < 0 && oH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Jce = {
  labelElement: "label",
  size: "sm"
}, mM = C.forwardRef((e, t) => {
  const n = vn("InputLabel", Jce, e), {
    labelElement: r,
    children: a,
    required: s,
    size: l,
    classNames: p,
    styles: m,
    unstyled: h,
    className: g,
    htmlFor: b,
    __staticSelector: x
  } = n, E = Zce(n, [
    "labelElement",
    "children",
    "required",
    "size",
    "classNames",
    "styles",
    "unstyled",
    "className",
    "htmlFor",
    "__staticSelector"
  ]), { classes: O, cx: _ } = Kce({ size: l }, { name: ["InputWrapper", x], classNames: p, styles: m, unstyled: h });
  return /* @__PURE__ */ le.createElement(hn, Qce({
    component: r,
    ref: t,
    className: _(O.label, g),
    htmlFor: r === "label" ? b : void 0
  }, E), a, s && /* @__PURE__ */ le.createElement("span", {
    className: O.required,
    "aria-hidden": !0
  }, " *"));
});
mM.displayName = "@mantine/core/InputLabel";
var ede = yn((e, { size: t }) => ({
  error: {
    wordBreak: "break-word",
    color: e.fn.variant({ variant: "filled", color: "red" }).background,
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }) - 2,
    lineHeight: 1.2,
    display: "block"
  }
}));
const tde = ede;
var nde = Object.defineProperty, UE = Object.getOwnPropertySymbols, aH = Object.prototype.hasOwnProperty, iH = Object.prototype.propertyIsEnumerable, Oz = (e, t, n) => t in e ? nde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, rde = (e, t) => {
  for (var n in t || (t = {}))
    aH.call(t, n) && Oz(e, n, t[n]);
  if (UE)
    for (var n of UE(t))
      iH.call(t, n) && Oz(e, n, t[n]);
  return e;
}, ode = (e, t) => {
  var n = {};
  for (var r in e)
    aH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && UE)
    for (var r of UE(e))
      t.indexOf(r) < 0 && iH.call(e, r) && (n[r] = e[r]);
  return n;
};
const ade = {
  size: "sm"
}, hM = C.forwardRef((e, t) => {
  const n = vn("InputError", ade, e), { children: r, className: a, classNames: s, styles: l, unstyled: p, size: m, __staticSelector: h } = n, g = ode(n, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector"]), { classes: b, cx: x } = tde({ size: m }, { name: ["InputWrapper", h], classNames: s, styles: l, unstyled: p });
  return /* @__PURE__ */ le.createElement(Gi, rde({
    className: x(b.error, a),
    ref: t
  }, g), r);
});
hM.displayName = "@mantine/core/InputError";
var ide = yn((e, { size: t }) => ({
  description: {
    wordBreak: "break-word",
    color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6],
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }) - 2,
    lineHeight: 1.2,
    display: "block"
  }
}));
const sde = ide;
var lde = Object.defineProperty, BE = Object.getOwnPropertySymbols, sH = Object.prototype.hasOwnProperty, lH = Object.prototype.propertyIsEnumerable, Pz = (e, t, n) => t in e ? lde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ude = (e, t) => {
  for (var n in t || (t = {}))
    sH.call(t, n) && Pz(e, n, t[n]);
  if (BE)
    for (var n of BE(t))
      lH.call(t, n) && Pz(e, n, t[n]);
  return e;
}, cde = (e, t) => {
  var n = {};
  for (var r in e)
    sH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && BE)
    for (var r of BE(e))
      t.indexOf(r) < 0 && lH.call(e, r) && (n[r] = e[r]);
  return n;
};
const dde = {
  size: "sm"
}, vM = C.forwardRef((e, t) => {
  const n = vn("InputDescription", dde, e), { children: r, className: a, classNames: s, styles: l, unstyled: p, size: m, __staticSelector: h } = n, g = cde(n, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector"]), { classes: b, cx: x } = sde({ size: m }, { name: ["InputWrapper", h], classNames: s, styles: l, unstyled: p });
  return /* @__PURE__ */ le.createElement(Gi, ude({
    color: "dimmed",
    className: x(b.description, a),
    ref: t,
    unstyled: p
  }, g), r);
});
vM.displayName = "@mantine/core/InputDescription";
const uH = C.createContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0
}), fde = uH.Provider, pde = () => C.useContext(uH);
function mde(e, { hasDescription: t, hasError: n }) {
  const r = e.findIndex((m) => m === "input"), a = e[r - 1], s = e[r + 1];
  return { offsetBottom: t && s === "description" || n && s === "error", offsetTop: t && a === "description" || n && a === "error" };
}
var hde = Object.defineProperty, vde = Object.defineProperties, yde = Object.getOwnPropertyDescriptors, Rz = Object.getOwnPropertySymbols, gde = Object.prototype.hasOwnProperty, bde = Object.prototype.propertyIsEnumerable, kz = (e, t, n) => t in e ? hde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, wde = (e, t) => {
  for (var n in t || (t = {}))
    gde.call(t, n) && kz(e, n, t[n]);
  if (Rz)
    for (var n of Rz(t))
      bde.call(t, n) && kz(e, n, t[n]);
  return e;
}, xde = (e, t) => vde(e, yde(t)), Sde = yn((e) => ({
  root: xde(wde({}, e.fn.fontStyles()), {
    lineHeight: e.lineHeight
  })
}));
const Ede = Sde;
var Cde = Object.defineProperty, Tde = Object.defineProperties, _de = Object.getOwnPropertyDescriptors, HE = Object.getOwnPropertySymbols, cH = Object.prototype.hasOwnProperty, dH = Object.prototype.propertyIsEnumerable, Dz = (e, t, n) => t in e ? Cde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, xf = (e, t) => {
  for (var n in t || (t = {}))
    cH.call(t, n) && Dz(e, n, t[n]);
  if (HE)
    for (var n of HE(t))
      dH.call(t, n) && Dz(e, n, t[n]);
  return e;
}, $z = (e, t) => Tde(e, _de(t)), Ode = (e, t) => {
  var n = {};
  for (var r in e)
    cH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && HE)
    for (var r of HE(e))
      t.indexOf(r) < 0 && dH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Pde = {
  labelElement: "label",
  size: "sm",
  inputContainer: (e) => e,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, fH = C.forwardRef((e, t) => {
  const n = vn("InputWrapper", Pde, e), {
    className: r,
    label: a,
    children: s,
    required: l,
    id: p,
    error: m,
    description: h,
    labelElement: g,
    labelProps: b,
    descriptionProps: x,
    errorProps: E,
    classNames: O,
    styles: _,
    size: P,
    inputContainer: M,
    __staticSelector: D,
    unstyled: N,
    inputWrapperOrder: I,
    withAsterisk: R
  } = n, j = Ode(n, [
    "className",
    "label",
    "children",
    "required",
    "id",
    "error",
    "description",
    "labelElement",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "classNames",
    "styles",
    "size",
    "inputContainer",
    "__staticSelector",
    "unstyled",
    "inputWrapperOrder",
    "withAsterisk"
  ]), { classes: U, cx: q } = Ede(null, {
    classNames: O,
    styles: _,
    name: ["InputWrapper", D],
    unstyled: N
  }), J = {
    classNames: O,
    styles: _,
    unstyled: N,
    size: P,
    __staticSelector: D
  }, H = typeof R == "boolean" ? R : l, Z = p ? `${p}-error` : E == null ? void 0 : E.id, re = p ? `${p}-description` : x == null ? void 0 : x.id, K = `${!!m && typeof m != "boolean" ? Z : ""} ${h ? re : ""}`, Q = K.trim().length > 0 ? K.trim() : void 0, te = a && /* @__PURE__ */ le.createElement(mM, xf(xf({
    key: "label",
    labelElement: g,
    id: p ? `${p}-label` : void 0,
    htmlFor: p,
    required: H
  }, J), b), a), ne = h && /* @__PURE__ */ le.createElement(vM, $z(xf(xf({
    key: "description"
  }, x), J), {
    size: (x == null ? void 0 : x.size) || J.size,
    id: (x == null ? void 0 : x.id) || re
  }), h), ae = /* @__PURE__ */ le.createElement(C.Fragment, {
    key: "input"
  }, M(s)), se = typeof m != "boolean" && m && /* @__PURE__ */ le.createElement(hM, $z(xf(xf({}, E), J), {
    size: (E == null ? void 0 : E.size) || J.size,
    key: "error",
    id: (E == null ? void 0 : E.id) || Z
  }), m), V = I.map((ee) => {
    switch (ee) {
      case "label":
        return te;
      case "input":
        return ae;
      case "description":
        return ne;
      case "error":
        return se;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ le.createElement(fde, {
    value: xf({
      describedBy: Q
    }, mde(I, {
      hasDescription: !!ne,
      hasError: !!se
    }))
  }, /* @__PURE__ */ le.createElement(hn, xf({
    className: q(U.root, r),
    ref: t
  }, j), V));
});
fH.displayName = "@mantine/core/InputWrapper";
var Rde = Object.defineProperty, WE = Object.getOwnPropertySymbols, pH = Object.prototype.hasOwnProperty, mH = Object.prototype.propertyIsEnumerable, Mz = (e, t, n) => t in e ? Rde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, kde = (e, t) => {
  for (var n in t || (t = {}))
    pH.call(t, n) && Mz(e, n, t[n]);
  if (WE)
    for (var n of WE(t))
      mH.call(t, n) && Mz(e, n, t[n]);
  return e;
}, Dde = (e, t) => {
  var n = {};
  for (var r in e)
    pH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && WE)
    for (var r of WE(e))
      t.indexOf(r) < 0 && mH.call(e, r) && (n[r] = e[r]);
  return n;
};
const $de = {}, hH = C.forwardRef((e, t) => {
  const n = vn("InputPlaceholder", $de, e), { sx: r } = n, a = Dde(n, ["sx"]);
  return /* @__PURE__ */ le.createElement(hn, kde({
    component: "span",
    sx: [(s) => s.fn.placeholderStyles(), ...B0(r)],
    ref: t
  }, a));
});
hH.displayName = "@mantine/core/InputPlaceholder";
var Mde = Object.defineProperty, Nde = Object.defineProperties, Ide = Object.getOwnPropertyDescriptors, Nz = Object.getOwnPropertySymbols, Ade = Object.prototype.hasOwnProperty, jde = Object.prototype.propertyIsEnumerable, Iz = (e, t, n) => t in e ? Mde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, E1 = (e, t) => {
  for (var n in t || (t = {}))
    Ade.call(t, n) && Iz(e, n, t[n]);
  if (Nz)
    for (var n of Nz(t))
      jde.call(t, n) && Iz(e, n, t[n]);
  return e;
}, xk = (e, t) => Nde(e, Ide(t));
const Yi = {
  xs: 30,
  sm: 36,
  md: 42,
  lg: 50,
  xl: 60
};
function Lde({ theme: e, variant: t }) {
  return t === "default" ? {
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4]}`,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
    transition: "border-color 100ms ease",
    "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
  } : t === "filled" ? {
    border: "1px solid transparent",
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1],
    "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
  } : {
    borderWidth: 0,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    backgroundColor: "transparent",
    minHeight: 28,
    outline: 0,
    "&:focus, &:focus-within": {
      outline: "none",
      borderColor: "transparent"
    },
    "&:disabled": {
      backgroundColor: "transparent",
      "&:focus, &:focus-within": {
        outline: "none",
        borderColor: "transparent"
      }
    }
  };
}
var Fde = yn((e, {
  size: t,
  multiline: n,
  radius: r,
  variant: a,
  invalid: s,
  rightSectionWidth: l,
  withRightSection: p,
  iconWidth: m,
  offsetBottom: h,
  offsetTop: g,
  pointer: b
}) => {
  const x = e.fn.variant({ variant: "filled", color: "red" }).background, E = a === "default" || a === "filled" ? {
    minHeight: e.fn.size({ size: t, sizes: Yi }),
    paddingLeft: e.fn.size({ size: t, sizes: Yi }) / 3,
    paddingRight: p ? l : e.fn.size({ size: t, sizes: Yi }) / 3,
    borderRadius: e.fn.radius(r)
  } : null;
  return {
    wrapper: {
      position: "relative",
      marginTop: g ? `calc(${e.spacing.xs}px / 2)` : void 0,
      marginBottom: h ? `calc(${e.spacing.xs}px / 2)` : void 0
    },
    input: E1(xk(E1(xk(E1({}, e.fn.fontStyles()), {
      height: n ? a === "unstyled" ? void 0 : "auto" : e.fn.size({ size: t, sizes: Yi }),
      WebkitTapHighlightColor: "transparent",
      lineHeight: n ? e.lineHeight : `${e.fn.size({ size: t, sizes: Yi }) - 2}px`,
      appearance: "none",
      resize: "none",
      boxSizing: "border-box",
      fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
      width: "100%",
      color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
      display: "block",
      textAlign: "left",
      cursor: b ? "pointer" : void 0
    }), E), {
      "&:disabled": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[1],
        color: e.colors.dark[2],
        opacity: 0.6,
        cursor: "not-allowed",
        "&::placeholder": {
          color: e.colors.dark[2]
        }
      },
      "&::placeholder": xk(E1({}, e.fn.placeholderStyles()), {
        opacity: 1
      }),
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration": {
        appearance: "none"
      },
      "&[type=number]": {
        MozAppearance: "textfield"
      }
    }), Lde({ theme: e, variant: a })),
    withIcon: {
      paddingLeft: typeof m == "number" ? m : e.fn.size({ size: t, sizes: Yi })
    },
    invalid: {
      color: x,
      borderColor: x,
      "&::placeholder": {
        opacity: 1,
        color: x
      }
    },
    disabled: {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[1],
      color: e.colors.dark[2],
      opacity: 0.6,
      cursor: "not-allowed",
      "&::placeholder": {
        color: e.colors.dark[2]
      }
    },
    icon: {
      pointerEvents: "none",
      position: "absolute",
      zIndex: 1,
      left: 0,
      top: 0,
      bottom: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: typeof m == "number" ? m : e.fn.size({ size: t, sizes: Yi }),
      color: s ? e.colors.red[e.colorScheme === "dark" ? 6 : 7] : e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[5]
    },
    rightSection: {
      position: "absolute",
      top: 0,
      bottom: 0,
      right: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: l
    }
  };
});
const zde = Fde;
var Vde = Object.defineProperty, Ude = Object.defineProperties, Bde = Object.getOwnPropertyDescriptors, YE = Object.getOwnPropertySymbols, vH = Object.prototype.hasOwnProperty, yH = Object.prototype.propertyIsEnumerable, Az = (e, t, n) => t in e ? Vde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, C1 = (e, t) => {
  for (var n in t || (t = {}))
    vH.call(t, n) && Az(e, n, t[n]);
  if (YE)
    for (var n of YE(t))
      yH.call(t, n) && Az(e, n, t[n]);
  return e;
}, jz = (e, t) => Ude(e, Bde(t)), Hde = (e, t) => {
  var n = {};
  for (var r in e)
    vH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && YE)
    for (var r of YE(e))
      t.indexOf(r) < 0 && yH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Wde = {
  rightSectionWidth: 36,
  size: "sm",
  variant: "default"
}, Dm = C.forwardRef((e, t) => {
  const n = vn("Input", Wde, e), {
    className: r,
    invalid: a,
    required: s,
    disabled: l,
    variant: p,
    icon: m,
    style: h,
    rightSectionWidth: g,
    iconWidth: b,
    rightSection: x,
    rightSectionProps: E,
    radius: O,
    size: _,
    wrapperProps: P,
    classNames: M,
    styles: D,
    __staticSelector: N,
    multiline: I,
    sx: R,
    unstyled: j,
    pointer: U
  } = n, q = Hde(n, [
    "className",
    "invalid",
    "required",
    "disabled",
    "variant",
    "icon",
    "style",
    "rightSectionWidth",
    "iconWidth",
    "rightSection",
    "rightSectionProps",
    "radius",
    "size",
    "wrapperProps",
    "classNames",
    "styles",
    "__staticSelector",
    "multiline",
    "sx",
    "unstyled",
    "pointer"
  ]), { offsetBottom: J, offsetTop: H, describedBy: Z } = pde(), { classes: re, cx: Y } = zde({
    radius: O,
    size: _,
    multiline: I,
    variant: p,
    invalid: a,
    rightSectionWidth: g,
    iconWidth: b,
    withRightSection: !!x,
    offsetBottom: J,
    offsetTop: H,
    pointer: U
  }, { classNames: M, styles: D, name: ["Input", N], unstyled: j }), { systemStyles: K, rest: Q } = Oy(q);
  return /* @__PURE__ */ le.createElement(hn, C1(C1({
    className: Y(re.wrapper, r),
    sx: R,
    style: h
  }, K), P), m && /* @__PURE__ */ le.createElement("div", {
    className: re.icon
  }, m), /* @__PURE__ */ le.createElement(hn, jz(C1({
    component: "input"
  }, Q), {
    ref: t,
    required: s,
    "aria-invalid": a,
    "aria-describedby": Z,
    disabled: l,
    className: Y(re[`${p}Variant`], re.input, {
      [re.withIcon]: m,
      [re.invalid]: a,
      [re.disabled]: l
    })
  })), x && /* @__PURE__ */ le.createElement("div", jz(C1({}, E), {
    className: re.rightSection
  }), x));
});
Dm.displayName = "@mantine/core/Input";
Dm.Wrapper = fH;
Dm.Label = mM;
Dm.Description = vM;
Dm.Error = hM;
Dm.Placeholder = hH;
const ec = Dm;
var Yde = yn((e, { orientation: t, buttonBorderWidth: n }) => ({
  root: {
    display: "flex",
    flexDirection: t === "vertical" ? "column" : "row",
    "& [data-button]": {
      "&:first-of-type": {
        borderBottomRightRadius: 0,
        [t === "vertical" ? "borderBottomLeftRadius" : "borderTopRightRadius"]: 0,
        [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: n / 2
      },
      "&:last-of-type": {
        borderTopLeftRadius: 0,
        [t === "vertical" ? "borderTopRightRadius" : "borderBottomLeftRadius"]: 0,
        [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: n / 2
      },
      "&:not(:first-of-type):not(:last-of-type)": {
        borderRadius: 0,
        [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: n / 2,
        [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: n / 2
      },
      "& + [data-button]": {
        [t === "vertical" ? "marginTop" : "marginLeft"]: -n,
        "@media (min-resolution: 192dpi)": {
          [t === "vertical" ? "marginTop" : "marginLeft"]: 0
        }
      }
    }
  }
}));
const qde = Yde;
var Gde = Object.defineProperty, qE = Object.getOwnPropertySymbols, gH = Object.prototype.hasOwnProperty, bH = Object.prototype.propertyIsEnumerable, Lz = (e, t, n) => t in e ? Gde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Kde = (e, t) => {
  for (var n in t || (t = {}))
    gH.call(t, n) && Lz(e, n, t[n]);
  if (qE)
    for (var n of qE(t))
      bH.call(t, n) && Lz(e, n, t[n]);
  return e;
}, Xde = (e, t) => {
  var n = {};
  for (var r in e)
    gH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && qE)
    for (var r of qE(e))
      t.indexOf(r) < 0 && bH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Qde = {
  orientation: "horizontal",
  buttonBorderWidth: 1
}, wH = C.forwardRef((e, t) => {
  const n = vn("ButtonGroup", Qde, e), { className: r, orientation: a, buttonBorderWidth: s, unstyled: l } = n, p = Xde(n, ["className", "orientation", "buttonBorderWidth", "unstyled"]), { classes: m, cx: h } = qde({ orientation: a, buttonBorderWidth: s }, { name: "ButtonGroup", unstyled: l });
  return /* @__PURE__ */ le.createElement(hn, Kde({
    className: h(m.root, r),
    ref: t
  }, p));
});
wH.displayName = "@mantine/core/ButtonGroup";
var Zde = Object.defineProperty, Jde = Object.defineProperties, efe = Object.getOwnPropertyDescriptors, Fz = Object.getOwnPropertySymbols, tfe = Object.prototype.hasOwnProperty, nfe = Object.prototype.propertyIsEnumerable, zz = (e, t, n) => t in e ? Zde(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, dm = (e, t) => {
  for (var n in t || (t = {}))
    tfe.call(t, n) && zz(e, n, t[n]);
  if (Fz)
    for (var n of Fz(t))
      nfe.call(t, n) && zz(e, n, t[n]);
  return e;
}, BD = (e, t) => Jde(e, efe(t));
const HD = {
  xs: { height: Yi.xs, paddingLeft: 14, paddingRight: 14 },
  sm: { height: Yi.sm, paddingLeft: 18, paddingRight: 18 },
  md: { height: Yi.md, paddingLeft: 22, paddingRight: 22 },
  lg: { height: Yi.lg, paddingLeft: 26, paddingRight: 26 },
  xl: { height: Yi.xl, paddingLeft: 32, paddingRight: 32 },
  "compact-xs": { height: 22, paddingLeft: 7, paddingRight: 7 },
  "compact-sm": { height: 26, paddingLeft: 8, paddingRight: 8 },
  "compact-md": { height: 30, paddingLeft: 10, paddingRight: 10 },
  "compact-lg": { height: 34, paddingLeft: 12, paddingRight: 12 },
  "compact-xl": { height: 40, paddingLeft: 14, paddingRight: 14 }
};
function rfe({ compact: e, size: t, withLeftIcon: n, withRightIcon: r }) {
  if (e)
    return HD[`compact-${t}`];
  const a = HD[t];
  return BD(dm({}, a), {
    paddingLeft: n ? a.paddingLeft / 1.5 : a.paddingLeft,
    paddingRight: r ? a.paddingRight / 1.5 : a.paddingRight
  });
}
const ofe = (e) => ({
  display: e ? "block" : "inline-block",
  width: e ? "100%" : "auto"
});
function afe({ variant: e, theme: t, color: n, gradient: r }) {
  const a = t.fn.variant({ color: n, variant: e, gradient: r });
  return e === "gradient" ? {
    border: 0,
    backgroundImage: a.background,
    color: a.color,
    "&:hover": t.fn.hover({
      backgroundSize: "200%"
    })
  } : dm({
    border: `1px solid ${a.border}`,
    backgroundColor: a.background,
    color: a.color
  }, t.fn.hover({
    backgroundColor: a.hover
  }));
}
var ife = yn((e, {
  color: t,
  size: n,
  radius: r,
  fullWidth: a,
  compact: s,
  gradient: l,
  variant: p,
  withLeftIcon: m,
  withRightIcon: h
}) => ({
  root: BD(dm(BD(dm(dm(dm(dm({}, rfe({ compact: s, size: n, withLeftIcon: m, withRightIcon: h })), e.fn.fontStyles()), e.fn.focusStyles()), ofe(a)), {
    borderRadius: e.fn.radius(r),
    fontWeight: 600,
    position: "relative",
    lineHeight: 1,
    fontSize: e.fn.size({ size: n, sizes: e.fontSizes }),
    userSelect: "none",
    cursor: "pointer"
  }), afe({ variant: p, theme: e, color: t, gradient: l })), {
    "&:active": e.activeStyles,
    "&:disabled, &[data-disabled]": {
      borderColor: "transparent",
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
      color: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[5],
      cursor: "not-allowed",
      backgroundImage: "none",
      pointerEvents: "none",
      "&:active": {
        transform: "none"
      }
    },
    "&[data-loading]": {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        top: -1,
        left: -1,
        right: -1,
        bottom: -1,
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], 0.5) : "rgba(255, 255, 255, .5)",
        borderRadius: e.fn.radius(r),
        cursor: "not-allowed"
      }
    }
  }),
  icon: {
    display: "flex",
    alignItems: "center"
  },
  leftIcon: {
    marginRight: 10
  },
  rightIcon: {
    marginLeft: 10
  },
  centerLoader: {
    position: "absolute",
    left: "50%",
    transform: "translateX(-50%)",
    opacity: 0.5
  },
  inner: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "100%",
    overflow: "visible"
  },
  label: {
    whiteSpace: "nowrap",
    height: "100%",
    overflow: "hidden",
    display: "flex",
    alignItems: "center"
  }
}));
const sfe = ife;
var lfe = Object.defineProperty, GE = Object.getOwnPropertySymbols, xH = Object.prototype.hasOwnProperty, SH = Object.prototype.propertyIsEnumerable, Vz = (e, t, n) => t in e ? lfe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Uz = (e, t) => {
  for (var n in t || (t = {}))
    xH.call(t, n) && Vz(e, n, t[n]);
  if (GE)
    for (var n of GE(t))
      SH.call(t, n) && Vz(e, n, t[n]);
  return e;
}, ufe = (e, t) => {
  var n = {};
  for (var r in e)
    xH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && GE)
    for (var r of GE(e))
      t.indexOf(r) < 0 && SH.call(e, r) && (n[r] = e[r]);
  return n;
};
const cfe = {
  size: "sm",
  type: "button",
  variant: "filled",
  loaderPosition: "left"
}, yM = C.forwardRef((e, t) => {
  const n = vn("Button", cfe, e), {
    className: r,
    size: a,
    color: s,
    type: l,
    disabled: p,
    children: m,
    leftIcon: h,
    rightIcon: g,
    fullWidth: b,
    variant: x,
    radius: E,
    uppercase: O,
    compact: _,
    loading: P,
    loaderPosition: M,
    loaderProps: D,
    gradient: N,
    classNames: I,
    styles: R,
    unstyled: j
  } = n, U = ufe(n, [
    "className",
    "size",
    "color",
    "type",
    "disabled",
    "children",
    "leftIcon",
    "rightIcon",
    "fullWidth",
    "variant",
    "radius",
    "uppercase",
    "compact",
    "loading",
    "loaderPosition",
    "loaderProps",
    "gradient",
    "classNames",
    "styles",
    "unstyled"
  ]), { classes: q, cx: J, theme: H } = sfe({
    radius: E,
    color: s,
    size: a,
    fullWidth: b,
    compact: _,
    gradient: N,
    variant: x,
    withLeftIcon: !!h,
    withRightIcon: !!g
  }, { name: "Button", unstyled: j, classNames: I, styles: R }), Z = H.fn.variant({ color: s, variant: x }), re = /* @__PURE__ */ le.createElement(NT, Uz({
    color: Z.color,
    size: H.fn.size({ size: a, sizes: HD }).height / 2
  }, D));
  return /* @__PURE__ */ le.createElement(MT, Uz({
    className: J(q.root, r),
    type: l,
    disabled: p,
    "data-button": !0,
    "data-disabled": p || void 0,
    "data-loading": P || void 0,
    ref: t,
    unstyled: j
  }, U), /* @__PURE__ */ le.createElement("div", {
    className: q.inner
  }, (h || P && M === "left") && /* @__PURE__ */ le.createElement("span", {
    className: J(q.icon, q.leftIcon)
  }, P && M === "left" ? re : h), P && M === "center" && /* @__PURE__ */ le.createElement("span", {
    className: q.centerLoader
  }, re), /* @__PURE__ */ le.createElement("span", {
    className: q.label,
    style: { textTransform: O ? "uppercase" : void 0 }
  }, m), (g || P && M === "right") && /* @__PURE__ */ le.createElement("span", {
    className: J(q.icon, q.rightIcon)
  }, P && M === "right" ? re : g)));
});
yM.displayName = "@mantine/core/Button";
yM.Group = wH;
const vy = yM;
var dfe = yn((e, { radius: t, shadow: n, withBorder: r }) => ({
  root: {
    outline: 0,
    WebkitTapHighlightColor: "transparent",
    display: "block",
    textDecoration: "none",
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
    boxSizing: "border-box",
    borderRadius: e.fn.radius(t),
    boxShadow: e.shadows[n] || n || "none",
    border: r ? `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}` : void 0
  }
}));
const ffe = dfe;
var pfe = Object.defineProperty, KE = Object.getOwnPropertySymbols, EH = Object.prototype.hasOwnProperty, CH = Object.prototype.propertyIsEnumerable, Bz = (e, t, n) => t in e ? pfe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, mfe = (e, t) => {
  for (var n in t || (t = {}))
    EH.call(t, n) && Bz(e, n, t[n]);
  if (KE)
    for (var n of KE(t))
      CH.call(t, n) && Bz(e, n, t[n]);
  return e;
}, hfe = (e, t) => {
  var n = {};
  for (var r in e)
    EH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && KE)
    for (var r of KE(e))
      t.indexOf(r) < 0 && CH.call(e, r) && (n[r] = e[r]);
  return n;
};
const vfe = {}, TH = C.forwardRef((e, t) => {
  const n = vn("Paper", vfe, e), { className: r, children: a, radius: s, withBorder: l, shadow: p, unstyled: m } = n, h = hfe(n, ["className", "children", "radius", "withBorder", "shadow", "unstyled"]), { classes: g, cx: b } = ffe({ radius: s, shadow: p, withBorder: l }, { name: "Paper", unstyled: m });
  return /* @__PURE__ */ le.createElement(hn, mfe({
    className: b(g.root, r),
    ref: t
  }, h), a);
});
TH.displayName = "@mantine/core/Paper";
const XE = TH, _H = C.createContext(null), yfe = _H.Provider, gfe = () => C.useContext(_H);
function bfe(e) {
  return C.Children.toArray(e).filter(Boolean);
}
const OH = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  apart: "space-between"
};
var wfe = yn((e, { spacing: t, position: n, noWrap: r, grow: a, align: s, count: l }) => ({
  root: {
    boxSizing: "border-box",
    display: "flex",
    flexDirection: "row",
    alignItems: s || "center",
    flexWrap: r ? "nowrap" : "wrap",
    justifyContent: OH[n],
    gap: e.fn.size({ size: t, sizes: e.spacing }),
    "& > *": {
      boxSizing: "border-box",
      maxWidth: a ? `calc(${100 / l}% - ${e.fn.size({ size: t, sizes: e.spacing }) - e.fn.size({ size: t, sizes: e.spacing }) / l}px)` : void 0,
      flexGrow: a ? 1 : 0
    }
  }
}));
const xfe = wfe;
var Sfe = Object.defineProperty, QE = Object.getOwnPropertySymbols, PH = Object.prototype.hasOwnProperty, RH = Object.prototype.propertyIsEnumerable, Hz = (e, t, n) => t in e ? Sfe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Efe = (e, t) => {
  for (var n in t || (t = {}))
    PH.call(t, n) && Hz(e, n, t[n]);
  if (QE)
    for (var n of QE(t))
      RH.call(t, n) && Hz(e, n, t[n]);
  return e;
}, Cfe = (e, t) => {
  var n = {};
  for (var r in e)
    PH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && QE)
    for (var r of QE(e))
      t.indexOf(r) < 0 && RH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Tfe = {
  position: "left",
  spacing: "md"
}, Gl = C.forwardRef((e, t) => {
  const n = vn("Group", Tfe, e), { className: r, position: a, align: s, children: l, noWrap: p, grow: m, spacing: h, unstyled: g } = n, b = Cfe(n, ["className", "position", "align", "children", "noWrap", "grow", "spacing", "unstyled"]), x = bfe(l), { classes: E, cx: O } = xfe({
    align: s,
    grow: m,
    noWrap: p,
    spacing: h,
    position: a,
    count: x.length
  }, { unstyled: g, name: "Group" });
  return /* @__PURE__ */ le.createElement(hn, Efe({
    className: O(E.root, r),
    ref: t
  }, b), x);
});
Gl.displayName = "@mantine/core/Group";
var _fe = yn((e, { spacing: t, align: n, justify: r }) => ({
  root: {
    display: "flex",
    flexDirection: "column",
    alignItems: n,
    justifyContent: r,
    gap: e.fn.size({ size: t, sizes: e.spacing })
  }
}));
const Ofe = _fe;
var Pfe = Object.defineProperty, ZE = Object.getOwnPropertySymbols, kH = Object.prototype.hasOwnProperty, DH = Object.prototype.propertyIsEnumerable, Wz = (e, t, n) => t in e ? Pfe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Rfe = (e, t) => {
  for (var n in t || (t = {}))
    kH.call(t, n) && Wz(e, n, t[n]);
  if (ZE)
    for (var n of ZE(t))
      DH.call(t, n) && Wz(e, n, t[n]);
  return e;
}, kfe = (e, t) => {
  var n = {};
  for (var r in e)
    kH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && ZE)
    for (var r of ZE(e))
      t.indexOf(r) < 0 && DH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Dfe = {
  spacing: "md",
  align: "stretch",
  justify: "flex-start"
}, mw = C.forwardRef((e, t) => {
  const n = vn("Stack", Dfe, e), { spacing: r, className: a, align: s, justify: l, unstyled: p } = n, m = kfe(n, ["spacing", "className", "align", "justify", "unstyled"]), { classes: h, cx: g } = Ofe({ spacing: r, align: s, justify: l }, { name: "Stack", unstyled: p });
  return /* @__PURE__ */ le.createElement(hn, Rfe({
    className: g(h.root, a),
    ref: t
  }, m));
});
mw.displayName = "@mantine/core/Stack";
function $H({
  spacing: e,
  offset: t,
  orientation: n,
  children: r,
  role: a,
  unstyled: s
}) {
  return n === "horizontal" ? /* @__PURE__ */ le.createElement(Gl, {
    pt: t,
    spacing: e,
    role: a,
    unstyled: s
  }, r) : /* @__PURE__ */ le.createElement(mw, {
    pt: t,
    spacing: e,
    role: a,
    unstyled: s
  }, r);
}
var $fe = Object.defineProperty, JE = Object.getOwnPropertySymbols, MH = Object.prototype.hasOwnProperty, NH = Object.prototype.propertyIsEnumerable, Yz = (e, t, n) => t in e ? $fe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, qz = (e, t) => {
  for (var n in t || (t = {}))
    MH.call(t, n) && Yz(e, n, t[n]);
  if (JE)
    for (var n of JE(t))
      NH.call(t, n) && Yz(e, n, t[n]);
  return e;
}, Mfe = (e, t) => {
  var n = {};
  for (var r in e)
    MH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && JE)
    for (var r of JE(e))
      t.indexOf(r) < 0 && NH.call(e, r) && (n[r] = e[r]);
  return n;
};
const Nfe = {
  orientation: "horizontal",
  spacing: "lg",
  size: "sm",
  offset: "xs"
}, IH = C.forwardRef((e, t) => {
  const n = vn("CheckboxGroup", Nfe, e), {
    children: r,
    value: a,
    defaultValue: s,
    onChange: l,
    orientation: p,
    spacing: m,
    size: h,
    wrapperProps: g,
    offset: b
  } = n, x = Mfe(n, [
    "children",
    "value",
    "defaultValue",
    "onChange",
    "orientation",
    "spacing",
    "size",
    "wrapperProps",
    "offset"
  ]), [E, O] = Ju({
    value: a,
    defaultValue: s,
    finalValue: [],
    onChange: l
  }), _ = (P) => {
    const M = P.currentTarget.value;
    O(E.includes(M) ? E.filter((D) => D !== M) : [...E, M]);
  };
  return /* @__PURE__ */ le.createElement(yfe, {
    value: { value: E, onChange: _, size: h }
  }, /* @__PURE__ */ le.createElement(ec.Wrapper, qz(qz({
    labelElement: "div",
    size: h,
    __staticSelector: "CheckboxGroup",
    ref: t
  }, g), x), /* @__PURE__ */ le.createElement($H, {
    spacing: m,
    orientation: p,
    offset: b
  }, r)));
});
IH.displayName = "@mantine/core/CheckboxGroup";
var Ife = Object.defineProperty, eC = Object.getOwnPropertySymbols, AH = Object.prototype.hasOwnProperty, jH = Object.prototype.propertyIsEnumerable, Gz = (e, t, n) => t in e ? Ife(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, WD = (e, t) => {
  for (var n in t || (t = {}))
    AH.call(t, n) && Gz(e, n, t[n]);
  if (eC)
    for (var n of eC(t))
      jH.call(t, n) && Gz(e, n, t[n]);
  return e;
}, Afe = (e, t) => {
  var n = {};
  for (var r in e)
    AH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && eC)
    for (var r of eC(e))
      t.indexOf(r) < 0 && jH.call(e, r) && (n[r] = e[r]);
  return n;
};
function jfe(e) {
  return /* @__PURE__ */ le.createElement("svg", WD({
    viewBox: "0 0 10 7",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e), /* @__PURE__ */ le.createElement("path", {
    d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function Lfe(e) {
  var t = e, { indeterminate: n } = t, r = Afe(t, ["indeterminate"]);
  return n ? /* @__PURE__ */ le.createElement("svg", WD({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 32 6"
  }, r), /* @__PURE__ */ le.createElement("rect", {
    width: "32",
    height: "6",
    fill: "currentColor",
    rx: "3"
  })) : /* @__PURE__ */ le.createElement(jfe, WD({}, r));
}
var Ffe = Object.defineProperty, zfe = Object.defineProperties, Vfe = Object.getOwnPropertyDescriptors, Kz = Object.getOwnPropertySymbols, Ufe = Object.prototype.hasOwnProperty, Bfe = Object.prototype.propertyIsEnumerable, Xz = (e, t, n) => t in e ? Ffe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Hfe = (e, t) => {
  for (var n in t || (t = {}))
    Ufe.call(t, n) && Xz(e, n, t[n]);
  if (Kz)
    for (var n of Kz(t))
      Bfe.call(t, n) && Xz(e, n, t[n]);
  return e;
}, Wfe = (e, t) => zfe(e, Vfe(t));
const Yfe = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
}, qfe = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 16,
  xl: 20
};
var Gfe = yn((e, {
  size: t,
  radius: n,
  color: r,
  transitionDuration: a,
  labelPosition: s,
  error: l,
  indeterminate: p
}, m) => {
  const h = e.fn.size({ size: t, sizes: Yfe }), g = e.fn.variant({ variant: "filled", color: r }), b = e.fn.variant({ variant: "filled", color: "red" }).background;
  return {
    icon: {
      ref: m("icon"),
      color: p ? "inherit" : e.white,
      transform: p ? "none" : "translateY(5px) scale(0.5)",
      opacity: p ? 1 : 0,
      transitionProperty: "opacity, transform",
      transitionTimingFunction: "ease",
      transitionDuration: `${a}ms`,
      pointerEvents: "none",
      width: e.fn.size({ size: t, sizes: qfe }),
      position: "absolute",
      zIndex: 1,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      margin: "auto",
      "@media (prefers-reduced-motion)": {
        transitionDuration: e.respectReducedMotion ? "0ms" : void 0
      }
    },
    inner: {
      position: "relative",
      width: h,
      height: h,
      order: s === "left" ? 2 : 1
    },
    input: Wfe(Hfe({}, e.fn.focusStyles()), {
      appearance: "none",
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
      border: `1px solid ${l ? b : e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4]}`,
      width: h,
      height: h,
      borderRadius: e.fn.radius(n),
      padding: 0,
      display: "block",
      margin: 0,
      transition: `border-color ${a}ms ease, background-color ${a}ms ease`,
      cursor: e.cursorType,
      "&:checked": {
        backgroundColor: g.background,
        borderColor: g.background,
        [`& + .${m("icon")}`]: {
          opacity: 1,
          color: e.white,
          transform: "translateY(0) scale(1)"
        }
      },
      "&:disabled": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        borderColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[3],
        cursor: "not-allowed",
        [`& + .${m("icon")}`]: {
          color: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[5]
        }
      }
    })
  };
});
const Kfe = Gfe;
var Xfe = Object.defineProperty, Qfe = Object.defineProperties, Zfe = Object.getOwnPropertyDescriptors, Qz = Object.getOwnPropertySymbols, Jfe = Object.prototype.hasOwnProperty, epe = Object.prototype.propertyIsEnumerable, Zz = (e, t, n) => t in e ? Xfe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, tpe = (e, t) => {
  for (var n in t || (t = {}))
    Jfe.call(t, n) && Zz(e, n, t[n]);
  if (Qz)
    for (var n of Qz(t))
      epe.call(t, n) && Zz(e, n, t[n]);
  return e;
}, npe = (e, t) => Qfe(e, Zfe(t));
const rpe = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
};
var ope = yn((e, { labelPosition: t, size: n }) => ({
  root: {},
  body: {
    display: "flex"
  },
  labelWrapper: npe(tpe({}, e.fn.fontStyles()), {
    display: "inline-flex",
    flexDirection: "column",
    WebkitTapHighlightColor: "transparent",
    fontSize: e.fn.size({ size: n, sizes: e.fontSizes }),
    lineHeight: `${e.fn.size({ size: n, sizes: rpe })}px`,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    cursor: e.cursorType,
    order: t === "left" ? 1 : 2
  }),
  description: {
    marginTop: `calc(${e.spacing.xs}px / 2)`,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
  },
  error: {
    marginTop: `calc(${e.spacing.xs}px / 2)`,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
  },
  label: {
    cursor: e.cursorType,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm,
    "&[data-disabled]": {
      color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
    }
  }
}));
const ape = ope;
var ipe = Object.defineProperty, tC = Object.getOwnPropertySymbols, LH = Object.prototype.hasOwnProperty, FH = Object.prototype.propertyIsEnumerable, Jz = (e, t, n) => t in e ? ipe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, spe = (e, t) => {
  for (var n in t || (t = {}))
    LH.call(t, n) && Jz(e, n, t[n]);
  if (tC)
    for (var n of tC(t))
      FH.call(t, n) && Jz(e, n, t[n]);
  return e;
}, lpe = (e, t) => {
  var n = {};
  for (var r in e)
    LH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && tC)
    for (var r of tC(e))
      t.indexOf(r) < 0 && FH.call(e, r) && (n[r] = e[r]);
  return n;
};
function gM(e) {
  var t = e, {
    __staticSelector: n,
    className: r,
    classNames: a,
    styles: s,
    unstyled: l,
    children: p,
    label: m,
    description: h,
    id: g,
    disabled: b,
    error: x,
    size: E,
    labelPosition: O
  } = t, _ = lpe(t, [
    "__staticSelector",
    "className",
    "classNames",
    "styles",
    "unstyled",
    "children",
    "label",
    "description",
    "id",
    "disabled",
    "error",
    "size",
    "labelPosition"
  ]);
  const { classes: P, cx: M } = ape({ size: E, labelPosition: O }, { name: n, styles: s, classNames: a, unstyled: l });
  return /* @__PURE__ */ le.createElement(hn, spe({
    className: M(P.root, r)
  }, _), /* @__PURE__ */ le.createElement("div", {
    className: M(P.body)
  }, p, /* @__PURE__ */ le.createElement("div", {
    className: P.labelWrapper
  }, m && /* @__PURE__ */ le.createElement("label", {
    className: P.label,
    "data-disabled": b || void 0,
    htmlFor: g
  }, m), h && /* @__PURE__ */ le.createElement(ec.Description, {
    className: P.description
  }, h), x && x !== "boolean" && /* @__PURE__ */ le.createElement(ec.Error, {
    className: P.error
  }, x))));
}
gM.displayName = "@mantine/core/InlineInput";
var upe = Object.defineProperty, nC = Object.getOwnPropertySymbols, zH = Object.prototype.hasOwnProperty, VH = Object.prototype.propertyIsEnumerable, eV = (e, t, n) => t in e ? upe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, T1 = (e, t) => {
  for (var n in t || (t = {}))
    zH.call(t, n) && eV(e, n, t[n]);
  if (nC)
    for (var n of nC(t))
      VH.call(t, n) && eV(e, n, t[n]);
  return e;
}, cpe = (e, t) => {
  var n = {};
  for (var r in e)
    zH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && nC)
    for (var r of nC(e))
      t.indexOf(r) < 0 && VH.call(e, r) && (n[r] = e[r]);
  return n;
};
const dpe = {
  size: "sm",
  transitionDuration: 100,
  icon: Lfe,
  labelPosition: "right"
}, rC = C.forwardRef((e, t) => {
  const n = vn("Checkbox", dpe, e), {
    className: r,
    style: a,
    sx: s,
    checked: l,
    disabled: p,
    color: m,
    label: h,
    indeterminate: g,
    id: b,
    size: x,
    radius: E,
    wrapperProps: O,
    children: _,
    classNames: P,
    styles: M,
    transitionDuration: D,
    icon: N,
    unstyled: I,
    labelPosition: R,
    description: j,
    error: U
  } = n, q = cpe(n, [
    "className",
    "style",
    "sx",
    "checked",
    "disabled",
    "color",
    "label",
    "indeterminate",
    "id",
    "size",
    "radius",
    "wrapperProps",
    "children",
    "classNames",
    "styles",
    "transitionDuration",
    "icon",
    "unstyled",
    "labelPosition",
    "description",
    "error"
  ]), J = gfe(), H = Hf(b), { systemStyles: Z, rest: re } = Oy(q), { classes: Y } = Kfe({
    size: (J == null ? void 0 : J.size) || x,
    radius: E,
    color: m,
    transitionDuration: D,
    labelPosition: R,
    error: !!U,
    indeterminate: g
  }, { name: "Checkbox", classNames: P, styles: M, unstyled: I }), K = J ? {
    checked: J.value.includes(re.value),
    onChange: J.onChange
  } : {};
  return /* @__PURE__ */ le.createElement(gM, T1(T1({
    className: r,
    sx: s,
    style: a,
    id: H,
    size: (J == null ? void 0 : J.size) || x,
    labelPosition: R,
    label: h,
    description: j,
    error: U,
    disabled: p,
    __staticSelector: "Checkbox",
    classNames: P,
    styles: M,
    unstyled: I,
    "data-checked": K.checked || void 0
  }, Z), O), /* @__PURE__ */ le.createElement("div", {
    className: Y.inner
  }, /* @__PURE__ */ le.createElement("input", T1(T1({
    id: H,
    ref: t,
    type: "checkbox",
    className: Y.input,
    checked: l,
    disabled: p
  }, re), K)), /* @__PURE__ */ le.createElement(N, {
    indeterminate: g,
    className: Y.icon
  })));
});
rC.displayName = "@mantine/core/Checkbox";
rC.Group = IH;
function UH({
  transitions: e,
  duration: t = 250,
  exitDuration: n = t,
  mounted: r,
  children: a,
  timingFunction: s,
  onExit: l,
  onEntered: p,
  onEnter: m,
  onExited: h
}) {
  const { transitionDuration: g, transitionStatus: b, transitionTimingFunction: x } = H6({
    mounted: r,
    duration: t,
    exitDuration: n,
    timingFunction: s,
    onExit: l,
    onEntered: p,
    onEnter: m,
    onExited: h
  });
  if (g === 0)
    return r ? /* @__PURE__ */ le.createElement(le.Fragment, null, a({})) : null;
  if (b === "exited")
    return null;
  const E = Object.keys(e).reduce((O, _) => (O[_] = B6({
    duration: e[_].duration,
    transition: e[_].transition,
    timingFunction: e[_].timingFunction || x,
    state: b
  }), O), {});
  return /* @__PURE__ */ le.createElement(le.Fragment, null, a(E));
}
UH.displayName = "@mantine/core/GroupedTransition";
var fpe = yn((e, { zIndex: t }) => ({
  root: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: t
  }
}));
const ppe = fpe;
var mpe = Object.defineProperty, hpe = Object.defineProperties, vpe = Object.getOwnPropertyDescriptors, oC = Object.getOwnPropertySymbols, BH = Object.prototype.hasOwnProperty, HH = Object.prototype.propertyIsEnumerable, tV = (e, t, n) => t in e ? mpe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Sk = (e, t) => {
  for (var n in t || (t = {}))
    BH.call(t, n) && tV(e, n, t[n]);
  if (oC)
    for (var n of oC(t))
      HH.call(t, n) && tV(e, n, t[n]);
  return e;
}, ype = (e, t) => hpe(e, vpe(t)), gpe = (e, t) => {
  var n = {};
  for (var r in e)
    BH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && oC)
    for (var r of oC(e))
      t.indexOf(r) < 0 && HH.call(e, r) && (n[r] = e[r]);
  return n;
};
const bpe = {
  opacity: 0.6,
  color: "#fff",
  zIndex: fd("modal"),
  radius: 0,
  blur: 0
}, WH = C.forwardRef((e, t) => {
  const n = vn("Overlay", bpe, e), { opacity: r, blur: a, color: s, gradient: l, zIndex: p, radius: m, sx: h, unstyled: g, className: b } = n, x = gpe(n, ["opacity", "blur", "color", "gradient", "zIndex", "radius", "sx", "unstyled", "className"]), { classes: E, cx: O } = ppe({ zIndex: p }, { name: "Overlay", unstyled: g }), _ = l ? { backgroundImage: l } : { backgroundColor: s }, P = (M) => /* @__PURE__ */ le.createElement(hn, Sk({
    ref: t,
    className: O(E.root, b),
    sx: [
      (D) => ype(Sk({}, _), {
        opacity: r,
        borderRadius: D.fn.size({ size: m, sizes: D.radius })
      }),
      ...B0(h)
    ]
  }, M));
  return a ? /* @__PURE__ */ le.createElement(hn, Sk({
    className: O(E.root, b),
    sx: [{ backdropFilter: `blur(${a}px)` }, ...B0(h)]
  }, x), P()) : P(x);
});
WH.displayName = "@mantine/core/Overlay";
const YH = WH, [wpe, xpe] = $T("Grid component was not found in tree");
var Spe = Object.defineProperty, nV = Object.getOwnPropertySymbols, Epe = Object.prototype.hasOwnProperty, Cpe = Object.prototype.propertyIsEnumerable, rV = (e, t, n) => t in e ? Spe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Tpe = (e, t) => {
  for (var n in t || (t = {}))
    Epe.call(t, n) && rV(e, n, t[n]);
  if (nV)
    for (var n of nV(t))
      Cpe.call(t, n) && rV(e, n, t[n]);
  return e;
};
const bM = (e, t) => e === "content" ? "auto" : e === "auto" ? "0px" : e ? `${100 / (t / e)}%` : void 0, qH = (e, t, n) => n || e === "auto" || e === "content" ? "unset" : bM(e, t), GH = (e, t) => {
  if (e)
    return e === "auto" || t ? 1 : 0;
}, KH = (e, t) => e === 0 ? 0 : e ? `${100 / (t / e)}%` : void 0, XH = (e, t) => typeof e < "u" ? t.fn.size({ size: e, sizes: t.spacing }) / 2 : void 0;
function _pe({
  sizes: e,
  offsets: t,
  orders: n,
  theme: r,
  columns: a,
  gutters: s,
  grow: l
}) {
  return a4.reduce((p, m) => (p[`@media (min-width: ${r.breakpoints[m]}px)`] = {
    order: n[m],
    flexBasis: bM(e[m], a),
    padding: XH(s[m], r),
    flexShrink: 0,
    width: e[m] === "content" ? "auto" : void 0,
    maxWidth: qH(e[m], a, l),
    marginLeft: KH(t[m], a),
    flexGrow: GH(e[m], l)
  }, p), {});
}
var Ope = yn((e, {
  gutter: t,
  gutterXs: n,
  gutterSm: r,
  gutterMd: a,
  gutterLg: s,
  gutterXl: l,
  grow: p,
  offset: m,
  offsetXs: h,
  offsetSm: g,
  offsetMd: b,
  offsetLg: x,
  offsetXl: E,
  columns: O,
  span: _,
  xs: P,
  sm: M,
  md: D,
  lg: N,
  xl: I,
  order: R,
  orderXs: j,
  orderSm: U,
  orderMd: q,
  orderLg: J,
  orderXl: H
}) => ({
  col: Tpe({
    boxSizing: "border-box",
    flexGrow: GH(_, p),
    order: R,
    padding: XH(t, e),
    marginLeft: KH(m, O),
    flexBasis: bM(_, O),
    flexShrink: 0,
    width: _ === "content" ? "auto" : void 0,
    maxWidth: qH(_, O, p)
  }, _pe({
    sizes: { xs: P, sm: M, md: D, lg: N, xl: I },
    offsets: { xs: h, sm: g, md: b, lg: x, xl: E },
    orders: { xs: j, sm: U, md: q, lg: J, xl: H },
    gutters: { xs: n, sm: r, md: a, lg: s, xl: l },
    theme: e,
    columns: O,
    grow: p
  }))
}));
const Ppe = Ope;
var Rpe = Object.defineProperty, aC = Object.getOwnPropertySymbols, QH = Object.prototype.hasOwnProperty, ZH = Object.prototype.propertyIsEnumerable, oV = (e, t, n) => t in e ? Rpe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, kpe = (e, t) => {
  for (var n in t || (t = {}))
    QH.call(t, n) && oV(e, n, t[n]);
  if (aC)
    for (var n of aC(t))
      ZH.call(t, n) && oV(e, n, t[n]);
  return e;
}, Dpe = (e, t) => {
  var n = {};
  for (var r in e)
    QH.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && aC)
    for (var r of aC(e))
      t.indexOf(r) < 0 && ZH.call(e, r) && (n[r] = e[r]);
  return n;
};
const $pe = {};
function Mpe(e) {
  return e === "auto" || e === "content" ? !0 : typeof e == "number" && e > 0 && e % 1 === 0;
}
const JH = C.forwardRef((e, t) => {
  const n = vn("GridCol", $pe, e), {
    children: r,
    span: a,
    offset: s,
    offsetXs: l,
    offsetSm: p,
    offsetMd: m,
    offsetLg: h,
    offsetXl: g,
    xs: b,
    sm: x,
    md: E,
    lg: O,
    xl: _,
    order: P,
    orderXs: M,
    orderSm: D,
    orderMd: N,
    orderLg: I,
    orderXl: R,
    className: j,
    id: U,
    unstyled: q
  } = n, J = Dpe(n, [
    "children",
    "span",
    "offset",
    "offsetXs",
    "offsetSm",
    "offsetMd",
    "offsetLg",
    "offsetXl",
    "xs",
    "sm",
    "md",
    "lg",
    "xl",
    "order",
    "orderXs",
    "orderSm",
    "orderMd",
    "orderLg",
    "orderXl",
    "className",
    "id",
    "unstyled"
  ]), H = xpe(), Z = a || H.columns, { classes: re, cx: Y } = Ppe({
    gutter: H.gutter,
    gutterXs: H.gutterXs,
    gutterSm: H.gutterSm,
    gutterMd: H.gutterMd,
    gutterLg: H.gutterLg,
    gutterXl: H.gutterXl,
    offset: s,
    offsetXs: l,
    offsetSm: p,
    offsetMd: m,
    offsetLg: h,
    offsetXl: g,
    xs: b,
    sm: x,
    md: E,
    lg: O,
    xl: _,
    order: P,
    orderXs: M,
    orderSm: D,
    orderMd: N,
    orderLg: I,
    orderXl: R,
    grow: H.grow,
    columns: H.columns,
    span: Z
  }, { unstyled: q, name: "Grid" });
  return !Mpe(Z) || Z > H.columns ? null : /* @__PURE__ */ le.createElement(hn, kpe({
    className: Y(re.col, j),
    ref: t
  }, J), r);
});
JH.displayName = "@mantine/core/Col";
var Npe = Object.defineProperty, aV = Object.getOwnPropertySymbols, Ipe = Object.prototype.hasOwnProperty, Ape = Object.prototype.propertyIsEnumerable, iV = (e, t, n) => t in e ? Npe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, jpe = (e, t) => {
  for (var n in t || (t = {}))
    Ipe.call(t, n) && iV(e, n, t[n]);
  if (aV)
    for (var n of aV(t))
      Ape.call(t, n) && iV(e, n, t[n]);
  return e;
};
function Lpe(e, t) {
  return a4.reduce((n, r) => (typeof e[r] < "u" && (n[`@media (min-width: ${t.breakpoints[r]}px)`] = {
    margin: -t.fn.size({ size: e[r], sizes: t.spacing }) / 2
  }), n), {});
}
var Fpe = yn((e, { justify: t, align: n, gutter: r, gutterXs: a, gutterSm: s, gutterMd: l, gutterLg: p, gutterXl: m }) => ({
  root: jpe({
    margin: -e.fn.size({ size: r, sizes: e.spacing }) / 2,
    display: "flex",
    flexWrap: "wrap",
    justifyContent: t,
    alignItems: n
  }, Lpe({ xs: a, sm: s, md: l, lg: p, xl: m }, e))
}));
const zpe = Fpe;
var Vpe = Object.defineProperty, iC = Object.getOwnPropertySymbols, eW = Object.prototype.hasOwnProperty, tW = Object.prototype.propertyIsEnumerable, sV = (e, t, n) => t in e ? Vpe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Upe = (e, t) => {
  for (var n in t || (t = {}))
    eW.call(t, n) && sV(e, n, t[n]);
  if (iC)
    for (var n of iC(t))
      tW.call(t, n) && sV(e, n, t[n]);
  return e;
}, Bpe = (e, t) => {
  var n = {};
  for (var r in e)
    eW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && iC)
    for (var r of iC(e))
      t.indexOf(r) < 0 && tW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Hpe = {
  gutter: "md",
  justify: "flex-start",
  align: "stretch",
  columns: 12
}, Bv = C.forwardRef((e, t) => {
  const n = vn("Grid", Hpe, e), {
    gutter: r,
    gutterXs: a,
    gutterSm: s,
    gutterMd: l,
    gutterLg: p,
    gutterXl: m,
    children: h,
    grow: g,
    justify: b,
    align: x,
    columns: E,
    className: O,
    id: _,
    unstyled: P
  } = n, M = Bpe(n, [
    "gutter",
    "gutterXs",
    "gutterSm",
    "gutterMd",
    "gutterLg",
    "gutterXl",
    "children",
    "grow",
    "justify",
    "align",
    "columns",
    "className",
    "id",
    "unstyled"
  ]), { classes: D, cx: N } = zpe({ gutter: r, justify: b, align: x, gutterXs: a, gutterSm: s, gutterMd: l, gutterLg: p, gutterXl: m }, { unstyled: P, name: "Grid" });
  return /* @__PURE__ */ le.createElement(wpe, {
    value: { gutter: r, gutterXs: a, gutterSm: s, gutterMd: l, gutterLg: p, gutterXl: m, grow: g, columns: E }
  }, /* @__PURE__ */ le.createElement(hn, Upe({
    className: N(D.root, O),
    ref: t
  }, M), h));
});
Bv.Col = JH;
Bv.displayName = "@mantine/core/Grid";
function Wpe({ open: e, close: t, openDelay: n, closeDelay: r }) {
  const a = C.useRef(-1), s = C.useRef(-1), l = () => {
    window.clearTimeout(a.current), window.clearTimeout(s.current);
  }, p = () => {
    l(), n === 0 ? e() : a.current = window.setTimeout(e, n);
  }, m = () => {
    l(), r === 0 ? t() : s.current = window.setTimeout(t, r);
  };
  return C.useEffect(() => l, []), { openDropdown: p, closeDropdown: m };
}
var Ype = Object.defineProperty, qpe = Object.defineProperties, Gpe = Object.getOwnPropertyDescriptors, lV = Object.getOwnPropertySymbols, Kpe = Object.prototype.hasOwnProperty, Xpe = Object.prototype.propertyIsEnumerable, uV = (e, t, n) => t in e ? Ype(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, cV = (e, t) => {
  for (var n in t || (t = {}))
    Kpe.call(t, n) && uV(e, n, t[n]);
  if (lV)
    for (var n of lV(t))
      Xpe.call(t, n) && uV(e, n, t[n]);
  return e;
}, dV = (e, t) => qpe(e, Gpe(t));
const Qpe = (e) => dd({
  from: {
    boxShadow: `0 0 0.5px 0 ${e}`,
    opacity: 0.6
  },
  to: {
    boxShadow: `0 0 0.5px 4.4px ${e}`,
    opacity: 0
  }
});
function fV(e, t = 0) {
  const n = {}, [r, a] = e.split("-");
  let s = "", l = "";
  return r === "top" && (n.top = t, l = "-50%"), r === "middle" && (n.top = "50%", l = "-50%"), r === "bottom" && (n.bottom = t, l = "50%"), a === "start" && (n.left = t, s = "-50%"), a === "center" && (n.left = "50%", s = "-50%"), a === "end" && (n.right = t, s = "50%"), n.transform = `translate(${s}, ${l})`, n;
}
var Zpe = yn((e, {
  radius: t,
  size: n,
  color: r,
  position: a,
  offset: s,
  inline: l,
  withBorder: p,
  withLabel: m,
  zIndex: h
}) => {
  const { background: g } = e.fn.variant({
    variant: "filled",
    primaryFallback: !1,
    color: r || e.primaryColor
  });
  return {
    root: {
      position: "relative",
      display: l ? "inline-block" : "block"
    },
    indicator: dV(cV({}, fV(a, s)), {
      zIndex: h,
      position: "absolute",
      [m ? "minWidth" : "width"]: n,
      height: n,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: e.fontSizes.xs,
      paddingLeft: m ? `calc(${e.spacing.xs}px / 2)` : 0,
      paddingRight: m ? `calc(${e.spacing.xs}px / 2)` : 0,
      borderRadius: e.fn.size({ size: t, sizes: e.radius }),
      backgroundColor: e.fn.variant({
        variant: "filled",
        primaryFallback: !1,
        color: r || e.primaryColor
      }).background,
      border: p ? `2px solid ${e.colorScheme === "dark" ? e.colors.dark[7] : e.white}` : void 0,
      color: e.white,
      whiteSpace: "nowrap"
    }),
    processing: {
      animation: `${Qpe(g)} 1000ms linear infinite`
    },
    common: dV(cV({}, fV(a, s)), {
      position: "absolute",
      [m ? "minWidth" : "width"]: n,
      height: n,
      borderRadius: e.fn.size({ size: t, sizes: e.radius })
    })
  };
});
const Jpe = Zpe, eme = dd({
  from: {
    transform: "translateY(-60%)",
    opacity: 0
  },
  to: {
    transform: "translateY(0%)",
    opacity: 1
  }
}), tme = dd({
  from: {
    transform: "translateY(60%)",
    opacity: 0
  },
  to: {
    transform: "translateY(0%)",
    opacity: 1
  }
}), nme = dd({
  from: {
    transform: "translateY(0%)",
    opacity: 1
  },
  to: {
    transform: "translateY(-60%)",
    opacity: 0
  }
}), rme = dd({
  from: {
    transform: "translateY(0%)",
    opacity: 1
  },
  to: {
    transform: "translateY(60%)",
    opacity: 0
  }
});
var ome = yn(() => ({
  baseNumber: {
    height: 18,
    width: "0.6em",
    maxWidth: "0.6em",
    position: "relative",
    display: "inline-block"
  },
  oldNumberTop: {
    transform: "translateY(-100%);"
  },
  oldNumberBottom: {
    transform: "translateY(100%);"
  },
  oldNumber: {
    display: "inline-block",
    opacity: 0,
    position: "absolute",
    left: 0,
    right: 0
  },
  currentNumberTop: {
    transform: "translateY(0%);"
  },
  currentNumber: {
    display: "inline-block",
    opacity: 1,
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  currentNumberScrollDown: {
    animation: `${eme} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  currentNumberScrollUp: {
    animation: `${tme} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  oldNumberScrollUp: {
    animation: `${nme} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  oldNumberScrollDown: {
    animation: `${rme} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  }
}));
const ame = ome, ime = C.forwardRef((e, t) => {
  const [n, r] = C.useState(e.value), [a, s] = C.useState(e.value), [l, p] = C.useState("up"), [m, h] = C.useState(!1), g = g4(e.value), b = (M) => {
    h(!0), p(M), setTimeout(() => {
      h(!1);
    }, 180);
  }, x = () => {
    const { newOriginalNumber: M, oldOriginalNumber: D } = e;
    M == null || D == null || (M > D ? b("up") : M < D && b("down"));
  };
  C.useEffect(() => {
    r(g), s(e.value), x();
  }, [e.value, g]);
  const { classes: E, cx: O } = ame(null, { name: "MachineNumber" }), _ = C.useMemo(() => m ? l === "up" ? E.currentNumberScrollUp : E.currentNumberScrollDown : null, [m, l]), P = C.useMemo(() => m ? l === "up" ? E.oldNumberScrollUp : E.oldNumberScrollDown : null, [m, l]);
  return /* @__PURE__ */ le.createElement("span", {
    ref: t,
    className: E.baseNumber
  }, n && /* @__PURE__ */ le.createElement("span", {
    className: O(E.oldNumber, E.currentNumberTop, P)
  }, n) || null, /* @__PURE__ */ le.createElement("span", null, /* @__PURE__ */ le.createElement("span", {
    className: O(E.currentNumber, _)
  }, a)), n && /* @__PURE__ */ le.createElement("span", {
    className: O(E.oldNumber, E.oldNumberBottom, P)
  }, n) || null);
});
var sme = yn(() => ({
  base: {
    display: "flex",
    alignItems: "center",
    overflow: "hidden"
  }
}));
const lme = sme, ume = C.forwardRef(({ value: e = 0, max: t }, n) => {
  const [r, a] = C.useState(), [s, l] = C.useState(), p = g4(e);
  C.useEffect(() => {
    typeof e == "string" ? (a(void 0), l(void 0)) : typeof p == "string" ? (a(void 0), l(e)) : (a(p), l(e));
  }, [e, p]);
  const m = C.useMemo(() => {
    if (typeof e == "string")
      return [];
    if (e < 1)
      return [0];
    const g = [];
    let b = e;
    for (typeof t == "number" && (b = Math.min(t, b)); b >= 1; )
      g.push(b % 10), b /= 10, b = Math.floor(b);
    return g.reverse(), g;
  }, [e, t]), { classes: h } = lme(null, { name: "machine" });
  return typeof e == "string" ? /* @__PURE__ */ le.createElement("span", {
    ref: n
  }, e) : /* @__PURE__ */ le.createElement("span", {
    ref: n,
    className: h.base
  }, m.map((g, b) => /* @__PURE__ */ le.createElement(ime, {
    key: m.length - b - 1,
    value: g,
    oldOriginalNumber: r,
    newOriginalNumber: s
  })), typeof t == "number" && e > t && /* @__PURE__ */ le.createElement("span", null, "+"));
});
var cme = Object.defineProperty, sC = Object.getOwnPropertySymbols, nW = Object.prototype.hasOwnProperty, rW = Object.prototype.propertyIsEnumerable, pV = (e, t, n) => t in e ? cme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, dme = (e, t) => {
  for (var n in t || (t = {}))
    nW.call(t, n) && pV(e, n, t[n]);
  if (sC)
    for (var n of sC(t))
      rW.call(t, n) && pV(e, n, t[n]);
  return e;
}, fme = (e, t) => {
  var n = {};
  for (var r in e)
    nW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && sC)
    for (var r of sC(e))
      t.indexOf(r) < 0 && rW.call(e, r) && (n[r] = e[r]);
  return n;
};
const pme = {
  position: "top-end",
  offset: 0,
  inline: !1,
  withBorder: !1,
  disabled: !1,
  showZero: !0,
  processing: !1,
  dot: !0,
  size: 10,
  overflowCount: 99,
  radius: 1e3,
  zIndex: fd("app")
}, wM = C.forwardRef((e, t) => {
  const n = vn("Indicator", pme, e), {
    children: r,
    position: a,
    offset: s,
    size: l,
    radius: p,
    inline: m,
    withBorder: h,
    className: g,
    color: b,
    dot: x,
    styles: E,
    label: O,
    overflowCount: _,
    showZero: P,
    classNames: M,
    disabled: D,
    zIndex: N,
    unstyled: I,
    processing: R
  } = n, j = fme(n, [
    "children",
    "position",
    "offset",
    "size",
    "radius",
    "inline",
    "withBorder",
    "className",
    "color",
    "dot",
    "styles",
    "label",
    "overflowCount",
    "showZero",
    "classNames",
    "disabled",
    "zIndex",
    "unstyled",
    "processing"
  ]), { classes: U, cx: q } = Jpe({ position: a, offset: s, size: l, radius: p, inline: m, color: b, withBorder: h, zIndex: N, withLabel: !!O }, { name: "Indicator", classNames: M, styles: E, unstyled: I }), J = C.useMemo(() => typeof O == "number" ? /* @__PURE__ */ le.createElement(ume, {
    value: O,
    max: _
  }) : O, [O, _]), H = C.useMemo(() => !D && (x || O != null && !(O <= 0 && !P)), [D, O, P]);
  return /* @__PURE__ */ le.createElement(hn, dme({
    ref: t,
    className: q(U.root, g)
  }, j), H && /* @__PURE__ */ le.createElement(le.Fragment, null, /* @__PURE__ */ le.createElement("div", {
    className: q(U.indicator, U.common)
  }, J), R && /* @__PURE__ */ le.createElement("div", {
    className: q(U.processing, U.common)
  })), r);
});
wM.displayName = "@mantine/core/Indicator";
var mme = yn({
  root: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden"
  }
});
const hme = mme;
var vme = Object.defineProperty, yme = Object.defineProperties, gme = Object.getOwnPropertyDescriptors, lC = Object.getOwnPropertySymbols, oW = Object.prototype.hasOwnProperty, aW = Object.prototype.propertyIsEnumerable, mV = (e, t, n) => t in e ? vme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _1 = (e, t) => {
  for (var n in t || (t = {}))
    oW.call(t, n) && mV(e, n, t[n]);
  if (lC)
    for (var n of lC(t))
      aW.call(t, n) && mV(e, n, t[n]);
  return e;
}, bme = (e, t) => yme(e, gme(t)), wme = (e, t) => {
  var n = {};
  for (var r in e)
    oW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && lC)
    for (var r of lC(e))
      t.indexOf(r) < 0 && aW.call(e, r) && (n[r] = e[r]);
  return n;
};
const xme = {
  overlayOpacity: 0.75,
  transitionDuration: 0,
  zIndex: fd("overlay")
}, xM = C.forwardRef((e, t) => {
  const n = vn("LoadingOverlay", xme, e), {
    className: r,
    visible: a,
    loaderProps: s,
    overlayOpacity: l,
    overlayColor: p,
    transitionDuration: m,
    exitTransitionDuration: h,
    zIndex: g,
    style: b,
    loader: x,
    radius: E,
    overlayBlur: O,
    unstyled: _
  } = n, P = wme(n, [
    "className",
    "visible",
    "loaderProps",
    "overlayOpacity",
    "overlayColor",
    "transitionDuration",
    "exitTransitionDuration",
    "zIndex",
    "style",
    "loader",
    "radius",
    "overlayBlur",
    "unstyled"
  ]), { classes: M, cx: D, theme: N } = hme(null, { name: "LoadingOverlay", unstyled: _ }), I = `calc(${g} + 1)`;
  return /* @__PURE__ */ le.createElement(UT, {
    duration: m,
    exitDuration: h,
    mounted: a,
    transition: "fade"
  }, (R) => /* @__PURE__ */ le.createElement(hn, _1({
    className: D(M.root, r),
    style: bme(_1(_1({}, R), b), { zIndex: g }),
    ref: t
  }, P), x ? /* @__PURE__ */ le.createElement("div", {
    style: { zIndex: I }
  }, x) : /* @__PURE__ */ le.createElement(NT, _1({
    style: { zIndex: I }
  }, s)), /* @__PURE__ */ le.createElement(YH, {
    opacity: l,
    zIndex: g,
    radius: E,
    blur: O,
    unstyled: _,
    color: p || (N.colorScheme === "dark" ? N.colors.dark[5] : N.white)
  })));
});
xM.displayName = "@mantine/core/LoadingOverlay";
const iW = {
  context: "Menu component was not found in the tree",
  children: "Menu.Target component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
}, [Sme, hw] = $T(iW.context);
var Eme = yn((e) => ({
  divider: {
    margin: `calc(${e.spacing.xs}px / 2) -5px`,
    borderTop: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`
  }
}));
const Cme = Eme;
var Tme = Object.defineProperty, uC = Object.getOwnPropertySymbols, sW = Object.prototype.hasOwnProperty, lW = Object.prototype.propertyIsEnumerable, hV = (e, t, n) => t in e ? Tme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _me = (e, t) => {
  for (var n in t || (t = {}))
    sW.call(t, n) && hV(e, n, t[n]);
  if (uC)
    for (var n of uC(t))
      lW.call(t, n) && hV(e, n, t[n]);
  return e;
}, Ome = (e, t) => {
  var n = {};
  for (var r in e)
    sW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && uC)
    for (var r of uC(e))
      t.indexOf(r) < 0 && lW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Pme = {}, uW = C.forwardRef((e, t) => {
  const n = vn("MenuDivider", Pme, e), { children: r, className: a } = n, s = Ome(n, ["children", "className"]), { classNames: l, styles: p, unstyled: m } = hw(), { classes: h, cx: g } = Cme(null, { name: "Menu", classNames: l, styles: p, unstyled: m });
  return /* @__PURE__ */ le.createElement(hn, _me({
    className: g(h.divider, a),
    ref: t
  }, s));
});
uW.displayName = "@mantine/core/MenuDivider";
var Rme = Object.defineProperty, cC = Object.getOwnPropertySymbols, cW = Object.prototype.hasOwnProperty, dW = Object.prototype.propertyIsEnumerable, vV = (e, t, n) => t in e ? Rme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, kme = (e, t) => {
  for (var n in t || (t = {}))
    cW.call(t, n) && vV(e, n, t[n]);
  if (cC)
    for (var n of cC(t))
      dW.call(t, n) && vV(e, n, t[n]);
  return e;
}, Dme = (e, t) => {
  var n = {};
  for (var r in e)
    cW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && cC)
    for (var r of cC(e))
      t.indexOf(r) < 0 && dW.call(e, r) && (n[r] = e[r]);
  return n;
};
const $me = {};
function fW(e) {
  const t = vn("MenuDropdown", $me, e), { children: n, onMouseEnter: r, onMouseLeave: a } = t, s = Dme(t, ["children", "onMouseEnter", "onMouseLeave"]), l = C.useRef(), p = hw(), m = (b) => {
    (b.key === "ArrowUp" || b.key === "ArrowDown") && (b.preventDefault(), l.current.querySelectorAll("[data-menu-item]")[0].focus());
  }, h = Zc(r, () => p.trigger === "hover" && p.openDropdown()), g = Zc(a, () => p.trigger === "hover" && p.closeDropdown());
  return /* @__PURE__ */ le.createElement(Zs.Dropdown, kme({
    onMouseEnter: h,
    onMouseLeave: g,
    role: "menu",
    "aria-orientation": "vertical"
  }, s), /* @__PURE__ */ le.createElement("div", {
    tabIndex: -1,
    "data-menu-dropdown": !0,
    "data-autofocus": !0,
    onKeyDown: m,
    ref: l,
    style: { outline: 0 }
  }, n));
}
fW.displayName = "@mantine/core/MenuDropdown";
var Mme = Object.defineProperty, Nme = Object.defineProperties, Ime = Object.getOwnPropertyDescriptors, yV = Object.getOwnPropertySymbols, Ame = Object.prototype.hasOwnProperty, jme = Object.prototype.propertyIsEnumerable, gV = (e, t, n) => t in e ? Mme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Lme = (e, t) => {
  for (var n in t || (t = {}))
    Ame.call(t, n) && gV(e, n, t[n]);
  if (yV)
    for (var n of yV(t))
      jme.call(t, n) && gV(e, n, t[n]);
  return e;
}, Fme = (e, t) => Nme(e, Ime(t)), zme = yn((e, { color: t, radius: n }) => ({
  item: Fme(Lme({}, e.fn.fontStyles()), {
    WebkitTapHighlightColor: "transparent",
    fontSize: e.fontSizes.sm,
    border: 0,
    backgroundColor: "transparent",
    outline: 0,
    width: "100%",
    textAlign: "left",
    textDecoration: "none",
    boxSizing: "border-box",
    padding: `${e.spacing.xs}px ${e.spacing.sm}px`,
    cursor: "pointer",
    borderRadius: e.fn.radius(n),
    color: t ? e.fn.variant({ variant: "filled", primaryFallback: !1, color: t }).background : e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    display: "flex",
    alignItems: "center",
    "&:disabled": {
      color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5],
      pointerEvents: "none",
      userSelect: "none"
    },
    "&[data-hovered]": {
      backgroundColor: t ? e.fn.variant({ variant: "light", color: t }).background : e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[3], 0.35) : e.colors.gray[1]
    }
  }),
  itemLabel: {
    flex: 1
  },
  itemIcon: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    marginRight: e.spacing.xs
  },
  itemRightSection: {}
}));
const Vme = zme;
var Ume = Object.defineProperty, Bme = Object.defineProperties, Hme = Object.getOwnPropertyDescriptors, dC = Object.getOwnPropertySymbols, pW = Object.prototype.hasOwnProperty, mW = Object.prototype.propertyIsEnumerable, bV = (e, t, n) => t in e ? Ume(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Wme = (e, t) => {
  for (var n in t || (t = {}))
    pW.call(t, n) && bV(e, n, t[n]);
  if (dC)
    for (var n of dC(t))
      mW.call(t, n) && bV(e, n, t[n]);
  return e;
}, Yme = (e, t) => Bme(e, Hme(t)), qme = (e, t) => {
  var n = {};
  for (var r in e)
    pW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && dC)
    for (var r of dC(e))
      t.indexOf(r) < 0 && mW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Gme = {}, hW = C.forwardRef((e, t) => {
  const n = vn("MenuItem", Gme, e), { children: r, className: a, color: s, closeMenuOnClick: l, icon: p, rightSection: m } = n, h = qme(n, ["children", "className", "color", "closeMenuOnClick", "icon", "rightSection"]), g = hw(), { classes: b, cx: x, theme: E } = Vme({ radius: g.radius, color: s }, { name: "Menu", classNames: g.classNames, styles: g.styles, unstyled: g.unstyled }), O = C.useRef(), _ = g.getItemIndex(O.current), P = h, M = Zc(P.onMouseLeave, () => g.setHovered(-1)), D = Zc(P.onMouseEnter, () => g.setHovered(g.getItemIndex(O.current))), N = Zc(P.onClick, () => {
    typeof l == "boolean" ? l && g.closeDropdownImmediately() : g.closeOnItemClick && g.closeDropdownImmediately();
  }), I = Zc(P.onFocus, () => g.setHovered(g.getItemIndex(O.current)));
  return /* @__PURE__ */ le.createElement(hn, Yme(Wme({
    component: "button",
    type: "button"
  }, h), {
    tabIndex: -1,
    onFocus: I,
    className: x(b.item, a),
    ref: Wf(O, t),
    role: "menuitem",
    "data-menu-item": !0,
    "data-hovered": g.hovered === _ ? !0 : void 0,
    onMouseEnter: D,
    onMouseLeave: M,
    onClick: N,
    onKeyDown: Z3({
      siblingSelector: "[data-menu-item]",
      parentSelector: "[data-menu-dropdown]",
      activateOnFocus: !1,
      loop: g.loop,
      dir: E.dir,
      orientation: "vertical",
      onKeyDown: P.onKeydown
    })
  }), p && /* @__PURE__ */ le.createElement("div", {
    className: b.itemIcon
  }, p), r && /* @__PURE__ */ le.createElement("div", {
    className: b.itemLabel
  }, r), m && /* @__PURE__ */ le.createElement("div", {
    className: b.itemRightSection
  }, m));
});
hW.displayName = "@mantine/core/MenuItem";
const Kme = hW;
var Xme = yn((e) => ({
  label: {
    color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6],
    fontWeight: 500,
    fontSize: e.fontSizes.xs,
    padding: `calc(${e.spacing.xs}px / 2) ${e.spacing.sm}px`,
    cursor: "default"
  }
}));
const Qme = Xme;
var Zme = Object.defineProperty, fC = Object.getOwnPropertySymbols, vW = Object.prototype.hasOwnProperty, yW = Object.prototype.propertyIsEnumerable, wV = (e, t, n) => t in e ? Zme(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Jme = (e, t) => {
  for (var n in t || (t = {}))
    vW.call(t, n) && wV(e, n, t[n]);
  if (fC)
    for (var n of fC(t))
      yW.call(t, n) && wV(e, n, t[n]);
  return e;
}, ehe = (e, t) => {
  var n = {};
  for (var r in e)
    vW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && fC)
    for (var r of fC(e))
      t.indexOf(r) < 0 && yW.call(e, r) && (n[r] = e[r]);
  return n;
};
const the = {}, gW = C.forwardRef((e, t) => {
  const n = vn("MenuLabel", the, e), { children: r, className: a } = n, s = ehe(n, ["children", "className"]), { classNames: l, styles: p, unstyled: m } = hw(), { classes: h, cx: g } = Qme(null, { name: "Menu", classNames: l, styles: p, unstyled: m });
  return /* @__PURE__ */ le.createElement(Gi, Jme({
    className: g(h.label, a),
    ref: t
  }, s), r);
});
gW.displayName = "@mantine/core/MenuLabel";
var nhe = Object.defineProperty, pC = Object.getOwnPropertySymbols, bW = Object.prototype.hasOwnProperty, wW = Object.prototype.propertyIsEnumerable, xV = (e, t, n) => t in e ? nhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, rhe = (e, t) => {
  for (var n in t || (t = {}))
    bW.call(t, n) && xV(e, n, t[n]);
  if (pC)
    for (var n of pC(t))
      wW.call(t, n) && xV(e, n, t[n]);
  return e;
}, ohe = (e, t) => {
  var n = {};
  for (var r in e)
    bW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && pC)
    for (var r of pC(e))
      t.indexOf(r) < 0 && wW.call(e, r) && (n[r] = e[r]);
  return n;
};
const ahe = {
  refProp: "ref"
}, xW = C.forwardRef((e, t) => {
  const n = vn("MenuTarget", ahe, e), { children: r, refProp: a } = n, s = ohe(n, ["children", "refProp"]);
  if (!uw(r))
    throw new Error(iW.children);
  const l = hw(), p = Zc(r.props.onClick, () => l.trigger === "click" && l.toggleDropdown()), m = Zc(r.props.onMouseEnter, () => l.trigger === "hover" && l.openDropdown()), h = Zc(r.props.onMouseLeave, () => l.trigger === "hover" && l.closeDropdown());
  return /* @__PURE__ */ le.createElement(Zs.Target, rhe({
    refProp: a,
    popupType: "menu",
    ref: t
  }, s), C.cloneElement(r, {
    onClick: p,
    onMouseEnter: m,
    onMouseLeave: h,
    "data-expanded": l.opened ? !0 : void 0
  }));
});
xW.displayName = "@mantine/core/MenuTarget";
var ihe = yn({
  dropdown: { padding: 4 }
});
const she = ihe;
var lhe = Object.defineProperty, uhe = Object.defineProperties, che = Object.getOwnPropertyDescriptors, mC = Object.getOwnPropertySymbols, SW = Object.prototype.hasOwnProperty, EW = Object.prototype.propertyIsEnumerable, SV = (e, t, n) => t in e ? lhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, EV = (e, t) => {
  for (var n in t || (t = {}))
    SW.call(t, n) && SV(e, n, t[n]);
  if (mC)
    for (var n of mC(t))
      EW.call(t, n) && SV(e, n, t[n]);
  return e;
}, CV = (e, t) => uhe(e, che(t)), dhe = (e, t) => {
  var n = {};
  for (var r in e)
    SW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && mC)
    for (var r of mC(e))
      t.indexOf(r) < 0 && EW.call(e, r) && (n[r] = e[r]);
  return n;
};
const fhe = {
  closeOnItemClick: !0,
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100
};
function To(e) {
  const t = vn("Menu", fhe, e), {
    children: n,
    onOpen: r,
    onClose: a,
    opened: s,
    defaultOpened: l,
    onChange: p,
    closeOnItemClick: m,
    loop: h,
    closeOnEscape: g,
    trigger: b,
    openDelay: x,
    closeDelay: E,
    classNames: O,
    styles: _,
    unstyled: P,
    radius: M
  } = t, D = dhe(t, [
    "children",
    "onOpen",
    "onClose",
    "opened",
    "defaultOpened",
    "onChange",
    "closeOnItemClick",
    "loop",
    "closeOnEscape",
    "trigger",
    "openDelay",
    "closeDelay",
    "classNames",
    "styles",
    "unstyled",
    "radius"
  ]), { classes: N, cx: I } = she(), [R, { setHovered: j, resetHovered: U }] = koe(), [q, J] = Ju({
    value: s,
    defaultValue: l,
    finalValue: !1,
    onChange: p
  }), H = () => {
    J(!1), q && (a == null || a());
  }, Z = () => {
    J(!0), !q && (r == null || r());
  }, re = () => q ? H() : Z(), { openDropdown: Y, closeDropdown: K } = Wpe({ open: Z, close: H, closeDelay: E, openDelay: x }), Q = (te) => Ooe("[data-menu-item]", "[data-menu-dropdown]", te);
  return Xs(() => {
    U();
  }, [q]), /* @__PURE__ */ le.createElement(Sme, {
    value: {
      opened: q,
      toggleDropdown: re,
      getItemIndex: Q,
      hovered: R,
      setHovered: j,
      closeOnItemClick: m,
      closeDropdown: b === "click" ? H : K,
      openDropdown: b === "click" ? Z : Y,
      closeDropdownImmediately: H,
      loop: h,
      trigger: b,
      radius: M,
      classNames: O,
      styles: _,
      unstyled: P
    }
  }, /* @__PURE__ */ le.createElement(Zs, CV(EV({}, D), {
    radius: M,
    opened: q,
    onChange: J,
    defaultOpened: l,
    trapFocus: b === "click",
    closeOnEscape: g && b === "click",
    __staticSelector: "Menu",
    classNames: CV(EV({}, O), { dropdown: I(N.dropdown, O == null ? void 0 : O.dropdown) }),
    styles: _,
    unstyled: P,
    onClose: H,
    onOpen: Z
  }), n));
}
To.displayName = "@mantine/core/Menu";
To.Item = Kme;
To.Label = gW;
To.Dropdown = fW;
To.Target = xW;
To.Divider = uW;
var phe = Object.defineProperty, TV = Object.getOwnPropertySymbols, mhe = Object.prototype.hasOwnProperty, hhe = Object.prototype.propertyIsEnumerable, _V = (e, t, n) => t in e ? phe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, vhe = (e, t) => {
  for (var n in t || (t = {}))
    mhe.call(t, n) && _V(e, n, t[n]);
  if (TV)
    for (var n of TV(t))
      hhe.call(t, n) && _V(e, n, t[n]);
  return e;
};
const yhe = {
  xs: 320,
  sm: 380,
  md: 440,
  lg: 620,
  xl: 780
};
function ghe(e) {
  return e ? {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    maxHeight: "100vh",
    overflowY: "auto"
  } : {};
}
var bhe = yn((e, { overflow: t, size: n, centered: r, zIndex: a, fullScreen: s }) => ({
  close: {},
  overlay: {
    display: s ? "none" : void 0
  },
  root: {
    position: "fixed",
    zIndex: a,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  inner: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    overflowY: "auto",
    padding: s ? 0 : `${e.spacing.xl * 2}px ${e.spacing.md}px`,
    display: "flex",
    justifyContent: "center",
    alignItems: r ? "center" : "flex-start"
  },
  title: {
    marginRight: e.spacing.md,
    textOverflow: "ellipsis",
    display: "block",
    wordBreak: "break-word"
  },
  modal: vhe({
    position: "relative",
    width: s ? "100vw" : e.fn.size({ sizes: yhe, size: n }),
    borderRadius: s ? 0 : void 0,
    outline: 0,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
    marginTop: r ? "auto" : void 0,
    marginBottom: r ? "auto" : void 0,
    zIndex: 1
  }, ghe(s)),
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: e.spacing.md,
    marginRight: -9
  },
  body: {
    maxHeight: t === "inside" ? "calc(100vh - 185px)" : null,
    overflowY: t === "inside" ? "auto" : null,
    wordBreak: "break-word"
  }
}));
const whe = bhe;
var xhe = Object.defineProperty, hC = Object.getOwnPropertySymbols, CW = Object.prototype.hasOwnProperty, TW = Object.prototype.propertyIsEnumerable, OV = (e, t, n) => t in e ? xhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, She = (e, t) => {
  for (var n in t || (t = {}))
    CW.call(t, n) && OV(e, n, t[n]);
  if (hC)
    for (var n of hC(t))
      TW.call(t, n) && OV(e, n, t[n]);
  return e;
}, Ehe = (e, t) => {
  var n = {};
  for (var r in e)
    CW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && hC)
    for (var r of hC(e))
      t.indexOf(r) < 0 && TW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Che = {
  size: "md",
  transitionDuration: 250,
  overflow: "outside",
  padding: "lg",
  shadow: "lg",
  closeOnClickOutside: !0,
  closeOnEscape: !0,
  trapFocus: !0,
  withCloseButton: !0,
  withinPortal: !0,
  lockScroll: !0,
  withFocusReturn: !0,
  overlayBlur: 0,
  zIndex: fd("modal"),
  exitTransitionDuration: 0
};
function ky(e) {
  const t = vn("Modal", Che, e), {
    className: n,
    opened: r,
    title: a,
    onClose: s,
    children: l,
    withCloseButton: p,
    overlayOpacity: m,
    size: h,
    transitionDuration: g,
    exitTransitionDuration: b,
    closeButtonLabel: x,
    overlayColor: E,
    overflow: O,
    transition: _,
    padding: P,
    shadow: M,
    radius: D,
    id: N,
    classNames: I,
    styles: R,
    closeOnClickOutside: j,
    trapFocus: U,
    closeOnEscape: q,
    centered: J,
    target: H,
    withinPortal: Z,
    zIndex: re,
    overlayBlur: Y,
    transitionTimingFunction: K,
    fullScreen: Q,
    unstyled: te,
    lockScroll: ne,
    withFocusReturn: ae
  } = t, se = Ehe(t, [
    "className",
    "opened",
    "title",
    "onClose",
    "children",
    "withCloseButton",
    "overlayOpacity",
    "size",
    "transitionDuration",
    "exitTransitionDuration",
    "closeButtonLabel",
    "overlayColor",
    "overflow",
    "transition",
    "padding",
    "shadow",
    "radius",
    "id",
    "classNames",
    "styles",
    "closeOnClickOutside",
    "trapFocus",
    "closeOnEscape",
    "centered",
    "target",
    "withinPortal",
    "zIndex",
    "overlayBlur",
    "transitionTimingFunction",
    "fullScreen",
    "unstyled",
    "lockScroll",
    "withFocusReturn"
  ]), V = Hf(N), ee = `${V}-title`, he = `${V}-body`, { classes: ue, cx: fe, theme: Ce } = whe({ size: h, overflow: O, centered: J, zIndex: re, fullScreen: Q }, { unstyled: te, classNames: I, styles: R, name: "Modal" }), Se = h4(U && r), Te = C.useRef(null), pe = Wf(Se, Te), ye = typeof m == "number" ? m : Ce.colorScheme === "dark" ? 0.85 : 0.75;
  wie(ne && r);
  const Oe = (Pe) => {
    !U && Pe.key === "Escape" && q && s();
  };
  C.useEffect(() => {
    if (!U)
      return window.addEventListener("keydown", Oe), () => window.removeEventListener("keydown", Oe);
  }, [U]), d4({ opened: r, shouldReturnFocus: U && ae });
  const Fe = C.useRef(null);
  ID("mousedown", (Pe) => {
    Fe.current = Pe.target;
  });
  const me = () => {
    Fe.current === Te.current && j && s();
  };
  return /* @__PURE__ */ le.createElement(dw, {
    withinPortal: Z,
    target: H
  }, /* @__PURE__ */ le.createElement(UH, {
    mounted: r,
    duration: g,
    exitDuration: b,
    timingFunction: K,
    transitions: {
      modal: {
        duration: g,
        transition: _ || (Q ? "fade" : "pop")
      },
      overlay: {
        duration: g / 2,
        transition: "fade",
        timingFunction: "ease"
      }
    }
  }, (Pe) => /* @__PURE__ */ le.createElement(le.Fragment, null, /* @__PURE__ */ le.createElement(hn, She({
    id: V,
    className: fe(ue.root, n)
  }, se), /* @__PURE__ */ le.createElement("div", {
    style: Pe.overlay
  }, /* @__PURE__ */ le.createElement(YH, {
    className: ue.overlay,
    sx: { position: "fixed" },
    zIndex: 0,
    blur: Y,
    color: E || (Ce.colorScheme === "dark" ? Ce.colors.dark[9] : Ce.black),
    opacity: ye,
    unstyled: te
  })), /* @__PURE__ */ le.createElement("div", {
    role: "presentation",
    className: ue.inner,
    onClick: me,
    onKeyDown: (Ee) => {
      var Ke;
      ((Ke = Ee.target) == null ? void 0 : Ke.getAttribute("data-mantine-stop-propagation")) !== "true" && Ee.key === "Escape" && q && s();
    },
    ref: pe
  }, /* @__PURE__ */ le.createElement(XE, {
    className: ue.modal,
    shadow: M,
    p: P,
    radius: D,
    role: "dialog",
    "aria-labelledby": ee,
    "aria-describedby": he,
    "aria-modal": !0,
    tabIndex: -1,
    style: Pe.modal,
    unstyled: te,
    onClick: (Ee) => Ee.stopPropagation()
  }, (a || p) && /* @__PURE__ */ le.createElement("div", {
    className: ue.header
  }, /* @__PURE__ */ le.createElement(Gi, {
    id: ee,
    className: ue.title
  }, a), p && /* @__PURE__ */ le.createElement(IT, {
    iconSize: 16,
    onClick: s,
    "aria-label": x,
    className: ue.close
  })), /* @__PURE__ */ le.createElement("div", {
    id: he,
    className: ue.body
  }, l)))))));
}
ky.displayName = "@mantine/core/Modal";
const The = {
  xs: 16,
  sm: 22,
  md: 26,
  lg: 30,
  xl: 36
}, _he = {
  xs: 10,
  sm: 12,
  md: 14,
  lg: 16,
  xl: 18
};
var Ohe = yn((e, { size: t, disabled: n, radius: r, readOnly: a, variant: s }) => ({
  defaultValue: {
    display: "flex",
    alignItems: "center",
    backgroundColor: n ? e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[3] : e.colorScheme === "dark" ? e.colors.dark[7] : s === "filled" ? e.white : e.colors.gray[1],
    color: n ? e.colorScheme === "dark" ? e.colors.dark[1] : e.colors.gray[7] : e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
    height: e.fn.size({ size: t, sizes: The }),
    paddingLeft: e.fn.size({ size: t, sizes: e.spacing }),
    paddingRight: n || a ? e.fn.size({ size: t, sizes: e.spacing }) : 0,
    fontWeight: 500,
    fontSize: e.fn.size({ size: t, sizes: _he }),
    borderRadius: e.fn.size({ size: r, sizes: e.radius }),
    cursor: n ? "not-allowed" : "default",
    userSelect: "none",
    maxWidth: "calc(100% - 20px)"
  },
  defaultValueRemove: {
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
    marginLeft: e.fn.size({ size: t, sizes: e.spacing }) / 6
  },
  defaultValueLabel: {
    display: "block",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }
}));
const Phe = Ohe;
var Rhe = Object.defineProperty, vC = Object.getOwnPropertySymbols, _W = Object.prototype.hasOwnProperty, OW = Object.prototype.propertyIsEnumerable, PV = (e, t, n) => t in e ? Rhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, khe = (e, t) => {
  for (var n in t || (t = {}))
    _W.call(t, n) && PV(e, n, t[n]);
  if (vC)
    for (var n of vC(t))
      OW.call(t, n) && PV(e, n, t[n]);
  return e;
}, Dhe = (e, t) => {
  var n = {};
  for (var r in e)
    _W.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && vC)
    for (var r of vC(e))
      t.indexOf(r) < 0 && OW.call(e, r) && (n[r] = e[r]);
  return n;
};
const RV = {
  xs: 16,
  sm: 22,
  md: 24,
  lg: 26,
  xl: 30
};
function PW(e) {
  var t = e, {
    label: n,
    classNames: r,
    styles: a,
    className: s,
    onRemove: l,
    disabled: p,
    readOnly: m,
    size: h,
    radius: g = "sm",
    variant: b
  } = t, x = Dhe(t, [
    "label",
    "classNames",
    "styles",
    "className",
    "onRemove",
    "disabled",
    "readOnly",
    "size",
    "radius",
    "variant"
  ]);
  const { classes: E, cx: O } = Phe({ size: h, disabled: p, readOnly: m, radius: g, variant: b }, { classNames: r, styles: a, name: "MultiSelect" });
  return /* @__PURE__ */ le.createElement("div", khe({
    className: O(E.defaultValue, s)
  }, x), /* @__PURE__ */ le.createElement("span", {
    className: E.defaultValueLabel
  }, n), !p && !m && /* @__PURE__ */ le.createElement(IT, {
    "aria-hidden": !0,
    onMouseDown: l,
    size: RV[h],
    radius: 2,
    color: "blue",
    variant: "transparent",
    iconSize: RV[h] / 2,
    className: E.defaultValueRemove,
    tabIndex: -1
  }));
}
PW.displayName = "@mantine/core/MultiSelect/DefaultValue";
function $he({
  data: e,
  searchable: t,
  limit: n,
  searchValue: r,
  filter: a,
  value: s,
  disableSelectedItemFiltering: l
}) {
  if (!t && s.length === 0)
    return e;
  if (!t) {
    const m = [];
    for (let h = 0; h < e.length; h += 1)
      (l || !s.some((g) => g === e[h].value && !e[h].disabled)) && m.push(e[h]);
    return m;
  }
  const p = [];
  for (let m = 0; m < e.length && (a(r, s.some((h) => h === e[m].value && !e[m].disabled), e[m]) && p.push(e[m]), !(p.length >= n)); m += 1)
    ;
  return p;
}
var Mhe = Object.defineProperty, yC = Object.getOwnPropertySymbols, RW = Object.prototype.hasOwnProperty, kW = Object.prototype.propertyIsEnumerable, kV = (e, t, n) => t in e ? Mhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, DV = (e, t) => {
  for (var n in t || (t = {}))
    RW.call(t, n) && kV(e, n, t[n]);
  if (yC)
    for (var n of yC(t))
      kW.call(t, n) && kV(e, n, t[n]);
  return e;
}, Nhe = (e, t) => {
  var n = {};
  for (var r in e)
    RW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && yC)
    for (var r of yC(e))
      t.indexOf(r) < 0 && kW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Ihe = {
  xs: 14,
  sm: 18,
  md: 20,
  lg: 24,
  xl: 28
};
function Ahe(e) {
  var t = e, { size: n, error: r, style: a } = t, s = Nhe(t, ["size", "error", "style"]);
  const l = Da(), p = l.fn.size({ size: n, sizes: Ihe });
  return /* @__PURE__ */ le.createElement("svg", DV({
    width: p,
    height: p,
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: DV({ color: r ? l.colors.red[6] : l.colors.gray[6] }, a),
    "data-chevron": !0
  }, s), /* @__PURE__ */ le.createElement("path", {
    d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function DW({
  shouldClear: e,
  clearButtonLabel: t,
  onClear: n,
  size: r,
  error: a,
  clearButtonTabIndex: s
}) {
  return e ? /* @__PURE__ */ le.createElement(IT, {
    variant: "transparent",
    "aria-label": t,
    onClick: n,
    size: r,
    tabIndex: s,
    onMouseDown: (l) => l.preventDefault()
  }) : /* @__PURE__ */ le.createElement(Ahe, {
    error: a,
    size: r
  });
}
DW.displayName = "@mantine/core/SelectRightSection";
var jhe = Object.defineProperty, Lhe = Object.defineProperties, Fhe = Object.getOwnPropertyDescriptors, gC = Object.getOwnPropertySymbols, $W = Object.prototype.hasOwnProperty, MW = Object.prototype.propertyIsEnumerable, $V = (e, t, n) => t in e ? jhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ek = (e, t) => {
  for (var n in t || (t = {}))
    $W.call(t, n) && $V(e, n, t[n]);
  if (gC)
    for (var n of gC(t))
      MW.call(t, n) && $V(e, n, t[n]);
  return e;
}, MV = (e, t) => Lhe(e, Fhe(t)), zhe = (e, t) => {
  var n = {};
  for (var r in e)
    $W.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && gC)
    for (var r of gC(e))
      t.indexOf(r) < 0 && MW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Vhe = {
  xs: 24,
  sm: 30,
  md: 34,
  lg: 44,
  xl: 54
};
function NW(e) {
  var t = e, {
    styles: n,
    rightSection: r,
    rightSectionWidth: a,
    theme: s
  } = t, l = zhe(t, [
    "styles",
    "rightSection",
    "rightSectionWidth",
    "theme"
  ]);
  if (r)
    return { rightSection: r, rightSectionWidth: a, styles: n };
  const p = typeof n == "function" ? n(s) : n;
  return {
    rightSectionWidth: s.fn.size({ size: l.size, sizes: Vhe }),
    rightSection: !l.readOnly && !(l.disabled && l.shouldClear) && /* @__PURE__ */ le.createElement(DW, Ek({}, l)),
    styles: MV(Ek({}, p), {
      rightSection: MV(Ek({}, p == null ? void 0 : p.rightSection), {
        pointerEvents: l.shouldClear ? void 0 : "none"
      })
    })
  };
}
var Uhe = Object.defineProperty, Bhe = Object.defineProperties, Hhe = Object.getOwnPropertyDescriptors, NV = Object.getOwnPropertySymbols, Whe = Object.prototype.hasOwnProperty, Yhe = Object.prototype.propertyIsEnumerable, IV = (e, t, n) => t in e ? Uhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, qhe = (e, t) => {
  for (var n in t || (t = {}))
    Whe.call(t, n) && IV(e, n, t[n]);
  if (NV)
    for (var n of NV(t))
      Yhe.call(t, n) && IV(e, n, t[n]);
  return e;
}, Ghe = (e, t) => Bhe(e, Hhe(t)), Khe = yn((e, { size: t, invalid: n }) => ({
  wrapper: {
    position: "relative"
  },
  values: {
    minHeight: e.fn.size({ size: t, sizes: Yi }) - 2,
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    marginLeft: `calc(${-e.spacing.xs}px / 2)`,
    boxSizing: "border-box"
  },
  value: {
    margin: `calc(${e.spacing.xs}px / 2 - 2px) calc(${e.spacing.xs}px / 2)`
  },
  searchInput: Ghe(qhe({}, e.fn.fontStyles()), {
    flex: 1,
    minWidth: 60,
    backgroundColor: "transparent",
    border: 0,
    outline: 0,
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    padding: 0,
    marginLeft: `calc(${e.spacing.xs}px / 2)`,
    appearance: "none",
    color: "inherit",
    lineHeight: `${e.fn.size({ size: t, sizes: Yi }) - 2}px`,
    "&::placeholder": {
      opacity: 1,
      color: n ? e.colors.red[e.colorScheme === "dark" ? 6 : 7] : e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
    },
    "&:disabled": {
      cursor: "not-allowed"
    }
  }),
  searchInputEmpty: {
    width: "100%"
  },
  searchInputInputHidden: {
    width: 0,
    height: 0,
    margin: 0,
    overflow: "hidden"
  },
  searchInputPointer: {
    cursor: "pointer",
    "&:disabled": {
      cursor: "not-allowed"
    }
  },
  input: {
    cursor: "pointer",
    "&:disabled": {
      cursor: "not-allowed"
    }
  }
}));
const Xhe = Khe;
var Qhe = Object.defineProperty, Zhe = Object.defineProperties, Jhe = Object.getOwnPropertyDescriptors, bC = Object.getOwnPropertySymbols, IW = Object.prototype.hasOwnProperty, AW = Object.prototype.propertyIsEnumerable, AV = (e, t, n) => t in e ? Qhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Dv = (e, t) => {
  for (var n in t || (t = {}))
    IW.call(t, n) && AV(e, n, t[n]);
  if (bC)
    for (var n of bC(t))
      AW.call(t, n) && AV(e, n, t[n]);
  return e;
}, jV = (e, t) => Zhe(e, Jhe(t)), eve = (e, t) => {
  var n = {};
  for (var r in e)
    IW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && bC)
    for (var r of bC(e))
      t.indexOf(r) < 0 && AW.call(e, r) && (n[r] = e[r]);
  return n;
};
function tve(e, t, n) {
  return t ? !1 : n.label.toLowerCase().trim().includes(e.toLowerCase().trim());
}
function nve(e, t) {
  return !!e && !t.some((n) => n.value.toLowerCase() === e.toLowerCase());
}
function LV(e, t) {
  if (!Array.isArray(e))
    return;
  if (t.length === 0)
    return [];
  const n = t.map((r) => typeof r == "object" ? r.value : r);
  return e.filter((r) => n.includes(r));
}
const rve = {
  size: "sm",
  valueComponent: PW,
  itemComponent: rM,
  transition: "pop-top-left",
  transitionDuration: 0,
  maxDropdownHeight: 220,
  shadow: "sm",
  searchable: !1,
  filter: tve,
  limit: 1 / 0,
  clearSearchOnChange: !0,
  clearable: !1,
  clearSearchOnBlur: !1,
  disabled: !1,
  initiallyOpened: !1,
  creatable: !1,
  shouldCreate: nve,
  switchDirectionOnFlip: !1,
  zIndex: fd("popover"),
  selectOnBlur: !1,
  clearButtonTabIndex: 0,
  positionDependencies: [],
  dropdownPosition: "flip"
}, BT = C.forwardRef((e, t) => {
  const n = vn("MultiSelect", rve, e), {
    className: r,
    style: a,
    required: s,
    label: l,
    description: p,
    size: m,
    error: h,
    classNames: g,
    styles: b,
    wrapperProps: x,
    value: E,
    defaultValue: O,
    data: _,
    onChange: P,
    valueComponent: M,
    itemComponent: D,
    id: N,
    transition: I,
    transitionDuration: R,
    transitionTimingFunction: j,
    maxDropdownHeight: U,
    shadow: q,
    nothingFound: J,
    onFocus: H,
    onBlur: Z,
    searchable: re,
    placeholder: Y,
    filter: K,
    limit: Q,
    clearSearchOnChange: te,
    clearable: ne,
    clearSearchOnBlur: ae,
    clearButtonLabel: se,
    variant: V,
    onSearchChange: ee,
    searchValue: he,
    disabled: ue,
    initiallyOpened: fe,
    radius: Ce,
    icon: Se,
    rightSection: Te,
    rightSectionWidth: pe,
    creatable: ye,
    getCreateLabel: Oe,
    shouldCreate: Fe,
    onCreate: me,
    sx: Pe,
    dropdownComponent: Ee,
    onDropdownClose: Ke,
    onDropdownOpen: oe,
    maxSelectedValues: de,
    withinPortal: we,
    switchDirectionOnFlip: Me,
    zIndex: Ae,
    selectOnBlur: je,
    name: qe,
    dropdownPosition: ot,
    errorProps: et,
    labelProps: ct,
    descriptionProps: Qt,
    clearButtonTabIndex: Ht,
    form: kt,
    positionDependencies: St,
    onKeyDown: cn,
    unstyled: Ne,
    inputContainer: Ie,
    inputWrapperOrder: Je,
    readOnly: pt,
    withAsterisk: ht,
    hoverOnSearchChange: vt,
    disableSelectedItemFiltering: Nt
  } = n, Tn = eve(n, [
    "className",
    "style",
    "required",
    "label",
    "description",
    "size",
    "error",
    "classNames",
    "styles",
    "wrapperProps",
    "value",
    "defaultValue",
    "data",
    "onChange",
    "valueComponent",
    "itemComponent",
    "id",
    "transition",
    "transitionDuration",
    "transitionTimingFunction",
    "maxDropdownHeight",
    "shadow",
    "nothingFound",
    "onFocus",
    "onBlur",
    "searchable",
    "placeholder",
    "filter",
    "limit",
    "clearSearchOnChange",
    "clearable",
    "clearSearchOnBlur",
    "clearButtonLabel",
    "variant",
    "onSearchChange",
    "searchValue",
    "disabled",
    "initiallyOpened",
    "radius",
    "icon",
    "rightSection",
    "rightSectionWidth",
    "creatable",
    "getCreateLabel",
    "shouldCreate",
    "onCreate",
    "sx",
    "dropdownComponent",
    "onDropdownClose",
    "onDropdownOpen",
    "maxSelectedValues",
    "withinPortal",
    "switchDirectionOnFlip",
    "zIndex",
    "selectOnBlur",
    "name",
    "dropdownPosition",
    "errorProps",
    "labelProps",
    "descriptionProps",
    "clearButtonTabIndex",
    "form",
    "positionDependencies",
    "onKeyDown",
    "unstyled",
    "inputContainer",
    "inputWrapperOrder",
    "readOnly",
    "withAsterisk",
    "hoverOnSearchChange",
    "disableSelectedItemFiltering"
  ]), { classes: bt, cx: Pn, theme: wn } = Xhe({ size: m, invalid: !!h }, { classNames: g, styles: b, unstyled: Ne, name: "MultiSelect" }), { systemStyles: Cn, rest: ar } = Oy(Tn), ir = C.useRef(), go = C.useRef({}), Kr = Hf(N), [xr, Ln] = C.useState(fe), [Dn, Yn] = C.useState(-1), [Jr, dr] = C.useState("column"), [Dr, Fr] = Ju({
    value: he,
    defaultValue: "",
    finalValue: void 0,
    onChange: ee
  }), [zr, Vr] = C.useState(!1), { scrollIntoView: be, targetRef: at, scrollableRef: wt } = y4({
    duration: 0,
    offset: 5,
    cancelable: !1,
    isList: !0
  }), Tt = ye && typeof Oe == "function";
  let it = null;
  const nt = _.map((zt) => typeof zt == "string" ? { label: zt, value: zt } : zt), ge = J3({ data: nt }), [$e, dt] = Ju({
    value: LV(E, _),
    defaultValue: LV(O, _),
    finalValue: [],
    onChange: P
  }), Ft = C.useRef(!!de && de < $e.length), fn = (zt) => {
    if (!pt) {
      const Kn = $e.filter((Ur) => Ur !== zt);
      dt(Kn), de && Kn.length < de && (Ft.current = !1);
    }
  }, er = (zt) => {
    Fr(zt.currentTarget.value), !ue && !Ft.current && re && Ln(!0);
  }, In = (zt) => {
    typeof H == "function" && H(zt), !ue && !Ft.current && re && Ln(!0);
  }, An = $he({
    data: ge,
    searchable: re,
    searchValue: Dr,
    limit: Q,
    filter: K,
    value: $e,
    disableSelectedItemFiltering: Nt
  }), _n = (zt, Kn, Ur) => {
    let Ma = zt;
    for (; Ur(Ma); )
      if (Ma = Kn(Ma), !An[Ma].disabled)
        return Ma;
    return zt;
  };
  Xs(() => {
    Yn(vt && Dr ? 0 : -1);
  }, [Dr, vt]), Xs(() => {
    !ue && $e.length > _.length && Ln(!1), de && $e.length < de && (Ft.current = !1), de && $e.length >= de && (Ft.current = !0, Ln(!1));
  }, [$e]);
  const rs = (zt) => {
    if (!pt)
      if (te && Fr(""), $e.includes(zt.value))
        fn(zt.value);
      else {
        if (zt.creatable && typeof me == "function") {
          const Kn = me(zt.value);
          typeof Kn < "u" && Kn !== null && dt(typeof Kn == "string" ? [...$e, Kn] : [...$e, Kn.value]);
        } else
          dt([...$e, zt.value]);
        $e.length === de - 1 && (Ft.current = !0, Ln(!1)), Dn === An.length - 1 && Yn(An.length - 2), An.length === 1 && Ln(!1);
      }
  }, $a = (zt) => {
    typeof Z == "function" && Z(zt), je && An[Dn] && xr && rs(An[Dn]), ae && Fr(""), Ln(!1);
  }, On = (zt) => {
    if (zr || (cn == null || cn(zt), pt) || zt.key !== "Backspace" && de && Ft.current)
      return;
    const Kn = Jr === "column", Ur = () => {
      Yn((oi) => {
        var Na;
        const Ei = _n(oi, (la) => la + 1, (la) => la < An.length - 1);
        return xr && (at.current = go.current[(Na = An[Ei]) == null ? void 0 : Na.value], be({
          alignment: Kn ? "end" : "start"
        })), Ei;
      });
    }, Ma = () => {
      Yn((oi) => {
        var Na;
        const Ei = _n(oi, (la) => la - 1, (la) => la > 0);
        return xr && (at.current = go.current[(Na = An[Ei]) == null ? void 0 : Na.value], be({
          alignment: Kn ? "start" : "end"
        })), Ei;
      });
    };
    switch (zt.key) {
      case "ArrowUp": {
        zt.preventDefault(), Ln(!0), Kn ? Ma() : Ur();
        break;
      }
      case "ArrowDown": {
        zt.preventDefault(), Ln(!0), Kn ? Ur() : Ma();
        break;
      }
      case "Enter": {
        zt.preventDefault(), An[Dn] && xr ? rs(An[Dn]) : Ln(!0);
        break;
      }
      case " ": {
        re || (zt.preventDefault(), An[Dn] && xr ? rs(An[Dn]) : Ln(!0));
        break;
      }
      case "Backspace": {
        $e.length > 0 && Dr.length === 0 && (dt($e.slice(0, -1)), Ln(!0), de && (Ft.current = !1));
        break;
      }
      case "Home": {
        if (!re) {
          zt.preventDefault(), xr || Ln(!0);
          const oi = An.findIndex((Na) => !Na.disabled);
          Yn(oi), be({
            alignment: Kn ? "end" : "start"
          });
        }
        break;
      }
      case "End": {
        if (!re) {
          zt.preventDefault(), xr || Ln(!0);
          const oi = An.map((Na) => !!Na.disabled).lastIndexOf(!1);
          Yn(oi), be({
            alignment: Kn ? "end" : "start"
          });
        }
        break;
      }
      case "Escape":
        Ln(!1);
    }
  }, Si = $e.map((zt) => {
    let Kn = ge.find((Ur) => Ur.value === zt && !Ur.disabled);
    return !Kn && Tt && (Kn = {
      value: zt,
      label: zt
    }), Kn;
  }).filter((zt) => !!zt).map((zt) => /* @__PURE__ */ le.createElement(M, jV(Dv({}, zt), {
    variant: V,
    disabled: ue,
    className: bt.value,
    readOnly: pt,
    onRemove: (Kn) => {
      Kn.preventDefault(), Kn.stopPropagation(), fn(zt.value);
    },
    key: zt.value,
    size: m,
    styles: b,
    classNames: g,
    radius: Ce
  }))), Ts = (zt) => $e.includes(zt), Zl = () => {
    var zt;
    Fr(""), dt([]), (zt = ir.current) == null || zt.focus(), de && (Ft.current = !1);
  };
  Tt && Fe(Dr, ge) && (it = Oe(Dr), An.push({ label: Dr, value: Dr, creatable: !0 }));
  const ri = !pt && (An.length > 0 ? xr : xr && !!J);
  return Xs(() => {
    const zt = ri ? oe : Ke;
    typeof zt == "function" && zt();
  }, [ri]), /* @__PURE__ */ le.createElement(ec.Wrapper, Dv(Dv({
    required: s,
    id: Kr,
    label: l,
    error: h,
    description: p,
    size: m,
    className: r,
    style: a,
    classNames: g,
    styles: b,
    __staticSelector: "MultiSelect",
    sx: Pe,
    errorProps: et,
    descriptionProps: Qt,
    labelProps: ct,
    inputContainer: Ie,
    inputWrapperOrder: Je,
    unstyled: Ne,
    withAsterisk: ht
  }, Cn), x), /* @__PURE__ */ le.createElement(Nf, {
    opened: ri,
    transition: I,
    transitionDuration: R,
    shadow: "sm",
    withinPortal: we,
    __staticSelector: "MultiSelect",
    onDirectionChange: dr,
    switchDirectionOnFlip: Me,
    zIndex: Ae,
    dropdownPosition: ot,
    positionDependencies: [...St, Dr],
    classNames: g,
    styles: b,
    unstyled: Ne
  }, /* @__PURE__ */ le.createElement(Nf.Target, null, /* @__PURE__ */ le.createElement("div", {
    className: bt.wrapper,
    role: "combobox",
    "aria-haspopup": "listbox",
    "aria-owns": xr && ri ? `${Kr}-items` : null,
    "aria-controls": Kr,
    "aria-expanded": xr,
    onMouseLeave: () => Yn(-1),
    tabIndex: -1
  }, /* @__PURE__ */ le.createElement("input", {
    type: "hidden",
    name: qe,
    value: $e.join(","),
    form: kt,
    disabled: ue
  }), /* @__PURE__ */ le.createElement(ec, Dv({
    __staticSelector: "MultiSelect",
    style: { overflow: "hidden" },
    component: "div",
    multiline: !0,
    size: m,
    variant: V,
    disabled: ue,
    invalid: !!h,
    required: s,
    radius: Ce,
    icon: Se,
    unstyled: Ne,
    onMouseDown: (zt) => {
      var Kn;
      zt.preventDefault(), !ue && !Ft.current && Ln(!xr), (Kn = ir.current) == null || Kn.focus();
    },
    classNames: jV(Dv({}, g), {
      input: Pn({ [bt.input]: !re }, g == null ? void 0 : g.input)
    })
  }, NW({
    theme: wn,
    rightSection: Te,
    rightSectionWidth: pe,
    styles: b,
    size: m,
    shouldClear: ne && $e.length > 0,
    clearButtonLabel: se,
    onClear: Zl,
    error: h,
    disabled: ue,
    clearButtonTabIndex: Ht,
    readOnly: pt
  })), /* @__PURE__ */ le.createElement("div", {
    className: bt.values
  }, Si, /* @__PURE__ */ le.createElement("input", Dv({
    ref: Wf(t, ir),
    type: "search",
    id: Kr,
    className: Pn(bt.searchInput, {
      [bt.searchInputPointer]: !re,
      [bt.searchInputInputHidden]: !xr && $e.length > 0 || !re && $e.length > 0,
      [bt.searchInputEmpty]: $e.length === 0
    }),
    onKeyDown: On,
    value: Dr,
    onChange: er,
    onFocus: In,
    onBlur: $a,
    readOnly: !re || Ft.current || pt,
    placeholder: $e.length === 0 ? Y : void 0,
    disabled: ue,
    "data-mantine-stop-propagation": xr,
    autoComplete: "off",
    onCompositionStart: () => Vr(!0),
    onCompositionEnd: () => Vr(!1)
  }, ar)))))), /* @__PURE__ */ le.createElement(Nf.Dropdown, {
    component: Ee || FT,
    maxHeight: U,
    direction: Jr,
    id: Kr,
    innerRef: wt,
    __staticSelector: "MultiSelect",
    classNames: g,
    styles: b
  }, /* @__PURE__ */ le.createElement(nM, {
    data: An,
    hovered: Dn,
    classNames: g,
    styles: b,
    uuid: Kr,
    __staticSelector: "MultiSelect",
    onItemHover: Yn,
    onItemSelect: rs,
    itemsRefs: go,
    itemComponent: D,
    size: m,
    nothingFound: J,
    isItemSelected: Ts,
    creatable: ye && !!it,
    createLabel: it,
    unstyled: Ne
  }))));
});
BT.displayName = "@mantine/core/MultiSelect";
var ove = Object.defineProperty, ave = Object.defineProperties, ive = Object.getOwnPropertyDescriptors, wC = Object.getOwnPropertySymbols, jW = Object.prototype.hasOwnProperty, LW = Object.prototype.propertyIsEnumerable, FV = (e, t, n) => t in e ? ove(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ck = (e, t) => {
  for (var n in t || (t = {}))
    jW.call(t, n) && FV(e, n, t[n]);
  if (wC)
    for (var n of wC(t))
      LW.call(t, n) && FV(e, n, t[n]);
  return e;
}, sve = (e, t) => ave(e, ive(t)), lve = (e, t) => {
  var n = {};
  for (var r in e)
    jW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && wC)
    for (var r of wC(e))
      t.indexOf(r) < 0 && LW.call(e, r) && (n[r] = e[r]);
  return n;
};
const uve = {
  type: "text",
  size: "sm",
  __staticSelector: "TextInput"
}, HT = C.forwardRef((e, t) => {
  const n = nH("TextInput", uve, e), { inputProps: r, wrapperProps: a } = n, s = lve(n, ["inputProps", "wrapperProps"]);
  return /* @__PURE__ */ le.createElement(ec.Wrapper, Ck({}, a), /* @__PURE__ */ le.createElement(ec, sve(Ck(Ck({}, r), s), {
    ref: t
  })));
});
HT.displayName = "@mantine/core/TextInput";
const FW = C.createContext(!1), cve = FW.Provider, dve = () => C.useContext(FW);
function zW({ children: e, openDelay: t = 0, closeDelay: n = 0 }) {
  return /* @__PURE__ */ le.createElement(cve, {
    value: !0
  }, /* @__PURE__ */ le.createElement(Hue, {
    delay: { open: t, close: n }
  }, e));
}
zW.displayName = "@mantine/core/TooltipGroup";
var fve = Object.defineProperty, pve = Object.defineProperties, mve = Object.getOwnPropertyDescriptors, zV = Object.getOwnPropertySymbols, hve = Object.prototype.hasOwnProperty, vve = Object.prototype.propertyIsEnumerable, VV = (e, t, n) => t in e ? fve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, UV = (e, t) => {
  for (var n in t || (t = {}))
    hve.call(t, n) && VV(e, n, t[n]);
  if (zV)
    for (var n of zV(t))
      vve.call(t, n) && VV(e, n, t[n]);
  return e;
}, yve = (e, t) => pve(e, mve(t));
function gve(e, t) {
  if (!t)
    return {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[9],
      color: e.white
    };
  const n = e.fn.variant({ variant: "filled", color: t, primaryFallback: !1 });
  return {
    backgroundColor: n.background,
    color: n.color
  };
}
var bve = yn((e, { color: t, radius: n, width: r, multiline: a }) => ({
  tooltip: yve(UV(UV({}, e.fn.fontStyles()), gve(e, t)), {
    lineHeight: e.lineHeight,
    fontSize: e.fontSizes.sm,
    borderRadius: e.fn.radius(n),
    padding: `calc(${e.spacing.xs}px / 2) ${e.spacing.xs}px`,
    position: "absolute",
    whiteSpace: a ? "unset" : "nowrap",
    pointerEvents: "none",
    width: r
  }),
  arrow: {
    backgroundColor: "inherit",
    border: 0,
    zIndex: 1
  }
}));
const VW = bve, UW = {
  children: "Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
};
function wve({
  offset: e,
  position: t
}) {
  const [n, r] = C.useState(!1), a = C.useRef(), { x: s, y: l, reference: p, floating: m, refs: h, update: g, placement: b } = fM({
    placement: t,
    middleware: [
      lM({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), x = b.includes("right") ? e : t.includes("left") ? e * -1 : 0, E = b.includes("bottom") ? e : t.includes("top") ? e * -1 : 0, O = C.useCallback(({ clientX: _, clientY: P }) => {
    p({
      getBoundingClientRect() {
        return {
          width: 0,
          height: 0,
          x: _,
          y: P,
          left: _ + x,
          top: P + E,
          right: _,
          bottom: P
        };
      }
    });
  }, [p]);
  return C.useEffect(() => {
    if (h.floating.current) {
      const _ = a.current;
      _.addEventListener("mousemove", O);
      const P = ed(h.floating.current);
      return P.forEach((M) => {
        M.addEventListener("scroll", g);
      }), () => {
        _.removeEventListener("mousemove", O), P.forEach((M) => {
          M.removeEventListener("scroll", g);
        });
      };
    }
  }, [p, h.floating.current, g, O, n]), { handleMouseMove: O, x: s, y: l, opened: n, setOpened: r, boundaryRef: a, floating: m };
}
var xve = Object.defineProperty, Sve = Object.defineProperties, Eve = Object.getOwnPropertyDescriptors, xC = Object.getOwnPropertySymbols, BW = Object.prototype.hasOwnProperty, HW = Object.prototype.propertyIsEnumerable, BV = (e, t, n) => t in e ? xve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Tk = (e, t) => {
  for (var n in t || (t = {}))
    BW.call(t, n) && BV(e, n, t[n]);
  if (xC)
    for (var n of xC(t))
      HW.call(t, n) && BV(e, n, t[n]);
  return e;
}, _k = (e, t) => Sve(e, Eve(t)), Cve = (e, t) => {
  var n = {};
  for (var r in e)
    BW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && xC)
    for (var r of xC(e))
      t.indexOf(r) < 0 && HW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Tve = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  position: "right",
  zIndex: fd("popover")
};
function WW(e) {
  var t;
  const n = vn("TooltipFloating", Tve, e), {
    children: r,
    refProp: a,
    withinPortal: s,
    style: l,
    className: p,
    classNames: m,
    styles: h,
    unstyled: g,
    radius: b,
    color: x,
    label: E,
    offset: O,
    position: _,
    multiline: P,
    width: M,
    zIndex: D,
    disabled: N
  } = n, I = Cve(n, [
    "children",
    "refProp",
    "withinPortal",
    "style",
    "className",
    "classNames",
    "styles",
    "unstyled",
    "radius",
    "color",
    "label",
    "offset",
    "position",
    "multiline",
    "width",
    "zIndex",
    "disabled"
  ]), { handleMouseMove: R, x: j, y: U, opened: q, boundaryRef: J, floating: H, setOpened: Z } = wve({
    offset: O,
    position: _
  }), { classes: re, cx: Y } = VW({ radius: b, color: x, multiline: P, width: M }, { name: "TooltipFloating", classNames: m, styles: h, unstyled: g });
  if (!uw(r))
    throw new Error(UW.children);
  const K = Wf(J, r.ref), Q = (ne) => {
    var ae, se;
    (se = (ae = r.props).onMouseEnter) == null || se.call(ae, ne), R(ne), Z(!0);
  }, te = (ne) => {
    var ae, se;
    (se = (ae = r.props).onMouseLeave) == null || se.call(ae, ne), Z(!1);
  };
  return /* @__PURE__ */ le.createElement(le.Fragment, null, /* @__PURE__ */ le.createElement(dw, {
    withinPortal: s
  }, /* @__PURE__ */ le.createElement(hn, _k(Tk({}, I), {
    ref: H,
    className: Y(re.tooltip, p),
    style: _k(Tk({}, l), {
      zIndex: D,
      display: !N && q ? "block" : "none",
      top: U ?? "",
      left: (t = Math.round(j)) != null ? t : ""
    })
  }), E)), C.cloneElement(r, _k(Tk({}, r.props), {
    [a]: K,
    onMouseEnter: Q,
    onMouseLeave: te
  })));
}
WW.displayName = "@mantine/core/TooltipFloating";
function _ve(e) {
  const [t, n] = C.useState(!1), a = typeof e.opened == "boolean" ? e.opened : t, s = dve(), l = Hf(), { delay: p, currentId: m, setCurrentId: h } = I6(), g = C.useCallback((q) => {
    n(q), q && h(l);
  }, [h, l]), {
    x: b,
    y: x,
    reference: E,
    floating: O,
    context: _,
    refs: P,
    update: M,
    placement: D,
    middlewareData: { arrow: { x: N, y: I } = {} }
  } = fM({
    placement: e.position,
    open: a,
    onOpenChange: g,
    middleware: [
      w6(e.offset),
      lM({ padding: 8 }),
      g6(),
      k6({ element: e.arrowRef, padding: e.arrowOffset }),
      ...e.inline ? [b6()] : []
    ]
  }), { getReferenceProps: R, getFloatingProps: j } = nce([
    Bue(_, {
      enabled: e.events.hover,
      delay: s ? p : { open: e.openDelay, close: e.closeDelay },
      mouseOnly: !e.events.touch
    }),
    ece(_, { enabled: e.events.focus, keyboardOnly: !0 }),
    tce(_, { role: "tooltip" }),
    Jue(_, { enabled: typeof e.opened === void 0 }),
    Wue(_, { id: l })
  ]);
  return j6({
    opened: a,
    positionDependencies: e.positionDependencies,
    floating: { refs: P, update: M }
  }), Xs(() => {
    var q;
    (q = e.onPositionChange) == null || q.call(e, D);
  }, [D]), {
    x: b,
    y: x,
    arrowX: N,
    arrowY: I,
    reference: E,
    floating: O,
    getFloatingProps: j,
    getReferenceProps: R,
    isGroupPhase: a && m && m !== l,
    opened: a,
    placement: D
  };
}
var Ove = Object.defineProperty, Pve = Object.defineProperties, Rve = Object.getOwnPropertyDescriptors, SC = Object.getOwnPropertySymbols, YW = Object.prototype.hasOwnProperty, qW = Object.prototype.propertyIsEnumerable, HV = (e, t, n) => t in e ? Ove(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Jb = (e, t) => {
  for (var n in t || (t = {}))
    YW.call(t, n) && HV(e, n, t[n]);
  if (SC)
    for (var n of SC(t))
      qW.call(t, n) && HV(e, n, t[n]);
  return e;
}, kve = (e, t) => Pve(e, Rve(t)), Dve = (e, t) => {
  var n = {};
  for (var r in e)
    YW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && SC)
    for (var r of SC(e))
      t.indexOf(r) < 0 && qW.call(e, r) && (n[r] = e[r]);
  return n;
};
const $ve = {
  position: "top",
  refProp: "ref",
  withinPortal: !1,
  inline: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transition: "fade",
  transitionDuration: 100,
  width: "auto",
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: fd("popover"),
  positionDependencies: []
}, WT = C.forwardRef((e, t) => {
  const n = C.useRef(null), r = vn("Tooltip", $ve, e), {
    children: a,
    position: s,
    refProp: l,
    label: p,
    openDelay: m,
    closeDelay: h,
    onPositionChange: g,
    opened: b,
    withinPortal: x,
    radius: E,
    color: O,
    classNames: _,
    styles: P,
    unstyled: M,
    style: D,
    className: N,
    withArrow: I,
    arrowSize: R,
    arrowOffset: j,
    arrowRadius: U,
    arrowPosition: q,
    offset: J,
    transition: H,
    transitionDuration: Z,
    multiline: re,
    width: Y,
    events: K,
    zIndex: Q,
    disabled: te,
    positionDependencies: ne,
    onClick: ae,
    onMouseEnter: se,
    onMouseLeave: V,
    inline: ee
  } = r, he = Dve(r, [
    "children",
    "position",
    "refProp",
    "label",
    "openDelay",
    "closeDelay",
    "onPositionChange",
    "opened",
    "withinPortal",
    "radius",
    "color",
    "classNames",
    "styles",
    "unstyled",
    "style",
    "className",
    "withArrow",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "offset",
    "transition",
    "transitionDuration",
    "multiline",
    "width",
    "events",
    "zIndex",
    "disabled",
    "positionDependencies",
    "onClick",
    "onMouseEnter",
    "onMouseLeave",
    "inline"
  ]), { classes: ue, cx: fe, theme: Ce } = VW({ radius: E, color: O, width: Y, multiline: re }, { name: "Tooltip", classNames: _, styles: P, unstyled: M }), Se = _ve({
    position: Q6(Ce.dir, s),
    closeDelay: h,
    openDelay: m,
    onPositionChange: g,
    opened: b,
    events: K,
    arrowRef: n,
    arrowOffset: j,
    offset: J + (I ? R / 2 : 0),
    positionDependencies: [...ne, a],
    inline: ee
  });
  if (!uw(a))
    throw new Error(UW.children);
  const Te = Wf(Se.reference, a.ref, t);
  return /* @__PURE__ */ le.createElement(le.Fragment, null, /* @__PURE__ */ le.createElement(dw, {
    withinPortal: x
  }, /* @__PURE__ */ le.createElement(UT, {
    mounted: !te && Se.opened,
    transition: H,
    duration: Se.isGroupPhase ? 10 : Z
  }, (pe) => {
    var ye, Oe;
    return /* @__PURE__ */ le.createElement(hn, Jb(Jb({}, he), Se.getFloatingProps({
      ref: Se.floating,
      className: ue.tooltip,
      style: kve(Jb(Jb({}, D), pe), {
        zIndex: Q,
        top: (ye = Se.y) != null ? ye : 0,
        left: (Oe = Se.x) != null ? Oe : 0
      })
    })), p, /* @__PURE__ */ le.createElement(pM, {
      ref: n,
      arrowX: Se.arrowX,
      arrowY: Se.arrowY,
      visible: I,
      withBorder: !1,
      position: Se.placement,
      arrowSize: R,
      arrowOffset: j,
      arrowRadius: U,
      arrowPosition: q,
      className: ue.arrow
    }));
  })), C.cloneElement(a, Se.getReferenceProps(Jb({
    onClick: ae,
    onMouseEnter: se,
    onMouseLeave: V,
    onMouseMove: e.onMouseMove,
    onPointerDown: e.onPointerDown,
    onPointerEnter: e.onPointerEnter,
    [l]: Te,
    className: fe(N, a.props.className)
  }, a.props))));
});
WT.Group = zW;
WT.Floating = WW;
WT.displayName = "@mantine/core/Tooltip";
const $m = WT;
function Mve({
  data: e,
  searchable: t,
  limit: n,
  searchValue: r,
  filter: a,
  value: s,
  filterDataOnExactSearchMatch: l
}) {
  if (!t)
    return e;
  const p = s != null && e.find((h) => h.value === s) || null;
  if (p && !l && (p == null ? void 0 : p.label) === r) {
    if (n) {
      if (n >= e.length)
        return e;
      const h = e.indexOf(p), g = h + n, b = g - e.length;
      return b > 0 ? e.slice(h - b) : e.slice(h, g);
    }
    return e;
  }
  const m = [];
  for (let h = 0; h < e.length && (a(r, e[h]) && m.push(e[h]), !(m.length >= n)); h += 1)
    ;
  return m;
}
var Nve = yn(() => ({
  input: {
    "&:not(:disabled)": {
      cursor: "pointer",
      "&::selection": {
        backgroundColor: "transparent"
      }
    }
  }
}));
const Ive = Nve;
var Ave = Object.defineProperty, jve = Object.defineProperties, Lve = Object.getOwnPropertyDescriptors, EC = Object.getOwnPropertySymbols, GW = Object.prototype.hasOwnProperty, KW = Object.prototype.propertyIsEnumerable, WV = (e, t, n) => t in e ? Ave(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, e0 = (e, t) => {
  for (var n in t || (t = {}))
    GW.call(t, n) && WV(e, n, t[n]);
  if (EC)
    for (var n of EC(t))
      KW.call(t, n) && WV(e, n, t[n]);
  return e;
}, Ok = (e, t) => jve(e, Lve(t)), Fve = (e, t) => {
  var n = {};
  for (var r in e)
    GW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && EC)
    for (var r of EC(e))
      t.indexOf(r) < 0 && KW.call(e, r) && (n[r] = e[r]);
  return n;
};
function zve(e, t) {
  return t.label.toLowerCase().trim().includes(e.toLowerCase().trim());
}
function Vve(e, t) {
  return !!e && !t.some((n) => n.label.toLowerCase() === e.toLowerCase());
}
const Uve = {
  required: !1,
  size: "sm",
  shadow: "sm",
  itemComponent: rM,
  transition: "fade",
  transitionDuration: 0,
  initiallyOpened: !1,
  filter: zve,
  maxDropdownHeight: 220,
  searchable: !1,
  clearable: !1,
  limit: 1 / 0,
  disabled: !1,
  creatable: !1,
  shouldCreate: Vve,
  selectOnBlur: !1,
  switchDirectionOnFlip: !1,
  filterDataOnExactSearchMatch: !1,
  zIndex: fd("popover"),
  clearButtonTabIndex: 0,
  positionDependencies: [],
  dropdownPosition: "flip"
}, Dy = C.forwardRef((e, t) => {
  const n = nH("Select", Uve, e), {
    inputProps: r,
    wrapperProps: a,
    shadow: s,
    data: l,
    value: p,
    defaultValue: m,
    onChange: h,
    itemComponent: g,
    onKeyDown: b,
    onBlur: x,
    onFocus: E,
    transition: O,
    transitionDuration: _,
    initiallyOpened: P,
    transitionTimingFunction: M,
    unstyled: D,
    classNames: N,
    styles: I,
    filter: R,
    maxDropdownHeight: j,
    searchable: U,
    clearable: q,
    nothingFound: J,
    clearButtonLabel: H,
    limit: Z,
    disabled: re,
    onSearchChange: Y,
    searchValue: K,
    rightSection: Q,
    rightSectionWidth: te,
    creatable: ne,
    getCreateLabel: ae,
    shouldCreate: se,
    selectOnBlur: V,
    onCreate: ee,
    dropdownComponent: he,
    onDropdownClose: ue,
    onDropdownOpen: fe,
    withinPortal: Ce,
    switchDirectionOnFlip: Se,
    zIndex: Te,
    name: pe,
    dropdownPosition: ye,
    allowDeselect: Oe,
    placeholder: Fe,
    filterDataOnExactSearchMatch: me,
    clearButtonTabIndex: Pe,
    form: Ee,
    positionDependencies: Ke,
    readOnly: oe,
    hoverOnSearchChange: de
  } = n, we = Fve(n, [
    "inputProps",
    "wrapperProps",
    "shadow",
    "data",
    "value",
    "defaultValue",
    "onChange",
    "itemComponent",
    "onKeyDown",
    "onBlur",
    "onFocus",
    "transition",
    "transitionDuration",
    "initiallyOpened",
    "transitionTimingFunction",
    "unstyled",
    "classNames",
    "styles",
    "filter",
    "maxDropdownHeight",
    "searchable",
    "clearable",
    "nothingFound",
    "clearButtonLabel",
    "limit",
    "disabled",
    "onSearchChange",
    "searchValue",
    "rightSection",
    "rightSectionWidth",
    "creatable",
    "getCreateLabel",
    "shouldCreate",
    "selectOnBlur",
    "onCreate",
    "dropdownComponent",
    "onDropdownClose",
    "onDropdownOpen",
    "withinPortal",
    "switchDirectionOnFlip",
    "zIndex",
    "name",
    "dropdownPosition",
    "allowDeselect",
    "placeholder",
    "filterDataOnExactSearchMatch",
    "clearButtonTabIndex",
    "form",
    "positionDependencies",
    "readOnly",
    "hoverOnSearchChange"
  ]), { classes: Me, cx: Ae, theme: je } = Ive(), [qe, ot] = C.useState(P), [et, ct] = C.useState(-1), Qt = C.useRef(), Ht = C.useRef({}), [kt, St] = C.useState("column"), cn = kt === "column", { scrollIntoView: Ne, targetRef: Ie, scrollableRef: Je } = y4({
    duration: 0,
    offset: 5,
    cancelable: !1,
    isList: !0
  }), pt = Oe === void 0 ? q : Oe, ht = (it) => {
    if (qe !== it) {
      ot(it);
      const nt = it ? fe : ue;
      typeof nt == "function" && nt();
    }
  }, vt = ne && typeof ae == "function";
  let Nt = null;
  const Tn = l.map((it) => typeof it == "string" ? { label: it, value: it } : it), bt = J3({ data: Tn }), [Pn, wn, Cn] = Ju({
    value: p,
    defaultValue: m,
    finalValue: null,
    onChange: h
  }), ar = bt.find((it) => it.value === Pn), [ir, go] = Ju({
    value: K,
    defaultValue: (ar == null ? void 0 : ar.label) || "",
    finalValue: void 0,
    onChange: Y
  }), Kr = (it) => {
    go(it), U && typeof Y == "function" && Y(it);
  }, xr = () => {
    var it;
    oe || (wn(null), Cn || Kr(""), (it = Qt.current) == null || it.focus());
  };
  C.useEffect(() => {
    const it = bt.find((nt) => nt.value === Pn);
    it ? Kr(it.label) : (!vt || !Pn) && Kr("");
  }, [Pn]), C.useEffect(() => {
    ar && (!U || !qe) && Kr(ar.label);
  }, [ar == null ? void 0 : ar.label]);
  const Ln = (it) => {
    if (!oe)
      if (pt && (ar == null ? void 0 : ar.value) === it.value)
        wn(null), ht(!1);
      else {
        if (it.creatable && typeof ee == "function") {
          const nt = ee(it.value);
          typeof nt < "u" && nt !== null && wn(typeof nt == "string" ? nt : nt.value);
        } else
          wn(it.value);
        Cn || Kr(it.label), ct(-1), ht(!1), Qt.current.focus();
      }
  }, Dn = Mve({
    data: bt,
    searchable: U,
    limit: Z,
    searchValue: ir,
    filter: R,
    filterDataOnExactSearchMatch: me,
    value: Pn
  });
  vt && se(ir, Dn) && (Nt = ae(ir), Dn.push({ label: ir, value: ir, creatable: !0 }));
  const Yn = (it, nt, ge) => {
    let $e = it;
    for (; ge($e); )
      if ($e = nt($e), !Dn[$e].disabled)
        return $e;
    return it;
  };
  Xs(() => {
    ct(de && ir ? 0 : -1);
  }, [ir, de]);
  const Jr = Pn ? Dn.findIndex((it) => it.value === Pn) : 0, dr = !oe && (Dn.length > 0 ? qe : qe && !!J), Dr = () => {
    ct((it) => {
      var nt;
      const ge = Yn(it, ($e) => $e - 1, ($e) => $e > 0);
      return Ie.current = Ht.current[(nt = Dn[ge]) == null ? void 0 : nt.value], dr && Ne({ alignment: cn ? "start" : "end" }), ge;
    });
  }, Fr = () => {
    ct((it) => {
      var nt;
      const ge = Yn(it, ($e) => $e + 1, ($e) => $e < Dn.length - 1);
      return Ie.current = Ht.current[(nt = Dn[ge]) == null ? void 0 : nt.value], dr && Ne({ alignment: cn ? "end" : "start" }), ge;
    });
  }, zr = () => window.setTimeout(() => {
    var it;
    Ie.current = Ht.current[(it = Dn[Jr]) == null ? void 0 : it.value], Ne({ alignment: cn ? "end" : "start" });
  }, 0);
  Xs(() => {
    dr && zr();
  }, [dr]);
  const Vr = (it) => {
    switch (typeof b == "function" && b(it), it.key) {
      case "ArrowUp": {
        it.preventDefault(), qe ? cn ? Dr() : Fr() : (ct(Jr), ht(!0), zr());
        break;
      }
      case "ArrowDown": {
        it.preventDefault(), qe ? cn ? Fr() : Dr() : (ct(Jr), ht(!0), zr());
        break;
      }
      case "Home": {
        if (!U) {
          it.preventDefault(), qe || ht(!0);
          const nt = Dn.findIndex((ge) => !ge.disabled);
          ct(nt), dr && Ne({ alignment: cn ? "end" : "start" });
        }
        break;
      }
      case "End": {
        if (!U) {
          it.preventDefault(), qe || ht(!0);
          const nt = Dn.map((ge) => !!ge.disabled).lastIndexOf(!1);
          ct(nt), dr && Ne({ alignment: cn ? "end" : "start" });
        }
        break;
      }
      case "Escape": {
        it.preventDefault(), ht(!1), ct(-1);
        break;
      }
      case " ": {
        U || (it.preventDefault(), Dn[et] && qe ? Ln(Dn[et]) : (ht(!0), ct(Jr), zr()));
        break;
      }
      case "Enter":
        U || it.preventDefault(), Dn[et] && qe && (it.preventDefault(), Ln(Dn[et]));
    }
  }, be = (it) => {
    typeof x == "function" && x(it);
    const nt = bt.find((ge) => ge.value === Pn);
    V && Dn[et] && qe && Ln(Dn[et]), Kr((nt == null ? void 0 : nt.label) || ""), ht(!1);
  }, at = (it) => {
    typeof E == "function" && E(it), U && ht(!0);
  }, wt = (it) => {
    oe || (Kr(it.currentTarget.value), q && it.currentTarget.value === "" && wn(null), ct(-1), ht(!0));
  }, Tt = () => {
    oe || (ht(!qe), Pn && !qe && ct(Jr));
  };
  return /* @__PURE__ */ le.createElement(ec.Wrapper, Ok(e0({}, a), {
    __staticSelector: "Select"
  }), /* @__PURE__ */ le.createElement(Nf, {
    opened: dr,
    transition: O,
    transitionDuration: _,
    shadow: "sm",
    withinPortal: Ce,
    __staticSelector: "Select",
    onDirectionChange: St,
    switchDirectionOnFlip: Se,
    zIndex: Te,
    dropdownPosition: ye,
    positionDependencies: [...Ke, ir],
    classNames: N,
    styles: I,
    unstyled: D
  }, /* @__PURE__ */ le.createElement(Nf.Target, null, /* @__PURE__ */ le.createElement("div", {
    role: "combobox",
    "aria-haspopup": "listbox",
    "aria-owns": dr ? `${r.id}-items` : null,
    "aria-controls": r.id,
    "aria-expanded": dr,
    onMouseLeave: () => ct(-1),
    tabIndex: -1
  }, /* @__PURE__ */ le.createElement("input", {
    type: "hidden",
    name: pe,
    value: Pn || "",
    form: Ee,
    disabled: re
  }), /* @__PURE__ */ le.createElement(ec, e0(Ok(e0(e0({
    autoComplete: "off",
    type: "search"
  }, r), we), {
    ref: Wf(t, Qt),
    onKeyDown: Vr,
    __staticSelector: "Select",
    value: ir,
    placeholder: Fe,
    onChange: wt,
    "aria-autocomplete": "list",
    "aria-controls": dr ? `${r.id}-items` : null,
    "aria-activedescendant": et >= 0 ? `${r.id}-${et}` : null,
    onMouseDown: Tt,
    onBlur: be,
    onFocus: at,
    readOnly: !U || oe,
    disabled: re,
    "data-mantine-stop-propagation": dr,
    name: null,
    classNames: Ok(e0({}, N), {
      input: Ae({ [Me.input]: !U }, N == null ? void 0 : N.input)
    })
  }), NW({
    theme: je,
    rightSection: Q,
    rightSectionWidth: te,
    styles: I,
    size: r.size,
    shouldClear: q && !!ar,
    clearButtonLabel: H,
    onClear: xr,
    error: a.error,
    clearButtonTabIndex: Pe,
    disabled: re,
    readOnly: oe
  }))))), /* @__PURE__ */ le.createElement(Nf.Dropdown, {
    component: he || FT,
    maxHeight: j,
    direction: kt,
    id: r.id,
    innerRef: Je,
    __staticSelector: "Select",
    classNames: N,
    styles: I
  }, /* @__PURE__ */ le.createElement(nM, {
    data: Dn,
    hovered: et,
    classNames: N,
    styles: I,
    isItemSelected: (it) => it === Pn,
    uuid: r.id,
    __staticSelector: "Select",
    onItemHover: ct,
    onItemSelect: Ln,
    itemsRefs: Ht,
    itemComponent: g,
    size: r.size,
    nothingFound: J,
    creatable: vt && !!Nt,
    createLabel: Nt,
    "aria-label": a.label,
    unstyled: D
  }))));
});
Dy.displayName = "@mantine/core/Select";
const Bve = dd({
  "from, to": { opacity: 0.4 },
  "50%": { opacity: 1 }
});
var Hve = yn((e, { height: t, width: n, radius: r, circle: a, animate: s }) => ({
  root: {
    height: t,
    width: a ? t : n,
    borderRadius: a ? t : e.fn.radius(r),
    position: "relative",
    WebkitTransform: "translateZ(0)"
  },
  visible: {
    overflow: "hidden",
    "&::before": {
      content: '""',
      position: "absolute",
      background: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      zIndex: 10
    },
    "&::after": {
      content: '""',
      position: "absolute",
      background: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3],
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      animation: s ? `${Bve} 1500ms linear infinite` : "none",
      zIndex: 11
    }
  }
}));
const Wve = Hve;
var Yve = Object.defineProperty, CC = Object.getOwnPropertySymbols, XW = Object.prototype.hasOwnProperty, QW = Object.prototype.propertyIsEnumerable, YV = (e, t, n) => t in e ? Yve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, qve = (e, t) => {
  for (var n in t || (t = {}))
    XW.call(t, n) && YV(e, n, t[n]);
  if (CC)
    for (var n of CC(t))
      QW.call(t, n) && YV(e, n, t[n]);
  return e;
}, Gve = (e, t) => {
  var n = {};
  for (var r in e)
    XW.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && CC)
    for (var r of CC(e))
      t.indexOf(r) < 0 && QW.call(e, r) && (n[r] = e[r]);
  return n;
};
const Kve = {
  height: "auto",
  width: "100%",
  visible: !0,
  animate: !0
}, ZW = C.forwardRef((e, t) => {
  const n = vn("Skeleton", Kve, e), { height: r, width: a, visible: s, animate: l, className: p, circle: m, radius: h, unstyled: g } = n, b = Gve(n, ["height", "width", "visible", "animate", "className", "circle", "radius", "unstyled"]), { classes: x, cx: E } = Wve({ height: r, width: a, circle: m, radius: h, animate: l }, { unstyled: g, name: "Skeleton" });
  return /* @__PURE__ */ le.createElement(hn, qve({
    className: E(x.root, { [x.visible]: s }, p),
    ref: t
  }, b));
});
ZW.displayName = "@mantine/core/Skeleton";
const JW = C.createContext(null), Xve = JW.Provider, Qve = () => C.useContext(JW);
var Zve = Object.defineProperty, TC = Object.getOwnPropertySymbols, e8 = Object.prototype.hasOwnProperty, t8 = Object.prototype.propertyIsEnumerable, qV = (e, t, n) => t in e ? Zve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, GV = (e, t) => {
  for (var n in t || (t = {}))
    e8.call(t, n) && qV(e, n, t[n]);
  if (TC)
    for (var n of TC(t))
      t8.call(t, n) && qV(e, n, t[n]);
  return e;
}, Jve = (e, t) => {
  var n = {};
  for (var r in e)
    e8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && TC)
    for (var r of TC(e))
      t.indexOf(r) < 0 && t8.call(e, r) && (n[r] = e[r]);
  return n;
};
const eye = {
  orientation: "horizontal",
  spacing: "lg",
  size: "sm",
  offset: "xs"
}, n8 = C.forwardRef((e, t) => {
  const n = vn("SwitchGroup", eye, e), {
    children: r,
    value: a,
    defaultValue: s,
    onChange: l,
    orientation: p,
    spacing: m,
    size: h,
    wrapperProps: g,
    offset: b
  } = n, x = Jve(n, [
    "children",
    "value",
    "defaultValue",
    "onChange",
    "orientation",
    "spacing",
    "size",
    "wrapperProps",
    "offset"
  ]), [E, O] = Ju({
    value: a,
    defaultValue: s,
    finalValue: [],
    onChange: l
  }), _ = (P) => {
    const M = P.currentTarget.value;
    O(E.includes(M) ? E.filter((D) => D !== M) : [...E, M]);
  };
  return /* @__PURE__ */ le.createElement(Xve, {
    value: { value: E, onChange: _, size: h }
  }, /* @__PURE__ */ le.createElement(ec.Wrapper, GV(GV({
    labelElement: "div",
    size: h,
    __staticSelector: "SwitchGroup",
    ref: t
  }, g), x), /* @__PURE__ */ le.createElement($H, {
    spacing: m,
    orientation: p,
    offset: b
  }, r)));
});
n8.displayName = "@mantine/core/SwitchGroup";
var tye = Object.defineProperty, nye = Object.defineProperties, rye = Object.getOwnPropertyDescriptors, KV = Object.getOwnPropertySymbols, oye = Object.prototype.hasOwnProperty, aye = Object.prototype.propertyIsEnumerable, XV = (e, t, n) => t in e ? tye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, iye = (e, t) => {
  for (var n in t || (t = {}))
    oye.call(t, n) && XV(e, n, t[n]);
  if (KV)
    for (var n of KV(t))
      aye.call(t, n) && XV(e, n, t[n]);
  return e;
}, sye = (e, t) => nye(e, rye(t));
const lye = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
}, uye = {
  xs: 32,
  sm: 38,
  md: 46,
  lg: 56,
  xl: 72
}, cye = {
  xs: 12,
  sm: 14,
  md: 18,
  lg: 22,
  xl: 28
}, dye = {
  xs: 5,
  sm: 6,
  md: 7,
  lg: 9,
  xl: 11
}, fye = {
  xs: 4,
  sm: 5,
  md: 6,
  lg: 8,
  xl: 10
};
var pye = yn((e, { size: t, radius: n, color: r, labelPosition: a, error: s }) => {
  const l = e.fn.size({ size: t, sizes: cye }), p = e.fn.size({ size: n, sizes: e.radius }), m = e.fn.variant({ variant: "filled", color: r }), h = e.fn.size({ size: t, sizes: uye }), g = t === "xs" ? 1 : 2, b = e.fn.variant({ variant: "filled", color: "red" }).background;
  return {
    input: {
      clip: "rect(1px, 1px, 1px, 1px)",
      height: 0,
      width: 0,
      overflow: "hidden",
      whiteSpace: "nowrap",
      padding: 0,
      WebkitClipPath: "inset(50%)",
      clipPath: "inset(50%)",
      position: "absolute"
    },
    track: sye(iye({}, e.fn.focusStyles("input:focus + &")), {
      cursor: e.cursorType,
      overflow: "hidden",
      WebkitTapHighlightColor: "transparent",
      position: "relative",
      borderRadius: p,
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[2],
      border: `1px solid ${s ? b : e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}`,
      height: e.fn.size({ size: t, sizes: lye }),
      minWidth: h,
      margin: 0,
      transitionProperty: "background-color, border-color",
      transitionTimingFunction: e.transitionTimingFunction,
      transitionDuration: "150ms",
      boxSizing: "border-box",
      appearance: "none",
      display: "flex",
      alignItems: "center",
      fontSize: e.fn.size({ size: t, sizes: dye }),
      fontWeight: 600,
      order: a === "left" ? 2 : 1,
      userSelect: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none",
      MsUserSelect: "none",
      zIndex: 0,
      lineHeight: 0,
      color: e.colorScheme === "dark" ? e.colors.dark[1] : e.colors.gray[6],
      transition: `color 150ms ${e.transitionTimingFunction}`,
      "input:checked + &": {
        backgroundColor: m.background,
        borderColor: m.background,
        color: e.white,
        transition: `color 150ms ${e.transitionTimingFunction}`
      },
      "input:disabled + &": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        cursor: "not-allowed"
      }
    }),
    thumb: {
      position: "absolute",
      zIndex: 1,
      borderRadius: p,
      boxSizing: "border-box",
      display: "flex",
      backgroundColor: e.white,
      height: l,
      width: l,
      border: `1px solid ${e.colorScheme === "dark" ? e.white : e.colors.gray[3]}`,
      left: `${g}px`,
      transition: `left 150ms ${e.transitionTimingFunction}`,
      "& > *": {
        margin: "auto"
      },
      "@media (prefers-reduced-motion)": {
        transitionDuration: e.respectReducedMotion ? "0ms" : ""
      },
      "input:checked + * > &": {
        left: `calc(100% - ${l}px - ${g}px)`,
        borderColor: e.white
      },
      "input:disabled + * > &": {
        borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[0]
      }
    },
    trackLabel: {
      height: "100%",
      display: "grid",
      placeContent: "center",
      minWidth: h - l,
      paddingInline: e.fn.size({ size: t, sizes: fye }),
      margin: `0 0 0 ${l + g}px`,
      transition: `margin 150ms ${e.transitionTimingFunction}`,
      "input:checked + * > &": {
        margin: `0 ${l + g}px 0 0`
      }
    }
  };
});
const mye = pye;
var hye = Object.defineProperty, vye = Object.defineProperties, yye = Object.getOwnPropertyDescriptors, _C = Object.getOwnPropertySymbols, r8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.propertyIsEnumerable, QV = (e, t, n) => t in e ? hye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Pk = (e, t) => {
  for (var n in t || (t = {}))
    r8.call(t, n) && QV(e, n, t[n]);
  if (_C)
    for (var n of _C(t))
      o8.call(t, n) && QV(e, n, t[n]);
  return e;
}, gye = (e, t) => vye(e, yye(t)), bye = (e, t) => {
  var n = {};
  for (var r in e)
    r8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && _C)
    for (var r of _C(e))
      t.indexOf(r) < 0 && o8.call(e, r) && (n[r] = e[r]);
  return n;
};
const wye = {
  offLabel: "",
  onLabel: "",
  size: "sm",
  radius: "xl",
  error: !1
}, Hv = C.forwardRef((e, t) => {
  var n;
  const r = vn("Switch", wye, e), {
    className: a,
    color: s,
    label: l,
    offLabel: p,
    onLabel: m,
    id: h,
    style: g,
    size: b,
    radius: x,
    wrapperProps: E,
    children: O,
    unstyled: _,
    styles: P,
    classNames: M,
    thumbIcon: D,
    sx: N,
    checked: I,
    defaultChecked: R,
    onChange: j,
    labelPosition: U,
    description: q,
    error: J,
    disabled: H
  } = r, Z = bye(r, [
    "className",
    "color",
    "label",
    "offLabel",
    "onLabel",
    "id",
    "style",
    "size",
    "radius",
    "wrapperProps",
    "children",
    "unstyled",
    "styles",
    "classNames",
    "thumbIcon",
    "sx",
    "checked",
    "defaultChecked",
    "onChange",
    "labelPosition",
    "description",
    "error",
    "disabled"
  ]), re = Qve(), { classes: Y } = mye({ size: (re == null ? void 0 : re.size) || b, color: s, radius: x, labelPosition: U, error: !!J }, { unstyled: _, styles: P, classNames: M, name: "Switch" }), { systemStyles: K, rest: Q } = Oy(Z), te = Hf(h), ne = re ? {
    checked: re.value.includes(Q.value),
    onChange: re.onChange
  } : {}, [ae, se] = Ju({
    value: (n = ne.checked) != null ? n : I,
    defaultValue: R,
    finalValue: !1
  });
  return /* @__PURE__ */ le.createElement(gM, Pk(Pk({
    className: a,
    sx: N,
    style: g,
    id: te,
    size: (re == null ? void 0 : re.size) || b,
    labelPosition: U,
    label: l,
    description: q,
    error: J,
    disabled: H,
    __staticSelector: "Switch",
    classNames: M,
    styles: P,
    unstyled: _,
    "data-checked": ne.checked || void 0
  }, K), E), /* @__PURE__ */ le.createElement("input", gye(Pk({}, Q), {
    disabled: H,
    checked: ae,
    onChange: (V) => {
      re ? ne.onChange(V) : j == null || j(V), se(V.currentTarget.checked);
    },
    id: te,
    ref: t,
    type: "checkbox",
    className: Y.input
  })), /* @__PURE__ */ le.createElement("label", {
    htmlFor: te,
    className: Y.track
  }, /* @__PURE__ */ le.createElement("div", {
    className: Y.thumb
  }, D), /* @__PURE__ */ le.createElement("div", {
    className: Y.trackLabel
  }, ae ? m : p)));
});
Hv.displayName = "@mantine/core/Switch";
Hv.Group = n8;
var xye = Object.defineProperty, Sye = Object.defineProperties, Eye = Object.getOwnPropertyDescriptors, ZV = Object.getOwnPropertySymbols, Cye = Object.prototype.hasOwnProperty, Tye = Object.prototype.propertyIsEnumerable, JV = (e, t, n) => t in e ? xye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, _ye = (e, t) => {
  for (var n in t || (t = {}))
    Cye.call(t, n) && JV(e, n, t[n]);
  if (ZV)
    for (var n of ZV(t))
      Tye.call(t, n) && JV(e, n, t[n]);
  return e;
}, Oye = (e, t) => Sye(e, Eye(t)), Pye = yn((e, {
  captionSide: t,
  horizontalSpacing: n,
  verticalSpacing: r,
  fontSize: a,
  withBorder: s,
  withColumnBorders: l
}) => {
  const p = `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}`;
  return {
    root: Oye(_ye({}, e.fn.fontStyles()), {
      width: "100%",
      borderCollapse: "collapse",
      captionSide: t,
      color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
      lineHeight: e.lineHeight,
      border: s ? p : "",
      "& caption": {
        marginTop: t === "top" ? 0 : e.spacing.xs,
        marginBottom: t === "bottom" ? 0 : e.spacing.xs,
        fontSize: e.fontSizes.sm,
        color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6]
      },
      "& thead tr th, & tfoot tr th, & tbody tr th": {
        textAlign: "left",
        fontWeight: "bold",
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
        fontSize: e.fn.size({ size: a, sizes: e.fontSizes }),
        padding: `${e.fn.size({
          size: r,
          sizes: e.spacing
        })}px ${e.fn.size({ size: n, sizes: e.spacing })}px`
      },
      "& thead tr th": {
        borderBottom: p
      },
      "& tfoot tr th, & tbody tr th": {
        borderTop: p
      },
      "& tbody tr td": {
        padding: `${e.fn.size({
          size: r,
          sizes: e.spacing
        })}px ${e.fn.size({ size: n, sizes: e.spacing })}px`,
        borderTop: p,
        fontSize: e.fn.size({ size: a, sizes: e.fontSizes })
      },
      "& tbody tr:first-of-type td, & tbody tr:first-of-type th": {
        borderTop: "none"
      },
      "& thead th, & tbody td": {
        borderRight: l ? p : "none",
        "&:last-of-type": {
          borderRight: "none",
          borderLeft: l ? p : "none"
        }
      },
      "& tbody tr th": {
        borderRight: l ? p : "none"
      },
      "&[data-striped] tbody tr:nth-of-type(odd)": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
      },
      "&[data-hover] tbody tr": e.fn.hover({
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1]
      })
    })
  };
});
const Rye = Pye;
var kye = Object.defineProperty, Dye = Object.defineProperties, $ye = Object.getOwnPropertyDescriptors, OC = Object.getOwnPropertySymbols, a8 = Object.prototype.hasOwnProperty, i8 = Object.prototype.propertyIsEnumerable, e5 = (e, t, n) => t in e ? kye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Mye = (e, t) => {
  for (var n in t || (t = {}))
    a8.call(t, n) && e5(e, n, t[n]);
  if (OC)
    for (var n of OC(t))
      i8.call(t, n) && e5(e, n, t[n]);
  return e;
}, Nye = (e, t) => Dye(e, $ye(t)), Iye = (e, t) => {
  var n = {};
  for (var r in e)
    a8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && OC)
    for (var r of OC(e))
      t.indexOf(r) < 0 && i8.call(e, r) && (n[r] = e[r]);
  return n;
};
const Aye = {
  striped: !1,
  highlightOnHover: !1,
  captionSide: "top",
  horizontalSpacing: "xs",
  fontSize: "sm",
  verticalSpacing: 7,
  withBorder: !1,
  withColumnBorders: !1
}, s8 = C.forwardRef((e, t) => {
  const n = vn("Table", Aye, e), {
    className: r,
    children: a,
    striped: s,
    highlightOnHover: l,
    captionSide: p,
    horizontalSpacing: m,
    verticalSpacing: h,
    fontSize: g,
    unstyled: b,
    withBorder: x,
    withColumnBorders: E
  } = n, O = Iye(n, [
    "className",
    "children",
    "striped",
    "highlightOnHover",
    "captionSide",
    "horizontalSpacing",
    "verticalSpacing",
    "fontSize",
    "unstyled",
    "withBorder",
    "withColumnBorders"
  ]), { classes: _, cx: P } = Rye({ captionSide: p, verticalSpacing: h, horizontalSpacing: m, fontSize: g, withBorder: x, withColumnBorders: E }, { unstyled: b, name: "Table" });
  return /* @__PURE__ */ le.createElement(hn, Nye(Mye({}, O), {
    component: "table",
    ref: t,
    className: P(_.root, r),
    "data-striped": s || void 0,
    "data-hover": l || void 0
  }), a);
});
s8.displayName = "@mantine/core/Table";
const YD = {
  context: "Tabs component was not found in the tree",
  value: "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value"
}, [jye, SM] = $T(YD.context);
var Lye = Object.defineProperty, t5 = Object.getOwnPropertySymbols, Fye = Object.prototype.hasOwnProperty, zye = Object.prototype.propertyIsEnumerable, n5 = (e, t, n) => t in e ? Lye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Vye = (e, t) => {
  for (var n in t || (t = {}))
    Fye.call(t, n) && n5(e, n, t[n]);
  if (t5)
    for (var n of t5(t))
      zye.call(t, n) && n5(e, n, t[n]);
  return e;
};
function Uye({ variant: e, orientation: t, inverted: n, placement: r }, a) {
  const s = t === "vertical";
  return e === "default" ? {
    [s ? r === "left" ? "borderRight" : "borderLeft" : n ? "borderTop" : "borderBottom"]: `2px solid ${a.colorScheme === "dark" ? a.colors.dark[4] : a.colors.gray[3]}`
  } : e === "outline" ? {
    [s ? r === "left" ? "borderRight" : "borderLeft" : n ? "borderTop" : "borderBottom"]: `1px solid ${a.colorScheme === "dark" ? a.colors.dark[4] : a.colors.gray[3]}`
  } : e === "pills" ? {
    gap: `calc(${a.spacing.sm}px / 2)`
  } : {};
}
var Bye = yn((e, t) => {
  const n = t.orientation === "vertical";
  return {
    tabsList: Vye({
      display: "flex",
      flexWrap: "wrap",
      flexDirection: n ? "column" : "row",
      justifyContent: OH[t.position],
      '& [role="tab"]': {
        flex: t.grow ? 1 : void 0
      }
    }, Uye(t, e))
  };
});
const Hye = Bye;
var Wye = Object.defineProperty, Yye = Object.defineProperties, qye = Object.getOwnPropertyDescriptors, PC = Object.getOwnPropertySymbols, l8 = Object.prototype.hasOwnProperty, u8 = Object.prototype.propertyIsEnumerable, r5 = (e, t, n) => t in e ? Wye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Gye = (e, t) => {
  for (var n in t || (t = {}))
    l8.call(t, n) && r5(e, n, t[n]);
  if (PC)
    for (var n of PC(t))
      u8.call(t, n) && r5(e, n, t[n]);
  return e;
}, Kye = (e, t) => Yye(e, qye(t)), Xye = (e, t) => {
  var n = {};
  for (var r in e)
    l8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && PC)
    for (var r of PC(e))
      t.indexOf(r) < 0 && u8.call(e, r) && (n[r] = e[r]);
  return n;
};
const Qye = {
  grow: !1,
  position: "left"
}, c8 = C.forwardRef((e, t) => {
  const n = vn("TabsList", Qye, e), { children: r, className: a, grow: s, position: l } = n, p = Xye(n, ["children", "className", "grow", "position"]), { orientation: m, variant: h, color: g, radius: b, inverted: x, placement: E, classNames: O, styles: _, unstyled: P } = SM(), { classes: M, cx: D } = Hye({ orientation: m, grow: s, variant: h, color: g, position: l, radius: b, inverted: x, placement: E }, { name: "Tabs", unstyled: P, classNames: O, styles: _ });
  return /* @__PURE__ */ le.createElement(hn, Kye(Gye({}, p), {
    className: D(M.tabsList, a),
    ref: t,
    role: "tablist",
    "aria-orientation": m
  }), r);
});
c8.displayName = "@mantine/core/TabsList";
var Zye = yn((e, { orientation: t }) => ({
  panel: {
    flex: t === "vertical" ? 1 : void 0
  }
}));
const Jye = Zye;
var ege = Object.defineProperty, tge = Object.defineProperties, nge = Object.getOwnPropertyDescriptors, RC = Object.getOwnPropertySymbols, d8 = Object.prototype.hasOwnProperty, f8 = Object.prototype.propertyIsEnumerable, o5 = (e, t, n) => t in e ? ege(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, rge = (e, t) => {
  for (var n in t || (t = {}))
    d8.call(t, n) && o5(e, n, t[n]);
  if (RC)
    for (var n of RC(t))
      f8.call(t, n) && o5(e, n, t[n]);
  return e;
}, oge = (e, t) => tge(e, nge(t)), age = (e, t) => {
  var n = {};
  for (var r in e)
    d8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && RC)
    for (var r of RC(e))
      t.indexOf(r) < 0 && f8.call(e, r) && (n[r] = e[r]);
  return n;
};
const ige = {}, p8 = C.forwardRef((e, t) => {
  const n = vn("TabsPanel", ige, e), { value: r, children: a, sx: s, className: l } = n, p = age(n, ["value", "children", "sx", "className"]), m = SM(), { classes: h, cx: g } = Jye({
    orientation: m.orientation,
    variant: m.variant,
    color: m.color,
    radius: m.radius,
    inverted: m.inverted,
    placement: m.placement
  }, { name: "Tabs", unstyled: m.unstyled, classNames: m.classNames, styles: m.styles }), b = m.value === r, x = m.keepMounted || b ? a : null;
  return /* @__PURE__ */ le.createElement(hn, oge(rge({}, p), {
    ref: t,
    sx: [{ display: b ? void 0 : "none" }, ...B0(s)],
    className: g(h.panel, l),
    role: "tabpanel",
    id: m.getPanelId(r),
    "aria-labelledby": m.getTabId(r)
  }), x);
});
p8.displayName = "@mantine/core/TabsPanel";
var sge = Object.defineProperty, lge = Object.defineProperties, uge = Object.getOwnPropertyDescriptors, a5 = Object.getOwnPropertySymbols, cge = Object.prototype.hasOwnProperty, dge = Object.prototype.propertyIsEnumerable, i5 = (e, t, n) => t in e ? sge(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Wv = (e, t) => {
  for (var n in t || (t = {}))
    cge.call(t, n) && i5(e, n, t[n]);
  if (a5)
    for (var n of a5(t))
      dge.call(t, n) && i5(e, n, t[n]);
  return e;
}, s5 = (e, t) => lge(e, uge(t));
function fge(e, { variant: t, orientation: n, color: r, radius: a, inverted: s, placement: l }) {
  const p = n === "vertical", m = e.fn.variant({ color: r, variant: "filled" }), h = e.fn.radius(a), g = n === "vertical" ? l === "left" ? `${h}px 0 0 ${h}px` : ` 0 ${h}px ${h}px 0` : s ? `0 0 ${h}px ${h}px` : `${h}px ${h}px 0 0`;
  return t === "default" ? s5(Wv({
    [p ? l === "left" ? "borderRight" : "borderLeft" : s ? "borderTop" : "borderBottom"]: "2px solid transparent",
    [p ? l === "left" ? "marginRight" : "marginLeft" : s ? "marginTop" : "marginBottom"]: -2,
    borderRadius: g
  }, e.fn.hover({
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
    borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]
  })), {
    "&[data-active]": Wv({
      borderColor: m.background,
      color: e.colorScheme === "dark" ? e.white : e.black
    }, e.fn.hover({ borderColor: m.background }))
  }) : t === "outline" ? {
    borderRadius: g,
    border: "1px solid transparent",
    [p ? l === "left" ? "borderRight" : "borderLeft" : s ? "borderTop" : "borderBottom"]: "none",
    "&[data-active]": {
      borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3],
      "&::before": {
        content: '""',
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
        position: "absolute",
        bottom: p ? 0 : s ? "unset" : -1,
        top: p ? 0 : s ? -1 : "unset",
        [p ? "width" : "height"]: 1,
        right: p ? l === "left" ? -1 : "unset" : 0,
        left: p ? l === "left" ? "unset" : -1 : 0
      }
    }
  } : t === "pills" ? s5(Wv({
    borderRadius: e.fn.radius(a)
  }, e.fn.hover({
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
  })), {
    "&[data-active]": Wv({
      backgroundColor: m.background,
      color: e.white
    }, e.fn.hover({ backgroundColor: m.background }))
  }) : {};
}
var pge = yn((e, t) => ({
  tabLabel: {},
  tab: Wv({
    position: "relative",
    padding: `${e.spacing.xs}px ${e.spacing.md}px`,
    paddingLeft: t.withIcon ? e.spacing.xs : void 0,
    paddingRight: t.withRightSection ? e.spacing.xs : void 0,
    fontSize: e.fontSizes.sm,
    whiteSpace: "nowrap",
    zIndex: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: t.orientation === "horizontal" ? "center" : void 0,
    lineHeight: 1,
    "&:disabled": Wv({
      opacity: 0.5,
      cursor: "not-allowed"
    }, e.fn.hover({ backgroundColor: "transparent" })),
    "&:focus": {
      zIndex: 1
    }
  }, fge(e, t)),
  tabRightSection: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&:not(:only-child)": {
      marginLeft: 7
    }
  },
  tabIcon: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&:not(:only-child)": {
      marginRight: 7
    }
  }
}));
const mge = pge;
var hge = Object.defineProperty, vge = Object.defineProperties, yge = Object.getOwnPropertyDescriptors, kC = Object.getOwnPropertySymbols, m8 = Object.prototype.hasOwnProperty, h8 = Object.prototype.propertyIsEnumerable, l5 = (e, t, n) => t in e ? hge(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, gge = (e, t) => {
  for (var n in t || (t = {}))
    m8.call(t, n) && l5(e, n, t[n]);
  if (kC)
    for (var n of kC(t))
      h8.call(t, n) && l5(e, n, t[n]);
  return e;
}, bge = (e, t) => vge(e, yge(t)), wge = (e, t) => {
  var n = {};
  for (var r in e)
    m8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && kC)
    for (var r of kC(e))
      t.indexOf(r) < 0 && h8.call(e, r) && (n[r] = e[r]);
  return n;
};
const xge = {}, v8 = C.forwardRef((e, t) => {
  const n = vn("TabsTab", xge, e), { value: r, children: a, onKeyDown: s, onClick: l, className: p, icon: m, rightSection: h, color: g } = n, b = wge(n, ["value", "children", "onKeyDown", "onClick", "className", "icon", "rightSection", "color"]), x = SM(), E = !!m, O = !!h, { theme: _, classes: P, cx: M } = mge({
    withIcon: E || O && !a,
    withRightSection: O || E && !a,
    orientation: x.orientation,
    color: g || x.color,
    variant: x.variant,
    radius: x.radius,
    inverted: x.inverted,
    placement: x.placement
  }, { name: "Tabs", unstyled: x.unstyled, classNames: x.classNames, styles: x.styles }), D = r === x.value, N = (I) => {
    x.onTabChange(x.allowTabDeactivation && r === x.value ? null : r), l == null || l(I);
  };
  return /* @__PURE__ */ le.createElement(MT, bge(gge({}, b), {
    unstyled: x.unstyled,
    className: M(P.tab, p),
    "data-active": D || void 0,
    ref: t,
    type: "button",
    role: "tab",
    id: x.getTabId(r),
    "aria-selected": D,
    tabIndex: D || x.value === null ? 0 : -1,
    "aria-controls": x.getPanelId(r),
    onClick: N,
    onKeyDown: Z3({
      siblingSelector: '[role="tab"]',
      parentSelector: '[role="tablist"]',
      activateOnFocus: x.activateTabWithKeyboard,
      loop: x.loop,
      dir: _.dir,
      orientation: x.orientation,
      onKeyDown: s
    })
  }), m && /* @__PURE__ */ le.createElement("div", {
    className: P.tabIcon
  }, m), a && /* @__PURE__ */ le.createElement("div", {
    className: P.tabLabel
  }, a), h && /* @__PURE__ */ le.createElement("div", {
    className: P.tabRightSection
  }, h));
});
v8.displayName = "@mantine/core/Tab";
function y8({
  defaultValue: e,
  value: t,
  onTabChange: n,
  orientation: r,
  children: a,
  loop: s,
  id: l,
  activateTabWithKeyboard: p,
  allowTabDeactivation: m,
  variant: h,
  color: g,
  radius: b,
  inverted: x,
  placement: E,
  keepMounted: O = !0,
  classNames: _,
  styles: P,
  unstyled: M
}) {
  const D = Hf(l), [N, I] = Ju({
    value: t,
    defaultValue: e,
    finalValue: null,
    onChange: n
  });
  return /* @__PURE__ */ le.createElement(jye, {
    value: {
      placement: E,
      value: N,
      orientation: r,
      id: D,
      loop: s,
      activateTabWithKeyboard: p,
      getTabId: FL(`${D}-tab`, YD.value),
      getPanelId: FL(`${D}-panel`, YD.value),
      onTabChange: I,
      allowTabDeactivation: m,
      variant: h,
      color: g,
      radius: b,
      inverted: x,
      keepMounted: O,
      classNames: _,
      styles: P,
      unstyled: M
    }
  }, a);
}
y8.displayName = "@mantine/core/TabsProvider";
var Sge = yn((e, { orientation: t, placement: n }) => ({
  root: {
    display: t === "vertical" ? "flex" : void 0,
    flexDirection: n === "right" ? "row-reverse" : "row"
  }
}));
const Ege = Sge;
var Cge = Object.defineProperty, Tge = Object.defineProperties, _ge = Object.getOwnPropertyDescriptors, DC = Object.getOwnPropertySymbols, g8 = Object.prototype.hasOwnProperty, b8 = Object.prototype.propertyIsEnumerable, u5 = (e, t, n) => t in e ? Cge(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Oge = (e, t) => {
  for (var n in t || (t = {}))
    g8.call(t, n) && u5(e, n, t[n]);
  if (DC)
    for (var n of DC(t))
      b8.call(t, n) && u5(e, n, t[n]);
  return e;
}, Pge = (e, t) => Tge(e, _ge(t)), Rge = (e, t) => {
  var n = {};
  for (var r in e)
    g8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && DC)
    for (var r of DC(e))
      t.indexOf(r) < 0 && b8.call(e, r) && (n[r] = e[r]);
  return n;
};
const kge = {
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, Vu = C.forwardRef((e, t) => {
  const n = vn("Tabs", kge, e), {
    defaultValue: r,
    value: a,
    orientation: s,
    loop: l,
    activateTabWithKeyboard: p,
    allowTabDeactivation: m,
    children: h,
    id: g,
    onTabChange: b,
    variant: x,
    color: E,
    className: O,
    unstyled: _,
    classNames: P,
    styles: M,
    radius: D,
    inverted: N,
    keepMounted: I,
    placement: R
  } = n, j = Rge(n, [
    "defaultValue",
    "value",
    "orientation",
    "loop",
    "activateTabWithKeyboard",
    "allowTabDeactivation",
    "children",
    "id",
    "onTabChange",
    "variant",
    "color",
    "className",
    "unstyled",
    "classNames",
    "styles",
    "radius",
    "inverted",
    "keepMounted",
    "placement"
  ]), { classes: U, cx: q } = Ege({ orientation: s, color: E, variant: x, radius: D, inverted: N, placement: R }, { unstyled: _, name: "Tabs", classNames: P, styles: M });
  return /* @__PURE__ */ le.createElement(y8, {
    activateTabWithKeyboard: p,
    defaultValue: r,
    orientation: s,
    onTabChange: b,
    value: a,
    id: g,
    loop: l,
    allowTabDeactivation: m,
    color: E,
    variant: x,
    radius: D,
    inverted: N,
    keepMounted: I,
    placement: R,
    classNames: P,
    styles: M,
    unstyled: _
  }, /* @__PURE__ */ le.createElement(hn, Pge(Oge({}, j), {
    className: q(U.root, O),
    id: g,
    ref: t
  }), h));
});
Vu.List = c8;
Vu.Tab = v8;
Vu.Panel = p8;
Vu.displayName = "@mantine/core/Tabs";
function Hs({
  path: e,
  method: t,
  body: n = void 0,
  queryParams: r = void 0
}) {
  let a = {};
  typeof r == "object" && (a = new URLSearchParams(r), e = e + "?" + a);
  const s = {
    method: t,
    mode: "cors",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    },
    redirect: "follow",
    referrerPolicy: "no-referrer",
    body: n ? JSON.stringify(n) : null
  };
  return { fetchPath: e, options: s };
}
function Dge(e) {
  const t = [];
  if (e.length === 0)
    return "";
  if (typeof e[0] != "string")
    throw new TypeError("Url must be a string. Received " + e[0]);
  e[0].match(/^[^/:]+:\/*$/) && e.length > 1 && (e[0] = e.shift() + e[0]), e[0].match(/^file:\/\/\//) ? e[0] = e[0].replace(/^([^/:]+):\/*/, "$1:///") : e[0] = e[0].replace(/^([^/:]+):\/*/, "$1://");
  for (let a = 0; a < e.length; a++) {
    let s = e[a];
    if (typeof s != "string")
      throw new TypeError("Url must be a string. Received " + s);
    s !== "" && (a > 0 && (s = s.replace(/^[\/]+/, "")), a < e.length - 1 ? s = s.replace(/[\/]+$/, "") : s = s.replace(/[\/]+$/, "/"), t.push(s));
  }
  let n = t.join("/");
  n = n.replace(/\/(\?|&|#[^!])/g, "$1");
  const r = n.split("?");
  return n = r.shift() + (r.length > 0 ? "?" : "") + r.join("&"), n;
}
function qi(...e) {
  const t = Array.from(Array.isArray(e[0]) ? e[0] : e);
  return Dge(t);
}
const $ge = { user: null, loading: !0 };
function Mge(e, t) {
  switch (t.type) {
    case "initCall":
      return { ...e, loading: !0, error: null };
    case "setUser":
      return { ...e, user: t.payload, loading: !1, error: !1 };
    case "setError":
      return { ...e, user: null, loading: !1, error: t.payload };
    case "setLoading":
      return { ...e, loading: t.payload };
    default:
      return e;
  }
}
function Nge(e) {
  const [t, n] = C.useReducer(Mge, $ge);
  C.useEffect(() => {
    r();
  }, []);
  async function r() {
    n({ type: "initCall" });
    try {
      const { fetchPath: m, options: h } = Hs({ path: qi(e, "auth/user"), method: "GET" }), g = await fetch(m, h);
      if (g.ok) {
        const b = await g.json();
        return n({ payload: b, type: "setUser" }), b;
      }
      throw new Error(g.statusText);
    } catch {
      n({ payload: !1, type: "setLoading" });
    }
  }
  async function a({ username: m, password: h }) {
    n({ type: "initCall" });
    try {
      const { fetchPath: g, options: b } = Hs({
        path: qi(e, "auth/login"),
        method: "POST",
        body: { username: m, password: h }
      }), x = await fetch(g, b);
      if (x.ok) {
        const E = await x.json();
        n({ payload: E, type: "setUser" });
      } else
        n({ payload: "Username or password wrong.", type: "setError" });
    } catch {
      n({ payload: "Failed to fetch", type: "setError" });
    }
  }
  async function s() {
    n({ type: "initCall" });
    try {
      const { fetchPath: m, options: h } = Hs({ path: qi(e, "auth/logout"), method: "Get" });
      (await fetch(m, h)).ok ? n({ payload: null, type: "setUser" }) : n({ payload: "Couldn't sign out user", type: "setError" });
    } catch {
      n({ payload: "Failed to fetch", type: "setError" });
    }
  }
  async function l(m) {
    n({ type: "initCall" });
    try {
      const { fetchPath: h, options: g } = Hs({
        path: qi(e, "auth/user"),
        method: "PUT",
        body: m
      }), b = await fetch(h, g);
      if (b.ok) {
        const x = await b.json();
        n({ payload: x, type: "setUser" });
      }
      n({ payload: "Couldn't update user data", type: "setError" });
    } catch {
      n({ payload: "Failed to post", type: "setError" });
    }
  }
  async function p(m) {
    try {
      const { fetchPath: h, options: g } = Hs({
        path: qi(e, "auth/resetpassword"),
        method: "PUT",
        body: { password: m }
      });
      (await fetch(h, g)).ok ? n({ payload: { ...t.user }, type: "setUser" }) : n({ payload: "Couldn't reset password", type: "setError" });
    } catch {
      n({ payload: "Failed to post", type: "setError" });
    }
  }
  return {
    user: t.user,
    loading: t.loading,
    error: t.error,
    signin: a,
    signout: s,
    update: l,
    resetPassword: p
  };
}
function Ige(e, t) {
  const { user: n } = t, [r, a] = C.useState(null), [s, l] = C.useState(!0), [p, m] = C.useState({ error: "401 Not authorized", message: "User is not logged in." });
  C.useEffect(() => {
    n && h(e);
  }, [n]);
  const h = async (g) => {
    l(!0);
    try {
      const { fetchPath: b, options: x } = Hs({ path: qi(g, "info/"), method: "GET" }), E = await fetch(b, x);
      if (E.ok) {
        const O = await E.json();
        a(O);
      } else
        m({ error: "404 Not Found", message: "Couldn't fetch info" });
    } catch {
      m({ error: "Network error", message: "Failed to fetch" });
    } finally {
      l(!1);
    }
  };
  return { info: r, loading: s, error: p };
}
const EM = C.createContext({
  theme: {},
  //Provide a default theme here
  auth: {},
  info: {}
});
function Age() {
  return C.useContext(EM).auth;
}
function jge() {
  return C.useContext(EM).info;
}
function pje() {
  return Da() || {};
}
function mje(e) {
  const t = { baseUrl: "", inheritMantineTheme: !1 }, { baseUrl: n, theme: r, inheritMantineTheme: a, children: s } = { ...t, ...e }, l = a ? { ...Da(), ...r } : { ...Soe, ...r }, p = Nge(n), m = { baseUrl: n, ...Ige(n, p) };
  return /* @__PURE__ */ L.jsx(EM.Provider, { value: { activeTheme: l, auth: p, info: m }, children: /* @__PURE__ */ L.jsx(l4, { theme: l, withCSSVariables: !0, withNormalizeCSS: !0, withGlobalStyles: !0, children: /* @__PURE__ */ L.jsx(Q3, { theme: Eoe, children: s }) }) });
}
const Lge = async (e, t) => {
  try {
    const { fetchPath: n, options: r } = Hs({
      path: qi(e, "/"),
      method: "GET",
      queryParams: { q: JSON.stringify(t) }
    }), a = await fetch(n, r);
    if (a.ok)
      return await a.json();
    throw new Error(a.statusText);
  } catch (n) {
    throw new Error(n);
  }
}, Fge = async (e) => {
  try {
    const { fetchPath: t, options: n } = Hs({ path: qi(e, "_info"), method: "GET" }), r = await fetch(t, n);
    if (r.ok)
      return await r.json();
    throw new Error(r.statusText);
  } catch (t) {
    throw new Error(t);
  }
}, zge = async (e, t) => {
  try {
    const { fetchPath: n, options: r } = Hs({ path: qi(e, t.toString()), method: "GET" }), a = await fetch(n, r);
    if (a.ok)
      return await a.json();
    throw new Error(z);
  } catch (n) {
    throw new Error(n);
  }
}, Vge = async (e, t) => {
  try {
    const { fetchPath: n, options: r } = Hs({
      path: qi(e, "/"),
      method: "POST",
      body: t
    }), a = await fetch(n, r);
    if (a.ok)
      return await a.json();
    throw new Error(a.statusText);
  } catch (n) {
    throw new Error(n);
  }
}, Uge = async (e, t, n) => {
  try {
    const { fetchPath: r, options: a } = Hs({ path: qi(e, t.toString()), method: "PUT", body: n }), s = await fetch(r, a);
    if (s.ok)
      return await s.json();
    throw new Error(s.statusText);
  } catch (r) {
    throw new Error(r);
  }
}, Bge = async (e, t) => {
  try {
    const { fetchPath: n, options: r } = Hs({ path: qi(e, t.toString()), method: "DELETE" }), a = await fetch(n, r);
    if (a.ok)
      return await a.json();
    throw new Error(a.statusText);
  } catch (n) {
    throw new Error(n);
  }
};
function c5(e, t) {
  const n = e || {
    columns: [],
    filters: [],
    // keys: [],
    page: 0,
    page_size: 25
  };
  return t.hasOwnProperty("columns") && (n.columns = t.columns), t.hasOwnProperty("filters") && (n.filters = t.filters), t.hasOwnProperty("order_column") && (n.order_column = t.order_column), t.hasOwnProperty("order_direction") && (n.order_direction = t.order_direction), t.hasOwnProperty("page") && (n.page = t.page), t.hasOwnProperty("page_size") && (n.page_size = t.page_size), n;
}
const d5 = (e) => {
  const t = {};
  for (const n of e)
    switch (n.type) {
      case "RelatedList":
        t[n.name] = [];
        break;
      case "Related":
        t[n.name] = {};
        break;
      case "Boolean":
        t[n.name] = "false";
        break;
      case "Date":
      case "DateTime":
        t[n.name] = null;
        break;
      case "Integer":
      case "Float":
        t[n.name] = null;
        break;
      default:
        t[n.name] = "";
    }
  return t;
};
function Mm(e) {
  this._maxSize = e, this.clear();
}
Mm.prototype.clear = function() {
  this._size = 0, this._values = /* @__PURE__ */ Object.create(null);
};
Mm.prototype.get = function(e) {
  return this._values[e];
};
Mm.prototype.set = function(e, t) {
  return this._size >= this._maxSize && this.clear(), e in this._values || this._size++, this._values[e] = t;
};
var Hge = /[^.^\]^[]+|(?=\[\]|\.\.)/g, w8 = /^\d+$/, Wge = /^\d/, Yge = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, qge = /^\s*(['"]?)(.*?)(\1)\s*$/, CM = 512, f5 = new Mm(CM), p5 = new Mm(CM), m5 = new Mm(CM), vm = {
  Cache: Mm,
  split: qD,
  normalizePath: Rk,
  setter: function(e) {
    var t = Rk(e);
    return p5.get(e) || p5.set(e, function(r, a) {
      for (var s = 0, l = t.length, p = r; s < l - 1; ) {
        var m = t[s];
        if (m === "__proto__" || m === "constructor" || m === "prototype")
          return r;
        p = p[t[s++]];
      }
      p[t[s]] = a;
    });
  },
  getter: function(e, t) {
    var n = Rk(e);
    return m5.get(e) || m5.set(e, function(a) {
      for (var s = 0, l = n.length; s < l; )
        if (a != null || !t)
          a = a[n[s++]];
        else
          return;
      return a;
    });
  },
  join: function(e) {
    return e.reduce(function(t, n) {
      return t + (TM(n) || w8.test(n) ? "[" + n + "]" : (t ? "." : "") + n);
    }, "");
  },
  forEach: function(e, t, n) {
    Gge(Array.isArray(e) ? e : qD(e), t, n);
  }
};
function Rk(e) {
  return f5.get(e) || f5.set(
    e,
    qD(e).map(function(t) {
      return t.replace(qge, "$2");
    })
  );
}
function qD(e) {
  return e.match(Hge) || [""];
}
function Gge(e, t, n) {
  var r = e.length, a, s, l, p;
  for (s = 0; s < r; s++)
    a = e[s], a && (Qge(a) && (a = '"' + a + '"'), p = TM(a), l = !p && /^\d+$/.test(a), t.call(n, a, p, l, s, e));
}
function TM(e) {
  return typeof e == "string" && e && ["'", '"'].indexOf(e.charAt(0)) !== -1;
}
function Kge(e) {
  return e.match(Wge) && !e.match(w8);
}
function Xge(e) {
  return Yge.test(e);
}
function Qge(e) {
  return !TM(e) && (Kge(e) || Xge(e));
}
const Zge = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g, YT = (e) => e.match(Zge) || [], qT = (e) => e[0].toUpperCase() + e.slice(1), _M = (e, t) => YT(e).join(t).toLowerCase(), x8 = (e) => YT(e).reduce(
  (t, n) => `${t}${t ? n[0].toUpperCase() + n.slice(1).toLowerCase() : n.toLowerCase()}`,
  ""
), Jge = (e) => qT(x8(e)), ebe = (e) => _M(e, "_"), tbe = (e) => _M(e, "-"), nbe = (e) => qT(_M(e, " ")), rbe = (e) => YT(e).map(qT).join(" ");
var kk = {
  words: YT,
  upperFirst: qT,
  camelCase: x8,
  pascalCase: Jge,
  snakeCase: ebe,
  kebabCase: tbe,
  sentenceCase: nbe,
  titleCase: rbe
}, OM = { exports: {} };
OM.exports = function(e) {
  return S8(obe(e), e);
};
OM.exports.array = S8;
function S8(e, t) {
  var n = e.length, r = new Array(n), a = {}, s = n, l = abe(t), p = ibe(e);
  for (t.forEach(function(h) {
    if (!p.has(h[0]) || !p.has(h[1]))
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
  }); s--; )
    a[s] || m(e[s], s, /* @__PURE__ */ new Set());
  return r;
  function m(h, g, b) {
    if (b.has(h)) {
      var x;
      try {
        x = ", node was:" + JSON.stringify(h);
      } catch {
        x = "";
      }
      throw new Error("Cyclic dependency" + x);
    }
    if (!p.has(h))
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(h));
    if (!a[g]) {
      a[g] = !0;
      var E = l.get(h) || /* @__PURE__ */ new Set();
      if (E = Array.from(E), g = E.length) {
        b.add(h);
        do {
          var O = E[--g];
          m(O, p.get(O), b);
        } while (g);
        b.delete(h);
      }
      r[--n] = h;
    }
  }
}
function obe(e) {
  for (var t = /* @__PURE__ */ new Set(), n = 0, r = e.length; n < r; n++) {
    var a = e[n];
    t.add(a[0]), t.add(a[1]);
  }
  return Array.from(t);
}
function abe(e) {
  for (var t = /* @__PURE__ */ new Map(), n = 0, r = e.length; n < r; n++) {
    var a = e[n];
    t.has(a[0]) || t.set(a[0], /* @__PURE__ */ new Set()), t.has(a[1]) || t.set(a[1], /* @__PURE__ */ new Set()), t.get(a[0]).add(a[1]);
  }
  return t;
}
function ibe(e) {
  for (var t = /* @__PURE__ */ new Map(), n = 0, r = e.length; n < r; n++)
    t.set(e[n], n);
  return t;
}
var sbe = OM.exports;
const lbe = /* @__PURE__ */ Uf(sbe), ube = Object.prototype.toString, cbe = Error.prototype.toString, dbe = RegExp.prototype.toString, fbe = typeof Symbol < "u" ? Symbol.prototype.toString : () => "", pbe = /^Symbol\((.*)\)(.*)$/;
function mbe(e) {
  return e != +e ? "NaN" : e === 0 && 1 / e < 0 ? "-0" : "" + e;
}
function h5(e, t = !1) {
  if (e == null || e === !0 || e === !1)
    return "" + e;
  const n = typeof e;
  if (n === "number")
    return mbe(e);
  if (n === "string")
    return t ? `"${e}"` : e;
  if (n === "function")
    return "[Function " + (e.name || "anonymous") + "]";
  if (n === "symbol")
    return fbe.call(e).replace(pbe, "Symbol($1)");
  const r = ube.call(e).slice(8, -1);
  return r === "Date" ? isNaN(e.getTime()) ? "" + e : e.toISOString(e) : r === "Error" || e instanceof Error ? "[" + cbe.call(e) + "]" : r === "RegExp" ? dbe.call(e) : null;
}
function Xu(e, t) {
  let n = h5(e, t);
  return n !== null ? n : JSON.stringify(e, function(r, a) {
    let s = h5(this[r], t);
    return s !== null ? s : a;
  }, 2);
}
function E8(e) {
  return e == null ? [] : [].concat(e);
}
let hbe = /\$\{\s*(\w+)\s*\}/g;
class bi extends Error {
  static formatError(t, n) {
    const r = n.label || n.path || "this";
    return r !== n.path && (n = Object.assign({}, n, {
      path: r
    })), typeof t == "string" ? t.replace(hbe, (a, s) => Xu(n[s])) : typeof t == "function" ? t(n) : t;
  }
  static isError(t) {
    return t && t.name === "ValidationError";
  }
  constructor(t, n, r, a) {
    super(), this.value = void 0, this.path = void 0, this.type = void 0, this.errors = void 0, this.params = void 0, this.inner = void 0, this.name = "ValidationError", this.value = n, this.path = r, this.type = a, this.errors = [], this.inner = [], E8(t).forEach((s) => {
      bi.isError(s) ? (this.errors.push(...s.errors), this.inner = this.inner.concat(s.inner.length ? s.inner : s)) : this.errors.push(s);
    }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0], Error.captureStackTrace && Error.captureStackTrace(this, bi);
  }
}
let Lu = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path: e,
    type: t,
    value: n,
    originalValue: r
  }) => {
    const a = r != null && r !== n ? ` (cast from the value \`${Xu(r, !0)}\`).` : ".";
    return t !== "mixed" ? `${e} must be a \`${t}\` type, but the final value was: \`${Xu(n, !0)}\`` + a : `${e} must match the configured type. The validated value was: \`${Xu(n, !0)}\`` + a;
  }
}, Fl = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
}, _f = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
}, GD = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
}, KD = {
  isValue: "${path} field must be ${value}"
}, XD = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
}, nE = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
}, vbe = {
  notType: (e) => {
    const {
      path: t,
      value: n,
      spec: r
    } = e, a = r.types.length;
    if (Array.isArray(n)) {
      if (n.length < a)
        return `${t} tuple value has too few items, expected a length of ${a} but got ${n.length} for value: \`${Xu(n, !0)}\``;
      if (n.length > a)
        return `${t} tuple value has too many items, expected a length of ${a} but got ${n.length} for value: \`${Xu(n, !0)}\``;
    }
    return bi.formatError(Lu.notType, e);
  }
};
var C8 = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed: Lu,
  string: Fl,
  number: _f,
  date: GD,
  object: XD,
  array: nE,
  boolean: KD
});
const Nm = (e) => e && e.__isYupSchema__;
class $C {
  static fromOptions(t, n) {
    if (!n.then && !n.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: r,
      then: a,
      otherwise: s
    } = n, l = typeof r == "function" ? r : (...p) => p.every((m) => m === r);
    return new $C(t, (p, m) => {
      var h;
      let g = l(...p) ? a : s;
      return (h = g == null ? void 0 : g(m)) != null ? h : m;
    });
  }
  constructor(t, n) {
    this.fn = void 0, this.refs = t, this.refs = t, this.fn = n;
  }
  resolve(t, n) {
    let r = this.refs.map((s) => (
      // TODO: ? operator here?
      s.getValue(n == null ? void 0 : n.value, n == null ? void 0 : n.parent, n == null ? void 0 : n.context)
    )), a = this.fn(r, t, n);
    if (a === void 0 || // @ts-ignore this can be base
    a === t)
      return t;
    if (!Nm(a))
      throw new TypeError("conditions must return a schema object");
    return a.resolve(n);
  }
}
const O1 = {
  context: "$",
  value: "."
};
function ybe(e, t) {
  return new qf(e, t);
}
class qf {
  constructor(t, n = {}) {
    if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof t != "string")
      throw new TypeError("ref must be a string, got: " + t);
    if (this.key = t.trim(), t === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === O1.context, this.isValue = this.key[0] === O1.value, this.isSibling = !this.isContext && !this.isValue;
    let r = this.isContext ? O1.context : this.isValue ? O1.value : "";
    this.path = this.key.slice(r.length), this.getter = this.path && vm.getter(this.path, !0), this.map = n.map;
  }
  getValue(t, n, r) {
    let a = this.isContext ? r : this.isValue ? t : n;
    return this.getter && (a = this.getter(a || {})), this.map && (a = this.map(a)), a;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(t, n) {
    return this.getValue(t, n == null ? void 0 : n.parent, n == null ? void 0 : n.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(t) {
    return t && t.__isYupRef;
  }
}
qf.prototype.__isYupRef = !0;
const Bl = (e) => e == null;
function $v(e) {
  function t({
    value: n,
    path: r = "",
    options: a,
    originalValue: s,
    schema: l
  }, p, m) {
    const {
      name: h,
      test: g,
      params: b,
      message: x,
      skipAbsent: E
    } = e;
    let {
      parent: O,
      context: _,
      abortEarly: P = l.spec.abortEarly
    } = a;
    function M(H) {
      return qf.isRef(H) ? H.getValue(n, O, _) : H;
    }
    function D(H = {}) {
      const Z = Object.assign({
        value: n,
        originalValue: s,
        label: l.spec.label,
        path: H.path || r,
        spec: l.spec
      }, b, H.params);
      for (const Y of Object.keys(Z))
        Z[Y] = M(Z[Y]);
      const re = new bi(bi.formatError(H.message || x, Z), n, Z.path, H.type || h);
      return re.params = Z, re;
    }
    const N = P ? p : m;
    let I = {
      path: r,
      parent: O,
      type: h,
      from: a.from,
      createError: D,
      resolve: M,
      options: a,
      originalValue: s,
      schema: l
    };
    const R = (H) => {
      bi.isError(H) ? N(H) : H ? m(null) : N(D());
    }, j = (H) => {
      bi.isError(H) ? N(H) : p(H);
    }, U = E && Bl(n);
    if (!a.sync) {
      try {
        Promise.resolve(U ? !0 : g.call(I, n, I)).then(R, j);
      } catch (H) {
        j(H);
      }
      return;
    }
    let q;
    try {
      var J;
      if (q = U ? !0 : g.call(I, n, I), typeof ((J = q) == null ? void 0 : J.then) == "function")
        throw new Error(`Validation test of type: "${I.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
    } catch (H) {
      j(H);
      return;
    }
    R(q);
  }
  return t.OPTIONS = e, t;
}
function PM(e, t, n, r = n) {
  let a, s, l;
  return t ? (vm.forEach(t, (p, m, h) => {
    let g = m ? p.slice(1, p.length - 1) : p;
    e = e.resolve({
      context: r,
      parent: a,
      value: n
    });
    let b = e.type === "tuple", x = h ? parseInt(g, 10) : 0;
    if (e.innerType || b) {
      if (b && !h)
        throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${l}" must contain an index to the tuple element, e.g. "${l}[0]"`);
      if (n && x >= n.length)
        throw new Error(`Yup.reach cannot resolve an array item at index: ${p}, in the path: ${t}. because there is no value at that index. `);
      a = n, n = n && n[x], e = b ? e.spec.types[x] : e.innerType;
    }
    if (!h) {
      if (!e.fields || !e.fields[g])
        throw new Error(`The schema does not contain the path: ${t}. (failed at: ${l} which is a type: "${e.type}")`);
      a = n, n = n && n[g], e = e.fields[g];
    }
    s = g, l = m ? "[" + p + "]" : "." + p;
  }), {
    schema: e,
    parent: a,
    parentPath: s
  }) : {
    parent: a,
    parentPath: t,
    schema: e
  };
}
function gbe(e, t, n, r) {
  return PM(e, t, n, r).schema;
}
class MC extends Set {
  describe() {
    const t = [];
    for (const n of this.values())
      t.push(qf.isRef(n) ? n.describe() : n);
    return t;
  }
  resolveAll(t) {
    let n = [];
    for (const r of this.values())
      n.push(t(r));
    return n;
  }
  clone() {
    return new MC(this.values());
  }
  merge(t, n) {
    const r = this.clone();
    return t.forEach((a) => r.add(a)), n.forEach((a) => r.delete(a)), r;
  }
}
function Yv(e, t = /* @__PURE__ */ new Map()) {
  if (Nm(e) || !e || typeof e != "object")
    return e;
  if (t.has(e))
    return t.get(e);
  let n;
  if (e instanceof Date)
    n = new Date(e.getTime()), t.set(e, n);
  else if (e instanceof RegExp)
    n = new RegExp(e), t.set(e, n);
  else if (Array.isArray(e)) {
    n = new Array(e.length), t.set(e, n);
    for (let r = 0; r < e.length; r++)
      n[r] = Yv(e[r], t);
  } else if (e instanceof Map) {
    n = /* @__PURE__ */ new Map(), t.set(e, n);
    for (const [r, a] of e.entries())
      n.set(r, Yv(a, t));
  } else if (e instanceof Set) {
    n = /* @__PURE__ */ new Set(), t.set(e, n);
    for (const r of e)
      n.add(Yv(r, t));
  } else if (e instanceof Object) {
    n = {}, t.set(e, n);
    for (const [r, a] of Object.entries(e))
      n[r] = Yv(a, t);
  } else
    throw Error(`Unable to clone ${e}`);
  return n;
}
class ti {
  constructor(t) {
    this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new MC(), this._blacklist = new MC(), this.exclusiveTests = /* @__PURE__ */ Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => {
      this.typeError(Lu.notType);
    }), this.type = t.type, this._typeCheck = t.check, this.spec = Object.assign({
      strip: !1,
      strict: !1,
      abortEarly: !0,
      recursive: !0,
      nullable: !1,
      optional: !0,
      coerce: !0
    }, t == null ? void 0 : t.spec), this.withMutation((n) => {
      n.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(t) {
    if (this._mutate)
      return t && Object.assign(this.spec, t), this;
    const n = Object.create(Object.getPrototypeOf(this));
    return n.type = this.type, n._typeCheck = this._typeCheck, n._whitelist = this._whitelist.clone(), n._blacklist = this._blacklist.clone(), n.internalTests = Object.assign({}, this.internalTests), n.exclusiveTests = Object.assign({}, this.exclusiveTests), n.deps = [...this.deps], n.conditions = [...this.conditions], n.tests = [...this.tests], n.transforms = [...this.transforms], n.spec = Yv(Object.assign({}, this.spec, t)), n;
  }
  label(t) {
    let n = this.clone();
    return n.spec.label = t, n;
  }
  meta(...t) {
    if (t.length === 0)
      return this.spec.meta;
    let n = this.clone();
    return n.spec.meta = Object.assign(n.spec.meta || {}, t[0]), n;
  }
  withMutation(t) {
    let n = this._mutate;
    this._mutate = !0;
    let r = t(this);
    return this._mutate = n, r;
  }
  concat(t) {
    if (!t || t === this)
      return this;
    if (t.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`);
    let n = this, r = t.clone();
    const a = Object.assign({}, n.spec, r.spec);
    return r.spec = a, r.internalTests = Object.assign({}, n.internalTests, r.internalTests), r._whitelist = n._whitelist.merge(t._whitelist, t._blacklist), r._blacklist = n._blacklist.merge(t._blacklist, t._whitelist), r.tests = n.tests, r.exclusiveTests = n.exclusiveTests, r.withMutation((s) => {
      t.tests.forEach((l) => {
        s.test(l.OPTIONS);
      });
    }), r.transforms = [...n.transforms, ...r.transforms], r;
  }
  isType(t) {
    return t == null ? !!(this.spec.nullable && t === null || this.spec.optional && t === void 0) : this._typeCheck(t);
  }
  resolve(t) {
    let n = this;
    if (n.conditions.length) {
      let r = n.conditions;
      n = n.clone(), n.conditions = [], n = r.reduce((a, s) => s.resolve(a, t), n), n = n.resolve(t);
    }
    return n;
  }
  resolveOptions(t) {
    var n, r, a;
    return Object.assign({}, t, {
      from: t.from || [],
      strict: (n = t.strict) != null ? n : this.spec.strict,
      abortEarly: (r = t.abortEarly) != null ? r : this.spec.abortEarly,
      recursive: (a = t.recursive) != null ? a : this.spec.recursive
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(t, n = {}) {
    let r = this.resolve(Object.assign({
      value: t
    }, n)), a = n.assert === "ignore-optionality", s = r._cast(t, n);
    if (n.assert !== !1 && !r.isType(s)) {
      if (a && Bl(s))
        return s;
      let l = Xu(t), p = Xu(s);
      throw new TypeError(`The value of ${n.path || "field"} could not be cast to a value that satisfies the schema type: "${r.type}". 

attempted value: ${l} 
` + (p !== l ? `result of cast: ${p}` : ""));
    }
    return s;
  }
  _cast(t, n) {
    let r = t === void 0 ? t : this.transforms.reduce((a, s) => s.call(this, a, t, this), t);
    return r === void 0 && (r = this.getDefault(n)), r;
  }
  _validate(t, n = {}, r, a) {
    let {
      path: s,
      originalValue: l = t,
      strict: p = this.spec.strict
    } = n, m = t;
    p || (m = this._cast(m, Object.assign({
      assert: !1
    }, n)));
    let h = [];
    for (let g of Object.values(this.internalTests))
      g && h.push(g);
    this.runTests({
      path: s,
      value: m,
      originalValue: l,
      options: n,
      tests: h
    }, r, (g) => {
      if (g.length)
        return a(g, m);
      this.runTests({
        path: s,
        value: m,
        originalValue: l,
        options: n,
        tests: this.tests
      }, r, a);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(t, n, r) {
    let a = !1, {
      tests: s,
      value: l,
      originalValue: p,
      path: m,
      options: h
    } = t, g = (_) => {
      a || (a = !0, n(_, l));
    }, b = (_) => {
      a || (a = !0, r(_, l));
    }, x = s.length, E = [];
    if (!x)
      return b([]);
    let O = {
      value: l,
      originalValue: p,
      path: m,
      options: h,
      schema: this
    };
    for (let _ = 0; _ < s.length; _++) {
      const P = s[_];
      P(O, g, function(D) {
        D && (E = E.concat(D)), --x <= 0 && b(E);
      });
    }
  }
  asNestedTest({
    key: t,
    index: n,
    parent: r,
    parentPath: a,
    originalParent: s,
    options: l
  }) {
    const p = t ?? n;
    if (p == null)
      throw TypeError("Must include `key` or `index` for nested validations");
    const m = typeof p == "number";
    let h = r[p];
    const g = Object.assign({}, l, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: !0,
      parent: r,
      value: h,
      originalValue: s[p],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [m ? "index" : "key"]: p,
      path: m || p.includes(".") ? `${a || ""}[${h ? p : `"${p}"`}]` : (a ? `${a}.` : "") + t
    });
    return (b, x, E) => this.resolve(g)._validate(h, g, x, E);
  }
  validate(t, n) {
    let r = this.resolve(Object.assign({}, n, {
      value: t
    }));
    return new Promise((a, s) => r._validate(t, n, (l, p) => {
      bi.isError(l) && (l.value = p), s(l);
    }, (l, p) => {
      l.length ? s(new bi(l, p)) : a(p);
    }));
  }
  validateSync(t, n) {
    let r = this.resolve(Object.assign({}, n, {
      value: t
    })), a;
    return r._validate(t, Object.assign({}, n, {
      sync: !0
    }), (s, l) => {
      throw bi.isError(s) && (s.value = l), s;
    }, (s, l) => {
      if (s.length)
        throw new bi(s, t);
      a = l;
    }), a;
  }
  isValid(t, n) {
    return this.validate(t, n).then(() => !0, (r) => {
      if (bi.isError(r))
        return !1;
      throw r;
    });
  }
  isValidSync(t, n) {
    try {
      return this.validateSync(t, n), !0;
    } catch (r) {
      if (bi.isError(r))
        return !1;
      throw r;
    }
  }
  _getDefault(t) {
    let n = this.spec.default;
    return n == null ? n : typeof n == "function" ? n.call(this, t) : Yv(n);
  }
  getDefault(t) {
    return this.resolve(t || {})._getDefault(t);
  }
  default(t) {
    return arguments.length === 0 ? this._getDefault() : this.clone({
      default: t
    });
  }
  strict(t = !0) {
    return this.clone({
      strict: t
    });
  }
  nullability(t, n) {
    const r = this.clone({
      nullable: t
    });
    return r.internalTests.nullable = $v({
      message: n,
      name: "nullable",
      test(a) {
        return a === null ? this.schema.spec.nullable : !0;
      }
    }), r;
  }
  optionality(t, n) {
    const r = this.clone({
      optional: t
    });
    return r.internalTests.optionality = $v({
      message: n,
      name: "optionality",
      test(a) {
        return a === void 0 ? this.schema.spec.optional : !0;
      }
    }), r;
  }
  optional() {
    return this.optionality(!0);
  }
  defined(t = Lu.defined) {
    return this.optionality(!1, t);
  }
  nullable() {
    return this.nullability(!0);
  }
  nonNullable(t = Lu.notNull) {
    return this.nullability(!1, t);
  }
  required(t = Lu.required) {
    return this.clone().withMutation((n) => n.nonNullable(t).defined(t));
  }
  notRequired() {
    return this.clone().withMutation((t) => t.nullable().optional());
  }
  transform(t) {
    let n = this.clone();
    return n.transforms.push(t), n;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...t) {
    let n;
    if (t.length === 1 ? typeof t[0] == "function" ? n = {
      test: t[0]
    } : n = t[0] : t.length === 2 ? n = {
      name: t[0],
      test: t[1]
    } : n = {
      name: t[0],
      message: t[1],
      test: t[2]
    }, n.message === void 0 && (n.message = Lu.default), typeof n.test != "function")
      throw new TypeError("`test` is a required parameters");
    let r = this.clone(), a = $v(n), s = n.exclusive || n.name && r.exclusiveTests[n.name] === !0;
    if (n.exclusive && !n.name)
      throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    return n.name && (r.exclusiveTests[n.name] = !!n.exclusive), r.tests = r.tests.filter((l) => !(l.OPTIONS.name === n.name && (s || l.OPTIONS.test === a.OPTIONS.test))), r.tests.push(a), r;
  }
  when(t, n) {
    !Array.isArray(t) && typeof t != "string" && (n = t, t = ".");
    let r = this.clone(), a = E8(t).map((s) => new qf(s));
    return a.forEach((s) => {
      s.isSibling && r.deps.push(s.key);
    }), r.conditions.push(typeof n == "function" ? new $C(a, n) : $C.fromOptions(a, n)), r;
  }
  typeError(t) {
    let n = this.clone();
    return n.internalTests.typeError = $v({
      message: t,
      name: "typeError",
      skipAbsent: !0,
      test(r) {
        return this.schema._typeCheck(r) ? !0 : this.createError({
          params: {
            type: this.schema.type
          }
        });
      }
    }), n;
  }
  oneOf(t, n = Lu.oneOf) {
    let r = this.clone();
    return t.forEach((a) => {
      r._whitelist.add(a), r._blacklist.delete(a);
    }), r.internalTests.whiteList = $v({
      message: n,
      name: "oneOf",
      skipAbsent: !0,
      test(a) {
        let s = this.schema._whitelist, l = s.resolveAll(this.resolve);
        return l.includes(a) ? !0 : this.createError({
          params: {
            values: Array.from(s).join(", "),
            resolved: l
          }
        });
      }
    }), r;
  }
  notOneOf(t, n = Lu.notOneOf) {
    let r = this.clone();
    return t.forEach((a) => {
      r._blacklist.add(a), r._whitelist.delete(a);
    }), r.internalTests.blacklist = $v({
      message: n,
      name: "notOneOf",
      test(a) {
        let s = this.schema._blacklist, l = s.resolveAll(this.resolve);
        return l.includes(a) ? this.createError({
          params: {
            values: Array.from(s).join(", "),
            resolved: l
          }
        }) : !0;
      }
    }), r;
  }
  strip(t = !0) {
    let n = this.clone();
    return n.spec.strip = t, n;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(t) {
    const n = (t ? this.resolve(t) : this).clone(), {
      label: r,
      meta: a,
      optional: s,
      nullable: l
    } = n.spec;
    return {
      meta: a,
      label: r,
      optional: s,
      nullable: l,
      default: n.getDefault(t),
      type: n.type,
      oneOf: n._whitelist.describe(),
      notOneOf: n._blacklist.describe(),
      tests: n.tests.map((m) => ({
        name: m.OPTIONS.name,
        params: m.OPTIONS.params
      })).filter((m, h, g) => g.findIndex((b) => b.name === m.name) === h)
    };
  }
}
ti.prototype.__isYupSchema__ = !0;
for (const e of ["validate", "validateSync"])
  ti.prototype[`${e}At`] = function(t, n, r = {}) {
    const {
      parent: a,
      parentPath: s,
      schema: l
    } = PM(this, t, n, r.context);
    return l[e](a && a[s], Object.assign({}, r, {
      parent: a,
      path: t
    }));
  };
for (const e of ["equals", "is"])
  ti.prototype[e] = ti.prototype.oneOf;
for (const e of ["not", "nope"])
  ti.prototype[e] = ti.prototype.notOneOf;
const bbe = () => !0;
function RM(e) {
  return new kM(e);
}
class kM extends ti {
  constructor(t) {
    super(typeof t == "function" ? {
      type: "mixed",
      check: t
    } : Object.assign({
      type: "mixed",
      check: bbe
    }, t));
  }
}
RM.prototype = kM.prototype;
function QD() {
  return new DM();
}
class DM extends ti {
  constructor() {
    super({
      type: "boolean",
      check(t) {
        return t instanceof Boolean && (t = t.valueOf()), typeof t == "boolean";
      }
    }), this.withMutation(() => {
      this.transform((t, n, r) => {
        if (r.spec.coerce && !r.isType(t)) {
          if (/^(true|1)$/i.test(String(t)))
            return !0;
          if (/^(false|0)$/i.test(String(t)))
            return !1;
        }
        return t;
      });
    });
  }
  isTrue(t = KD.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "true"
      },
      test(n) {
        return Bl(n) || n === !0;
      }
    });
  }
  isFalse(t = KD.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "false"
      },
      test(n) {
        return Bl(n) || n === !1;
      }
    });
  }
  default(t) {
    return super.default(t);
  }
  defined(t) {
    return super.defined(t);
  }
  optional() {
    return super.optional();
  }
  required(t) {
    return super.required(t);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(t) {
    return super.nonNullable(t);
  }
  strip(t) {
    return super.strip(t);
  }
}
QD.prototype = DM.prototype;
let wbe = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
), xbe = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
), Sbe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Ebe = (e) => Bl(e) || e === e.trim(), Cbe = {}.toString();
function NC() {
  return new $M();
}
class $M extends ti {
  constructor() {
    super({
      type: "string",
      check(t) {
        return t instanceof String && (t = t.valueOf()), typeof t == "string";
      }
    }), this.withMutation(() => {
      this.transform((t, n, r) => {
        if (!r.spec.coerce || r.isType(t) || Array.isArray(t))
          return t;
        const a = t != null && t.toString ? t.toString() : t;
        return a === Cbe ? t : a;
      });
    });
  }
  required(t) {
    return super.required(t).withMutation((n) => n.test({
      message: t || Lu.required,
      name: "required",
      skipAbsent: !0,
      test: (r) => !!r.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((t) => (t.tests = t.tests.filter((n) => n.OPTIONS.name !== "required"), t));
  }
  length(t, n = Fl.length) {
    return this.test({
      message: n,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      skipAbsent: !0,
      test(r) {
        return r.length === this.resolve(t);
      }
    });
  }
  min(t, n = Fl.min) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(r) {
        return r.length >= this.resolve(t);
      }
    });
  }
  max(t, n = Fl.max) {
    return this.test({
      name: "max",
      exclusive: !0,
      message: n,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(r) {
        return r.length <= this.resolve(t);
      }
    });
  }
  matches(t, n) {
    let r = !1, a, s;
    return n && (typeof n == "object" ? {
      excludeEmptyString: r = !1,
      message: a,
      name: s
    } = n : a = n), this.test({
      name: s || "matches",
      message: a || Fl.matches,
      params: {
        regex: t
      },
      skipAbsent: !0,
      test: (l) => l === "" && r || l.search(t) !== -1
    });
  }
  email(t = Fl.email) {
    return this.matches(wbe, {
      name: "email",
      message: t,
      excludeEmptyString: !0
    });
  }
  url(t = Fl.url) {
    return this.matches(xbe, {
      name: "url",
      message: t,
      excludeEmptyString: !0
    });
  }
  uuid(t = Fl.uuid) {
    return this.matches(Sbe, {
      name: "uuid",
      message: t,
      excludeEmptyString: !1
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((t) => t === null ? "" : t);
  }
  trim(t = Fl.trim) {
    return this.transform((n) => n != null ? n.trim() : n).test({
      message: t,
      name: "trim",
      test: Ebe
    });
  }
  lowercase(t = Fl.lowercase) {
    return this.transform((n) => Bl(n) ? n : n.toLowerCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (n) => Bl(n) || n === n.toLowerCase()
    });
  }
  uppercase(t = Fl.uppercase) {
    return this.transform((n) => Bl(n) ? n : n.toUpperCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (n) => Bl(n) || n === n.toUpperCase()
    });
  }
}
NC.prototype = $M.prototype;
let Tbe = (e) => e != +e;
function T8() {
  return new MM();
}
class MM extends ti {
  constructor() {
    super({
      type: "number",
      check(t) {
        return t instanceof Number && (t = t.valueOf()), typeof t == "number" && !Tbe(t);
      }
    }), this.withMutation(() => {
      this.transform((t, n, r) => {
        if (!r.spec.coerce)
          return t;
        let a = t;
        if (typeof a == "string") {
          if (a = a.replace(/\s/g, ""), a === "")
            return NaN;
          a = +a;
        }
        return r.isType(a) || a === null ? a : parseFloat(a);
      });
    });
  }
  min(t, n = _f.min) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(r) {
        return r >= this.resolve(t);
      }
    });
  }
  max(t, n = _f.max) {
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(r) {
        return r <= this.resolve(t);
      }
    });
  }
  lessThan(t, n = _f.lessThan) {
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        less: t
      },
      skipAbsent: !0,
      test(r) {
        return r < this.resolve(t);
      }
    });
  }
  moreThan(t, n = _f.moreThan) {
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        more: t
      },
      skipAbsent: !0,
      test(r) {
        return r > this.resolve(t);
      }
    });
  }
  positive(t = _f.positive) {
    return this.moreThan(0, t);
  }
  negative(t = _f.negative) {
    return this.lessThan(0, t);
  }
  integer(t = _f.integer) {
    return this.test({
      name: "integer",
      message: t,
      skipAbsent: !0,
      test: (n) => Number.isInteger(n)
    });
  }
  truncate() {
    return this.transform((t) => Bl(t) ? t : t | 0);
  }
  round(t) {
    var n;
    let r = ["ceil", "floor", "round", "trunc"];
    if (t = ((n = t) == null ? void 0 : n.toLowerCase()) || "round", t === "trunc")
      return this.truncate();
    if (r.indexOf(t.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + r.join(", "));
    return this.transform((a) => Bl(a) ? a : Math[t](a));
  }
}
T8.prototype = MM.prototype;
var _be = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function Obe(e) {
  var t = [1, 4, 5, 6, 7, 10, 11], n = 0, r, a;
  if (a = _be.exec(e)) {
    for (var s = 0, l; l = t[s]; ++s)
      a[l] = +a[l] || 0;
    a[2] = (+a[2] || 1) - 1, a[3] = +a[3] || 1, a[7] = a[7] ? String(a[7]).substr(0, 3) : 0, (a[8] === void 0 || a[8] === "") && (a[9] === void 0 || a[9] === "") ? r = +new Date(a[1], a[2], a[3], a[4], a[5], a[6], a[7]) : (a[8] !== "Z" && a[9] !== void 0 && (n = a[10] * 60 + a[11], a[9] === "+" && (n = 0 - n)), r = Date.UTC(a[1], a[2], a[3], a[4], a[5] + n, a[6], a[7]));
  } else
    r = Date.parse ? Date.parse(e) : NaN;
  return r;
}
let _8 = /* @__PURE__ */ new Date(""), Pbe = (e) => Object.prototype.toString.call(e) === "[object Date]";
function NM() {
  return new $y();
}
class $y extends ti {
  constructor() {
    super({
      type: "date",
      check(t) {
        return Pbe(t) && !isNaN(t.getTime());
      }
    }), this.withMutation(() => {
      this.transform((t, n, r) => !r.spec.coerce || r.isType(t) || t === null ? t : (t = Obe(t), isNaN(t) ? $y.INVALID_DATE : new Date(t)));
    });
  }
  prepareParam(t, n) {
    let r;
    if (qf.isRef(t))
      r = t;
    else {
      let a = this.cast(t);
      if (!this._typeCheck(a))
        throw new TypeError(`\`${n}\` must be a Date or a value that can be \`cast()\` to a Date`);
      r = a;
    }
    return r;
  }
  min(t, n = GD.min) {
    let r = this.prepareParam(t, "min");
    return this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(a) {
        return a >= this.resolve(r);
      }
    });
  }
  max(t, n = GD.max) {
    let r = this.prepareParam(t, "max");
    return this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(a) {
        return a <= this.resolve(r);
      }
    });
  }
}
$y.INVALID_DATE = _8;
NM.prototype = $y.prototype;
NM.INVALID_DATE = _8;
function Rbe(e, t = []) {
  let n = [], r = /* @__PURE__ */ new Set(), a = new Set(t.map(([l, p]) => `${l}-${p}`));
  function s(l, p) {
    let m = vm.split(l)[0];
    r.add(m), a.has(`${p}-${m}`) || n.push([p, m]);
  }
  for (const l of Object.keys(e)) {
    let p = e[l];
    r.add(l), qf.isRef(p) && p.isSibling ? s(p.path, l) : Nm(p) && "deps" in p && p.deps.forEach((m) => s(m, l));
  }
  return lbe.array(Array.from(r), n).reverse();
}
function v5(e, t) {
  let n = 1 / 0;
  return e.some((r, a) => {
    var s;
    if ((s = t.path) != null && s.includes(r))
      return n = a, !0;
  }), n;
}
function O8(e) {
  return (t, n) => v5(e, t) - v5(e, n);
}
const P8 = (e, t, n) => {
  if (typeof e != "string")
    return e;
  let r = e;
  try {
    r = JSON.parse(e);
  } catch {
  }
  return n.isType(r) ? r : e;
};
function rE(e) {
  if ("fields" in e) {
    const t = {};
    for (const [n, r] of Object.entries(e.fields))
      t[n] = rE(r);
    return e.setFields(t);
  }
  if (e.type === "array") {
    const t = e.optional();
    return t.innerType && (t.innerType = rE(t.innerType)), t;
  }
  return e.type === "tuple" ? e.optional().clone({
    types: e.spec.types.map(rE)
  }) : "optional" in e ? e.optional() : e;
}
const kbe = (e, t) => {
  const n = [...vm.normalizePath(t)];
  if (n.length === 1)
    return n[0] in e;
  let r = n.pop(), a = vm.getter(vm.join(n), !0)(e);
  return !!(a && r in a);
};
let y5 = (e) => Object.prototype.toString.call(e) === "[object Object]";
function Dbe(e, t) {
  let n = Object.keys(e.fields);
  return Object.keys(t).filter((r) => n.indexOf(r) === -1);
}
const $be = O8([]);
function Y0(e) {
  return new IM(e);
}
class IM extends ti {
  constructor(t) {
    super({
      type: "object",
      check(n) {
        return y5(n) || typeof n == "function";
      }
    }), this.fields = /* @__PURE__ */ Object.create(null), this._sortErrors = $be, this._nodes = [], this._excludedEdges = [], this.withMutation(() => {
      t && this.shape(t);
    });
  }
  _cast(t, n = {}) {
    var r;
    let a = super._cast(t, n);
    if (a === void 0)
      return this.getDefault(n);
    if (!this._typeCheck(a))
      return a;
    let s = this.fields, l = (r = n.stripUnknown) != null ? r : this.spec.noUnknown, p = [].concat(this._nodes, Object.keys(a).filter((b) => !this._nodes.includes(b))), m = {}, h = Object.assign({}, n, {
      parent: m,
      __validating: n.__validating || !1
    }), g = !1;
    for (const b of p) {
      let x = s[b], E = b in a;
      if (x) {
        let O, _ = a[b];
        h.path = (n.path ? `${n.path}.` : "") + b, x = x.resolve({
          value: _,
          context: n.context,
          parent: m
        });
        let P = x instanceof ti ? x.spec : void 0, M = P == null ? void 0 : P.strict;
        if (P != null && P.strip) {
          g = g || b in a;
          continue;
        }
        O = !n.__validating || !M ? (
          // TODO: use _cast, this is double resolving
          x.cast(a[b], h)
        ) : a[b], O !== void 0 && (m[b] = O);
      } else
        E && !l && (m[b] = a[b]);
      (E !== b in m || m[b] !== a[b]) && (g = !0);
    }
    return g ? m : a;
  }
  _validate(t, n = {}, r, a) {
    let {
      from: s = [],
      originalValue: l = t,
      recursive: p = this.spec.recursive
    } = n;
    n.from = [{
      schema: this,
      value: l
    }, ...s], n.__validating = !0, n.originalValue = l, super._validate(t, n, r, (m, h) => {
      if (!p || !y5(h)) {
        a(m, h);
        return;
      }
      l = l || h;
      let g = [];
      for (let b of this._nodes) {
        let x = this.fields[b];
        !x || qf.isRef(x) || g.push(x.asNestedTest({
          options: n,
          key: b,
          parent: h,
          parentPath: n.path,
          originalParent: l
        }));
      }
      this.runTests({
        tests: g,
        value: h,
        originalValue: l,
        options: n
      }, r, (b) => {
        a(b.sort(this._sortErrors).concat(m), h);
      });
    });
  }
  clone(t) {
    const n = super.clone(t);
    return n.fields = Object.assign({}, this.fields), n._nodes = this._nodes, n._excludedEdges = this._excludedEdges, n._sortErrors = this._sortErrors, n;
  }
  concat(t) {
    let n = super.concat(t), r = n.fields;
    for (let [a, s] of Object.entries(this.fields)) {
      const l = r[a];
      r[a] = l === void 0 ? s : l;
    }
    return n.withMutation((a) => (
      // XXX: excludes here is wrong
      a.setFields(r, [...this._excludedEdges, ...t._excludedEdges])
    ));
  }
  _getDefault(t) {
    if ("default" in this.spec)
      return super._getDefault(t);
    if (!this._nodes.length)
      return;
    let n = {};
    return this._nodes.forEach((r) => {
      var a;
      const s = this.fields[r];
      let l = t;
      (a = l) != null && a.value && (l = Object.assign({}, l, {
        parent: l.value,
        value: l.value[r]
      })), n[r] = s && "getDefault" in s ? s.getDefault(l) : void 0;
    }), n;
  }
  setFields(t, n) {
    let r = this.clone();
    return r.fields = t, r._nodes = Rbe(t, n), r._sortErrors = O8(Object.keys(t)), n && (r._excludedEdges = n), r;
  }
  shape(t, n = []) {
    return this.clone().withMutation((r) => {
      let a = r._excludedEdges;
      return n.length && (Array.isArray(n[0]) || (n = [n]), a = [...r._excludedEdges, ...n]), r.setFields(Object.assign(r.fields, t), a);
    });
  }
  partial() {
    const t = {};
    for (const [n, r] of Object.entries(this.fields))
      t[n] = "optional" in r && r.optional instanceof Function ? r.optional() : r;
    return this.setFields(t);
  }
  deepPartial() {
    return rE(this);
  }
  pick(t) {
    const n = {};
    for (const r of t)
      this.fields[r] && (n[r] = this.fields[r]);
    return this.setFields(n);
  }
  omit(t) {
    const n = Object.assign({}, this.fields);
    for (const r of t)
      delete n[r];
    return this.setFields(n);
  }
  from(t, n, r) {
    let a = vm.getter(t, !0);
    return this.transform((s) => {
      if (!s)
        return s;
      let l = s;
      return kbe(s, t) && (l = Object.assign({}, s), r || delete l[t], l[n] = a(s)), l;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(P8);
  }
  noUnknown(t = !0, n = XD.noUnknown) {
    typeof t != "boolean" && (n = t, t = !0);
    let r = this.test({
      name: "noUnknown",
      exclusive: !0,
      message: n,
      test(a) {
        if (a == null)
          return !0;
        const s = Dbe(this.schema, a);
        return !t || s.length === 0 || this.createError({
          params: {
            unknown: s.join(", ")
          }
        });
      }
    });
    return r.spec.noUnknown = t, r;
  }
  unknown(t = !0, n = XD.noUnknown) {
    return this.noUnknown(!t, n);
  }
  transformKeys(t) {
    return this.transform((n) => {
      if (!n)
        return n;
      const r = {};
      for (const a of Object.keys(n))
        r[t(a)] = n[a];
      return r;
    });
  }
  camelCase() {
    return this.transformKeys(kk.camelCase);
  }
  snakeCase() {
    return this.transformKeys(kk.snakeCase);
  }
  constantCase() {
    return this.transformKeys((t) => kk.snakeCase(t).toUpperCase());
  }
  describe(t) {
    let n = super.describe(t);
    n.fields = {};
    for (const [a, s] of Object.entries(this.fields)) {
      var r;
      let l = t;
      (r = l) != null && r.value && (l = Object.assign({}, l, {
        parent: l.value,
        value: l.value[a]
      })), n.fields[a] = s.describe(l);
    }
    return n;
  }
}
Y0.prototype = IM.prototype;
function AM(e) {
  return new jM(e);
}
class jM extends ti {
  constructor(t) {
    super({
      type: "array",
      spec: {
        types: t
      },
      check(n) {
        return Array.isArray(n);
      }
    }), this.innerType = void 0, this.innerType = t;
  }
  _cast(t, n) {
    const r = super._cast(t, n);
    if (!this._typeCheck(r) || !this.innerType)
      return r;
    let a = !1;
    const s = r.map((l, p) => {
      const m = this.innerType.cast(l, Object.assign({}, n, {
        path: `${n.path || ""}[${p}]`
      }));
      return m !== l && (a = !0), m;
    });
    return a ? s : r;
  }
  _validate(t, n = {}, r, a) {
    var s;
    let l = this.innerType, p = (s = n.recursive) != null ? s : this.spec.recursive;
    n.originalValue != null && n.originalValue, super._validate(t, n, r, (m, h) => {
      var g;
      if (!p || !l || !this._typeCheck(h)) {
        a(m, h);
        return;
      }
      let b = new Array(h.length);
      for (let E = 0; E < h.length; E++) {
        var x;
        b[E] = l.asNestedTest({
          options: n,
          index: E,
          parent: h,
          parentPath: n.path,
          originalParent: (x = n.originalValue) != null ? x : t
        });
      }
      this.runTests({
        value: h,
        tests: b,
        originalValue: (g = n.originalValue) != null ? g : t,
        options: n
      }, r, (E) => a(E.concat(m), h));
    });
  }
  clone(t) {
    const n = super.clone(t);
    return n.innerType = this.innerType, n;
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(P8);
  }
  concat(t) {
    let n = super.concat(t);
    return n.innerType = this.innerType, t.innerType && (n.innerType = n.innerType ? (
      // @ts-expect-error Lazy doesn't have concat and will break
      n.innerType.concat(t.innerType)
    ) : t.innerType), n;
  }
  of(t) {
    let n = this.clone();
    if (!Nm(t))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + Xu(t));
    return n.innerType = t, n.spec = Object.assign({}, n.spec, {
      types: t
    }), n;
  }
  length(t, n = nE.length) {
    return this.test({
      message: n,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      skipAbsent: !0,
      test(r) {
        return r.length === this.resolve(t);
      }
    });
  }
  min(t, n) {
    return n = n || nE.min, this.test({
      message: n,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      // FIXME(ts): Array<typeof T>
      test(r) {
        return r.length >= this.resolve(t);
      }
    });
  }
  max(t, n) {
    return n = n || nE.max, this.test({
      message: n,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(r) {
        return r.length <= this.resolve(t);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((t, n) => this._typeCheck(t) ? t : n == null ? [] : [].concat(n));
  }
  compact(t) {
    let n = t ? (r, a, s) => !t(r, a, s) : (r) => !!r;
    return this.transform((r) => r != null ? r.filter(n) : r);
  }
  describe(t) {
    let n = super.describe(t);
    if (this.innerType) {
      var r;
      let a = t;
      (r = a) != null && r.value && (a = Object.assign({}, a, {
        parent: a.value,
        value: a.value[0]
      })), n.innerType = this.innerType.describe(a);
    }
    return n;
  }
}
AM.prototype = jM.prototype;
function R8(e) {
  return new LM(e);
}
class LM extends ti {
  constructor(t) {
    super({
      type: "tuple",
      spec: {
        types: t
      },
      check(n) {
        const r = this.spec.types;
        return Array.isArray(n) && n.length === r.length;
      }
    }), this.withMutation(() => {
      this.typeError(vbe.notType);
    });
  }
  _cast(t, n) {
    const {
      types: r
    } = this.spec, a = super._cast(t, n);
    if (!this._typeCheck(a))
      return a;
    let s = !1;
    const l = r.map((p, m) => {
      const h = p.cast(a[m], Object.assign({}, n, {
        path: `${n.path || ""}[${m}]`
      }));
      return h !== a[m] && (s = !0), h;
    });
    return s ? l : a;
  }
  _validate(t, n = {}, r, a) {
    let s = this.spec.types;
    super._validate(t, n, r, (l, p) => {
      var m;
      if (!this._typeCheck(p)) {
        a(l, p);
        return;
      }
      let h = [];
      for (let [b, x] of s.entries()) {
        var g;
        h[b] = x.asNestedTest({
          options: n,
          index: b,
          parent: p,
          parentPath: n.path,
          originalParent: (g = n.originalValue) != null ? g : t
        });
      }
      this.runTests({
        value: p,
        tests: h,
        originalValue: (m = n.originalValue) != null ? m : t,
        options: n
      }, r, (b) => a(b.concat(l), p));
    });
  }
  describe(t) {
    let n = super.describe(t);
    return n.innerType = this.spec.types.map((r, a) => {
      var s;
      let l = t;
      return (s = l) != null && s.value && (l = Object.assign({}, l, {
        parent: l.value,
        value: l.value[a]
      })), r.describe(l);
    }), n;
  }
}
R8.prototype = LM.prototype;
function Mbe(e) {
  return new FM(e);
}
class FM {
  constructor(t) {
    this.type = "lazy", this.__isYupSchema__ = !0, this.spec = void 0, this._resolve = (n, r = {}) => {
      let a = this.builder(n, r);
      if (!Nm(a))
        throw new TypeError("lazy() functions must return a valid schema");
      return this.spec.optional && (a = a.optional()), a.resolve(r);
    }, this.builder = t, this.spec = {
      meta: void 0,
      optional: !1
    };
  }
  clone(t) {
    const n = new FM(this.builder);
    return n.spec = Object.assign({}, this.spec, t), n;
  }
  optionality(t) {
    return this.clone({
      optional: t
    });
  }
  optional() {
    return this.optionality(!0);
  }
  resolve(t) {
    return this._resolve(t.value, t);
  }
  cast(t, n) {
    return this._resolve(t, n).cast(t, n);
  }
  asNestedTest(t) {
    let {
      key: n,
      index: r,
      parent: a,
      options: s
    } = t, l = a[r ?? n];
    return this._resolve(l, Object.assign({}, s, {
      value: l,
      parent: a
    })).asNestedTest(t);
  }
  validate(t, n) {
    return this._resolve(t, n).validate(t, n);
  }
  validateSync(t, n) {
    return this._resolve(t, n).validateSync(t, n);
  }
  validateAt(t, n, r) {
    return this._resolve(n, r).validateAt(t, n, r);
  }
  validateSyncAt(t, n, r) {
    return this._resolve(n, r).validateSyncAt(t, n, r);
  }
  isValid(t, n) {
    return this._resolve(t, n).isValid(t, n);
  }
  isValidSync(t, n) {
    return this._resolve(t, n).isValidSync(t, n);
  }
  describe(t) {
    return t ? this.resolve(t).describe(t) : {
      type: "lazy",
      meta: this.spec.meta,
      label: void 0
    };
  }
  meta(...t) {
    if (t.length === 0)
      return this.spec.meta;
    let n = this.clone();
    return n.spec.meta = Object.assign(n.spec.meta || {}, t[0]), n;
  }
}
function Nbe(e) {
  Object.keys(e).forEach((t) => {
    Object.keys(e[t]).forEach((n) => {
      C8[t][n] = e[t][n];
    });
  });
}
function Ibe(e, t, n) {
  if (!e || !Nm(e.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof t != "string")
    throw new TypeError("A Method name must be provided");
  if (typeof n != "function")
    throw new TypeError("Method function must be provided");
  e.prototype[t] = n;
}
const g5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArraySchema: jM,
  BooleanSchema: DM,
  DateSchema: $y,
  MixedSchema: kM,
  NumberSchema: MM,
  ObjectSchema: IM,
  Schema: ti,
  StringSchema: $M,
  TupleSchema: LM,
  ValidationError: bi,
  addMethod: Ibe,
  array: AM,
  bool: QD,
  boolean: QD,
  date: NM,
  defaultLocale: C8,
  getIn: PM,
  isSchema: Nm,
  lazy: Mbe,
  mixed: RM,
  number: T8,
  object: Y0,
  printValue: Xu,
  reach: gbe,
  ref: ybe,
  setLocale: Nbe,
  string: NC,
  tuple: R8
}, Symbol.toStringTag, { value: "Module" })), b5 = (e) => {
  const t = e.reduce((n, r) => {
    let { name: a, required: s, type: l } = r;
    switch (l) {
      case "RelatedList":
        l = "array";
        break;
      case "Related":
        l = "object";
        break;
      case "Date":
        l = "string";
        break;
      case "Integer":
      case "Float":
        l = "number";
        break;
      default:
        l = "string";
    }
    let p;
    try {
      s ? p = g5[l]().typeError(`Field must be of type ${l}`).required("Field is required") : p = g5[l]().typeError(`Field must be of type ${l}`).nullable(!0);
    } catch (m) {
      console.log(m);
    }
    return n[a] = p, n;
  }, {});
  return Y0().shape(t);
}, Abe = {
  data: null,
  info: null,
  queryParams: null,
  loading: !1,
  error: null
};
function jbe(e, t) {
  switch (t.type) {
    case "setData":
      return { ...e, data: t.payload, loading: !1, error: null };
    case "setInfo":
      return { ...e, info: t.payload };
    case "setQueryParams":
      return { ...e, queryParams: { ...t.payload } };
    case "setLoading":
      return { ...e, loading: t.payload };
    case "setError":
      return {
        ...e,
        error: t.payload
      };
    default:
      throw new Error();
  }
}
function Lbe(e) {
  const [t, n] = C.useReducer(jbe, {
    ...Abe,
    queryParams: e.initialQueryParams ? c5(null, e.initialQueryParams) : null
  });
  C.useEffect(() => {
    t.queryParams && a();
  }, [t.queryParams]), C.useEffect(() => {
    s();
  }, [e.path]);
  const r = (g) => {
    n({ type: "setLoading", payload: !0 });
    const b = c5(t.queryParams, g);
    n({ type: "setQueryParams", payload: b });
  }, a = async () => {
    try {
      const g = e.relation ? {
        ...t.queryParams,
        filters: [
          ...t.queryParams.filters,
          { col: e.relation.foreign_key, opr: e.relation.type, value: e.relation.id }
        ]
      } : t.queryParams, b = await Lge(e.path, g);
      return n({ type: "setData", payload: b }), b;
    } catch (g) {
      n({ type: "setError", payload: { message: "Couldn't fetch list", originalError: g } });
    }
  }, s = async () => {
    try {
      const g = await Fge(e.path), b = {
        ...g,
        add: {
          columns: g.add_columns,
          title: g.add_title,
          schema: b5(g.add_columns),
          defaultValues: d5(g.add_columns)
        },
        edit: {
          columns: g.edit_columns,
          title: g.edit_title,
          schema: b5(g.edit_columns),
          defaultValues: d5(g.edit_columns)
        }
      };
      return await n({ type: "setInfo", payload: b }), b;
    } catch (g) {
      n({ type: "setError", payload: { message: "Couldn't fetch list info", originalError: g } });
    }
  }, l = async (g) => {
    try {
      return await zge(e.path, g);
    } catch (b) {
      n({ type: "setError", payload: { message: `Couldn't fetch item with id ${g}`, originalError: b } });
    }
  }, p = async (g) => {
    try {
      const b = await Vge(e.path, g);
      return s(), a(), b;
    } catch (b) {
      n({ type: "setError", payload: { message: "Couldnt add item.", originalError: b } });
    }
  }, m = async (g, b) => {
    try {
      const x = await Uge(e.path, g, b);
      return s(), a(), x;
    } catch (x) {
      n({ type: "setError", payload: { message: `Couldn't update item with id ${g}`, originalError: x } });
    }
  }, h = async (g) => {
    try {
      const b = await Bge(e.path, g);
      return s(), a(), b;
    } catch (b) {
      n({ type: "setError", payload: { message: `Couldn't delete item with id ${g}`, originalError: b } });
    }
  };
  return {
    path: e.path,
    data: t.data,
    info: t.info,
    queryParams: t.queryParams,
    loading: t.loading,
    error: t.error,
    setQueryParams: r,
    getEntry: l,
    addEntry: p,
    updateEntry: m,
    deleteEntry: h
  };
}
const k8 = C.createContext({
  Api: {}
});
function sa() {
  const e = C.useContext(k8);
  if (e === void 0)
    throw new Error("useApi must be used within a SeidrApiProvider");
  return e.Api;
}
function Fbe({ path: e = "", initialQueryParams: t, relation: n, children: r }) {
  const { baseUrl: a } = jge(), s = Lbe({ path: qi(a, e), initialQueryParams: t, relation: n });
  return /* @__PURE__ */ L.jsx(k8.Provider, { value: { Api: s }, children: r });
}
const zbe = yn((e, { dense: t }) => ({
  toolbarRoot: {
    display: "flex",
    justifyContent: "space-between",
    padding: e.spacing.md,
    paddingBottom: t ? 0.5 * e.spacing.xs : e.spacing.md
  }
}));
var Vbe = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
}, Ube = Object.defineProperty, Bbe = Object.defineProperties, Hbe = Object.getOwnPropertyDescriptors, IC = Object.getOwnPropertySymbols, D8 = Object.prototype.hasOwnProperty, $8 = Object.prototype.propertyIsEnumerable, w5 = (e, t, n) => t in e ? Ube(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, x5 = (e, t) => {
  for (var n in t || (t = {}))
    D8.call(t, n) && w5(e, n, t[n]);
  if (IC)
    for (var n of IC(t))
      $8.call(t, n) && w5(e, n, t[n]);
  return e;
}, Wbe = (e, t) => Bbe(e, Hbe(t)), Ybe = (e, t) => {
  var n = {};
  for (var r in e)
    D8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && IC)
    for (var r of IC(e))
      t.indexOf(r) < 0 && $8.call(e, r) && (n[r] = e[r]);
  return n;
}, Oo = (e, t, n) => {
  const r = C.forwardRef(
    (a, s) => {
      var l = a, { color: p = "currentColor", size: m = 24, stroke: h = 2, children: g } = l, b = Ybe(l, ["color", "size", "stroke", "children"]);
      return C.createElement(
        "svg",
        x5(Wbe(x5({
          ref: s
        }, Vbe), {
          width: m,
          height: m,
          stroke: p,
          strokeWidth: h,
          className: `tabler-icon tabler-icon-${e}`
        }), b),
        [...n.map(([x, E]) => C.createElement(x, E)), ...g || []]
      );
    }
  );
  return r.propTypes = {
    color: c.string,
    size: c.oneOfType([c.string, c.number]),
    stroke: c.oneOfType([c.string, c.number])
  }, r.displayName = `${t}`, r;
}, qbe = Oo("alert-circle", "IconAlertCircle", [
  ["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }],
  ["path", { d: "M12 8v4", key: "svg-1" }],
  ["path", { d: "M12 16h.01", key: "svg-2" }]
]), Gbe = Oo("app-window", "IconAppWindow", [
  [
    "path",
    {
      d: "M3 5m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M6 8h.01", key: "svg-1" }],
  ["path", { d: "M9 8h.01", key: "svg-2" }]
]), Kbe = Oo("arrow-bar-to-left", "IconArrowBarToLeft", [
  ["path", { d: "M10 12l10 0", key: "svg-0" }],
  ["path", { d: "M10 12l4 4", key: "svg-1" }],
  ["path", { d: "M10 12l4 -4", key: "svg-2" }],
  ["path", { d: "M4 4l0 16", key: "svg-3" }]
]), Xbe = Oo(
  "arrow-bar-to-right",
  "IconArrowBarToRight",
  [
    ["path", { d: "M14 12l-10 0", key: "svg-0" }],
    ["path", { d: "M14 12l-4 4", key: "svg-1" }],
    ["path", { d: "M14 12l-4 -4", key: "svg-2" }],
    ["path", { d: "M20 4l0 16", key: "svg-3" }]
  ]
), S5 = Oo("border-right", "IconBorderRight", [
  ["path", { d: "M20 4l0 16", key: "svg-0" }],
  ["path", { d: "M4 4l0 .01", key: "svg-1" }],
  ["path", { d: "M8 4l0 .01", key: "svg-2" }],
  ["path", { d: "M12 4l0 .01", key: "svg-3" }],
  ["path", { d: "M16 4l0 .01", key: "svg-4" }],
  ["path", { d: "M4 8l0 .01", key: "svg-5" }],
  ["path", { d: "M12 8l0 .01", key: "svg-6" }],
  ["path", { d: "M4 12l0 .01", key: "svg-7" }],
  ["path", { d: "M8 12l0 .01", key: "svg-8" }],
  ["path", { d: "M12 12l0 .01", key: "svg-9" }],
  ["path", { d: "M16 12l0 .01", key: "svg-10" }],
  ["path", { d: "M4 16l0 .01", key: "svg-11" }],
  ["path", { d: "M12 16l0 .01", key: "svg-12" }],
  ["path", { d: "M4 20l0 .01", key: "svg-13" }],
  ["path", { d: "M8 20l0 .01", key: "svg-14" }],
  ["path", { d: "M12 20l0 .01", key: "svg-15" }],
  ["path", { d: "M16 20l0 .01", key: "svg-16" }]
]), M8 = Oo("calendar", "IconCalendar", [
  [
    "path",
    {
      d: "M4 7a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M16 3v4", key: "svg-1" }],
  ["path", { d: "M8 3v4", key: "svg-2" }],
  ["path", { d: "M4 11h16", key: "svg-3" }],
  ["path", { d: "M11 15h1", key: "svg-4" }],
  ["path", { d: "M12 15v3", key: "svg-5" }]
]), ZD = Oo("chevron-down", "IconChevronDown", [
  ["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]
]), Qbe = Oo("chevron-left", "IconChevronLeft", [
  ["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]
]), Zbe = Oo("chevron-right", "IconChevronRight", [
  ["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]
]), E5 = Oo("chevron-up", "IconChevronUp", [
  ["path", { d: "M6 15l6 -6l6 6", key: "svg-0" }]
]), Jbe = Oo("contrast-2", "IconContrast2", [
  [
    "path",
    {
      d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M4 18h2a6 6 0 0 0 6 -6a6 6 0 0 1 6 -6h2", key: "svg-1" }]
]), e0e = Oo("eye", "IconEye", [
  ["path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }],
  [
    "path",
    {
      d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6",
      key: "svg-1"
    }
  ]
]), C5 = Oo("filter", "IconFilter", [
  [
    "path",
    {
      d: "M4 4h16v2.172a2 2 0 0 1 -.586 1.414l-4.414 4.414v7l-6 2v-8.5l-4.48 -4.928a2 2 0 0 1 -.52 -1.345v-2.227z",
      key: "svg-0"
    }
  ]
]), t0e = Oo("id-badge-2", "IconIdBadge2", [
  ["path", { d: "M7 12h3v4h-3z", key: "svg-0" }],
  [
    "path",
    {
      d: "M10 6h-6a1 1 0 0 0 -1 1v12a1 1 0 0 0 1 1h16a1 1 0 0 0 1 -1v-12a1 1 0 0 0 -1 -1h-6",
      key: "svg-1"
    }
  ],
  [
    "path",
    {
      d: "M10 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v3a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z",
      key: "svg-2"
    }
  ],
  ["path", { d: "M14 16h2", key: "svg-3" }],
  ["path", { d: "M14 12h4", key: "svg-4" }]
]), T5 = Oo("lock", "IconLock", [
  [
    "path",
    {
      d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }],
  ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]
]), n0e = Oo("logout", "IconLogout", [
  [
    "path",
    {
      d: "M14 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2",
      key: "svg-0"
    }
  ],
  ["path", { d: "M9 12h12l-3 -3", key: "svg-1" }],
  ["path", { d: "M18 15l3 -3", key: "svg-2" }]
]), r0e = Oo("pencil", "IconPencil", [
  [
    "path",
    { d: "M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4", key: "svg-0" }
  ],
  ["path", { d: "M13.5 6.5l4 4", key: "svg-1" }]
]), N8 = Oo("plus", "IconPlus", [
  ["path", { d: "M12 5l0 14", key: "svg-0" }],
  ["path", { d: "M5 12l14 0", key: "svg-1" }]
]), o0e = Oo("resize", "IconResize", [
  [
    "path",
    {
      d: "M4 11v8a1 1 0 0 0 1 1h8m-9 -14v-1a1 1 0 0 1 1 -1h1m5 0h2m5 0h1a1 1 0 0 1 1 1v1m0 5v2m0 5v1a1 1 0 0 1 -1 1h-1",
      key: "svg-0"
    }
  ],
  ["path", { d: "M4 12h7a1 1 0 0 1 1 1v7", key: "svg-1" }]
]), a0e = Oo("settings", "IconSettings", [
  [
    "path",
    {
      d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-1" }]
]), I8 = Oo("trash", "IconTrash", [
  ["path", { d: "M4 7l16 0", key: "svg-0" }],
  ["path", { d: "M10 11l0 6", key: "svg-1" }],
  ["path", { d: "M14 11l0 6", key: "svg-2" }],
  [
    "path",
    { d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12", key: "svg-3" }
  ],
  ["path", { d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3", key: "svg-4" }]
]), i0e = Oo("users", "IconUsers", [
  ["path", { d: "M9 7m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }],
  ["path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "svg-2" }],
  ["path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85", key: "svg-3" }]
]);
function s0e({ onSettingsChange: e, settings: t }) {
  const [n, r] = C.useState(!1);
  return /* @__PURE__ */ L.jsxs(
    To,
    {
      position: "bottom-start",
      onOpen: () => r(!0),
      onClose: () => r(!1),
      opened: n,
      closeOnItemClick: !1,
      children: [
        /* @__PURE__ */ L.jsx(To.Target, { children: /* @__PURE__ */ L.jsx($m, { opened: n ? !1 : void 0, label: "Settings", children: /* @__PURE__ */ L.jsx(qs, { children: /* @__PURE__ */ L.jsx(a0e, {}) }) }) }),
        /* @__PURE__ */ L.jsxs(To.Dropdown, { children: [
          /* @__PURE__ */ L.jsx(To.Label, { children: "Theme" }),
          /* @__PURE__ */ L.jsx(
            To.Item,
            {
              icon: /* @__PURE__ */ L.jsx(Jbe, { size: 16 }),
              rightSection: /* @__PURE__ */ L.jsx(
                Hv,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.striped,
                  onChange: (a) => e({ ...t, striped: !t.striped })
                }
              ),
              children: "Striped"
            }
          ),
          /* @__PURE__ */ L.jsx(
            To.Item,
            {
              icon: /* @__PURE__ */ L.jsx(S5, { size: 16 }),
              rightSection: /* @__PURE__ */ L.jsx(
                Hv,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.rightBorder,
                  onChange: (a) => e({ ...t, rightBorder: !t.rightBorder })
                }
              ),
              children: "Right Border"
            }
          ),
          /* @__PURE__ */ L.jsx(To.Label, { children: "Layout" }),
          /* @__PURE__ */ L.jsx(
            To.Item,
            {
              icon: /* @__PURE__ */ L.jsx(o0e, { size: 16 }),
              rightSection: /* @__PURE__ */ L.jsx(
                Hv,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.dense,
                  onChange: (a) => e({ ...t, dense: !t.dense })
                }
              ),
              children: "Dense"
            }
          ),
          /* @__PURE__ */ L.jsx(
            To.Item,
            {
              icon: /* @__PURE__ */ L.jsx(S5, { size: 16 }),
              rightSection: /* @__PURE__ */ L.jsx(
                Hv,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.rtl,
                  onChange: (a) => e({ ...t, rtl: !t.rtl })
                }
              ),
              children: "RTL"
            }
          )
        ] })
      ]
    }
  );
}
var vw = (e) => e.type === "checkbox", qv = (e) => e instanceof Date, yi = (e) => e == null;
const A8 = (e) => typeof e == "object";
var ia = (e) => !yi(e) && !Array.isArray(e) && A8(e) && !qv(e), j8 = (e) => ia(e) && e.target ? vw(e.target) ? e.target.checked : e.target.value : e, l0e = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, L8 = (e, t) => e.has(l0e(t)), u0e = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return ia(t) && t.hasOwnProperty("isPrototypeOf");
}, zM = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function gi(e) {
  let t;
  const n = Array.isArray(e);
  if (e instanceof Date)
    t = new Date(e);
  else if (e instanceof Set)
    t = new Set(e);
  else if (!(zM && (e instanceof Blob || e instanceof FileList)) && (n || ia(e)))
    if (t = n ? [] : {}, !n && !u0e(e))
      t = e;
    else
      for (const r in e)
        e.hasOwnProperty(r) && (t[r] = gi(e[r]));
  else
    return e;
  return t;
}
var My = (e) => Array.isArray(e) ? e.filter(Boolean) : [], ao = (e) => e === void 0, Pt = (e, t, n) => {
  if (!t || !ia(e))
    return n;
  const r = My(t.split(/[,[\].]+?/)).reduce((a, s) => yi(a) ? a : a[s], e);
  return ao(r) || r === e ? ao(e[t]) ? n : e[t] : r;
};
const AC = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, Ws = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, Qc = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, c0e = le.createContext(null), GT = () => le.useContext(c0e);
var F8 = (e, t, n, r = !0) => {
  const a = {
    defaultValues: t._defaultValues
  };
  for (const s in e)
    Object.defineProperty(a, s, {
      get: () => {
        const l = s;
        return t._proxyFormState[l] !== Ws.all && (t._proxyFormState[l] = !r || Ws.all), n && (n[l] = !0), e[l];
      }
    });
  return a;
}, vs = (e) => ia(e) && !Object.keys(e).length, z8 = (e, t, n, r) => {
  n(e);
  const { name: a, ...s } = e;
  return vs(s) || Object.keys(s).length >= Object.keys(t).length || Object.keys(s).find((l) => t[l] === (!r || Ws.all));
}, bs = (e) => Array.isArray(e) ? e : [e], V8 = (e, t, n) => n && t ? e === t : !e || !t || e === t || bs(e).some((r) => r && (r.startsWith(t) || t.startsWith(r)));
function KT(e) {
  const t = le.useRef(e);
  t.current = e, le.useEffect(() => {
    const n = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      n && n.unsubscribe();
    };
  }, [e.disabled]);
}
function d0e(e) {
  const t = GT(), { control: n = t.control, disabled: r, name: a, exact: s } = e || {}, [l, p] = le.useState(n._formState), m = le.useRef(!0), h = le.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }), g = le.useRef(a);
  return g.current = a, KT({
    disabled: r,
    next: (b) => m.current && V8(g.current, b.name, s) && z8(b, h.current, n._updateFormState) && p({
      ...n._formState,
      ...b
    }),
    subject: n._subjects.state
  }), le.useEffect(() => (m.current = !0, h.current.isValid && n._updateValid(!0), () => {
    m.current = !1;
  }), [n]), F8(l, n, h.current, !1);
}
var Gu = (e) => typeof e == "string", U8 = (e, t, n, r, a) => Gu(e) ? (r && t.watch.add(e), Pt(n, e, a)) : Array.isArray(e) ? e.map((s) => (r && t.watch.add(s), Pt(n, s))) : (r && (t.watchAll = !0), n);
function f0e(e) {
  const t = GT(), { control: n = t.control, name: r, defaultValue: a, disabled: s, exact: l } = e || {}, p = le.useRef(r);
  p.current = r, KT({
    disabled: s,
    subject: n._subjects.values,
    next: (g) => {
      V8(p.current, g.name, l) && h(gi(U8(p.current, n._names, g.values || n._formValues, !1, a)));
    }
  });
  const [m, h] = le.useState(n._getWatch(r, a));
  return le.useEffect(() => n._removeUnmounted()), m;
}
var VM = (e) => /^\w*$/.test(e), B8 = (e) => My(e.replace(/["|']|\]/g, "").split(/\.|\[/));
function jr(e, t, n) {
  let r = -1;
  const a = VM(t) ? [t] : B8(t), s = a.length, l = s - 1;
  for (; ++r < s; ) {
    const p = a[r];
    let m = n;
    if (r !== l) {
      const h = e[p];
      m = ia(h) || Array.isArray(h) ? h : isNaN(+a[r + 1]) ? {} : [];
    }
    e[p] = m, e = e[p];
  }
  return e;
}
function md(e) {
  const t = GT(), { name: n, control: r = t.control, shouldUnregister: a } = e, s = L8(r._names.array, n), l = f0e({
    control: r,
    name: n,
    defaultValue: Pt(r._formValues, n, Pt(r._defaultValues, n, e.defaultValue)),
    exact: !0
  }), p = d0e({
    control: r,
    name: n
  }), m = le.useRef(r.register(n, {
    ...e.rules,
    value: l
  }));
  return m.current = r.register(n, e.rules), le.useEffect(() => {
    const h = r._options.shouldUnregister || a, g = (b, x) => {
      const E = Pt(r._fields, b);
      E && (E._f.mount = x);
    };
    if (g(n, !0), h) {
      const b = gi(Pt(r._options.defaultValues, n));
      jr(r._defaultValues, n, b), ao(Pt(r._formValues, n)) && jr(r._formValues, n, b);
    }
    return () => {
      (s ? h && !r._state.action : h) ? r.unregister(n) : g(n, !1);
    };
  }, [n, r, s, a]), {
    field: {
      name: n,
      value: l,
      onChange: le.useCallback((h) => m.current.onChange({
        target: {
          value: j8(h),
          name: n
        },
        type: AC.CHANGE
      }), [n]),
      onBlur: le.useCallback(() => m.current.onBlur({
        target: {
          value: Pt(r._formValues, n),
          name: n
        },
        type: AC.BLUR
      }), [n, r]),
      ref: (h) => {
        const g = Pt(r._fields, n);
        g && h && (g._f.ref = {
          focus: () => h.focus(),
          select: () => h.select(),
          setCustomValidity: (b) => h.setCustomValidity(b),
          reportValidity: () => h.reportValidity()
        });
      }
    },
    formState: p,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: !0,
        get: () => !!Pt(p.errors, n)
      },
      isDirty: {
        enumerable: !0,
        get: () => !!Pt(p.dirtyFields, n)
      },
      isTouched: {
        enumerable: !0,
        get: () => !!Pt(p.touchedFields, n)
      },
      error: {
        enumerable: !0,
        get: () => Pt(p.errors, n)
      }
    })
  };
}
var H8 = (e, t, n, r, a) => t ? {
  ...n[e],
  types: {
    ...n[e] && n[e].types ? n[e].types : {},
    [r]: a || !0
  }
} : {};
const jC = (e, t, n) => {
  for (const r of n || Object.keys(e)) {
    const a = Pt(e, r);
    if (a) {
      const { _f: s, ...l } = a;
      if (s && t(s.name)) {
        if (s.ref.focus) {
          s.ref.focus();
          break;
        } else if (s.refs && s.refs[0].focus) {
          s.refs[0].focus();
          break;
        }
      } else
        ia(l) && jC(l, t);
    }
  }
};
var Sf = () => {
  const e = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    const n = (Math.random() * 16 + e) % 16 | 0;
    return (t == "x" ? n : n & 3 | 8).toString(16);
  });
}, Dk = (e, t, n = {}) => n.shouldFocus || ao(n.shouldFocus) ? n.focusName || `${e}.${ao(n.focusIndex) ? t : n.focusIndex}.` : "", JD = (e) => ({
  isOnSubmit: !e || e === Ws.onSubmit,
  isOnBlur: e === Ws.onBlur,
  isOnChange: e === Ws.onChange,
  isOnAll: e === Ws.all,
  isOnTouch: e === Ws.onTouched
}), e$ = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some((r) => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length)))), W8 = (e, t, n) => {
  const r = My(Pt(e, n));
  return jr(r, "root", t[n]), jr(e, n, r), e;
}, ty = (e) => typeof e == "boolean", UM = (e) => e.type === "file", kf = (e) => typeof e == "function", LC = (e) => {
  if (!zM)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, oE = (e) => Gu(e), BM = (e) => e.type === "radio", FC = (e) => e instanceof RegExp;
const _5 = {
  value: !1,
  isValid: !1
}, O5 = { value: !0, isValid: !0 };
var Y8 = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((n) => n && n.checked && !n.disabled).map((n) => n.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !ao(e[0].attributes.value) ? ao(e[0].value) || e[0].value === "" ? O5 : { value: e[0].value, isValid: !0 } : O5
    ) : _5;
  }
  return _5;
};
const P5 = {
  isValid: !1,
  value: null
};
var q8 = (e) => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? {
  isValid: !0,
  value: n.value
} : t, P5) : P5;
function R5(e, t, n = "validate") {
  if (oE(e) || Array.isArray(e) && e.every(oE) || ty(e) && !e)
    return {
      type: n,
      message: oE(e) ? e : "",
      ref: t
    };
}
var Mv = (e) => ia(e) && !FC(e) ? e : {
  value: e,
  message: ""
}, t$ = async (e, t, n, r, a) => {
  const { ref: s, refs: l, required: p, maxLength: m, minLength: h, min: g, max: b, pattern: x, validate: E, name: O, valueAsNumber: _, mount: P, disabled: M } = e._f, D = Pt(t, O);
  if (!P || M)
    return {};
  const N = l ? l[0] : s, I = (re) => {
    r && N.reportValidity && (N.setCustomValidity(ty(re) ? "" : re || ""), N.reportValidity());
  }, R = {}, j = BM(s), U = vw(s), q = j || U, J = (_ || UM(s)) && ao(s.value) && ao(D) || LC(s) && s.value === "" || D === "" || Array.isArray(D) && !D.length, H = H8.bind(null, O, n, R), Z = (re, Y, K, Q = Qc.maxLength, te = Qc.minLength) => {
    const ne = re ? Y : K;
    R[O] = {
      type: re ? Q : te,
      message: ne,
      ref: s,
      ...H(re ? Q : te, ne)
    };
  };
  if (a ? !Array.isArray(D) || !D.length : p && (!q && (J || yi(D)) || ty(D) && !D || U && !Y8(l).isValid || j && !q8(l).isValid)) {
    const { value: re, message: Y } = oE(p) ? { value: !!p, message: p } : Mv(p);
    if (re && (R[O] = {
      type: Qc.required,
      message: Y,
      ref: N,
      ...H(Qc.required, Y)
    }, !n))
      return I(Y), R;
  }
  if (!J && (!yi(g) || !yi(b))) {
    let re, Y;
    const K = Mv(b), Q = Mv(g);
    if (!yi(D) && !isNaN(D)) {
      const te = s.valueAsNumber || D && +D;
      yi(K.value) || (re = te > K.value), yi(Q.value) || (Y = te < Q.value);
    } else {
      const te = s.valueAsDate || new Date(D), ne = (V) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + V), ae = s.type == "time", se = s.type == "week";
      Gu(K.value) && D && (re = ae ? ne(D) > ne(K.value) : se ? D > K.value : te > new Date(K.value)), Gu(Q.value) && D && (Y = ae ? ne(D) < ne(Q.value) : se ? D < Q.value : te < new Date(Q.value));
    }
    if ((re || Y) && (Z(!!re, K.message, Q.message, Qc.max, Qc.min), !n))
      return I(R[O].message), R;
  }
  if ((m || h) && !J && (Gu(D) || a && Array.isArray(D))) {
    const re = Mv(m), Y = Mv(h), K = !yi(re.value) && D.length > +re.value, Q = !yi(Y.value) && D.length < +Y.value;
    if ((K || Q) && (Z(K, re.message, Y.message), !n))
      return I(R[O].message), R;
  }
  if (x && !J && Gu(D)) {
    const { value: re, message: Y } = Mv(x);
    if (FC(re) && !D.match(re) && (R[O] = {
      type: Qc.pattern,
      message: Y,
      ref: s,
      ...H(Qc.pattern, Y)
    }, !n))
      return I(Y), R;
  }
  if (E) {
    if (kf(E)) {
      const re = await E(D, t), Y = R5(re, N);
      if (Y && (R[O] = {
        ...Y,
        ...H(Qc.validate, Y.message)
      }, !n))
        return I(Y.message), R;
    } else if (ia(E)) {
      let re = {};
      for (const Y in E) {
        if (!vs(re) && !n)
          break;
        const K = R5(await E[Y](D, t), N, Y);
        K && (re = {
          ...K,
          ...H(Y, K.message)
        }, I(K.message), n && (R[O] = re));
      }
      if (!vs(re) && (R[O] = {
        ref: N,
        ...re
      }, !n))
        return R;
    }
  }
  return I(!0), R;
};
function $k(e, t) {
  return [...e, ...bs(t)];
}
var Mk = (e) => Array.isArray(e) ? e.map(() => {
}) : void 0;
function Nk(e, t, n) {
  return [
    ...e.slice(0, t),
    ...bs(n),
    ...e.slice(t)
  ];
}
var Ik = (e, t, n) => Array.isArray(e) ? (ao(e[n]) && (e[n] = void 0), e.splice(n, 0, e.splice(t, 1)[0]), e) : [];
function Ak(e, t) {
  return [...bs(t), ...bs(e)];
}
function p0e(e, t) {
  let n = 0;
  const r = [...e];
  for (const a of t)
    r.splice(a - n, 1), n++;
  return My(r).length ? r : [];
}
var jk = (e, t) => ao(t) ? [] : p0e(e, bs(t).sort((n, r) => n - r)), Lk = (e, t, n) => {
  e[t] = [e[n], e[n] = e[t]][0];
};
function m0e(e, t) {
  const n = t.slice(0, -1).length;
  let r = 0;
  for (; r < n; )
    e = ao(e) ? r++ : e[t[r++]];
  return e;
}
function h0e(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !ao(e[t]))
      return !1;
  return !0;
}
function va(e, t) {
  const n = Array.isArray(t) ? t : VM(t) ? [t] : B8(t), r = n.length === 1 ? e : m0e(e, n), a = n.length - 1, s = n[a];
  return r && delete r[s], a !== 0 && (ia(r) && vs(r) || Array.isArray(r) && h0e(r)) && va(e, n.slice(0, -1)), e;
}
var k5 = (e, t, n) => (e[t] = n, e);
function v0e(e) {
  const t = GT(), { control: n = t.control, name: r, keyName: a = "id", shouldUnregister: s } = e, [l, p] = le.useState(n._getFieldArray(r)), m = le.useRef(n._getFieldArray(r).map(Sf)), h = le.useRef(l), g = le.useRef(r), b = le.useRef(!1);
  g.current = r, h.current = l, n._names.array.add(r), e.rules && n.register(r, e.rules), KT({
    next: ({ values: R, name: j }) => {
      if (j === g.current || !j) {
        const U = Pt(R, g.current);
        Array.isArray(U) && (p(U), m.current = U.map(Sf));
      }
    },
    subject: n._subjects.array
  });
  const x = le.useCallback((R) => {
    b.current = !0, n._updateFieldArray(r, R);
  }, [n, r]), E = (R, j) => {
    const U = bs(gi(R)), q = $k(n._getFieldArray(r), U);
    n._names.focus = Dk(r, q.length - 1, j), m.current = $k(m.current, U.map(Sf)), x(q), p(q), n._updateFieldArray(r, q, $k, {
      argA: Mk(R)
    });
  }, O = (R, j) => {
    const U = bs(gi(R)), q = Ak(n._getFieldArray(r), U);
    n._names.focus = Dk(r, 0, j), m.current = Ak(m.current, U.map(Sf)), x(q), p(q), n._updateFieldArray(r, q, Ak, {
      argA: Mk(R)
    });
  }, _ = (R) => {
    const j = jk(n._getFieldArray(r), R);
    m.current = jk(m.current, R), x(j), p(j), n._updateFieldArray(r, j, jk, {
      argA: R
    });
  }, P = (R, j, U) => {
    const q = bs(gi(j)), J = Nk(n._getFieldArray(r), R, q);
    n._names.focus = Dk(r, R, U), m.current = Nk(m.current, R, q.map(Sf)), x(J), p(J), n._updateFieldArray(r, J, Nk, {
      argA: R,
      argB: Mk(j)
    });
  }, M = (R, j) => {
    const U = n._getFieldArray(r);
    Lk(U, R, j), Lk(m.current, R, j), x(U), p(U), n._updateFieldArray(r, U, Lk, {
      argA: R,
      argB: j
    }, !1);
  }, D = (R, j) => {
    const U = n._getFieldArray(r);
    Ik(U, R, j), Ik(m.current, R, j), x(U), p(U), n._updateFieldArray(r, U, Ik, {
      argA: R,
      argB: j
    }, !1);
  }, N = (R, j) => {
    const U = gi(j), q = k5(n._getFieldArray(r), R, U);
    m.current = [...q].map((J, H) => !J || H === R ? Sf() : m.current[H]), x(q), p([...q]), n._updateFieldArray(r, q, k5, {
      argA: R,
      argB: U
    }, !0, !1);
  }, I = (R) => {
    const j = bs(gi(R));
    m.current = j.map(Sf), x([...j]), p([...j]), n._updateFieldArray(r, [...j], (U) => U, {}, !0, !1);
  };
  return le.useEffect(() => {
    if (n._state.action = !1, e$(r, n._names) && n._subjects.state.next({
      ...n._formState
    }), b.current && (!JD(n._options.mode).isOnSubmit || n._formState.isSubmitted))
      if (n._options.resolver)
        n._executeSchema([r]).then((R) => {
          const j = Pt(R.errors, r), U = Pt(n._formState.errors, r);
          (U ? !j && U.type || j && (U.type !== j.type || U.message !== j.message) : j && j.type) && (j ? jr(n._formState.errors, r, j) : va(n._formState.errors, r), n._subjects.state.next({
            errors: n._formState.errors
          }));
        });
      else {
        const R = Pt(n._fields, r);
        R && R._f && t$(R, n._formValues, n._options.criteriaMode === Ws.all, n._options.shouldUseNativeValidation, !0).then((j) => !vs(j) && n._subjects.state.next({
          errors: W8(n._formState.errors, j, r)
        }));
      }
    n._subjects.values.next({
      name: r,
      values: { ...n._formValues }
    }), n._names.focus && jC(n._fields, (R) => !!R && R.startsWith(n._names.focus || "")), n._names.focus = "", n._updateValid();
  }, [l, r, n]), le.useEffect(() => (!Pt(n._formValues, r) && n._updateFieldArray(r), () => {
    (n._options.shouldUnregister || s) && n.unregister(r);
  }), [r, n, a, s]), {
    swap: le.useCallback(M, [x, r, n]),
    move: le.useCallback(D, [x, r, n]),
    prepend: le.useCallback(O, [x, r, n]),
    append: le.useCallback(E, [x, r, n]),
    remove: le.useCallback(_, [x, r, n]),
    insert: le.useCallback(P, [x, r, n]),
    update: le.useCallback(N, [x, r, n]),
    replace: le.useCallback(I, [x, r, n]),
    fields: le.useMemo(() => l.map((R, j) => ({
      ...R,
      [a]: m.current[j] || Sf()
    })), [l, a])
  };
}
function Fk() {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (a) => {
      for (const s of e)
        s.next && s.next(a);
    },
    subscribe: (a) => (e.push(a), {
      unsubscribe: () => {
        e = e.filter((s) => s !== a);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}
var zC = (e) => yi(e) || !A8(e);
function pm(e, t) {
  if (zC(e) || zC(t))
    return e === t;
  if (qv(e) && qv(t))
    return e.getTime() === t.getTime();
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (const a of n) {
    const s = e[a];
    if (!r.includes(a))
      return !1;
    if (a !== "ref") {
      const l = t[a];
      if (qv(s) && qv(l) || ia(s) && ia(l) || Array.isArray(s) && Array.isArray(l) ? !pm(s, l) : s !== l)
        return !1;
    }
  }
  return !0;
}
var G8 = (e) => e.type === "select-multiple", y0e = (e) => BM(e) || vw(e), zk = (e) => LC(e) && e.isConnected, K8 = (e) => {
  for (const t in e)
    if (kf(e[t]))
      return !0;
  return !1;
};
function VC(e, t = {}) {
  const n = Array.isArray(e);
  if (ia(e) || n)
    for (const r in e)
      Array.isArray(e[r]) || ia(e[r]) && !K8(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, VC(e[r], t[r])) : yi(e[r]) || (t[r] = !0);
  return t;
}
function X8(e, t, n) {
  const r = Array.isArray(e);
  if (ia(e) || r)
    for (const a in e)
      Array.isArray(e[a]) || ia(e[a]) && !K8(e[a]) ? ao(t) || zC(n[a]) ? n[a] = Array.isArray(e[a]) ? VC(e[a], []) : { ...VC(e[a]) } : X8(e[a], yi(t) ? {} : t[a], n[a]) : n[a] = !pm(e[a], t[a]);
  return n;
}
var Vk = (e, t) => X8(e, t, VC(t)), Q8 = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) => ao(e) ? e : t ? e === "" ? NaN : e && +e : n && Gu(e) ? new Date(e) : r ? r(e) : e;
function Uk(e) {
  const t = e.ref;
  if (!(e.refs ? e.refs.every((n) => n.disabled) : t.disabled))
    return UM(t) ? t.files : BM(t) ? q8(e.refs).value : G8(t) ? [...t.selectedOptions].map(({ value: n }) => n) : vw(t) ? Y8(e.refs).value : Q8(ao(t.value) ? e.ref.value : t.value, e);
}
var g0e = (e, t, n, r) => {
  const a = {};
  for (const s of e) {
    const l = Pt(t, s);
    l && jr(a, s, l._f);
  }
  return {
    criteriaMode: n,
    names: [...e],
    fields: a,
    shouldUseNativeValidation: r
  };
}, t0 = (e) => ao(e) ? e : FC(e) ? e.source : ia(e) ? FC(e.value) ? e.value.source : e.value : e, b0e = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function D5(e, t, n) {
  const r = Pt(e, n);
  if (r || VM(n))
    return {
      error: r,
      name: n
    };
  const a = n.split(".");
  for (; a.length; ) {
    const s = a.join("."), l = Pt(t, s), p = Pt(e, s);
    if (l && !Array.isArray(l) && n !== s)
      return { name: n };
    if (p && p.type)
      return {
        name: s,
        error: p
      };
    a.pop();
  }
  return {
    name: n
  };
}
var w0e = (e, t, n, r, a) => a.isOnAll ? !1 : !n && a.isOnTouch ? !(t || e) : (n ? r.isOnBlur : a.isOnBlur) ? !e : (n ? r.isOnChange : a.isOnChange) ? e : !0, x0e = (e, t) => !My(Pt(e, t)).length && va(e, t);
const S0e = {
  mode: Ws.onSubmit,
  reValidateMode: Ws.onChange,
  shouldFocusError: !0
};
function E0e(e = {}, t) {
  let n = {
    ...S0e,
    ...e
  }, r = {
    submitCount: 0,
    isDirty: !1,
    isLoading: kf(n.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    errors: {}
  }, a = {}, s = ia(n.defaultValues) || ia(n.values) ? gi(n.defaultValues || n.values) || {} : {}, l = n.shouldUnregister ? {} : gi(s), p = {
    action: !1,
    mount: !1,
    watch: !1
  }, m = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, h, g = 0;
  const b = {
    isDirty: !1,
    dirtyFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, x = {
    values: Fk(),
    array: Fk(),
    state: Fk()
  }, E = e.resetOptions && e.resetOptions.keepDirtyValues, O = JD(n.mode), _ = JD(n.reValidateMode), P = n.criteriaMode === Ws.all, M = (oe) => (de) => {
    clearTimeout(g), g = setTimeout(oe, de);
  }, D = async (oe) => {
    if (b.isValid || oe) {
      const de = n.resolver ? vs((await J()).errors) : await Z(a, !0);
      de !== r.isValid && x.state.next({
        isValid: de
      });
    }
  }, N = (oe) => b.isValidating && x.state.next({
    isValidating: oe
  }), I = (oe, de = [], we, Me, Ae = !0, je = !0) => {
    if (Me && we) {
      if (p.action = !0, je && Array.isArray(Pt(a, oe))) {
        const qe = we(Pt(a, oe), Me.argA, Me.argB);
        Ae && jr(a, oe, qe);
      }
      if (je && Array.isArray(Pt(r.errors, oe))) {
        const qe = we(Pt(r.errors, oe), Me.argA, Me.argB);
        Ae && jr(r.errors, oe, qe), x0e(r.errors, oe);
      }
      if (b.touchedFields && je && Array.isArray(Pt(r.touchedFields, oe))) {
        const qe = we(Pt(r.touchedFields, oe), Me.argA, Me.argB);
        Ae && jr(r.touchedFields, oe, qe);
      }
      b.dirtyFields && (r.dirtyFields = Vk(s, l)), x.state.next({
        name: oe,
        isDirty: Y(oe, de),
        dirtyFields: r.dirtyFields,
        errors: r.errors,
        isValid: r.isValid
      });
    } else
      jr(l, oe, de);
  }, R = (oe, de) => {
    jr(r.errors, oe, de), x.state.next({
      errors: r.errors
    });
  }, j = (oe, de, we, Me) => {
    const Ae = Pt(a, oe);
    if (Ae) {
      const je = Pt(l, oe, ao(we) ? Pt(s, oe) : we);
      ao(je) || Me && Me.defaultChecked || de ? jr(l, oe, de ? je : Uk(Ae._f)) : te(oe, je), p.mount && D();
    }
  }, U = (oe, de, we, Me, Ae) => {
    let je = !1, qe = !1;
    const ot = {
      name: oe
    };
    if (!we || Me) {
      b.isDirty && (qe = r.isDirty, r.isDirty = ot.isDirty = Y(), je = qe !== ot.isDirty);
      const et = pm(Pt(s, oe), de);
      qe = Pt(r.dirtyFields, oe), et ? va(r.dirtyFields, oe) : jr(r.dirtyFields, oe, !0), ot.dirtyFields = r.dirtyFields, je = je || b.dirtyFields && qe !== !et;
    }
    if (we) {
      const et = Pt(r.touchedFields, oe);
      et || (jr(r.touchedFields, oe, we), ot.touchedFields = r.touchedFields, je = je || b.touchedFields && et !== we);
    }
    return je && Ae && x.state.next(ot), je ? ot : {};
  }, q = (oe, de, we, Me) => {
    const Ae = Pt(r.errors, oe), je = b.isValid && ty(de) && r.isValid !== de;
    if (e.delayError && we ? (h = M(() => R(oe, we)), h(e.delayError)) : (clearTimeout(g), h = null, we ? jr(r.errors, oe, we) : va(r.errors, oe)), (we ? !pm(Ae, we) : Ae) || !vs(Me) || je) {
      const qe = {
        ...Me,
        ...je && ty(de) ? { isValid: de } : {},
        errors: r.errors,
        name: oe
      };
      r = {
        ...r,
        ...qe
      }, x.state.next(qe);
    }
    N(!1);
  }, J = async (oe) => n.resolver(l, n.context, g0e(oe || m.mount, a, n.criteriaMode, n.shouldUseNativeValidation)), H = async (oe) => {
    const { errors: de } = await J();
    if (oe)
      for (const we of oe) {
        const Me = Pt(de, we);
        Me ? jr(r.errors, we, Me) : va(r.errors, we);
      }
    else
      r.errors = de;
    return de;
  }, Z = async (oe, de, we = {
    valid: !0
  }) => {
    for (const Me in oe) {
      const Ae = oe[Me];
      if (Ae) {
        const { _f: je, ...qe } = Ae;
        if (je) {
          const ot = m.array.has(je.name), et = await t$(Ae, l, P, n.shouldUseNativeValidation && !de, ot);
          if (et[je.name] && (we.valid = !1, de))
            break;
          !de && (Pt(et, je.name) ? ot ? W8(r.errors, et, je.name) : jr(r.errors, je.name, et[je.name]) : va(r.errors, je.name));
        }
        qe && await Z(qe, de, we);
      }
    }
    return we.valid;
  }, re = () => {
    for (const oe of m.unMount) {
      const de = Pt(a, oe);
      de && (de._f.refs ? de._f.refs.every((we) => !zk(we)) : !zk(de._f.ref)) && Se(oe);
    }
    m.unMount = /* @__PURE__ */ new Set();
  }, Y = (oe, de) => (oe && de && jr(l, oe, de), !pm(ee(), s)), K = (oe, de, we) => U8(oe, m, {
    ...p.mount ? l : ao(de) ? s : Gu(oe) ? { [oe]: de } : de
  }, we, de), Q = (oe) => My(Pt(p.mount ? l : s, oe, e.shouldUnregister ? Pt(s, oe, []) : [])), te = (oe, de, we = {}) => {
    const Me = Pt(a, oe);
    let Ae = de;
    if (Me) {
      const je = Me._f;
      je && (!je.disabled && jr(l, oe, Q8(de, je)), Ae = LC(je.ref) && yi(de) ? "" : de, G8(je.ref) ? [...je.ref.options].forEach((qe) => qe.selected = Ae.includes(qe.value)) : je.refs ? vw(je.ref) ? je.refs.length > 1 ? je.refs.forEach((qe) => (!qe.defaultChecked || !qe.disabled) && (qe.checked = Array.isArray(Ae) ? !!Ae.find((ot) => ot === qe.value) : Ae === qe.value)) : je.refs[0] && (je.refs[0].checked = !!Ae) : je.refs.forEach((qe) => qe.checked = qe.value === Ae) : UM(je.ref) ? je.ref.value = "" : (je.ref.value = Ae, je.ref.type || x.values.next({
        name: oe,
        values: { ...l }
      })));
    }
    (we.shouldDirty || we.shouldTouch) && U(oe, Ae, we.shouldTouch, we.shouldDirty, !0), we.shouldValidate && V(oe);
  }, ne = (oe, de, we) => {
    for (const Me in de) {
      const Ae = de[Me], je = `${oe}.${Me}`, qe = Pt(a, je);
      (m.array.has(oe) || !zC(Ae) || qe && !qe._f) && !qv(Ae) ? ne(je, Ae, we) : te(je, Ae, we);
    }
  }, ae = (oe, de, we = {}) => {
    const Me = Pt(a, oe), Ae = m.array.has(oe), je = gi(de);
    jr(l, oe, je), Ae ? (x.array.next({
      name: oe,
      values: { ...l }
    }), (b.isDirty || b.dirtyFields) && we.shouldDirty && x.state.next({
      name: oe,
      dirtyFields: Vk(s, l),
      isDirty: Y(oe, je)
    })) : Me && !Me._f && !yi(je) ? ne(oe, je, we) : te(oe, je, we), e$(oe, m) && x.state.next({ ...r }), x.values.next({
      name: oe,
      values: { ...l }
    }), !p.mount && t();
  }, se = async (oe) => {
    const de = oe.target;
    let we = de.name, Me = !0;
    const Ae = Pt(a, we), je = () => de.type ? Uk(Ae._f) : j8(oe);
    if (Ae) {
      let qe, ot;
      const et = je(), ct = oe.type === AC.BLUR || oe.type === AC.FOCUS_OUT, Qt = !b0e(Ae._f) && !n.resolver && !Pt(r.errors, we) && !Ae._f.deps || w0e(ct, Pt(r.touchedFields, we), r.isSubmitted, _, O), Ht = e$(we, m, ct);
      jr(l, we, et), ct ? (Ae._f.onBlur && Ae._f.onBlur(oe), h && h(0)) : Ae._f.onChange && Ae._f.onChange(oe);
      const kt = U(we, et, ct, !1), St = !vs(kt) || Ht;
      if (!ct && x.values.next({
        name: we,
        type: oe.type,
        values: { ...l }
      }), Qt)
        return b.isValid && D(), St && x.state.next({ name: we, ...Ht ? {} : kt });
      if (!ct && Ht && x.state.next({ ...r }), N(!0), n.resolver) {
        const { errors: cn } = await J([we]), Ne = D5(r.errors, a, we), Ie = D5(cn, a, Ne.name || we);
        qe = Ie.error, we = Ie.name, ot = vs(cn);
      } else
        qe = (await t$(Ae, l, P, n.shouldUseNativeValidation))[we], Me = isNaN(et) || et === Pt(l, we, et), Me && (qe ? ot = !1 : b.isValid && (ot = await Z(a, !0)));
      Me && (Ae._f.deps && V(Ae._f.deps), q(we, ot, qe, kt));
    }
  }, V = async (oe, de = {}) => {
    let we, Me;
    const Ae = bs(oe);
    if (N(!0), n.resolver) {
      const je = await H(ao(oe) ? oe : Ae);
      we = vs(je), Me = oe ? !Ae.some((qe) => Pt(je, qe)) : we;
    } else
      oe ? (Me = (await Promise.all(Ae.map(async (je) => {
        const qe = Pt(a, je);
        return await Z(qe && qe._f ? { [je]: qe } : qe);
      }))).every(Boolean), !(!Me && !r.isValid) && D()) : Me = we = await Z(a);
    return x.state.next({
      ...!Gu(oe) || b.isValid && we !== r.isValid ? {} : { name: oe },
      ...n.resolver || !oe ? { isValid: we } : {},
      errors: r.errors,
      isValidating: !1
    }), de.shouldFocus && !Me && jC(a, (je) => je && Pt(r.errors, je), oe ? Ae : m.mount), Me;
  }, ee = (oe) => {
    const de = {
      ...s,
      ...p.mount ? l : {}
    };
    return ao(oe) ? de : Gu(oe) ? Pt(de, oe) : oe.map((we) => Pt(de, we));
  }, he = (oe, de) => ({
    invalid: !!Pt((de || r).errors, oe),
    isDirty: !!Pt((de || r).dirtyFields, oe),
    isTouched: !!Pt((de || r).touchedFields, oe),
    error: Pt((de || r).errors, oe)
  }), ue = (oe) => {
    oe && bs(oe).forEach((de) => va(r.errors, de)), x.state.next({
      errors: oe ? r.errors : {}
    });
  }, fe = (oe, de, we) => {
    const Me = (Pt(a, oe, { _f: {} })._f || {}).ref;
    jr(r.errors, oe, {
      ...de,
      ref: Me
    }), x.state.next({
      name: oe,
      errors: r.errors,
      isValid: !1
    }), we && we.shouldFocus && Me && Me.focus && Me.focus();
  }, Ce = (oe, de) => kf(oe) ? x.values.subscribe({
    next: (we) => oe(K(void 0, de), we)
  }) : K(oe, de, !0), Se = (oe, de = {}) => {
    for (const we of oe ? bs(oe) : m.mount)
      m.mount.delete(we), m.array.delete(we), de.keepValue || (va(a, we), va(l, we)), !de.keepError && va(r.errors, we), !de.keepDirty && va(r.dirtyFields, we), !de.keepTouched && va(r.touchedFields, we), !n.shouldUnregister && !de.keepDefaultValue && va(s, we);
    x.values.next({
      values: { ...l }
    }), x.state.next({
      ...r,
      ...de.keepDirty ? { isDirty: Y() } : {}
    }), !de.keepIsValid && D();
  }, Te = (oe, de = {}) => {
    let we = Pt(a, oe);
    const Me = ty(de.disabled);
    return jr(a, oe, {
      ...we || {},
      _f: {
        ...we && we._f ? we._f : { ref: { name: oe } },
        name: oe,
        mount: !0,
        ...de
      }
    }), m.mount.add(oe), we ? Me && jr(l, oe, de.disabled ? void 0 : Pt(l, oe, Uk(we._f))) : j(oe, !0, de.value), {
      ...Me ? { disabled: de.disabled } : {},
      ...n.progressive ? {
        required: !!de.required,
        min: t0(de.min),
        max: t0(de.max),
        minLength: t0(de.minLength),
        maxLength: t0(de.maxLength),
        pattern: t0(de.pattern)
      } : {},
      name: oe,
      onChange: se,
      onBlur: se,
      ref: (Ae) => {
        if (Ae) {
          Te(oe, de), we = Pt(a, oe);
          const je = ao(Ae.value) && Ae.querySelectorAll && Ae.querySelectorAll("input,select,textarea")[0] || Ae, qe = y0e(je), ot = we._f.refs || [];
          if (qe ? ot.find((et) => et === je) : je === we._f.ref)
            return;
          jr(a, oe, {
            _f: {
              ...we._f,
              ...qe ? {
                refs: [
                  ...ot.filter(zk),
                  je,
                  ...Array.isArray(Pt(s, oe)) ? [{}] : []
                ],
                ref: { type: je.type, name: oe }
              } : { ref: je }
            }
          }), j(oe, !1, void 0, je);
        } else
          we = Pt(a, oe, {}), we._f && (we._f.mount = !1), (n.shouldUnregister || de.shouldUnregister) && !(L8(m.array, oe) && p.action) && m.unMount.add(oe);
      }
    };
  }, pe = () => n.shouldFocusError && jC(a, (oe) => oe && Pt(r.errors, oe), m.mount), ye = (oe, de) => async (we) => {
    we && (we.preventDefault && we.preventDefault(), we.persist && we.persist());
    let Me = gi(l);
    if (x.state.next({
      isSubmitting: !0
    }), n.resolver) {
      const { errors: Ae, values: je } = await J();
      r.errors = Ae, Me = je;
    } else
      await Z(a);
    va(r.errors, "root"), vs(r.errors) ? (x.state.next({
      errors: {}
    }), await oe(Me, we)) : (de && await de({ ...r.errors }, we), pe(), setTimeout(pe)), x.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: vs(r.errors),
      submitCount: r.submitCount + 1,
      errors: r.errors
    });
  }, Oe = (oe, de = {}) => {
    Pt(a, oe) && (ao(de.defaultValue) ? ae(oe, Pt(s, oe)) : (ae(oe, de.defaultValue), jr(s, oe, de.defaultValue)), de.keepTouched || va(r.touchedFields, oe), de.keepDirty || (va(r.dirtyFields, oe), r.isDirty = de.defaultValue ? Y(oe, Pt(s, oe)) : Y()), de.keepError || (va(r.errors, oe), b.isValid && D()), x.state.next({ ...r }));
  }, Fe = (oe, de = {}) => {
    const we = oe || s, Me = gi(we), Ae = oe && !vs(oe) ? Me : s;
    if (de.keepDefaultValues || (s = we), !de.keepValues) {
      if (de.keepDirtyValues || E)
        for (const je of m.mount)
          Pt(r.dirtyFields, je) ? jr(Ae, je, Pt(l, je)) : ae(je, Pt(Ae, je));
      else {
        if (zM && ao(oe))
          for (const je of m.mount) {
            const qe = Pt(a, je);
            if (qe && qe._f) {
              const ot = Array.isArray(qe._f.refs) ? qe._f.refs[0] : qe._f.ref;
              if (LC(ot)) {
                const et = ot.closest("form");
                if (et) {
                  et.reset();
                  break;
                }
              }
            }
          }
        a = {};
      }
      l = e.shouldUnregister ? de.keepDefaultValues ? gi(s) : {} : gi(Ae), x.array.next({
        values: { ...Ae }
      }), x.values.next({
        values: { ...Ae }
      });
    }
    m = {
      mount: /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, !p.mount && t(), p.mount = !b.isValid || !!de.keepIsValid, p.watch = !!e.shouldUnregister, x.state.next({
      submitCount: de.keepSubmitCount ? r.submitCount : 0,
      isDirty: de.keepDirty ? r.isDirty : !!(de.keepDefaultValues && !pm(oe, s)),
      isSubmitted: de.keepIsSubmitted ? r.isSubmitted : !1,
      dirtyFields: de.keepDirtyValues ? r.dirtyFields : de.keepDefaultValues && oe ? Vk(s, oe) : {},
      touchedFields: de.keepTouched ? r.touchedFields : {},
      errors: de.keepErrors ? r.errors : {},
      isSubmitting: !1,
      isSubmitSuccessful: !1
    });
  }, me = (oe, de) => Fe(kf(oe) ? oe(l) : oe, de);
  return {
    control: {
      register: Te,
      unregister: Se,
      getFieldState: he,
      handleSubmit: ye,
      setError: fe,
      _executeSchema: J,
      _getWatch: K,
      _getDirty: Y,
      _updateValid: D,
      _removeUnmounted: re,
      _updateFieldArray: I,
      _getFieldArray: Q,
      _reset: Fe,
      _resetDefaultValues: () => kf(n.defaultValues) && n.defaultValues().then((oe) => {
        me(oe, n.resetOptions), x.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (oe) => {
        r = {
          ...r,
          ...oe
        };
      },
      _subjects: x,
      _proxyFormState: b,
      get _fields() {
        return a;
      },
      get _formValues() {
        return l;
      },
      get _state() {
        return p;
      },
      set _state(oe) {
        p = oe;
      },
      get _defaultValues() {
        return s;
      },
      get _names() {
        return m;
      },
      set _names(oe) {
        m = oe;
      },
      get _formState() {
        return r;
      },
      set _formState(oe) {
        r = oe;
      },
      get _options() {
        return n;
      },
      set _options(oe) {
        n = {
          ...n,
          ...oe
        };
      }
    },
    trigger: V,
    register: Te,
    handleSubmit: ye,
    watch: Ce,
    setValue: ae,
    getValues: ee,
    reset: me,
    resetField: Oe,
    clearErrors: ue,
    unregister: Se,
    setError: fe,
    setFocus: (oe, de = {}) => {
      const we = Pt(a, oe), Me = we && we._f;
      if (Me) {
        const Ae = Me.refs ? Me.refs[0] : Me.ref;
        Ae.focus && (Ae.focus(), de.shouldSelect && Ae.select());
      }
    },
    getFieldState: he
  };
}
function HM(e = {}) {
  const t = le.useRef(), [n, r] = le.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: kf(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    errors: {},
    defaultValues: kf(e.defaultValues) ? void 0 : e.defaultValues
  });
  t.current || (t.current = {
    ...E0e(e, () => r((s) => ({ ...s }))),
    formState: n
  });
  const a = t.current.control;
  return a._options = e, KT({
    subject: a._subjects.state,
    next: (s) => {
      z8(s, a._proxyFormState, a._updateFormState, !0) && r({ ...a._formState });
    }
  }), le.useEffect(() => {
    e.values && !pm(e.values, a._defaultValues) ? a._reset(e.values, a._options.resetOptions) : a._resetDefaultValues();
  }, [e.values, a]), le.useEffect(() => {
    a._state.mount || (a._updateValid(), a._state.mount = !0), a._state.watch && (a._state.watch = !1, a._subjects.state.next({ ...a._formState })), a._removeUnmounted();
  }), t.current.formState = F8(n, a), t.current;
}
var $5 = function(e, t, n) {
  if (e && "reportValidity" in e) {
    var r = Pt(n, t);
    e.setCustomValidity(r && r.message || ""), e.reportValidity();
  }
}, Z8 = function(e, t) {
  var n = function(a) {
    var s = t.fields[a];
    s && s.ref && "reportValidity" in s.ref ? $5(s.ref, a, e) : s.refs && s.refs.forEach(function(l) {
      return $5(l, a, e);
    });
  };
  for (var r in t.fields)
    n(r);
}, C0e = function(e, t) {
  t.shouldUseNativeValidation && Z8(e, t);
  var n = {};
  for (var r in e) {
    var a = Pt(t.fields, r);
    jr(n, r, Object.assign(e[r] || {}, { ref: a && a.ref }));
  }
  return n;
};
function WM(e, t, n) {
  return t === void 0 && (t = {}), n === void 0 && (n = {}), function(r, a, s) {
    try {
      return Promise.resolve(function(l, p) {
        try {
          var m = (t.context && process.env.NODE_ENV === "development" && console.warn("You should not used the yup options context. Please, use the 'useForm' context object instead"), Promise.resolve(e[n.mode === "sync" ? "validateSync" : "validate"](r, Object.assign({ abortEarly: !1 }, t, { context: a }))).then(function(h) {
            return s.shouldUseNativeValidation && Z8({}, s), { values: n.raw ? r : h, errors: {} };
          }));
        } catch (h) {
          return p(h);
        }
        return m && m.then ? m.then(void 0, p) : m;
      }(0, function(l) {
        if (!l.inner)
          throw l;
        return { values: {}, errors: C0e((p = l, m = !s.shouldUseNativeValidation && s.criteriaMode === "all", (p.inner || []).reduce(function(h, g) {
          if (h[g.path] || (h[g.path] = { message: g.message, type: g.type }), m) {
            var b = h[g.path].types, x = b && b[g.type];
            h[g.path] = H8(g.path, m, h, g.type, x ? [].concat(x, g.message) : g.message);
          }
          return h;
        }, {})), s) };
        var p, m;
      }));
    } catch (l) {
      return Promise.reject(l);
    }
  };
}
function lr(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var t = Number(e);
  return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t);
}
function id(e) {
  "@babel/helpers - typeof";
  return id = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, id(e);
}
function _t(e, t) {
  if (t.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function Rt(e) {
  _t(1, arguments);
  var t = Object.prototype.toString.call(e);
  return e instanceof Date || id(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function n$(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return isNaN(r) ? /* @__PURE__ */ new Date(NaN) : (r && n.setDate(n.getDate() + r), n);
}
function XT(e, t) {
  _t(2, arguments);
  var n = Rt(e).getTime(), r = lr(t);
  return new Date(n + r);
}
function T0e(e, t) {
  _t(2, arguments);
  var n = lr(t);
  return XT(e, n * 1e3);
}
var _0e = 6e4;
function O0e(e, t) {
  _t(2, arguments);
  var n = lr(t);
  return XT(e, n * _0e);
}
var P0e = 36e5;
function R0e(e, t) {
  _t(2, arguments);
  var n = lr(t);
  return XT(e, n * P0e);
}
function k0e(e, t) {
  _t(2, arguments);
  var n = lr(t), r = n * 7;
  return n$(e, r);
}
function aE(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  if (isNaN(r))
    return /* @__PURE__ */ new Date(NaN);
  if (!r)
    return n;
  var a = n.getDate(), s = new Date(n.getTime());
  s.setMonth(n.getMonth() + r + 1, 0);
  var l = s.getDate();
  return a >= l ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), a), n);
}
function M5(e, t) {
  _t(2, arguments);
  var n = lr(t);
  return aE(e, n * 12);
}
function D0e(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getFullYear() - r.getFullYear();
}
function R0(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t), a = n.getTime() - r.getTime();
  return a < 0 ? -1 : a > 0 ? 1 : a;
}
function $0e(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t), a = R0(n, r), s = Math.abs(D0e(n, r));
  n.setFullYear(1584), r.setFullYear(1584);
  var l = R0(n, r) === -a, p = a * (s - Number(l));
  return p === 0 ? 0 : p;
}
function M0e(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t), a = n.getFullYear() - r.getFullYear(), s = n.getMonth() - r.getMonth();
  return a * 12 + s;
}
function r$(e) {
  _t(1, arguments);
  var t = Rt(e);
  return t.setHours(23, 59, 59, 999), t;
}
function o$(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getMonth();
  return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function N0e(e) {
  _t(1, arguments);
  var t = Rt(e);
  return r$(t).getTime() === o$(t).getTime();
}
function J8(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t), a = R0(n, r), s = Math.abs(M0e(n, r)), l;
  if (s < 1)
    l = 0;
  else {
    n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30), n.setMonth(n.getMonth() - a * s);
    var p = R0(n, r) === -a;
    N0e(Rt(e)) && s === 1 && R0(e, r) === 1 && (p = !1), l = a * (s - Number(p));
  }
  return l === 0 ? 0 : l;
}
var N5 = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(t) {
    return t < 0 ? Math.ceil(t) : Math.floor(t);
  }
  // Math.trunc is not supported by IE
}, I0e = "trunc";
function yw(e) {
  return e ? N5[e] : N5[I0e];
}
function A0e(e, t, n) {
  _t(2, arguments);
  var r = J8(e, t) / 3;
  return yw(n == null ? void 0 : n.roundingMethod)(r);
}
function UC(e) {
  var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
  return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime();
}
function yy(e) {
  _t(1, arguments);
  var t = Rt(e);
  return t.setHours(0, 0, 0, 0), t;
}
var j0e = 864e5;
function L0e(e, t) {
  _t(2, arguments);
  var n = yy(e), r = yy(t), a = n.getTime() - UC(n), s = r.getTime() - UC(r);
  return Math.round((a - s) / j0e);
}
function I5(e, t) {
  var n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function e9(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t), a = I5(n, r), s = Math.abs(L0e(n, r));
  n.setDate(n.getDate() - a * s);
  var l = +(I5(n, r) === -a), p = a * (s - l);
  return p === 0 ? 0 : p;
}
function F0e(e, t, n) {
  _t(2, arguments);
  var r = e9(e, t) / 7;
  return yw(n == null ? void 0 : n.roundingMethod)(r);
}
var QT = 6e4, ZT = 36e5, z0e = 1e3;
function JT(e, t) {
  return _t(2, arguments), Rt(e).getTime() - Rt(t).getTime();
}
function V0e(e, t, n) {
  _t(2, arguments);
  var r = JT(e, t) / ZT;
  return yw(n == null ? void 0 : n.roundingMethod)(r);
}
function U0e(e, t, n) {
  _t(2, arguments);
  var r = JT(e, t) / QT;
  return yw(n == null ? void 0 : n.roundingMethod)(r);
}
function B0e(e, t, n) {
  _t(2, arguments);
  var r = JT(e, t) / 1e3;
  return yw(n == null ? void 0 : n.roundingMethod)(r);
}
function H0e(e, t) {
  var n;
  _t(1, arguments);
  var r = e || {}, a = Rt(r.start), s = Rt(r.end), l = s.getTime();
  if (!(a.getTime() <= l))
    throw new RangeError("Invalid interval");
  var p = [], m = a;
  m.setHours(0, 0, 0, 0);
  var h = Number((n = t == null ? void 0 : t.step) !== null && n !== void 0 ? n : 1);
  if (h < 1 || isNaN(h))
    throw new RangeError("`options.step` must be a number greater than 1");
  for (; m.getTime() <= l; )
    p.push(Rt(m)), m.setDate(m.getDate() + h), m.setHours(0, 0, 0, 0);
  return p;
}
var W0e = {};
function ic() {
  return W0e;
}
function Bk(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = ic(), b = lr((n = (r = (a = (s = t == null ? void 0 : t.weekStartsOn) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.weekStartsOn) !== null && a !== void 0 ? a : g.weekStartsOn) !== null && r !== void 0 ? r : (m = g.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(b >= 0 && b <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var x = Rt(e), E = x.getDay(), O = (E < b ? -7 : 0) + 6 - (E - b);
  return x.setDate(x.getDate() + O), x.setHours(23, 59, 59, 999), x;
}
function Hk(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getFullYear();
  return t.setFullYear(n + 1, 0, 0), t.setHours(23, 59, 59, 999), t;
}
function Y0e(e) {
  return _t(1, arguments), e instanceof Date || id(e) === "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function t9(e) {
  if (_t(1, arguments), !Y0e(e) && typeof e != "number")
    return !1;
  var t = Rt(e);
  return !isNaN(Number(t));
}
function n9(e, t) {
  _t(2, arguments);
  var n = lr(t);
  return XT(e, -n);
}
var q0e = 864e5;
function G0e(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getTime();
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  var r = t.getTime(), a = n - r;
  return Math.floor(a / q0e) + 1;
}
function gy(e) {
  _t(1, arguments);
  var t = 1, n = Rt(e), r = n.getUTCDay(), a = (r < t ? 7 : 0) + r - t;
  return n.setUTCDate(n.getUTCDate() - a), n.setUTCHours(0, 0, 0, 0), n;
}
function r9(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getUTCFullYear(), r = /* @__PURE__ */ new Date(0);
  r.setUTCFullYear(n + 1, 0, 4), r.setUTCHours(0, 0, 0, 0);
  var a = gy(r), s = /* @__PURE__ */ new Date(0);
  s.setUTCFullYear(n, 0, 4), s.setUTCHours(0, 0, 0, 0);
  var l = gy(s);
  return t.getTime() >= a.getTime() ? n + 1 : t.getTime() >= l.getTime() ? n : n - 1;
}
function K0e(e) {
  _t(1, arguments);
  var t = r9(e), n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(t, 0, 4), n.setUTCHours(0, 0, 0, 0);
  var r = gy(n);
  return r;
}
var X0e = 6048e5;
function o9(e) {
  _t(1, arguments);
  var t = Rt(e), n = gy(t).getTime() - K0e(t).getTime();
  return Math.round(n / X0e) + 1;
}
function Tm(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = ic(), b = lr((n = (r = (a = (s = t == null ? void 0 : t.weekStartsOn) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.weekStartsOn) !== null && a !== void 0 ? a : g.weekStartsOn) !== null && r !== void 0 ? r : (m = g.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(b >= 0 && b <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var x = Rt(e), E = x.getUTCDay(), O = (E < b ? 7 : 0) + E - b;
  return x.setUTCDate(x.getUTCDate() - O), x.setUTCHours(0, 0, 0, 0), x;
}
function YM(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = Rt(e), b = g.getUTCFullYear(), x = ic(), E = lr((n = (r = (a = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && a !== void 0 ? a : x.firstWeekContainsDate) !== null && r !== void 0 ? r : (m = x.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
  if (!(E >= 1 && E <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var O = /* @__PURE__ */ new Date(0);
  O.setUTCFullYear(b + 1, 0, E), O.setUTCHours(0, 0, 0, 0);
  var _ = Tm(O, t), P = /* @__PURE__ */ new Date(0);
  P.setUTCFullYear(b, 0, E), P.setUTCHours(0, 0, 0, 0);
  var M = Tm(P, t);
  return g.getTime() >= _.getTime() ? b + 1 : g.getTime() >= M.getTime() ? b : b - 1;
}
function Q0e(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = ic(), b = lr((n = (r = (a = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && a !== void 0 ? a : g.firstWeekContainsDate) !== null && r !== void 0 ? r : (m = g.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && n !== void 0 ? n : 1), x = YM(e, t), E = /* @__PURE__ */ new Date(0);
  E.setUTCFullYear(x, 0, b), E.setUTCHours(0, 0, 0, 0);
  var O = Tm(E, t);
  return O;
}
var Z0e = 6048e5;
function a9(e, t) {
  _t(1, arguments);
  var n = Rt(e), r = Tm(n, t).getTime() - Q0e(n, t).getTime();
  return Math.round(r / Z0e) + 1;
}
function Bn(e, t) {
  for (var n = e < 0 ? "-" : "", r = Math.abs(e).toString(); r.length < t; )
    r = "0" + r;
  return n + r;
}
var J0e = {
  // Year
  y: function(t, n) {
    var r = t.getUTCFullYear(), a = r > 0 ? r : 1 - r;
    return Bn(n === "yy" ? a % 100 : a, n.length);
  },
  // Month
  M: function(t, n) {
    var r = t.getUTCMonth();
    return n === "M" ? String(r + 1) : Bn(r + 1, 2);
  },
  // Day of the month
  d: function(t, n) {
    return Bn(t.getUTCDate(), n.length);
  },
  // AM or PM
  a: function(t, n) {
    var r = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (n) {
      case "a":
      case "aa":
        return r.toUpperCase();
      case "aaa":
        return r;
      case "aaaaa":
        return r[0];
      case "aaaa":
      default:
        return r === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function(t, n) {
    return Bn(t.getUTCHours() % 12 || 12, n.length);
  },
  // Hour [0-23]
  H: function(t, n) {
    return Bn(t.getUTCHours(), n.length);
  },
  // Minute
  m: function(t, n) {
    return Bn(t.getUTCMinutes(), n.length);
  },
  // Second
  s: function(t, n) {
    return Bn(t.getUTCSeconds(), n.length);
  },
  // Fraction of second
  S: function(t, n) {
    var r = n.length, a = t.getUTCMilliseconds(), s = Math.floor(a * Math.pow(10, r - 3));
    return Bn(s, n.length);
  }
};
const Ef = J0e;
var Nv = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, ewe = {
  // Era
  G: function(t, n, r) {
    var a = t.getUTCFullYear() > 0 ? 1 : 0;
    switch (n) {
      case "G":
      case "GG":
      case "GGG":
        return r.era(a, {
          width: "abbreviated"
        });
      case "GGGGG":
        return r.era(a, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return r.era(a, {
          width: "wide"
        });
    }
  },
  // Year
  y: function(t, n, r) {
    if (n === "yo") {
      var a = t.getUTCFullYear(), s = a > 0 ? a : 1 - a;
      return r.ordinalNumber(s, {
        unit: "year"
      });
    }
    return Ef.y(t, n);
  },
  // Local week-numbering year
  Y: function(t, n, r, a) {
    var s = YM(t, a), l = s > 0 ? s : 1 - s;
    if (n === "YY") {
      var p = l % 100;
      return Bn(p, 2);
    }
    return n === "Yo" ? r.ordinalNumber(l, {
      unit: "year"
    }) : Bn(l, n.length);
  },
  // ISO week-numbering year
  R: function(t, n) {
    var r = r9(t);
    return Bn(r, n.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, n) {
    var r = t.getUTCFullYear();
    return Bn(r, n.length);
  },
  // Quarter
  Q: function(t, n, r) {
    var a = Math.ceil((t.getUTCMonth() + 1) / 3);
    switch (n) {
      case "Q":
        return String(a);
      case "QQ":
        return Bn(a, 2);
      case "Qo":
        return r.ordinalNumber(a, {
          unit: "quarter"
        });
      case "QQQ":
        return r.quarter(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return r.quarter(a, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return r.quarter(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, n, r) {
    var a = Math.ceil((t.getUTCMonth() + 1) / 3);
    switch (n) {
      case "q":
        return String(a);
      case "qq":
        return Bn(a, 2);
      case "qo":
        return r.ordinalNumber(a, {
          unit: "quarter"
        });
      case "qqq":
        return r.quarter(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return r.quarter(a, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return r.quarter(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, n, r) {
    var a = t.getUTCMonth();
    switch (n) {
      case "M":
      case "MM":
        return Ef.M(t, n);
      case "Mo":
        return r.ordinalNumber(a + 1, {
          unit: "month"
        });
      case "MMM":
        return r.month(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return r.month(a, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return r.month(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function(t, n, r) {
    var a = t.getUTCMonth();
    switch (n) {
      case "L":
        return String(a + 1);
      case "LL":
        return Bn(a + 1, 2);
      case "Lo":
        return r.ordinalNumber(a + 1, {
          unit: "month"
        });
      case "LLL":
        return r.month(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return r.month(a, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return r.month(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function(t, n, r, a) {
    var s = a9(t, a);
    return n === "wo" ? r.ordinalNumber(s, {
      unit: "week"
    }) : Bn(s, n.length);
  },
  // ISO week of year
  I: function(t, n, r) {
    var a = o9(t);
    return n === "Io" ? r.ordinalNumber(a, {
      unit: "week"
    }) : Bn(a, n.length);
  },
  // Day of the month
  d: function(t, n, r) {
    return n === "do" ? r.ordinalNumber(t.getUTCDate(), {
      unit: "date"
    }) : Ef.d(t, n);
  },
  // Day of year
  D: function(t, n, r) {
    var a = G0e(t);
    return n === "Do" ? r.ordinalNumber(a, {
      unit: "dayOfYear"
    }) : Bn(a, n.length);
  },
  // Day of week
  E: function(t, n, r) {
    var a = t.getUTCDay();
    switch (n) {
      case "E":
      case "EE":
      case "EEE":
        return r.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return r.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return r.day(a, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return r.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, n, r, a) {
    var s = t.getUTCDay(), l = (s - a.weekStartsOn + 8) % 7 || 7;
    switch (n) {
      case "e":
        return String(l);
      case "ee":
        return Bn(l, 2);
      case "eo":
        return r.ordinalNumber(l, {
          unit: "day"
        });
      case "eee":
        return r.day(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return r.day(s, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return r.day(s, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return r.day(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, n, r, a) {
    var s = t.getUTCDay(), l = (s - a.weekStartsOn + 8) % 7 || 7;
    switch (n) {
      case "c":
        return String(l);
      case "cc":
        return Bn(l, n.length);
      case "co":
        return r.ordinalNumber(l, {
          unit: "day"
        });
      case "ccc":
        return r.day(s, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return r.day(s, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return r.day(s, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return r.day(s, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, n, r) {
    var a = t.getUTCDay(), s = a === 0 ? 7 : a;
    switch (n) {
      case "i":
        return String(s);
      case "ii":
        return Bn(s, n.length);
      case "io":
        return r.ordinalNumber(s, {
          unit: "day"
        });
      case "iii":
        return r.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return r.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return r.day(a, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return r.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, n, r) {
    var a = t.getUTCHours(), s = a / 12 >= 1 ? "pm" : "am";
    switch (n) {
      case "a":
      case "aa":
        return r.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return r.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return r.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return r.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, n, r) {
    var a = t.getUTCHours(), s;
    switch (a === 12 ? s = Nv.noon : a === 0 ? s = Nv.midnight : s = a / 12 >= 1 ? "pm" : "am", n) {
      case "b":
      case "bb":
        return r.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return r.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return r.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return r.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, n, r) {
    var a = t.getUTCHours(), s;
    switch (a >= 17 ? s = Nv.evening : a >= 12 ? s = Nv.afternoon : a >= 4 ? s = Nv.morning : s = Nv.night, n) {
      case "B":
      case "BB":
      case "BBB":
        return r.dayPeriod(s, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return r.dayPeriod(s, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return r.dayPeriod(s, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, n, r) {
    if (n === "ho") {
      var a = t.getUTCHours() % 12;
      return a === 0 && (a = 12), r.ordinalNumber(a, {
        unit: "hour"
      });
    }
    return Ef.h(t, n);
  },
  // Hour [0-23]
  H: function(t, n, r) {
    return n === "Ho" ? r.ordinalNumber(t.getUTCHours(), {
      unit: "hour"
    }) : Ef.H(t, n);
  },
  // Hour [0-11]
  K: function(t, n, r) {
    var a = t.getUTCHours() % 12;
    return n === "Ko" ? r.ordinalNumber(a, {
      unit: "hour"
    }) : Bn(a, n.length);
  },
  // Hour [1-24]
  k: function(t, n, r) {
    var a = t.getUTCHours();
    return a === 0 && (a = 24), n === "ko" ? r.ordinalNumber(a, {
      unit: "hour"
    }) : Bn(a, n.length);
  },
  // Minute
  m: function(t, n, r) {
    return n === "mo" ? r.ordinalNumber(t.getUTCMinutes(), {
      unit: "minute"
    }) : Ef.m(t, n);
  },
  // Second
  s: function(t, n, r) {
    return n === "so" ? r.ordinalNumber(t.getUTCSeconds(), {
      unit: "second"
    }) : Ef.s(t, n);
  },
  // Fraction of second
  S: function(t, n) {
    return Ef.S(t, n);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, n, r, a) {
    var s = a._originalDate || t, l = s.getTimezoneOffset();
    if (l === 0)
      return "Z";
    switch (n) {
      case "X":
        return j5(l);
      case "XXXX":
      case "XX":
        return am(l);
      case "XXXXX":
      case "XXX":
      default:
        return am(l, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, n, r, a) {
    var s = a._originalDate || t, l = s.getTimezoneOffset();
    switch (n) {
      case "x":
        return j5(l);
      case "xxxx":
      case "xx":
        return am(l);
      case "xxxxx":
      case "xxx":
      default:
        return am(l, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, n, r, a) {
    var s = a._originalDate || t, l = s.getTimezoneOffset();
    switch (n) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + A5(l, ":");
      case "OOOO":
      default:
        return "GMT" + am(l, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, n, r, a) {
    var s = a._originalDate || t, l = s.getTimezoneOffset();
    switch (n) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + A5(l, ":");
      case "zzzz":
      default:
        return "GMT" + am(l, ":");
    }
  },
  // Seconds timestamp
  t: function(t, n, r, a) {
    var s = a._originalDate || t, l = Math.floor(s.getTime() / 1e3);
    return Bn(l, n.length);
  },
  // Milliseconds timestamp
  T: function(t, n, r, a) {
    var s = a._originalDate || t, l = s.getTime();
    return Bn(l, n.length);
  }
};
function A5(e, t) {
  var n = e > 0 ? "-" : "+", r = Math.abs(e), a = Math.floor(r / 60), s = r % 60;
  if (s === 0)
    return n + String(a);
  var l = t || "";
  return n + String(a) + l + Bn(s, 2);
}
function j5(e, t) {
  if (e % 60 === 0) {
    var n = e > 0 ? "-" : "+";
    return n + Bn(Math.abs(e) / 60, 2);
  }
  return am(e, t);
}
function am(e, t) {
  var n = t || "", r = e > 0 ? "-" : "+", a = Math.abs(e), s = Bn(Math.floor(a / 60), 2), l = Bn(a % 60, 2);
  return r + s + n + l;
}
const twe = ewe;
var L5 = function(t, n) {
  switch (t) {
    case "P":
      return n.date({
        width: "short"
      });
    case "PP":
      return n.date({
        width: "medium"
      });
    case "PPP":
      return n.date({
        width: "long"
      });
    case "PPPP":
    default:
      return n.date({
        width: "full"
      });
  }
}, i9 = function(t, n) {
  switch (t) {
    case "p":
      return n.time({
        width: "short"
      });
    case "pp":
      return n.time({
        width: "medium"
      });
    case "ppp":
      return n.time({
        width: "long"
      });
    case "pppp":
    default:
      return n.time({
        width: "full"
      });
  }
}, nwe = function(t, n) {
  var r = t.match(/(P+)(p+)?/) || [], a = r[1], s = r[2];
  if (!s)
    return L5(t, n);
  var l;
  switch (a) {
    case "P":
      l = n.dateTime({
        width: "short"
      });
      break;
    case "PP":
      l = n.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      l = n.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      l = n.dateTime({
        width: "full"
      });
      break;
  }
  return l.replace("{{date}}", L5(a, n)).replace("{{time}}", i9(s, n));
}, rwe = {
  p: i9,
  P: nwe
};
const a$ = rwe;
var owe = ["D", "DD"], awe = ["YY", "YYYY"];
function s9(e) {
  return owe.indexOf(e) !== -1;
}
function l9(e) {
  return awe.indexOf(e) !== -1;
}
function BC(e, t, n) {
  if (e === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var iwe = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, swe = function(t, n, r) {
  var a, s = iwe[t];
  return typeof s == "string" ? a = s : n === 1 ? a = s.one : a = s.other.replace("{{count}}", n.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + a : a + " ago" : a;
};
const lwe = swe;
function Wk(e) {
  return function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.width ? String(t.width) : e.defaultWidth, r = e.formats[n] || e.formats[e.defaultWidth];
    return r;
  };
}
var uwe = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, cwe = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, dwe = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, fwe = {
  date: Wk({
    formats: uwe,
    defaultWidth: "full"
  }),
  time: Wk({
    formats: cwe,
    defaultWidth: "full"
  }),
  dateTime: Wk({
    formats: dwe,
    defaultWidth: "full"
  })
};
const pwe = fwe;
var mwe = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, hwe = function(t, n, r, a) {
  return mwe[t];
};
const vwe = hwe;
function n0(e) {
  return function(t, n) {
    var r = n != null && n.context ? String(n.context) : "standalone", a;
    if (r === "formatting" && e.formattingValues) {
      var s = e.defaultFormattingWidth || e.defaultWidth, l = n != null && n.width ? String(n.width) : s;
      a = e.formattingValues[l] || e.formattingValues[s];
    } else {
      var p = e.defaultWidth, m = n != null && n.width ? String(n.width) : e.defaultWidth;
      a = e.values[m] || e.values[p];
    }
    var h = e.argumentCallback ? e.argumentCallback(t) : t;
    return a[h];
  };
}
var ywe = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, gwe = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, bwe = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, wwe = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, xwe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, Swe = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, Ewe = function(t, n) {
  var r = Number(t), a = r % 100;
  if (a > 20 || a < 10)
    switch (a % 10) {
      case 1:
        return r + "st";
      case 2:
        return r + "nd";
      case 3:
        return r + "rd";
    }
  return r + "th";
}, Cwe = {
  ordinalNumber: Ewe,
  era: n0({
    values: ywe,
    defaultWidth: "wide"
  }),
  quarter: n0({
    values: gwe,
    defaultWidth: "wide",
    argumentCallback: function(t) {
      return t - 1;
    }
  }),
  month: n0({
    values: bwe,
    defaultWidth: "wide"
  }),
  day: n0({
    values: wwe,
    defaultWidth: "wide"
  }),
  dayPeriod: n0({
    values: xwe,
    defaultWidth: "wide",
    formattingValues: Swe,
    defaultFormattingWidth: "wide"
  })
};
const Twe = Cwe;
function r0(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.width, a = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(a);
    if (!s)
      return null;
    var l = s[0], p = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], m = Array.isArray(p) ? Owe(p, function(b) {
      return b.test(l);
    }) : _we(p, function(b) {
      return b.test(l);
    }), h;
    h = e.valueCallback ? e.valueCallback(m) : m, h = n.valueCallback ? n.valueCallback(h) : h;
    var g = t.slice(l.length);
    return {
      value: h,
      rest: g
    };
  };
}
function _we(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n) && t(e[n]))
      return n;
}
function Owe(e, t) {
  for (var n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function Pwe(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t.match(e.matchPattern);
    if (!r)
      return null;
    var a = r[0], s = t.match(e.parsePattern);
    if (!s)
      return null;
    var l = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    l = n.valueCallback ? n.valueCallback(l) : l;
    var p = t.slice(a.length);
    return {
      value: l,
      rest: p
    };
  };
}
var Rwe = /^(\d+)(th|st|nd|rd)?/i, kwe = /\d+/i, Dwe = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, $we = {
  any: [/^b/i, /^(a|c)/i]
}, Mwe = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, Nwe = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, Iwe = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, Awe = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, jwe = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, Lwe = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, Fwe = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, zwe = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, Vwe = {
  ordinalNumber: Pwe({
    matchPattern: Rwe,
    parsePattern: kwe,
    valueCallback: function(t) {
      return parseInt(t, 10);
    }
  }),
  era: r0({
    matchPatterns: Dwe,
    defaultMatchWidth: "wide",
    parsePatterns: $we,
    defaultParseWidth: "any"
  }),
  quarter: r0({
    matchPatterns: Mwe,
    defaultMatchWidth: "wide",
    parsePatterns: Nwe,
    defaultParseWidth: "any",
    valueCallback: function(t) {
      return t + 1;
    }
  }),
  month: r0({
    matchPatterns: Iwe,
    defaultMatchWidth: "wide",
    parsePatterns: Awe,
    defaultParseWidth: "any"
  }),
  day: r0({
    matchPatterns: jwe,
    defaultMatchWidth: "wide",
    parsePatterns: Lwe,
    defaultParseWidth: "any"
  }),
  dayPeriod: r0({
    matchPatterns: Fwe,
    defaultMatchWidth: "any",
    parsePatterns: zwe,
    defaultParseWidth: "any"
  })
};
const Uwe = Vwe;
var Bwe = {
  code: "en-US",
  formatDistance: lwe,
  formatLong: pwe,
  formatRelative: vwe,
  localize: Twe,
  match: Uwe,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const qM = Bwe;
var Hwe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Wwe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Ywe = /^'([^]*?)'?$/, qwe = /''/g, Gwe = /[a-zA-Z]/;
function Kwe(e, t, n) {
  var r, a, s, l, p, m, h, g, b, x, E, O, _, P, M, D, N, I;
  _t(2, arguments);
  var R = String(t), j = ic(), U = (r = (a = n == null ? void 0 : n.locale) !== null && a !== void 0 ? a : j.locale) !== null && r !== void 0 ? r : qM, q = lr((s = (l = (p = (m = n == null ? void 0 : n.firstWeekContainsDate) !== null && m !== void 0 ? m : n == null || (h = n.locale) === null || h === void 0 || (g = h.options) === null || g === void 0 ? void 0 : g.firstWeekContainsDate) !== null && p !== void 0 ? p : j.firstWeekContainsDate) !== null && l !== void 0 ? l : (b = j.locale) === null || b === void 0 || (x = b.options) === null || x === void 0 ? void 0 : x.firstWeekContainsDate) !== null && s !== void 0 ? s : 1);
  if (!(q >= 1 && q <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var J = lr((E = (O = (_ = (P = n == null ? void 0 : n.weekStartsOn) !== null && P !== void 0 ? P : n == null || (M = n.locale) === null || M === void 0 || (D = M.options) === null || D === void 0 ? void 0 : D.weekStartsOn) !== null && _ !== void 0 ? _ : j.weekStartsOn) !== null && O !== void 0 ? O : (N = j.locale) === null || N === void 0 || (I = N.options) === null || I === void 0 ? void 0 : I.weekStartsOn) !== null && E !== void 0 ? E : 0);
  if (!(J >= 0 && J <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!U.localize)
    throw new RangeError("locale must contain localize property");
  if (!U.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var H = Rt(e);
  if (!t9(H))
    throw new RangeError("Invalid time value");
  var Z = UC(H), re = n9(H, Z), Y = {
    firstWeekContainsDate: q,
    weekStartsOn: J,
    locale: U,
    _originalDate: H
  }, K = R.match(Wwe).map(function(Q) {
    var te = Q[0];
    if (te === "p" || te === "P") {
      var ne = a$[te];
      return ne(Q, U.formatLong);
    }
    return Q;
  }).join("").match(Hwe).map(function(Q) {
    if (Q === "''")
      return "'";
    var te = Q[0];
    if (te === "'")
      return Xwe(Q);
    var ne = twe[te];
    if (ne)
      return !(n != null && n.useAdditionalWeekYearTokens) && l9(Q) && BC(Q, t, String(e)), !(n != null && n.useAdditionalDayOfYearTokens) && s9(Q) && BC(Q, t, String(e)), ne(re, Q, U.localize, Y);
    if (te.match(Gwe))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + te + "`");
    return Q;
  }).join("");
  return K;
}
function Xwe(e) {
  var t = e.match(Ywe);
  return t ? t[1].replace(qwe, "'") : e;
}
function Qwe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getDate();
  return n;
}
function u9(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getFullYear(), r = t.getMonth(), a = /* @__PURE__ */ new Date(0);
  return a.setFullYear(n, r + 1, 0), a.setHours(0, 0, 0, 0), a.getDate();
}
function Zwe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getHours();
  return n;
}
function Jwe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getMinutes();
  return n;
}
function exe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getMonth();
  return n;
}
function txe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getSeconds();
  return n;
}
function nxe(e) {
  _t(1, arguments);
  var t = Rt(e), n = t.getMilliseconds();
  return n;
}
function ym(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = ic(), b = lr((n = (r = (a = (s = t == null ? void 0 : t.weekStartsOn) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.weekStartsOn) !== null && a !== void 0 ? a : g.weekStartsOn) !== null && r !== void 0 ? r : (m = g.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(b >= 0 && b <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var x = Rt(e), E = x.getDay(), O = (E < b ? 7 : 0) + E - b;
  return x.setDate(x.getDate() - O), x.setHours(0, 0, 0, 0), x;
}
function rxe(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = Rt(e), b = g.getFullYear(), x = ic(), E = lr((n = (r = (a = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && a !== void 0 ? a : x.firstWeekContainsDate) !== null && r !== void 0 ? r : (m = x.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
  if (!(E >= 1 && E <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var O = /* @__PURE__ */ new Date(0);
  O.setFullYear(b + 1, 0, E), O.setHours(0, 0, 0, 0);
  var _ = ym(O, t), P = /* @__PURE__ */ new Date(0);
  P.setFullYear(b, 0, E), P.setHours(0, 0, 0, 0);
  var M = ym(P, t);
  return g.getTime() >= _.getTime() ? b + 1 : g.getTime() >= M.getTime() ? b : b - 1;
}
function oxe(e, t) {
  var n, r, a, s, l, p, m, h;
  _t(1, arguments);
  var g = ic(), b = lr((n = (r = (a = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (l = t.locale) === null || l === void 0 || (p = l.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && a !== void 0 ? a : g.firstWeekContainsDate) !== null && r !== void 0 ? r : (m = g.locale) === null || m === void 0 || (h = m.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && n !== void 0 ? n : 1), x = rxe(e, t), E = /* @__PURE__ */ new Date(0);
  E.setFullYear(x, 0, b), E.setHours(0, 0, 0, 0);
  var O = ym(E, t);
  return O;
}
var axe = 6048e5;
function ixe(e, t) {
  _t(1, arguments);
  var n = Rt(e), r = ym(n, t).getTime() - oxe(n, t).getTime();
  return Math.round(r / axe) + 1;
}
function sxe(e) {
  return _t(1, arguments), Rt(e).getFullYear();
}
function Yk(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getTime() > r.getTime();
}
function o0(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getTime() < r.getTime();
}
function lxe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getTime() === r.getTime();
}
function uxe(e, t) {
  _t(2, arguments);
  var n = yy(e), r = yy(t);
  return n.getTime() === r.getTime();
}
function cxe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getFullYear() === r.getFullYear();
}
function dxe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = Rt(t);
  return n.getFullYear() === r.getFullYear() && n.getMonth() === r.getMonth();
}
function F5(e) {
  _t(1, arguments);
  var t = Rt(e);
  return t.setMinutes(0, 0, 0), t;
}
function fxe(e, t) {
  _t(2, arguments);
  var n = F5(e), r = F5(t);
  return n.getTime() === r.getTime();
}
function z5(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function pxe(e, t) {
  if (e) {
    if (typeof e == "string")
      return z5(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return z5(e, t);
  }
}
function V5(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = pxe(e)) || t && e && typeof e.length == "number") {
      n && (e = n);
      var r = 0, a = function() {
      };
      return {
        s: a,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(h) {
          throw h;
        },
        f: a
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, l = !1, p;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var h = n.next();
      return s = h.done, h;
    },
    e: function(h) {
      l = !0, p = h;
    },
    f: function() {
      try {
        !s && n.return != null && n.return();
      } finally {
        if (l)
          throw p;
      }
    }
  };
}
function mxe(e, t) {
  if (e == null)
    throw new TypeError("assign requires that input parameter not be null or undefined");
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return e;
}
function Ut(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function HC(e, t) {
  return HC = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, a) {
    return r.__proto__ = a, r;
  }, HC(e, t);
}
function ur(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && HC(e, t);
}
function WC(e) {
  return WC = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, WC(e);
}
function hxe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function vxe(e, t) {
  if (t && (id(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ut(e);
}
function cr(e) {
  var t = hxe();
  return function() {
    var r = WC(e), a;
    if (t) {
      var s = WC(this).constructor;
      a = Reflect.construct(r, arguments, s);
    } else
      a = r.apply(this, arguments);
    return vxe(this, a);
  };
}
function Zn(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yxe(e, t) {
  if (id(e) !== "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (id(r) !== "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function c9(e) {
  var t = yxe(e, "string");
  return id(t) === "symbol" ? t : String(t);
}
function U5(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, c9(r.key), r);
  }
}
function Jn(e, t, n) {
  return t && U5(e.prototype, t), n && U5(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function jt(e, t, n) {
  return t = c9(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var gxe = 10, d9 = /* @__PURE__ */ function() {
  function e() {
    Zn(this, e), jt(this, "priority", void 0), jt(this, "subPriority", 0);
  }
  return Jn(e, [{
    key: "validate",
    value: function(n, r) {
      return !0;
    }
  }]), e;
}(), bxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n(r, a, s, l, p) {
    var m;
    return Zn(this, n), m = t.call(this), m.value = r, m.validateValue = a, m.setValue = s, m.priority = l, p && (m.subPriority = p), m;
  }
  return Jn(n, [{
    key: "validate",
    value: function(a, s) {
      return this.validateValue(a, this.value, s);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return this.setValue(a, s, this.value, l);
    }
  }]), n;
}(d9), wxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", gxe), jt(Ut(r), "subPriority", -1), r;
  }
  return Jn(n, [{
    key: "set",
    value: function(a, s) {
      if (s.timestampIsSet)
        return a;
      var l = /* @__PURE__ */ new Date(0);
      return l.setFullYear(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate()), l.setHours(a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()), l;
    }
  }]), n;
}(d9), wr = /* @__PURE__ */ function() {
  function e() {
    Zn(this, e), jt(this, "incompatibleTokens", void 0), jt(this, "priority", void 0), jt(this, "subPriority", void 0);
  }
  return Jn(e, [{
    key: "run",
    value: function(n, r, a, s) {
      var l = this.parse(n, r, a, s);
      return l ? {
        setter: new bxe(l.value, this.validate, this.set, this.priority, this.subPriority),
        rest: l.rest
      } : null;
    }
  }, {
    key: "validate",
    value: function(n, r, a) {
      return !0;
    }
  }]), e;
}(), xxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 140), jt(Ut(r), "incompatibleTokens", ["R", "u", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "G":
        case "GG":
        case "GGG":
          return l.era(a, {
            width: "abbreviated"
          }) || l.era(a, {
            width: "narrow"
          });
        case "GGGGG":
          return l.era(a, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return l.era(a, {
            width: "wide"
          }) || l.era(a, {
            width: "abbreviated"
          }) || l.era(a, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return s.era = l, a.setUTCFullYear(l, 0, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), No = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, Bu = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Io(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  };
}
function vo(e, t) {
  var n = t.match(e);
  return n ? {
    value: parseInt(n[0], 10),
    rest: t.slice(n[0].length)
  } : null;
}
function Hu(e, t) {
  var n = t.match(e);
  if (!n)
    return null;
  if (n[0] === "Z")
    return {
      value: 0,
      rest: t.slice(1)
    };
  var r = n[1] === "+" ? 1 : -1, a = n[2] ? parseInt(n[2], 10) : 0, s = n[3] ? parseInt(n[3], 10) : 0, l = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: r * (a * ZT + s * QT + l * z0e),
    rest: t.slice(n[0].length)
  };
}
function f9(e) {
  return vo(No.anyDigitsSigned, e);
}
function _o(e, t) {
  switch (e) {
    case 1:
      return vo(No.singleDigit, t);
    case 2:
      return vo(No.twoDigits, t);
    case 3:
      return vo(No.threeDigits, t);
    case 4:
      return vo(No.fourDigits, t);
    default:
      return vo(new RegExp("^\\d{1," + e + "}"), t);
  }
}
function YC(e, t) {
  switch (e) {
    case 1:
      return vo(No.singleDigitSigned, t);
    case 2:
      return vo(No.twoDigitsSigned, t);
    case 3:
      return vo(No.threeDigitsSigned, t);
    case 4:
      return vo(No.fourDigitsSigned, t);
    default:
      return vo(new RegExp("^-?\\d{1," + e + "}"), t);
  }
}
function GM(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function p9(e, t) {
  var n = t > 0, r = n ? t : 1 - t, a;
  if (r <= 50)
    a = e || 100;
  else {
    var s = r + 50, l = Math.floor(s / 100) * 100, p = e >= s % 100;
    a = e + l - (p ? 100 : 0);
  }
  return n ? a : 1 - a;
}
function m9(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
var Sxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 130), jt(Ut(r), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      var p = function(h) {
        return {
          year: h,
          isTwoDigitYear: s === "yy"
        };
      };
      switch (s) {
        case "y":
          return Io(_o(4, a), p);
        case "yo":
          return Io(l.ordinalNumber(a, {
            unit: "year"
          }), p);
        default:
          return Io(_o(s.length, a), p);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s.isTwoDigitYear || s.year > 0;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      var p = a.getUTCFullYear();
      if (l.isTwoDigitYear) {
        var m = p9(l.year, p);
        return a.setUTCFullYear(m, 0, 1), a.setUTCHours(0, 0, 0, 0), a;
      }
      var h = !("era" in s) || s.era === 1 ? l.year : 1 - l.year;
      return a.setUTCFullYear(h, 0, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Exe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 130), jt(Ut(r), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      var p = function(h) {
        return {
          year: h,
          isTwoDigitYear: s === "YY"
        };
      };
      switch (s) {
        case "Y":
          return Io(_o(4, a), p);
        case "Yo":
          return Io(l.ordinalNumber(a, {
            unit: "year"
          }), p);
        default:
          return Io(_o(s.length, a), p);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s.isTwoDigitYear || s.year > 0;
    }
  }, {
    key: "set",
    value: function(a, s, l, p) {
      var m = YM(a, p);
      if (l.isTwoDigitYear) {
        var h = p9(l.year, m);
        return a.setUTCFullYear(h, 0, p.firstWeekContainsDate), a.setUTCHours(0, 0, 0, 0), Tm(a, p);
      }
      var g = !("era" in s) || s.era === 1 ? l.year : 1 - l.year;
      return a.setUTCFullYear(g, 0, p.firstWeekContainsDate), a.setUTCHours(0, 0, 0, 0), Tm(a, p);
    }
  }]), n;
}(wr), Cxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 130), jt(Ut(r), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s) {
      return YC(s === "R" ? 4 : s.length, a);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      var p = /* @__PURE__ */ new Date(0);
      return p.setUTCFullYear(l, 0, 4), p.setUTCHours(0, 0, 0, 0), gy(p);
    }
  }]), n;
}(wr), Txe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 130), jt(Ut(r), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s) {
      return YC(s === "u" ? 4 : s.length, a);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCFullYear(l, 0, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), _xe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 120), jt(Ut(r), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "Q":
        case "QQ":
          return _o(s.length, a);
        case "Qo":
          return l.ordinalNumber(a, {
            unit: "quarter"
          });
        case "QQQ":
          return l.quarter(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.quarter(a, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return l.quarter(a, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return l.quarter(a, {
            width: "wide",
            context: "formatting"
          }) || l.quarter(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.quarter(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 4;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMonth((l - 1) * 3, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Oxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 120), jt(Ut(r), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "q":
        case "qq":
          return _o(s.length, a);
        case "qo":
          return l.ordinalNumber(a, {
            unit: "quarter"
          });
        case "qqq":
          return l.quarter(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.quarter(a, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return l.quarter(a, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return l.quarter(a, {
            width: "wide",
            context: "standalone"
          }) || l.quarter(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.quarter(a, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 4;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMonth((l - 1) * 3, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Pxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), jt(Ut(r), "priority", 110), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      var p = function(h) {
        return h - 1;
      };
      switch (s) {
        case "M":
          return Io(vo(No.month, a), p);
        case "MM":
          return Io(_o(2, a), p);
        case "Mo":
          return Io(l.ordinalNumber(a, {
            unit: "month"
          }), p);
        case "MMM":
          return l.month(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.month(a, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return l.month(a, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return l.month(a, {
            width: "wide",
            context: "formatting"
          }) || l.month(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.month(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 11;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMonth(l, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Rxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 110), jt(Ut(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      var p = function(h) {
        return h - 1;
      };
      switch (s) {
        case "L":
          return Io(vo(No.month, a), p);
        case "LL":
          return Io(_o(2, a), p);
        case "Lo":
          return Io(l.ordinalNumber(a, {
            unit: "month"
          }), p);
        case "LLL":
          return l.month(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.month(a, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return l.month(a, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return l.month(a, {
            width: "wide",
            context: "standalone"
          }) || l.month(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.month(a, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 11;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMonth(l, 1), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr);
function kxe(e, t, n) {
  _t(2, arguments);
  var r = Rt(e), a = lr(t), s = a9(r, n) - a;
  return r.setUTCDate(r.getUTCDate() - s * 7), r;
}
var Dxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 100), jt(Ut(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "w":
          return vo(No.week, a);
        case "wo":
          return l.ordinalNumber(a, {
            unit: "week"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 53;
    }
  }, {
    key: "set",
    value: function(a, s, l, p) {
      return Tm(kxe(a, l, p), p);
    }
  }]), n;
}(wr);
function $xe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t), a = o9(n) - r;
  return n.setUTCDate(n.getUTCDate() - a * 7), n;
}
var Mxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 100), jt(Ut(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "I":
          return vo(No.week, a);
        case "Io":
          return l.ordinalNumber(a, {
            unit: "week"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 53;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return gy($xe(a, l));
    }
  }]), n;
}(wr), Nxe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ixe = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Axe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "subPriority", 1), jt(Ut(r), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "d":
          return vo(No.date, a);
        case "do":
          return l.ordinalNumber(a, {
            unit: "date"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      var l = a.getUTCFullYear(), p = m9(l), m = a.getUTCMonth();
      return p ? s >= 1 && s <= Ixe[m] : s >= 1 && s <= Nxe[m];
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCDate(l), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), jxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "subpriority", 1), jt(Ut(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "D":
        case "DD":
          return vo(No.dayOfYear, a);
        case "Do":
          return l.ordinalNumber(a, {
            unit: "date"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      var l = a.getUTCFullYear(), p = m9(l);
      return p ? s >= 1 && s <= 366 : s >= 1 && s <= 365;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMonth(0, l), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr);
function KM(e, t, n) {
  var r, a, s, l, p, m, h, g;
  _t(2, arguments);
  var b = ic(), x = lr((r = (a = (s = (l = n == null ? void 0 : n.weekStartsOn) !== null && l !== void 0 ? l : n == null || (p = n.locale) === null || p === void 0 || (m = p.options) === null || m === void 0 ? void 0 : m.weekStartsOn) !== null && s !== void 0 ? s : b.weekStartsOn) !== null && a !== void 0 ? a : (h = b.locale) === null || h === void 0 || (g = h.options) === null || g === void 0 ? void 0 : g.weekStartsOn) !== null && r !== void 0 ? r : 0);
  if (!(x >= 0 && x <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var E = Rt(e), O = lr(t), _ = E.getUTCDay(), P = O % 7, M = (P + 7) % 7, D = (M < x ? 7 : 0) + O - _;
  return E.setUTCDate(E.getUTCDate() + D), E;
}
var Lxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "E":
        case "EE":
        case "EEE":
          return l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return l.day(a, {
            width: "wide",
            context: "formatting"
          }) || l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 6;
    }
  }, {
    key: "set",
    value: function(a, s, l, p) {
      return a = KM(a, l, p), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Fxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l, p) {
      var m = function(g) {
        var b = Math.floor((g - 1) / 7) * 7;
        return (g + p.weekStartsOn + 6) % 7 + b;
      };
      switch (s) {
        case "e":
        case "ee":
          return Io(_o(s.length, a), m);
        case "eo":
          return Io(l.ordinalNumber(a, {
            unit: "day"
          }), m);
        case "eee":
          return l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return l.day(a, {
            width: "wide",
            context: "formatting"
          }) || l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 6;
    }
  }, {
    key: "set",
    value: function(a, s, l, p) {
      return a = KM(a, l, p), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), zxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l, p) {
      var m = function(g) {
        var b = Math.floor((g - 1) / 7) * 7;
        return (g + p.weekStartsOn + 6) % 7 + b;
      };
      switch (s) {
        case "c":
        case "cc":
          return Io(_o(s.length, a), m);
        case "co":
          return Io(l.ordinalNumber(a, {
            unit: "day"
          }), m);
        case "ccc":
          return l.day(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.day(a, {
            width: "short",
            context: "standalone"
          }) || l.day(a, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return l.day(a, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return l.day(a, {
            width: "short",
            context: "standalone"
          }) || l.day(a, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return l.day(a, {
            width: "wide",
            context: "standalone"
          }) || l.day(a, {
            width: "abbreviated",
            context: "standalone"
          }) || l.day(a, {
            width: "short",
            context: "standalone"
          }) || l.day(a, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 6;
    }
  }, {
    key: "set",
    value: function(a, s, l, p) {
      return a = KM(a, l, p), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr);
function Vxe(e, t) {
  _t(2, arguments);
  var n = lr(t);
  n % 7 === 0 && (n = n - 7);
  var r = 1, a = Rt(e), s = a.getUTCDay(), l = n % 7, p = (l + 7) % 7, m = (p < r ? 7 : 0) + n - s;
  return a.setUTCDate(a.getUTCDate() + m), a;
}
var Uxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 90), jt(Ut(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      var p = function(h) {
        return h === 0 ? 7 : h;
      };
      switch (s) {
        case "i":
        case "ii":
          return _o(s.length, a);
        case "io":
          return l.ordinalNumber(a, {
            unit: "day"
          });
        case "iii":
          return Io(l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          }), p);
        case "iiiii":
          return Io(l.day(a, {
            width: "narrow",
            context: "formatting"
          }), p);
        case "iiiiii":
          return Io(l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          }), p);
        case "iiii":
        default:
          return Io(l.day(a, {
            width: "wide",
            context: "formatting"
          }) || l.day(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(a, {
            width: "short",
            context: "formatting"
          }) || l.day(a, {
            width: "narrow",
            context: "formatting"
          }), p);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 7;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a = Vxe(a, l), a.setUTCHours(0, 0, 0, 0), a;
    }
  }]), n;
}(wr), Bxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 80), jt(Ut(r), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "a":
        case "aa":
        case "aaa":
          return l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return l.dayPeriod(a, {
            width: "wide",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCHours(GM(l), 0, 0, 0), a;
    }
  }]), n;
}(wr), Hxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 80), jt(Ut(r), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "b":
        case "bb":
        case "bbb":
          return l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return l.dayPeriod(a, {
            width: "wide",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCHours(GM(l), 0, 0, 0), a;
    }
  }]), n;
}(wr), Wxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 80), jt(Ut(r), "incompatibleTokens", ["a", "b", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "B":
        case "BB":
        case "BBB":
          return l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return l.dayPeriod(a, {
            width: "wide",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "abbreviated",
            context: "formatting"
          }) || l.dayPeriod(a, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCHours(GM(l), 0, 0, 0), a;
    }
  }]), n;
}(wr), Yxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 70), jt(Ut(r), "incompatibleTokens", ["H", "K", "k", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "h":
          return vo(No.hour12h, a);
        case "ho":
          return l.ordinalNumber(a, {
            unit: "hour"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 12;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      var p = a.getUTCHours() >= 12;
      return p && l < 12 ? a.setUTCHours(l + 12, 0, 0, 0) : !p && l === 12 ? a.setUTCHours(0, 0, 0, 0) : a.setUTCHours(l, 0, 0, 0), a;
    }
  }]), n;
}(wr), qxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 70), jt(Ut(r), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "H":
          return vo(No.hour23h, a);
        case "Ho":
          return l.ordinalNumber(a, {
            unit: "hour"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 23;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCHours(l, 0, 0, 0), a;
    }
  }]), n;
}(wr), Gxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 70), jt(Ut(r), "incompatibleTokens", ["h", "H", "k", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "K":
          return vo(No.hour11h, a);
        case "Ko":
          return l.ordinalNumber(a, {
            unit: "hour"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 11;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      var p = a.getUTCHours() >= 12;
      return p && l < 12 ? a.setUTCHours(l + 12, 0, 0, 0) : a.setUTCHours(l, 0, 0, 0), a;
    }
  }]), n;
}(wr), Kxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 70), jt(Ut(r), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "k":
          return vo(No.hour24h, a);
        case "ko":
          return l.ordinalNumber(a, {
            unit: "hour"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 1 && s <= 24;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      var p = l <= 24 ? l % 24 : l;
      return a.setUTCHours(p, 0, 0, 0), a;
    }
  }]), n;
}(wr), Xxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 60), jt(Ut(r), "incompatibleTokens", ["t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "m":
          return vo(No.minute, a);
        case "mo":
          return l.ordinalNumber(a, {
            unit: "minute"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 59;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMinutes(l, 0, 0), a;
    }
  }]), n;
}(wr), Qxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 50), jt(Ut(r), "incompatibleTokens", ["t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s, l) {
      switch (s) {
        case "s":
          return vo(No.second, a);
        case "so":
          return l.ordinalNumber(a, {
            unit: "second"
          });
        default:
          return _o(s.length, a);
      }
    }
  }, {
    key: "validate",
    value: function(a, s) {
      return s >= 0 && s <= 59;
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCSeconds(l, 0), a;
    }
  }]), n;
}(wr), Zxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 30), jt(Ut(r), "incompatibleTokens", ["t", "T"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s) {
      var l = function(m) {
        return Math.floor(m * Math.pow(10, -s.length + 3));
      };
      return Io(_o(s.length, a), l);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return a.setUTCMilliseconds(l), a;
    }
  }]), n;
}(wr), Jxe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 10), jt(Ut(r), "incompatibleTokens", ["t", "T", "x"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s) {
      switch (s) {
        case "X":
          return Hu(Bu.basicOptionalMinutes, a);
        case "XX":
          return Hu(Bu.basic, a);
        case "XXXX":
          return Hu(Bu.basicOptionalSeconds, a);
        case "XXXXX":
          return Hu(Bu.extendedOptionalSeconds, a);
        case "XXX":
        default:
          return Hu(Bu.extended, a);
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return s.timestampIsSet ? a : new Date(a.getTime() - l);
    }
  }]), n;
}(wr), eSe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 10), jt(Ut(r), "incompatibleTokens", ["t", "T", "X"]), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a, s) {
      switch (s) {
        case "x":
          return Hu(Bu.basicOptionalMinutes, a);
        case "xx":
          return Hu(Bu.basic, a);
        case "xxxx":
          return Hu(Bu.basicOptionalSeconds, a);
        case "xxxxx":
          return Hu(Bu.extendedOptionalSeconds, a);
        case "xxx":
        default:
          return Hu(Bu.extended, a);
      }
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return s.timestampIsSet ? a : new Date(a.getTime() - l);
    }
  }]), n;
}(wr), tSe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 40), jt(Ut(r), "incompatibleTokens", "*"), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a) {
      return f9(a);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return [new Date(l * 1e3), {
        timestampIsSet: !0
      }];
    }
  }]), n;
}(wr), nSe = /* @__PURE__ */ function(e) {
  ur(n, e);
  var t = cr(n);
  function n() {
    var r;
    Zn(this, n);
    for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = t.call.apply(t, [this].concat(s)), jt(Ut(r), "priority", 20), jt(Ut(r), "incompatibleTokens", "*"), r;
  }
  return Jn(n, [{
    key: "parse",
    value: function(a) {
      return f9(a);
    }
  }, {
    key: "set",
    value: function(a, s, l) {
      return [new Date(l), {
        timestampIsSet: !0
      }];
    }
  }]), n;
}(wr), rSe = {
  G: new xxe(),
  y: new Sxe(),
  Y: new Exe(),
  R: new Cxe(),
  u: new Txe(),
  Q: new _xe(),
  q: new Oxe(),
  M: new Pxe(),
  L: new Rxe(),
  w: new Dxe(),
  I: new Mxe(),
  d: new Axe(),
  D: new jxe(),
  E: new Lxe(),
  e: new Fxe(),
  c: new zxe(),
  i: new Uxe(),
  a: new Bxe(),
  b: new Hxe(),
  B: new Wxe(),
  h: new Yxe(),
  H: new qxe(),
  K: new Gxe(),
  k: new Kxe(),
  m: new Xxe(),
  s: new Qxe(),
  S: new Zxe(),
  X: new Jxe(),
  x: new eSe(),
  t: new tSe(),
  T: new nSe()
}, oSe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, aSe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, iSe = /^'([^]*?)'?$/, sSe = /''/g, lSe = /\S/, uSe = /[a-zA-Z]/;
function cSe(e, t, n, r) {
  var a, s, l, p, m, h, g, b, x, E, O, _, P, M, D, N, I, R;
  _t(3, arguments);
  var j = String(e), U = String(t), q = ic(), J = (a = (s = r == null ? void 0 : r.locale) !== null && s !== void 0 ? s : q.locale) !== null && a !== void 0 ? a : qM;
  if (!J.match)
    throw new RangeError("locale must contain match property");
  var H = lr((l = (p = (m = (h = r == null ? void 0 : r.firstWeekContainsDate) !== null && h !== void 0 ? h : r == null || (g = r.locale) === null || g === void 0 || (b = g.options) === null || b === void 0 ? void 0 : b.firstWeekContainsDate) !== null && m !== void 0 ? m : q.firstWeekContainsDate) !== null && p !== void 0 ? p : (x = q.locale) === null || x === void 0 || (E = x.options) === null || E === void 0 ? void 0 : E.firstWeekContainsDate) !== null && l !== void 0 ? l : 1);
  if (!(H >= 1 && H <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var Z = lr((O = (_ = (P = (M = r == null ? void 0 : r.weekStartsOn) !== null && M !== void 0 ? M : r == null || (D = r.locale) === null || D === void 0 || (N = D.options) === null || N === void 0 ? void 0 : N.weekStartsOn) !== null && P !== void 0 ? P : q.weekStartsOn) !== null && _ !== void 0 ? _ : (I = q.locale) === null || I === void 0 || (R = I.options) === null || R === void 0 ? void 0 : R.weekStartsOn) !== null && O !== void 0 ? O : 0);
  if (!(Z >= 0 && Z <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (U === "")
    return j === "" ? Rt(n) : /* @__PURE__ */ new Date(NaN);
  var re = {
    firstWeekContainsDate: H,
    weekStartsOn: Z,
    locale: J
  }, Y = [new wxe()], K = U.match(aSe).map(function(pe) {
    var ye = pe[0];
    if (ye in a$) {
      var Oe = a$[ye];
      return Oe(pe, J.formatLong);
    }
    return pe;
  }).join("").match(oSe), Q = [], te = V5(K), ne;
  try {
    var ae = function() {
      var ye = ne.value;
      !(r != null && r.useAdditionalWeekYearTokens) && l9(ye) && BC(ye, U, e), !(r != null && r.useAdditionalDayOfYearTokens) && s9(ye) && BC(ye, U, e);
      var Oe = ye[0], Fe = rSe[Oe];
      if (Fe) {
        var me = Fe.incompatibleTokens;
        if (Array.isArray(me)) {
          var Pe = Q.find(function(Ke) {
            return me.includes(Ke.token) || Ke.token === Oe;
          });
          if (Pe)
            throw new RangeError("The format string mustn't contain `".concat(Pe.fullToken, "` and `").concat(ye, "` at the same time"));
        } else if (Fe.incompatibleTokens === "*" && Q.length > 0)
          throw new RangeError("The format string mustn't contain `".concat(ye, "` and any other token at the same time"));
        Q.push({
          token: Oe,
          fullToken: ye
        });
        var Ee = Fe.run(j, ye, J.match, re);
        if (!Ee)
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        Y.push(Ee.setter), j = Ee.rest;
      } else {
        if (Oe.match(uSe))
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + Oe + "`");
        if (ye === "''" ? ye = "'" : Oe === "'" && (ye = dSe(ye)), j.indexOf(ye) === 0)
          j = j.slice(ye.length);
        else
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
      }
    };
    for (te.s(); !(ne = te.n()).done; ) {
      var se = ae();
      if (id(se) === "object")
        return se.v;
    }
  } catch (pe) {
    te.e(pe);
  } finally {
    te.f();
  }
  if (j.length > 0 && lSe.test(j))
    return /* @__PURE__ */ new Date(NaN);
  var V = Y.map(function(pe) {
    return pe.priority;
  }).sort(function(pe, ye) {
    return ye - pe;
  }).filter(function(pe, ye, Oe) {
    return Oe.indexOf(pe) === ye;
  }).map(function(pe) {
    return Y.filter(function(ye) {
      return ye.priority === pe;
    }).sort(function(ye, Oe) {
      return Oe.subPriority - ye.subPriority;
    });
  }).map(function(pe) {
    return pe[0];
  }), ee = Rt(n);
  if (isNaN(ee.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var he = n9(ee, UC(ee)), ue = {}, fe = V5(V), Ce;
  try {
    for (fe.s(); !(Ce = fe.n()).done; ) {
      var Se = Ce.value;
      if (!Se.validate(he, re))
        return /* @__PURE__ */ new Date(NaN);
      var Te = Se.set(he, ue, re);
      Array.isArray(Te) ? (he = Te[0], mxe(ue, Te[1])) : he = Te;
    }
  } catch (pe) {
    fe.e(pe);
  } finally {
    fe.f();
  }
  return he;
}
function dSe(e) {
  return e.match(iSe)[1].replace(sSe, "'");
}
function fSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return n.setDate(r), n;
}
function pSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return n.setHours(r), n;
}
function mSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return n.setMinutes(r), n;
}
function hSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t), a = n.getFullYear(), s = n.getDate(), l = /* @__PURE__ */ new Date(0);
  l.setFullYear(a, r, 15), l.setHours(0, 0, 0, 0);
  var p = u9(l);
  return n.setMonth(r, Math.min(s, p)), n;
}
function vSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return n.setSeconds(r), n;
}
function ySe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return n.setMilliseconds(r), n;
}
function gSe(e, t) {
  _t(2, arguments);
  var n = Rt(e), r = lr(t);
  return isNaN(n.getTime()) ? /* @__PURE__ */ new Date(NaN) : (n.setFullYear(r), n);
}
function B5(e) {
  _t(1, arguments);
  var t = Rt(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function P1(e) {
  _t(1, arguments);
  var t = Rt(e), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(t.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function bSe(e, t) {
  var n;
  _t(1, arguments);
  var r = lr((n = t == null ? void 0 : t.additionalDigits) !== null && n !== void 0 ? n : 2);
  if (r !== 2 && r !== 1 && r !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var a = ESe(e), s;
  if (a.date) {
    var l = CSe(a.date, r);
    s = TSe(l.restDateString, l.year);
  }
  if (!s || isNaN(s.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var p = s.getTime(), m = 0, h;
  if (a.time && (m = _Se(a.time), isNaN(m)))
    return /* @__PURE__ */ new Date(NaN);
  if (a.timezone) {
    if (h = OSe(a.timezone), isNaN(h))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    var g = new Date(p + m), b = /* @__PURE__ */ new Date(0);
    return b.setFullYear(g.getUTCFullYear(), g.getUTCMonth(), g.getUTCDate()), b.setHours(g.getUTCHours(), g.getUTCMinutes(), g.getUTCSeconds(), g.getUTCMilliseconds()), b;
  }
  return new Date(p + m + h);
}
var R1 = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, wSe = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, xSe = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, SSe = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function ESe(e) {
  var t = {}, n = e.split(R1.dateTimeDelimiter), r;
  if (n.length > 2)
    return t;
  if (/:/.test(n[0]) ? r = n[0] : (t.date = n[0], r = n[1], R1.timeZoneDelimiter.test(t.date) && (t.date = e.split(R1.timeZoneDelimiter)[0], r = e.substr(t.date.length, e.length))), r) {
    var a = R1.timezone.exec(r);
    a ? (t.time = r.replace(a[1], ""), t.timezone = a[1]) : t.time = r;
  }
  return t;
}
function CSe(e, t) {
  var n = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"), r = e.match(n);
  if (!r)
    return {
      year: NaN,
      restDateString: ""
    };
  var a = r[1] ? parseInt(r[1]) : null, s = r[2] ? parseInt(r[2]) : null;
  return {
    year: s === null ? a : s * 100,
    restDateString: e.slice((r[1] || r[2]).length)
  };
}
function TSe(e, t) {
  if (t === null)
    return /* @__PURE__ */ new Date(NaN);
  var n = e.match(wSe);
  if (!n)
    return /* @__PURE__ */ new Date(NaN);
  var r = !!n[4], a = a0(n[1]), s = a0(n[2]) - 1, l = a0(n[3]), p = a0(n[4]), m = a0(n[5]) - 1;
  if (r)
    return $Se(t, p, m) ? PSe(t, p, m) : /* @__PURE__ */ new Date(NaN);
  var h = /* @__PURE__ */ new Date(0);
  return !kSe(t, s, l) || !DSe(t, a) ? /* @__PURE__ */ new Date(NaN) : (h.setUTCFullYear(t, s, Math.max(a, l)), h);
}
function a0(e) {
  return e ? parseInt(e) : 1;
}
function _Se(e) {
  var t = e.match(xSe);
  if (!t)
    return NaN;
  var n = qk(t[1]), r = qk(t[2]), a = qk(t[3]);
  return MSe(n, r, a) ? n * ZT + r * QT + a * 1e3 : NaN;
}
function qk(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function OSe(e) {
  if (e === "Z")
    return 0;
  var t = e.match(SSe);
  if (!t)
    return 0;
  var n = t[1] === "+" ? -1 : 1, r = parseInt(t[2]), a = t[3] && parseInt(t[3]) || 0;
  return NSe(r, a) ? n * (r * ZT + a * QT) : NaN;
}
function PSe(e, t, n) {
  var r = /* @__PURE__ */ new Date(0);
  r.setUTCFullYear(e, 0, 4);
  var a = r.getUTCDay() || 7, s = (t - 1) * 7 + n + 1 - a;
  return r.setUTCDate(r.getUTCDate() + s), r;
}
var RSe = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function h9(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function kSe(e, t, n) {
  return t >= 0 && t <= 11 && n >= 1 && n <= (RSe[t] || (h9(e) ? 29 : 28));
}
function DSe(e, t) {
  return t >= 1 && t <= (h9(e) ? 366 : 365);
}
function $Se(e, t, n) {
  return t >= 1 && t <= 53 && n >= 0 && n <= 6;
}
function MSe(e, t, n) {
  return e === 24 ? t === 0 && n === 0 : n >= 0 && n < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function NSe(e, t) {
  return t >= 0 && t <= 59;
}
function ISe(e, t) {
  var n, r;
  _t(1, arguments);
  var a = Rt(e);
  if (isNaN(a.getTime()))
    throw new RangeError("Invalid time value");
  var s = String((n = t == null ? void 0 : t.format) !== null && n !== void 0 ? n : "extended"), l = String((r = t == null ? void 0 : t.representation) !== null && r !== void 0 ? r : "complete");
  if (s !== "extended" && s !== "basic")
    throw new RangeError("format must be 'extended' or 'basic'");
  if (l !== "date" && l !== "time" && l !== "complete")
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  var p = "", m = "", h = s === "extended" ? "-" : "", g = s === "extended" ? ":" : "";
  if (l !== "time") {
    var b = Bn(a.getDate(), 2), x = Bn(a.getMonth() + 1, 2), E = Bn(a.getFullYear(), 4);
    p = "".concat(E).concat(h).concat(x).concat(h).concat(b);
  }
  if (l !== "date") {
    var O = a.getTimezoneOffset();
    if (O !== 0) {
      var _ = Math.abs(O), P = Bn(Math.floor(_ / 60), 2), M = Bn(_ % 60, 2), D = O < 0 ? "+" : "-";
      m = "".concat(D).concat(P, ":").concat(M);
    } else
      m = "Z";
    var N = Bn(a.getHours(), 2), I = Bn(a.getMinutes(), 2), R = Bn(a.getSeconds(), 2), j = p === "" ? "" : "T", U = [N, I, R].join(g);
    p = "".concat(p).concat(j).concat(U).concat(m);
  }
  return p;
}
function ASe(e, t) {
  _t(2, arguments);
  var n = Rt(e).getTime(), r = Rt(t.start).getTime(), a = Rt(t.end).getTime();
  if (!(r <= a))
    throw new RangeError("Invalid interval");
  return n >= r && n <= a;
}
var i$ = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = void 0;
  var n = function(m, h) {
    switch (m) {
      case "P":
        return h.date({
          width: "short"
        });
      case "PP":
        return h.date({
          width: "medium"
        });
      case "PPP":
        return h.date({
          width: "long"
        });
      case "PPPP":
      default:
        return h.date({
          width: "full"
        });
    }
  }, r = function(m, h) {
    switch (m) {
      case "p":
        return h.time({
          width: "short"
        });
      case "pp":
        return h.time({
          width: "medium"
        });
      case "ppp":
        return h.time({
          width: "long"
        });
      case "pppp":
      default:
        return h.time({
          width: "full"
        });
    }
  }, a = function(m, h) {
    var g = m.match(/(P+)(p+)?/) || [], b = g[1], x = g[2];
    if (!x)
      return n(m, h);
    var E;
    switch (b) {
      case "P":
        E = h.dateTime({
          width: "short"
        });
        break;
      case "PP":
        E = h.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        E = h.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        E = h.dateTime({
          width: "full"
        });
        break;
    }
    return E.replace("{{date}}", n(b, h)).replace("{{time}}", r(x, h));
  }, s = {
    p: r,
    P: a
  }, l = s;
  t.default = l, e.exports = t.default;
})(i$, i$.exports);
var jSe = i$.exports;
const LSe = /* @__PURE__ */ Uf(jSe), FSe = {
  // Year
  y: {
    sectionType: "year",
    contentType: "digit",
    maxLength: 4
  },
  yy: "year",
  yyy: {
    sectionType: "year",
    contentType: "digit",
    maxLength: 4
  },
  yyyy: "year",
  // Month
  M: {
    sectionType: "month",
    contentType: "digit",
    maxLength: 2
  },
  MM: "month",
  MMMM: {
    sectionType: "month",
    contentType: "letter"
  },
  MMM: {
    sectionType: "month",
    contentType: "letter"
  },
  L: {
    sectionType: "month",
    contentType: "digit",
    maxLength: 2
  },
  LL: "month",
  LLL: {
    sectionType: "month",
    contentType: "letter"
  },
  LLLL: {
    sectionType: "month",
    contentType: "letter"
  },
  // Day of the month
  d: {
    sectionType: "day",
    contentType: "digit",
    maxLength: 2
  },
  dd: "day",
  do: {
    sectionType: "day",
    contentType: "digit-with-letter"
  },
  // Day of the week
  E: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEEEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  i: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 1
  },
  ii: "weekDay",
  iii: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  iiii: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  e: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 1
  },
  ee: "weekDay",
  eee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeeeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  c: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 1
  },
  cc: "weekDay",
  ccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  cccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  ccccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  cccccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  // Meridiem
  a: "meridiem",
  aa: "meridiem",
  aaa: "meridiem",
  // Hours
  H: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  HH: "hours",
  h: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  hh: "hours",
  // Minutes
  m: {
    sectionType: "minutes",
    contentType: "digit",
    maxLength: 2
  },
  mm: "minutes",
  // Seconds
  s: {
    sectionType: "seconds",
    contentType: "digit",
    maxLength: 2
  },
  ss: "seconds"
}, zSe = {
  year: "yyyy",
  month: "LLLL",
  monthShort: "MMM",
  dayOfMonth: "d",
  weekday: "EEEE",
  weekdayShort: "EEE",
  hours24h: "HH",
  hours12h: "hh",
  meridiem: "aa",
  minutes: "mm",
  seconds: "ss",
  fullDate: "PP",
  fullDateWithWeekday: "PPPP",
  keyboardDate: "P",
  shortDate: "MMM d",
  normalDate: "d MMMM",
  normalDateWithWeekday: "EEE, MMM d",
  monthAndYear: "LLLL yyyy",
  monthAndDate: "MMMM d",
  fullTime: "p",
  fullTime12h: "hh:mm aa",
  fullTime24h: "HH:mm",
  fullDateTime: "PP p",
  fullDateTime12h: "PP hh:mm aa",
  fullDateTime24h: "PP HH:mm",
  keyboardDateTime: "P p",
  keyboardDateTime12h: "P hh:mm aa",
  keyboardDateTime24h: "P HH:mm"
};
class v9 {
  constructor({
    locale: t,
    formats: n
  } = {}) {
    this.isMUIAdapter = !0, this.isTimezoneCompatible = !1, this.lib = "date-fns", this.locale = void 0, this.formats = void 0, this.formatTokenMap = FSe, this.escapedCharacters = {
      start: "'",
      end: "'"
    }, this.date = (r) => typeof r > "u" ? /* @__PURE__ */ new Date() : r === null ? null : new Date(r), this.dateWithTimezone = (r) => this.date(r), this.getTimezone = () => "default", this.setTimezone = (r) => r, this.toJsDate = (r) => r, this.parseISO = (r) => bSe(r), this.toISO = (r) => ISe(r, {
      format: "extended"
    }), this.parse = (r, a) => r === "" ? null : cSe(r, a, /* @__PURE__ */ new Date(), {
      locale: this.locale
    }), this.getCurrentLocaleCode = () => {
      var r;
      return ((r = this.locale) == null ? void 0 : r.code) || "en-US";
    }, this.is12HourCycleInCurrentLocale = () => this.locale ? /a/.test(this.locale.formatLong.time()) : !0, this.expandFormat = (r) => {
      const a = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      return r.match(a).map((s) => {
        const l = s[0];
        if (l === "p" || l === "P") {
          const p = LSe[l], m = this.locale || qM;
          return p(s, m.formatLong, {});
        }
        return s;
      }).join("");
    }, this.getFormatHelperText = (r) => this.expandFormat(r).replace(/(aaa|aa|a)/g, "(a|p)m").toLocaleLowerCase(), this.isNull = (r) => r === null, this.isValid = (r) => t9(this.date(r)), this.format = (r, a) => this.formatByString(r, this.formats[a]), this.formatByString = (r, a) => Kwe(r, a, {
      locale: this.locale
    }), this.formatNumber = (r) => r, this.getDiff = (r, a, s) => {
      switch (s) {
        case "years":
          return $0e(r, this.date(a));
        case "quarters":
          return A0e(r, this.date(a));
        case "months":
          return J8(r, this.date(a));
        case "weeks":
          return F0e(r, this.date(a));
        case "days":
          return e9(r, this.date(a));
        case "hours":
          return V0e(r, this.date(a));
        case "minutes":
          return U0e(r, this.date(a));
        case "seconds":
          return B0e(r, this.date(a));
        default:
          return JT(r, this.date(a));
      }
    }, this.isEqual = (r, a) => r === null && a === null ? !0 : lxe(r, a), this.isSameYear = (r, a) => cxe(r, a), this.isSameMonth = (r, a) => dxe(r, a), this.isSameDay = (r, a) => uxe(r, a), this.isSameHour = (r, a) => fxe(r, a), this.isAfter = (r, a) => Yk(r, a), this.isAfterYear = (r, a) => Yk(r, Hk(a)), this.isAfterDay = (r, a) => Yk(r, r$(a)), this.isBefore = (r, a) => o0(r, a), this.isBeforeYear = (r, a) => o0(r, P1(a)), this.isBeforeDay = (r, a) => o0(r, yy(a)), this.isWithinRange = (r, [a, s]) => ASe(r, {
      start: a,
      end: s
    }), this.startOfYear = (r) => P1(r), this.startOfMonth = (r) => B5(r), this.startOfWeek = (r) => ym(r, {
      locale: this.locale
    }), this.startOfDay = (r) => yy(r), this.endOfYear = (r) => Hk(r), this.endOfMonth = (r) => o$(r), this.endOfWeek = (r) => Bk(r, {
      locale: this.locale
    }), this.endOfDay = (r) => r$(r), this.addYears = (r, a) => M5(r, a), this.addMonths = (r, a) => aE(r, a), this.addWeeks = (r, a) => k0e(r, a), this.addDays = (r, a) => n$(r, a), this.addHours = (r, a) => R0e(r, a), this.addMinutes = (r, a) => O0e(r, a), this.addSeconds = (r, a) => T0e(r, a), this.getYear = (r) => sxe(r), this.getMonth = (r) => exe(r), this.getDate = (r) => Qwe(r), this.getHours = (r) => Zwe(r), this.getMinutes = (r) => Jwe(r), this.getSeconds = (r) => txe(r), this.getMilliseconds = (r) => nxe(r), this.setYear = (r, a) => gSe(r, a), this.setMonth = (r, a) => hSe(r, a), this.setDate = (r, a) => fSe(r, a), this.setHours = (r, a) => pSe(r, a), this.setMinutes = (r, a) => mSe(r, a), this.setSeconds = (r, a) => vSe(r, a), this.setMilliseconds = (r, a) => ySe(r, a), this.getDaysInMonth = (r) => u9(r), this.getNextMonth = (r) => aE(r, 1), this.getPreviousMonth = (r) => aE(r, -1), this.getMonthArray = (r) => {
      const s = [P1(r)];
      for (; s.length < 12; ) {
        const l = s[s.length - 1];
        s.push(this.getNextMonth(l));
      }
      return s;
    }, this.mergeDateAndTime = (r, a) => this.setSeconds(this.setMinutes(this.setHours(r, this.getHours(a)), this.getMinutes(a)), this.getSeconds(a)), this.getWeekdays = () => {
      const r = /* @__PURE__ */ new Date();
      return H0e({
        start: ym(r, {
          locale: this.locale
        }),
        end: Bk(r, {
          locale: this.locale
        })
      }).map((a) => this.formatByString(a, "EEEEEE"));
    }, this.getWeekArray = (r) => {
      const a = ym(B5(r), {
        locale: this.locale
      }), s = Bk(o$(r), {
        locale: this.locale
      });
      let l = 0, p = a;
      const m = [];
      for (; o0(p, s); ) {
        const h = Math.floor(l / 7);
        m[h] = m[h] || [], m[h].push(p), p = n$(p, 1), l += 1;
      }
      return m;
    }, this.getWeekNumber = (r) => ixe(r, {
      locale: this.locale
    }), this.getYearRange = (r, a) => {
      const s = P1(r), l = Hk(a), p = [];
      let m = s;
      for (; o0(m, l); )
        p.push(m), m = M5(m, 1);
      return p;
    }, this.getMeridiemText = (r) => r === "am" ? "AM" : "PM", this.locale = t, this.formats = B({}, zSe, n);
  }
}
const VSe = ["localeText"], qC = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (qC.displayName = "MuiPickersAdapterContext");
const gw = function(t) {
  var n;
  const {
    localeText: r
  } = t, a = st(t, VSe), {
    utils: s,
    localeText: l
  } = (n = C.useContext(qC)) != null ? n : {
    utils: void 0,
    localeText: void 0
  }, p = Lt({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: a,
    name: "MuiLocalizationProvider"
  }), {
    children: m,
    dateAdapter: h,
    dateFormats: g,
    dateLibInstance: b,
    adapterLocale: x,
    localeText: E
  } = p, O = C.useMemo(() => B({}, E, l, r), [E, l, r]), _ = C.useMemo(() => {
    if (!h)
      return s || null;
    const D = new h({
      locale: x,
      formats: g,
      instance: b
    });
    if (!D.isMUIAdapter)
      throw new Error(["MUI: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    return D;
  }, [h, x, g, b, s]), P = C.useMemo(() => _ ? {
    minDate: _.date("1900-01-01T00:00:00.000"),
    maxDate: _.date("2099-12-31T00:00:00.000")
  } : null, [_]), M = C.useMemo(() => ({
    utils: _,
    defaultDates: P,
    localeText: O
  }), [P, _, O]);
  return /* @__PURE__ */ L.jsx(qC.Provider, {
    value: M,
    children: m
  });
};
process.env.NODE_ENV !== "production" && (gw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Locale for the date library you are using
   */
  adapterLocale: c.any,
  children: c.node,
  /**
   * Date library adapter class function.
   * @see See the localization provider {@link https://mui.com/x/react-date-pickers/getting-started/#setup-your-date-library-adapter date adapter setup section} for more details.
   */
  dateAdapter: c.func,
  /**
   * Formats that are used for any child pickers
   */
  dateFormats: c.shape({
    dayOfMonth: c.string,
    fullDate: c.string,
    fullDateTime: c.string,
    fullDateTime12h: c.string,
    fullDateTime24h: c.string,
    fullDateWithWeekday: c.string,
    fullTime: c.string,
    fullTime12h: c.string,
    fullTime24h: c.string,
    hours12h: c.string,
    hours24h: c.string,
    keyboardDate: c.string,
    keyboardDateTime: c.string,
    keyboardDateTime12h: c.string,
    keyboardDateTime24h: c.string,
    meridiem: c.string,
    minutes: c.string,
    month: c.string,
    monthAndDate: c.string,
    monthAndYear: c.string,
    monthShort: c.string,
    normalDate: c.string,
    normalDateWithWeekday: c.string,
    seconds: c.string,
    shortDate: c.string,
    weekday: c.string,
    weekdayShort: c.string,
    year: c.string
  }),
  /**
   * Date library instance you are using, if it has some global overrides
   * ```jsx
   * dateLibInstance={momentTimeZone}
   * ```
   */
  dateLibInstance: c.any,
  /**
   * Locale for components texts
   */
  localeText: c.object
});
function USe(e, t, n, r, a) {
  const [s, l] = C.useState(() => a && n ? n(e).matches : r ? r(e).matches : t);
  return ei(() => {
    let p = !0;
    if (!n)
      return;
    const m = n(e), h = () => {
      p && l(m.matches);
    };
    return h(), m.addListener(h), () => {
      p = !1, m.removeListener(h);
    };
  }, [e, n]), s;
}
const y9 = iy["useSyncExternalStore"];
function BSe(e, t, n, r, a) {
  const s = C.useCallback(() => t, [t]), l = C.useMemo(() => {
    if (a && n)
      return () => n(e).matches;
    if (r !== null) {
      const {
        matches: g
      } = r(e);
      return () => g;
    }
    return s;
  }, [s, e, r, a, n]), [p, m] = C.useMemo(() => {
    if (n === null)
      return [s, () => () => {
      }];
    const g = n(e);
    return [() => g.matches, (b) => (g.addListener(b), () => {
      g.removeListener(b);
    })];
  }, [s, n, e]);
  return y9(m, p, l);
}
function g9(e, t = {}) {
  const n = RT(), r = typeof window < "u" && typeof window.matchMedia < "u", {
    defaultMatches: a = !1,
    matchMedia: s = r ? window.matchMedia : null,
    ssrMatchMedia: l = null,
    noSsr: p = !1
  } = H3({
    name: "MuiUseMediaQuery",
    props: t,
    theme: n
  });
  process.env.NODE_ENV !== "production" && typeof e == "function" && n === null && console.error(["MUI: The `query` argument provided is invalid.", "You are providing a function without a theme in the context.", "One of the parent elements needs to use a ThemeProvider."].join(`
`));
  let m = typeof e == "function" ? e(n) : e;
  m = m.replace(/^@media( ?)/m, "");
  const g = (y9 !== void 0 ? BSe : USe)(m, a, s, l, p);
  return process.env.NODE_ENV !== "production" && C.useDebugValue({
    query: m,
    match: g
  }), g;
}
function zf(e) {
  return typeof e == "string";
}
function HSe(e, t, n) {
  return e === void 0 || zf(e) ? t : B({}, t, {
    ownerState: B({}, t.ownerState, n)
  });
}
const WSe = {
  disableDefaultClasses: !1
}, YSe = /* @__PURE__ */ C.createContext(WSe);
function b9(e) {
  const {
    disableDefaultClasses: t
  } = C.useContext(YSe);
  return (n) => t ? "" : e(n);
}
function qSe(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function Vf(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function w9(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = w9(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function H5() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = w9(e)) && (r && (r += " "), r += t);
  return r;
}
function W5(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function GSe(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: a,
    className: s
  } = e;
  if (!t) {
    const E = H5(a == null ? void 0 : a.className, r == null ? void 0 : r.className, s, n == null ? void 0 : n.className), O = B({}, n == null ? void 0 : n.style, a == null ? void 0 : a.style, r == null ? void 0 : r.style), _ = B({}, n, a, r);
    return E.length > 0 && (_.className = E), Object.keys(O).length > 0 && (_.style = O), {
      props: _,
      internalRef: void 0
    };
  }
  const l = qSe(B({}, a, r)), p = W5(r), m = W5(a), h = t(l), g = H5(h == null ? void 0 : h.className, n == null ? void 0 : n.className, s, a == null ? void 0 : a.className, r == null ? void 0 : r.className), b = B({}, h == null ? void 0 : h.style, n == null ? void 0 : n.style, a == null ? void 0 : a.style, r == null ? void 0 : r.style), x = B({}, h, n, m, p);
  return g.length > 0 && (x.className = g), Object.keys(b).length > 0 && (x.style = b), {
    props: x,
    internalRef: h.ref
  };
}
const KSe = ["elementType", "externalSlotProps", "ownerState"];
function Gr(e) {
  var t;
  const {
    elementType: n,
    externalSlotProps: r,
    ownerState: a
  } = e, s = st(e, KSe), l = Vf(r, a), {
    props: p,
    internalRef: m
  } = GSe(B({}, s, {
    externalSlotProps: l
  })), h = yo(m, l == null ? void 0 : l.ref, (t = e.additionalProps) == null ? void 0 : t.ref);
  return HSe(n, B({}, p, {
    ref: h
  }), a);
}
const Wu = (e, t) => e.length !== t.length ? !1 : t.every((n) => e.includes(n)), x9 = ({
  openTo: e,
  defaultOpenTo: t,
  views: n,
  defaultViews: r
}) => {
  const a = n ?? r;
  let s;
  if (e != null)
    s = e;
  else if (a.includes(t))
    s = t;
  else if (a.length > 0)
    s = a[0];
  else
    throw new Error("MUI: The `views` prop must contain at least one view");
  return {
    views: a,
    openTo: s
  };
}, k0 = ({
  date: e,
  disableFuture: t,
  disablePast: n,
  maxDate: r,
  minDate: a,
  isDateDisabled: s,
  utils: l
}) => {
  const p = l.startOfDay(l.date());
  n && l.isBefore(a, p) && (a = p), t && l.isAfter(r, p) && (r = p);
  let m = e, h = e;
  for (l.isBefore(e, a) && (m = a, h = null), l.isAfter(e, r) && (h && (h = r), m = null); m || h; ) {
    if (m && l.isAfter(m, r) && (m = null), h && l.isBefore(h, a) && (h = null), m) {
      if (!s(m))
        return m;
      m = l.addDays(m, 1);
    }
    if (h) {
      if (!s(h))
        return h;
      h = l.addDays(h, -1);
    }
  }
  return null;
}, XSe = (e, t, n, r) => e.isBefore(t, n) ? n : e.isAfter(t, r) ? r : t, QSe = (e, t) => t == null || !e.isValid(t) ? null : t, ni = (e, t, n) => t == null || !e.isValid(t) ? n : t, ZSe = (e, t, n) => !e.isValid(t) && t != null && !e.isValid(n) && n != null ? !0 : e.isEqual(t, n), XM = (e, t) => {
  const r = [e.startOfYear(t)];
  for (; r.length < 12; ) {
    const a = r[r.length - 1];
    r.push(e.addMonths(a, 1));
  }
  return r;
}, s$ = (e, t, n) => {
  let r = t;
  return r = e.setHours(r, e.getHours(n)), r = e.setMinutes(r, e.getMinutes(n)), r = e.setSeconds(r, e.getSeconds(n)), r;
}, S9 = (e, t) => t === "date" ? e.startOfDay(e.date()) : e.date(), JSe = ["year", "month", "day"], ny = (e) => JSe.includes(e), q0 = (e, {
  format: t,
  views: n
}, r) => {
  if (t != null)
    return t;
  const a = e.formats;
  return Wu(n, ["year"]) ? a.year : Wu(n, ["month"]) ? a.month : Wu(n, ["day"]) ? a.dayOfMonth : Wu(n, ["month", "year"]) ? `${a.month} ${a.year}` : Wu(n, ["day", "month"]) ? `${a.month} ${a.dayOfMonth}` : r ? /en/.test(e.getCurrentLocaleCode()) ? a.normalDateWithWeekday : a.normalDate : a.keyboardDate;
}, E9 = ["hours", "minutes", "seconds"], GC = (e) => E9.includes(e), Gk = (e) => E9.includes(e) || e === "meridiem", e1e = (e, t) => e ? t.getHours(e) >= 12 ? "pm" : "am" : null, G0 = (e, t, n) => n && (e >= 12 ? "pm" : "am") !== t ? t === "am" ? e - 12 : e + 12 : e, t1e = (e, t, n, r) => {
  const a = G0(r.getHours(e), t, n);
  return r.setHours(e, a);
}, Y5 = (e, t) => t.getHours(e) * 3600 + t.getMinutes(e) * 60 + t.getSeconds(e), e_ = (e, t) => (n, r) => e ? t.isAfter(n, r) : Y5(n, t) > Y5(r, t), q5 = (e, {
  format: t,
  views: n,
  ampm: r
}) => {
  if (t != null)
    return t;
  const a = e.formats;
  return Wu(n, ["hours"]) ? r ? `${a.hours12h} ${a.meridiem}` : a.hours24h : Wu(n, ["minutes"]) ? a.minutes : Wu(n, ["seconds"]) ? a.seconds : Wu(n, ["minutes", "seconds"]) ? `${a.minutes}:${a.seconds}` : Wu(n, ["hours", "minutes", "seconds"]) ? r ? `${a.hours12h}:${a.minutes}:${a.seconds} ${a.meridiem}` : `${a.hours24h}:${a.minutes}:${a.seconds}` : r ? `${a.hours12h}:${a.minutes} ${a.meridiem}` : `${a.hours24h}:${a.minutes}`;
}, im = {
  year: 1,
  month: 2,
  day: 3,
  hours: 4,
  minutes: 5,
  seconds: 6,
  milliseconds: 7
}, n1e = (e) => Math.max(...e.map((t) => {
  var n;
  return (n = im[t.type]) != null ? n : 1;
})), i0 = (e, t, n) => {
  if (t === im.year)
    return e.startOfYear(n);
  if (t === im.month)
    return e.startOfMonth(n);
  if (t === im.day)
    return e.startOfDay(n);
  let r = n;
  return t < im.minutes && (r = e.setMinutes(r, 0)), t < im.seconds && (r = e.setSeconds(r, 0)), t < im.milliseconds && (r = e.setMilliseconds(r, 0)), r;
}, r1e = ({
  props: e,
  utils: t,
  valueType: n,
  granularity: r
}) => {
  var a;
  let s = i0(t, r, S9(t, n));
  e.minDate != null && t.isAfterDay(e.minDate, s) && (s = i0(t, r, e.minDate)), e.maxDate != null && t.isBeforeDay(e.maxDate, s) && (s = i0(t, r, e.maxDate));
  const l = e_((a = e.disableIgnoringDatePartForTimeValidation) != null ? a : !1, t);
  return e.minTime != null && l(e.minTime, s) && (s = i0(t, r, e.disableIgnoringDatePartForTimeValidation ? e.minTime : s$(t, s, e.minTime))), e.maxTime != null && l(s, e.maxTime) && (s = i0(t, r, e.disableIgnoringDatePartForTimeValidation ? e.maxTime : s$(t, s, e.maxTime))), s;
}, QM = (e, t) => {
  const n = e.formatTokenMap[t];
  if (n == null)
    throw new Error([`MUI: The token "${t}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join(`
`));
  return typeof n == "string" ? {
    type: n,
    contentType: n === "meridiem" ? "letter" : "digit",
    maxLength: void 0
  } : {
    type: n.sectionType,
    contentType: n.contentType,
    maxLength: n.maxLength
  };
}, o1e = (e) => {
  switch (e) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
}, t_ = (e, t) => {
  const n = [], r = e.date(), a = e.startOfWeek(r), s = e.endOfWeek(r);
  let l = a;
  for (; e.isBefore(l, s); )
    n.push(l), l = e.addDays(l, 1);
  return n.map((p) => e.formatByString(p, t));
}, C9 = (e, t, n) => {
  switch (t) {
    case "month":
      return XM(e, e.date()).map((r) => e.formatByString(r, n));
    case "weekDay":
      return t_(e, n);
    case "meridiem": {
      const r = e.date();
      return [e.startOfDay(r), e.endOfDay(r)].map((a) => e.formatByString(a, n));
    }
    default:
      return [];
  }
}, T9 = (e, t, n) => {
  let r = t;
  for (r = Number(r).toString(); r.length < n; )
    r = `0${r}`;
  return r;
}, ZM = (e, t, n, r) => {
  if (process.env.NODE_ENV !== "production" && r.type !== "day" && r.contentType === "digit-with-letter")
    throw new Error([`MUI: The token "${r.format}" is a digit format with letter in it.'
             This type of format is only supported for 'day' sections`].join(`
`));
  if (r.type === "day" && r.contentType === "digit-with-letter") {
    const s = e.setDate(n.longestMonth, t);
    return e.formatByString(s, r.format);
  }
  const a = t.toString();
  return r.hasLeadingZerosInInput ? T9(e, a, r.maxLength) : a;
}, a1e = (e, t, n, r, a) => {
  const s = o1e(n), l = n === "Home", p = n === "End", m = t.value === "" || l || p, h = () => {
    const b = r[t.type]({
      currentDate: a,
      format: t.format,
      contentType: t.contentType
    }), x = (_) => ZM(e, _, b, t);
    if (m)
      return t.type === "year" && !p && !l ? e.formatByString(e.date(), t.format) : s > 0 || l ? x(b.minimum) : x(b.maximum);
    const O = parseInt(t.value, 10) + s;
    return O > b.maximum ? x(b.minimum) : O < b.minimum ? x(b.maximum) : x(O);
  }, g = () => {
    const b = C9(e, t.type, t.format);
    if (b.length === 0)
      return t.value;
    if (m)
      return s > 0 || l ? b[0] : b[b.length - 1];
    const E = (b.indexOf(t.value) + b.length + s) % b.length;
    return b[E];
  };
  return t.contentType === "digit" || t.contentType === "digit-with-letter" ? h() : g();
}, JM = (e, t) => {
  let n = e.value || e.placeholder;
  const r = t === "non-input" ? e.hasLeadingZerosInFormat : e.hasLeadingZerosInInput;
  return t === "non-input" && e.hasLeadingZerosInInput && !e.hasLeadingZerosInFormat && (n = Number(n).toString()), ["input-rtl", "input-ltr"].includes(t) && e.contentType === "digit" && !r && n.length === 1 && (n = `${n}‎`), t === "input-rtl" && (n = `⁨${n}⁩`), n;
}, Gv = (e) => e.replace(/[\u2066\u2067\u2068\u2069]/g, ""), _9 = (e, t) => {
  let n = 0, r = t ? 1 : 0;
  const a = [];
  for (let s = 0; s < e.length; s += 1) {
    const l = e[s], p = JM(l, t ? "input-rtl" : "input-ltr"), m = `${l.startSeparator}${p}${l.endSeparator}`, h = Gv(m).length, g = m.length, b = Gv(p), x = r + p.indexOf(b[0]) + l.startSeparator.length, E = x + b.length;
    a.push(B({}, l, {
      start: n,
      end: n + h,
      startInInput: x,
      endInInput: E
    })), n += h, r += g;
  }
  return a;
}, i1e = (e, t, n, r) => {
  switch (n.type) {
    case "year":
      return t.fieldYearPlaceholder({
        digitAmount: e.formatByString(e.date(), r).length
      });
    case "month":
      return t.fieldMonthPlaceholder({
        contentType: n.contentType
      });
    case "day":
      return t.fieldDayPlaceholder();
    case "weekDay":
      return t.fieldWeekDayPlaceholder({
        contentType: n.contentType
      });
    case "hours":
      return t.fieldHoursPlaceholder();
    case "minutes":
      return t.fieldMinutesPlaceholder();
    case "seconds":
      return t.fieldSecondsPlaceholder();
    case "meridiem":
      return t.fieldMeridiemPlaceholder();
    default:
      return r;
  }
}, G5 = (e, t, n, r) => {
  if (process.env.NODE_ENV !== "production" && QM(e, n).type === "weekDay")
    throw new Error("changeSectionValueFormat doesn't support week day formats");
  return e.formatByString(e.parse(t, n), r);
}, O9 = (e, t) => e.formatByString(e.date(), t).length === 4, P9 = (e, t, n, r) => {
  if (t !== "digit")
    return !1;
  switch (n) {
    case "year":
      return O9(e, r) ? e.formatByString(e.setYear(e.date(), 1), r) === "0001" : e.formatByString(e.setYear(e.date(), 2001), r) === "01";
    case "month":
      return e.formatByString(e.startOfYear(e.date()), r).length > 1;
    case "day":
      return e.formatByString(e.startOfMonth(e.date()), r).length > 1;
    case "weekDay":
      return e.formatByString(e.startOfWeek(e.date()), r).length > 1;
    case "hours":
      return e.formatByString(e.setHours(e.date(), 1), r).length > 1;
    case "minutes":
      return e.formatByString(e.setMinutes(e.date(), 1), r).length > 1;
    case "seconds":
      return e.formatByString(e.setMinutes(e.date(), 1), r).length > 1;
    default:
      throw new Error("Invalid section type");
  }
}, s1e = (e, t) => {
  const n = [], {
    start: r,
    end: a
  } = e.escapedCharacters, s = new RegExp(`(\\${r}[^\\${a}]*\\${a})+`, "g");
  let l = null;
  for (; l = s.exec(t); )
    n.push({
      start: l.index,
      end: s.lastIndex - 1
    });
  return n;
}, K5 = (e, t, n, r, a, s, l) => {
  let p = "";
  const m = [], h = e.date(), g = (D) => {
    if (D === "")
      return null;
    const N = QM(e, D), I = P9(e, N.contentType, N.type, D), R = s ? I : N.contentType === "digit", j = r != null && e.isValid(r);
    let U = j ? e.formatByString(r, D) : "", q = null;
    if (R)
      if (I)
        q = U === "" ? e.formatByString(h, D).length : U.length;
      else {
        if (N.maxLength == null)
          throw new Error(`MUI: The token ${D} should have a 'maxDigitNumber' property on it's adapter`);
        q = N.maxLength, j && (U = T9(e, U, q));
      }
    return m.push(B({}, N, {
      format: D,
      maxLength: q,
      value: U,
      placeholder: i1e(e, t, N, D),
      hasLeadingZeros: I,
      hasLeadingZerosInFormat: I,
      hasLeadingZerosInInput: R,
      startSeparator: m.length === 0 ? p : "",
      endSeparator: "",
      modified: !1
    })), null;
  };
  let b = 10, x = n, E = e.expandFormat(n);
  for (; E !== x; )
    if (x = E, E = e.expandFormat(x), b -= 1, b < 0)
      throw new Error("MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component");
  const O = E, _ = s1e(e, O), P = new RegExp(`^(${Object.keys(e.formatTokenMap).join("|")})`);
  let M = "";
  for (let D = 0; D < O.length; D += 1) {
    const N = _.find((U) => U.start <= D && U.end >= D), I = O[D], R = N != null, j = `${M}${O.slice(D)}`;
    !R && I.match(/([A-Za-z]+)/) && P.test(j) ? M += I : R && (N == null ? void 0 : N.start) === D || (N == null ? void 0 : N.end) === D || (g(M), M = "", m.length === 0 ? p += I : m[m.length - 1].endSeparator += I);
  }
  return g(M), m.map((D) => {
    const N = (I) => {
      let R = I;
      return l && R !== null && R.includes(" ") && (R = `⁩${R}⁦`), a === "spacious" && ["/", ".", "-"].includes(R) && (R = ` ${R} `), R;
    };
    return D.startSeparator = N(D.startSeparator), D.endSeparator = N(D.endSeparator), D;
  });
}, l$ = (e, t) => {
  const n = t.some((p) => p.type === "day"), r = [], a = [];
  for (let p = 0; p < t.length; p += 1) {
    const m = t[p];
    n && m.type === "weekDay" || (r.push(m.format), a.push(JM(m, "non-input")));
  }
  const s = r.join(" "), l = a.join(" ");
  return e.parse(l, s);
}, l1e = (e, t) => {
  const r = e.map((a) => {
    const s = JM(a, t ? "input-rtl" : "input-ltr");
    return `${a.startSeparator}${s}${a.endSeparator}`;
  }).join("");
  return t ? `⁦${r}⁩` : r;
}, u1e = (e) => {
  const t = e.date(), n = e.endOfYear(t), {
    maxDaysInMonth: r,
    longestMonth: a
  } = XM(e, t).reduce((s, l) => {
    const p = e.getDaysInMonth(l);
    return p > s.maxDaysInMonth ? {
      maxDaysInMonth: p,
      longestMonth: l
    } : s;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format: s
    }) => ({
      minimum: 0,
      maximum: O9(e, s) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: e.getMonth(n) + 1
    }),
    day: ({
      currentDate: s
    }) => ({
      minimum: 1,
      maximum: s != null && e.isValid(s) ? e.getDaysInMonth(s) : r,
      longestMonth: a
    }),
    weekDay: ({
      format: s,
      contentType: l
    }) => {
      if (l === "digit") {
        const p = t_(e, s).map(Number);
        return {
          minimum: Math.min(...p),
          maximum: Math.max(...p)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format: s
    }) => {
      const l = e.getHours(n);
      return e.formatByString(e.endOfDay(t), s) !== l.toString() ? {
        minimum: 1,
        maximum: Number(e.formatByString(e.startOfDay(t), s))
      } : {
        minimum: 0,
        maximum: l
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: e.getMinutes(n)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: e.getSeconds(n)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 0
    })
  };
};
let X5 = !1;
const Q5 = (e, t) => {
  if (process.env.NODE_ENV !== "production" && !X5) {
    const n = [];
    ["date", "date-time"].includes(t) && n.push("weekDay", "day", "month", "year"), ["time", "date-time"].includes(t) && n.push("hours", "minutes", "seconds", "meridiem");
    const r = e.find((a) => !n.includes(a.type));
    r && (console.warn(`MUI: The field component you are using is not compatible with the "${r.type} date section.`, `The supported date sections are ["${n.join('", "')}"]\`.`), X5 = !0);
  }
}, c1e = (e, t, n, r) => {
  switch (t.type) {
    case "year":
      return e.setYear(r, e.getYear(n));
    case "month":
      return e.setMonth(r, e.getMonth(n));
    case "weekDay": {
      const a = t_(e, t.format), s = e.formatByString(n, t.format), l = a.indexOf(s), m = a.indexOf(t.value) - l;
      return e.addDays(n, m);
    }
    case "day":
      return e.setDate(r, e.getDate(n));
    case "meridiem": {
      const a = e.getHours(n) < 12, s = e.getHours(r);
      return a && s >= 12 ? e.addHours(r, -12) : !a && s < 12 ? e.addHours(r, 12) : r;
    }
    case "hours":
      return e.setHours(r, e.getHours(n));
    case "minutes":
      return e.setMinutes(r, e.getMinutes(n));
    case "seconds":
      return e.setSeconds(r, e.getSeconds(n));
    default:
      return r;
  }
}, Z5 = {
  year: 1,
  month: 2,
  day: 3,
  weekDay: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  meridiem: 8
}, J5 = (e, t, n, r, a) => (
  // cloning sections before sort to avoid mutating it
  [...n].sort((s, l) => Z5[s.type] - Z5[l.type]).reduce((s, l) => !a || l.modified ? c1e(e, l, t, s) : s, r)
), d1e = () => navigator.userAgent.toLowerCase().indexOf("android") > -1, f1e = (e, t, n) => {
  if (!(t.every((l) => l.type === "weekDay" || l.value !== "") && t.some((l) => l.type === "day")))
    return null;
  const a = t.map((l) => {
    if (l.type !== "day")
      return l;
    const p = n.day({
      currentDate: null,
      format: l.format,
      contentType: l.contentType
    });
    return B({}, l, {
      value: ZM(e, p.minimum, p, l)
    });
  }), s = l$(e, a);
  return s == null || !e.isValid(s) ? null : t.map((l) => {
    if (l.type !== "day")
      return l;
    const p = n.day({
      currentDate: s,
      format: l.format,
      contentType: l.contentType
    });
    return Number(l.value) <= p.maximum ? l : B({}, l, {
      value: p.maximum.toString()
    });
  });
}, p1e = (e, t) => {
  const n = {};
  if (!t)
    return e.forEach((m, h) => {
      const g = h === 0 ? null : h - 1, b = h === e.length - 1 ? null : h + 1;
      n[h] = {
        leftIndex: g,
        rightIndex: b
      };
    }), {
      neighbors: n,
      startIndex: 0,
      endIndex: e.length - 1
    };
  const r = {}, a = {};
  let s = 0, l = 0, p = e.length - 1;
  for (; p >= 0; ) {
    l = e.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (m, h) => {
        var g;
        return h >= s && ((g = m.endSeparator) == null ? void 0 : g.includes(" ")) && // Special case where the spaces were not there in the initial input
        m.endSeparator !== " / ";
      }
    ), l === -1 && (l = e.length - 1);
    for (let m = l; m >= s; m -= 1)
      a[m] = p, r[p] = m, p -= 1;
    s = l + 1;
  }
  return e.forEach((m, h) => {
    const g = a[h], b = g === 0 ? null : r[g - 1], x = g === e.length - 1 ? null : r[g + 1];
    n[h] = {
      leftIndex: b,
      rightIndex: x
    };
  }), {
    neighbors: n,
    startIndex: r[0],
    endIndex: r[e.length - 1]
  };
}, m1e = ["value", "referenceDate"], Ny = {
  emptyValue: null,
  getTodayValue: S9,
  getInitialReferenceValue: (e) => {
    let {
      value: t,
      referenceDate: n
    } = e, r = st(e, m1e);
    return t != null && r.utils.isValid(t) ? t : n ?? r1e(r);
  },
  cleanValue: QSe,
  areValuesEqual: ZSe,
  isSameError: (e, t) => e === t,
  hasError: (e) => e != null,
  defaultErrorState: null,
  getTimezone: (e, t) => t == null ? null : e.getTimezone(t)
}, R9 = {
  updateReferenceValue: (e, t, n) => t == null || !e.isValid(t) ? n : t,
  getSectionsFromValue: (e, t, n, r, a) => !e.isValid(t) && !!n ? n : _9(a(t), r),
  getValueStrFromSections: l1e,
  getActiveDateManager: (e, t) => ({
    date: t.value,
    referenceDate: t.referenceValue,
    getSections: (n) => n,
    getNewValuesFromNewActiveDate: (n) => ({
      value: n,
      referenceValue: n == null || !e.isValid(n) ? t.referenceValue : n
    })
  }),
  parseValueStr: (e, t, n) => n(e.trim(), t)
}, h1e = (e) => ({
  components: {
    MuiLocalizationProvider: {
      defaultProps: {
        localeText: B({}, e)
      }
    }
  }
}), k9 = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "open previous view",
  openNextView: "open next view",
  calendarViewSwitchingButtonAriaLabel: (e) => e === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange placeholders
  start: "Start",
  end: "End",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (e, t, n) => `Select ${e}. ${t === null ? "No time selected" : `Selected time is ${n.format(t, "fullTime")}`}`,
  hoursClockNumberText: (e) => `${e} hours`,
  minutesClockNumberText: (e) => `${e} minutes`,
  secondsClockNumberText: (e) => `${e} seconds`,
  // Digital clock labels
  selectViewText: (e) => `Select ${e}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (e) => `Week ${e}`,
  calendarWeekNumberText: (e) => `${e}`,
  // Open picker labels
  openDatePickerDialogue: (e, t) => e !== null && t.isValid(e) ? `Choose date, selected date is ${t.format(e, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (e, t) => e !== null && t.isValid(e) ? `Choose time, selected time is ${t.format(e, "fullTime")}` : "Choose time",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (e) => "Y".repeat(e.digitAmount),
  fieldMonthPlaceholder: (e) => e.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (e) => e.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa"
}, v1e = k9;
h1e(k9);
const Im = () => {
  const e = C.useContext(qC);
  if (e === null)
    throw new Error(["MUI: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join(`
`));
  if (e.utils === null)
    throw new Error(["MUI: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join(`
`));
  const t = C.useMemo(() => B({}, v1e, e.localeText), [e.localeText]);
  return C.useMemo(() => B({}, e, {
    localeText: t
  }), [e, t]);
}, or = () => Im().utils, Am = () => Im().defaultDates, es = () => Im().localeText, jm = () => {
  const e = or();
  return C.useRef(e.date()).current;
};
function D9(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = D9(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function Wt() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = D9(e)) && (r && (r += " "), r += t);
  return r;
}
const y1e = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function g1e(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function b1e(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function w1e(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || b1e(e));
}
function x1e(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(y1e)).forEach((r, a) => {
    const s = g1e(r);
    s === -1 || !w1e(r) || (s === 0 ? t.push(r) : n.push({
      documentOrder: a,
      tabIndex: s,
      node: r
    }));
  }), n.sort((r, a) => r.tabIndex === a.tabIndex ? r.documentOrder - a.documentOrder : r.tabIndex - a.tabIndex).map((r) => r.node).concat(t);
}
function S1e() {
  return !0;
}
function K0(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: a = !1,
    getTabbable: s = x1e,
    isEnabled: l = S1e,
    open: p
  } = e, m = C.useRef(!1), h = C.useRef(null), g = C.useRef(null), b = C.useRef(null), x = C.useRef(null), E = C.useRef(!1), O = C.useRef(null), _ = yo(t.ref, O), P = C.useRef(null);
  C.useEffect(() => {
    !p || !O.current || (E.current = !n);
  }, [n, p]), C.useEffect(() => {
    if (!p || !O.current)
      return;
    const N = aa(O.current);
    return O.current.contains(N.activeElement) || (O.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), O.current.setAttribute("tabIndex", "-1")), E.current && O.current.focus()), () => {
      a || (b.current && b.current.focus && (m.current = !0, b.current.focus()), b.current = null);
    };
  }, [p]), C.useEffect(() => {
    if (!p || !O.current)
      return;
    const N = aa(O.current), I = (U) => {
      const {
        current: q
      } = O;
      if (q !== null) {
        if (!N.hasFocus() || r || !l() || m.current) {
          m.current = !1;
          return;
        }
        if (!q.contains(N.activeElement)) {
          if (U && x.current !== U.target || N.activeElement !== x.current)
            x.current = null;
          else if (x.current !== null)
            return;
          if (!E.current)
            return;
          let Z = [];
          if ((N.activeElement === h.current || N.activeElement === g.current) && (Z = s(O.current)), Z.length > 0) {
            var J, H;
            const re = !!((J = P.current) != null && J.shiftKey && ((H = P.current) == null ? void 0 : H.key) === "Tab"), Y = Z[0], K = Z[Z.length - 1];
            typeof Y != "string" && typeof K != "string" && (re ? K.focus() : Y.focus());
          } else
            q.focus();
        }
      }
    }, R = (U) => {
      P.current = U, !(r || !l() || U.key !== "Tab") && N.activeElement === O.current && U.shiftKey && (m.current = !0, g.current && g.current.focus());
    };
    N.addEventListener("focusin", I), N.addEventListener("keydown", R, !0);
    const j = setInterval(() => {
      N.activeElement && N.activeElement.tagName === "BODY" && I(null);
    }, 50);
    return () => {
      clearInterval(j), N.removeEventListener("focusin", I), N.removeEventListener("keydown", R, !0);
    };
  }, [n, r, a, l, p, s]);
  const M = (N) => {
    b.current === null && (b.current = N.relatedTarget), E.current = !0, x.current = N.target;
    const I = t.props.onFocus;
    I && I(N);
  }, D = (N) => {
    b.current === null && (b.current = N.relatedTarget), E.current = !0;
  };
  return /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [/* @__PURE__ */ L.jsx("div", {
      tabIndex: p ? 0 : -1,
      onFocus: D,
      ref: h,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ C.cloneElement(t, {
      ref: _,
      onFocus: M
    }), /* @__PURE__ */ L.jsx("div", {
      tabIndex: p ? 0 : -1,
      onFocus: D,
      ref: g,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (K0.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: rw,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: c.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: c.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: c.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: c.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: c.func,
  /**
   * If `true`, focus is locked.
   */
  open: c.bool.isRequired
});
process.env.NODE_ENV !== "production" && (K0["propTypes"] = dT(K0.propTypes));
var Ki = "top", rl = "bottom", ol = "right", Xi = "left", eN = "auto", bw = [Ki, rl, ol, Xi], by = "start", X0 = "end", E1e = "clippingParents", $9 = "viewport", s0 = "popper", C1e = "reference", eU = /* @__PURE__ */ bw.reduce(function(e, t) {
  return e.concat([t + "-" + by, t + "-" + X0]);
}, []), M9 = /* @__PURE__ */ [].concat(bw, [eN]).reduce(function(e, t) {
  return e.concat([t, t + "-" + by, t + "-" + X0]);
}, []), T1e = "beforeRead", _1e = "read", O1e = "afterRead", P1e = "beforeMain", R1e = "main", k1e = "afterMain", D1e = "beforeWrite", $1e = "write", M1e = "afterWrite", N1e = [T1e, _1e, O1e, P1e, R1e, k1e, D1e, $1e, M1e];
function tc(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Ss(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function _m(e) {
  var t = Ss(e).Element;
  return e instanceof t || e instanceof Element;
}
function Js(e) {
  var t = Ss(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function tN(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Ss(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function I1e(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, a = t.attributes[n] || {}, s = t.elements[n];
    !Js(s) || !tc(s) || (Object.assign(s.style, r), Object.keys(a).forEach(function(l) {
      var p = a[l];
      p === !1 ? s.removeAttribute(l) : s.setAttribute(l, p === !0 ? "" : p);
    }));
  });
}
function A1e(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var a = t.elements[r], s = t.attributes[r] || {}, l = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), p = l.reduce(function(m, h) {
        return m[h] = "", m;
      }, {});
      !Js(a) || !tc(a) || (Object.assign(a.style, p), Object.keys(s).forEach(function(m) {
        a.removeAttribute(m);
      }));
    });
  };
}
const j1e = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: I1e,
  effect: A1e,
  requires: ["computeStyles"]
};
function Qu(e) {
  return e.split("-")[0];
}
var gm = Math.max, KC = Math.min, wy = Math.round;
function u$() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function N9() {
  return !/^((?!chrome|android).)*safari/i.test(u$());
}
function xy(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), a = 1, s = 1;
  t && Js(e) && (a = e.offsetWidth > 0 && wy(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && wy(r.height) / e.offsetHeight || 1);
  var l = _m(e) ? Ss(e) : window, p = l.visualViewport, m = !N9() && n, h = (r.left + (m && p ? p.offsetLeft : 0)) / a, g = (r.top + (m && p ? p.offsetTop : 0)) / s, b = r.width / a, x = r.height / s;
  return {
    width: b,
    height: x,
    top: g,
    right: h + b,
    bottom: g + x,
    left: h,
    x: h,
    y: g
  };
}
function nN(e) {
  var t = xy(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function I9(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && tN(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function sd(e) {
  return Ss(e).getComputedStyle(e);
}
function L1e(e) {
  return ["table", "td", "th"].indexOf(tc(e)) >= 0;
}
function Gf(e) {
  return ((_m(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function n_(e) {
  return tc(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (tN(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Gf(e)
  );
}
function tU(e) {
  return !Js(e) || // https://github.com/popperjs/popper-core/issues/837
  sd(e).position === "fixed" ? null : e.offsetParent;
}
function F1e(e) {
  var t = /firefox/i.test(u$()), n = /Trident/i.test(u$());
  if (n && Js(e)) {
    var r = sd(e);
    if (r.position === "fixed")
      return null;
  }
  var a = n_(e);
  for (tN(a) && (a = a.host); Js(a) && ["html", "body"].indexOf(tc(a)) < 0; ) {
    var s = sd(a);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return a;
    a = a.parentNode;
  }
  return null;
}
function ww(e) {
  for (var t = Ss(e), n = tU(e); n && L1e(n) && sd(n).position === "static"; )
    n = tU(n);
  return n && (tc(n) === "html" || tc(n) === "body" && sd(n).position === "static") ? t : n || F1e(e) || t;
}
function rN(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function D0(e, t, n) {
  return gm(e, KC(t, n));
}
function z1e(e, t, n) {
  var r = D0(e, t, n);
  return r > n ? n : r;
}
function A9() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function j9(e) {
  return Object.assign({}, A9(), e);
}
function L9(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var V1e = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, j9(typeof t != "number" ? t : L9(t, bw));
};
function U1e(e) {
  var t, n = e.state, r = e.name, a = e.options, s = n.elements.arrow, l = n.modifiersData.popperOffsets, p = Qu(n.placement), m = rN(p), h = [Xi, ol].indexOf(p) >= 0, g = h ? "height" : "width";
  if (!(!s || !l)) {
    var b = V1e(a.padding, n), x = nN(s), E = m === "y" ? Ki : Xi, O = m === "y" ? rl : ol, _ = n.rects.reference[g] + n.rects.reference[m] - l[m] - n.rects.popper[g], P = l[m] - n.rects.reference[m], M = ww(s), D = M ? m === "y" ? M.clientHeight || 0 : M.clientWidth || 0 : 0, N = _ / 2 - P / 2, I = b[E], R = D - x[g] - b[O], j = D / 2 - x[g] / 2 + N, U = D0(I, j, R), q = m;
    n.modifiersData[r] = (t = {}, t[q] = U, t.centerOffset = U - j, t);
  }
}
function B1e(e) {
  var t = e.state, n = e.options, r = n.element, a = r === void 0 ? "[data-popper-arrow]" : r;
  a != null && (typeof a == "string" && (a = t.elements.popper.querySelector(a), !a) || I9(t.elements.popper, a) && (t.elements.arrow = a));
}
const H1e = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: U1e,
  effect: B1e,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Sy(e) {
  return e.split("-")[1];
}
var W1e = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Y1e(e, t) {
  var n = e.x, r = e.y, a = t.devicePixelRatio || 1;
  return {
    x: wy(n * a) / a || 0,
    y: wy(r * a) / a || 0
  };
}
function nU(e) {
  var t, n = e.popper, r = e.popperRect, a = e.placement, s = e.variation, l = e.offsets, p = e.position, m = e.gpuAcceleration, h = e.adaptive, g = e.roundOffsets, b = e.isFixed, x = l.x, E = x === void 0 ? 0 : x, O = l.y, _ = O === void 0 ? 0 : O, P = typeof g == "function" ? g({
    x: E,
    y: _
  }) : {
    x: E,
    y: _
  };
  E = P.x, _ = P.y;
  var M = l.hasOwnProperty("x"), D = l.hasOwnProperty("y"), N = Xi, I = Ki, R = window;
  if (h) {
    var j = ww(n), U = "clientHeight", q = "clientWidth";
    if (j === Ss(n) && (j = Gf(n), sd(j).position !== "static" && p === "absolute" && (U = "scrollHeight", q = "scrollWidth")), j = j, a === Ki || (a === Xi || a === ol) && s === X0) {
      I = rl;
      var J = b && j === R && R.visualViewport ? R.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        j[U]
      );
      _ -= J - r.height, _ *= m ? 1 : -1;
    }
    if (a === Xi || (a === Ki || a === rl) && s === X0) {
      N = ol;
      var H = b && j === R && R.visualViewport ? R.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        j[q]
      );
      E -= H - r.width, E *= m ? 1 : -1;
    }
  }
  var Z = Object.assign({
    position: p
  }, h && W1e), re = g === !0 ? Y1e({
    x: E,
    y: _
  }, Ss(n)) : {
    x: E,
    y: _
  };
  if (E = re.x, _ = re.y, m) {
    var Y;
    return Object.assign({}, Z, (Y = {}, Y[I] = D ? "0" : "", Y[N] = M ? "0" : "", Y.transform = (R.devicePixelRatio || 1) <= 1 ? "translate(" + E + "px, " + _ + "px)" : "translate3d(" + E + "px, " + _ + "px, 0)", Y));
  }
  return Object.assign({}, Z, (t = {}, t[I] = D ? _ + "px" : "", t[N] = M ? E + "px" : "", t.transform = "", t));
}
function q1e(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, a = r === void 0 ? !0 : r, s = n.adaptive, l = s === void 0 ? !0 : s, p = n.roundOffsets, m = p === void 0 ? !0 : p, h = {
    placement: Qu(t.placement),
    variation: Sy(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: a,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, nU(Object.assign({}, h, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: l,
    roundOffsets: m
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, nU(Object.assign({}, h, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: m
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const G1e = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: q1e,
  data: {}
};
var k1 = {
  passive: !0
};
function K1e(e) {
  var t = e.state, n = e.instance, r = e.options, a = r.scroll, s = a === void 0 ? !0 : a, l = r.resize, p = l === void 0 ? !0 : l, m = Ss(t.elements.popper), h = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && h.forEach(function(g) {
    g.addEventListener("scroll", n.update, k1);
  }), p && m.addEventListener("resize", n.update, k1), function() {
    s && h.forEach(function(g) {
      g.removeEventListener("scroll", n.update, k1);
    }), p && m.removeEventListener("resize", n.update, k1);
  };
}
const X1e = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: K1e,
  data: {}
};
var Q1e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function iE(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return Q1e[t];
  });
}
var Z1e = {
  start: "end",
  end: "start"
};
function rU(e) {
  return e.replace(/start|end/g, function(t) {
    return Z1e[t];
  });
}
function oN(e) {
  var t = Ss(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function aN(e) {
  return xy(Gf(e)).left + oN(e).scrollLeft;
}
function J1e(e, t) {
  var n = Ss(e), r = Gf(e), a = n.visualViewport, s = r.clientWidth, l = r.clientHeight, p = 0, m = 0;
  if (a) {
    s = a.width, l = a.height;
    var h = N9();
    (h || !h && t === "fixed") && (p = a.offsetLeft, m = a.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: p + aN(e),
    y: m
  };
}
function eEe(e) {
  var t, n = Gf(e), r = oN(e), a = (t = e.ownerDocument) == null ? void 0 : t.body, s = gm(n.scrollWidth, n.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), l = gm(n.scrollHeight, n.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), p = -r.scrollLeft + aN(e), m = -r.scrollTop;
  return sd(a || n).direction === "rtl" && (p += gm(n.clientWidth, a ? a.clientWidth : 0) - s), {
    width: s,
    height: l,
    x: p,
    y: m
  };
}
function iN(e) {
  var t = sd(e), n = t.overflow, r = t.overflowX, a = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + a + r);
}
function F9(e) {
  return ["html", "body", "#document"].indexOf(tc(e)) >= 0 ? e.ownerDocument.body : Js(e) && iN(e) ? e : F9(n_(e));
}
function $0(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = F9(e), a = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Ss(r), l = a ? [s].concat(s.visualViewport || [], iN(r) ? r : []) : r, p = t.concat(l);
  return a ? p : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    p.concat($0(n_(l)))
  );
}
function c$(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function tEe(e, t) {
  var n = xy(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function oU(e, t, n) {
  return t === $9 ? c$(J1e(e, n)) : _m(t) ? tEe(t, n) : c$(eEe(Gf(e)));
}
function nEe(e) {
  var t = $0(n_(e)), n = ["absolute", "fixed"].indexOf(sd(e).position) >= 0, r = n && Js(e) ? ww(e) : e;
  return _m(r) ? t.filter(function(a) {
    return _m(a) && I9(a, r) && tc(a) !== "body";
  }) : [];
}
function rEe(e, t, n, r) {
  var a = t === "clippingParents" ? nEe(e) : [].concat(t), s = [].concat(a, [n]), l = s[0], p = s.reduce(function(m, h) {
    var g = oU(e, h, r);
    return m.top = gm(g.top, m.top), m.right = KC(g.right, m.right), m.bottom = KC(g.bottom, m.bottom), m.left = gm(g.left, m.left), m;
  }, oU(e, l, r));
  return p.width = p.right - p.left, p.height = p.bottom - p.top, p.x = p.left, p.y = p.top, p;
}
function z9(e) {
  var t = e.reference, n = e.element, r = e.placement, a = r ? Qu(r) : null, s = r ? Sy(r) : null, l = t.x + t.width / 2 - n.width / 2, p = t.y + t.height / 2 - n.height / 2, m;
  switch (a) {
    case Ki:
      m = {
        x: l,
        y: t.y - n.height
      };
      break;
    case rl:
      m = {
        x: l,
        y: t.y + t.height
      };
      break;
    case ol:
      m = {
        x: t.x + t.width,
        y: p
      };
      break;
    case Xi:
      m = {
        x: t.x - n.width,
        y: p
      };
      break;
    default:
      m = {
        x: t.x,
        y: t.y
      };
  }
  var h = a ? rN(a) : null;
  if (h != null) {
    var g = h === "y" ? "height" : "width";
    switch (s) {
      case by:
        m[h] = m[h] - (t[g] / 2 - n[g] / 2);
        break;
      case X0:
        m[h] = m[h] + (t[g] / 2 - n[g] / 2);
        break;
    }
  }
  return m;
}
function Q0(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, a = r === void 0 ? e.placement : r, s = n.strategy, l = s === void 0 ? e.strategy : s, p = n.boundary, m = p === void 0 ? E1e : p, h = n.rootBoundary, g = h === void 0 ? $9 : h, b = n.elementContext, x = b === void 0 ? s0 : b, E = n.altBoundary, O = E === void 0 ? !1 : E, _ = n.padding, P = _ === void 0 ? 0 : _, M = j9(typeof P != "number" ? P : L9(P, bw)), D = x === s0 ? C1e : s0, N = e.rects.popper, I = e.elements[O ? D : x], R = rEe(_m(I) ? I : I.contextElement || Gf(e.elements.popper), m, g, l), j = xy(e.elements.reference), U = z9({
    reference: j,
    element: N,
    strategy: "absolute",
    placement: a
  }), q = c$(Object.assign({}, N, U)), J = x === s0 ? q : j, H = {
    top: R.top - J.top + M.top,
    bottom: J.bottom - R.bottom + M.bottom,
    left: R.left - J.left + M.left,
    right: J.right - R.right + M.right
  }, Z = e.modifiersData.offset;
  if (x === s0 && Z) {
    var re = Z[a];
    Object.keys(H).forEach(function(Y) {
      var K = [ol, rl].indexOf(Y) >= 0 ? 1 : -1, Q = [Ki, rl].indexOf(Y) >= 0 ? "y" : "x";
      H[Y] += re[Q] * K;
    });
  }
  return H;
}
function oEe(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, a = n.boundary, s = n.rootBoundary, l = n.padding, p = n.flipVariations, m = n.allowedAutoPlacements, h = m === void 0 ? M9 : m, g = Sy(r), b = g ? p ? eU : eU.filter(function(O) {
    return Sy(O) === g;
  }) : bw, x = b.filter(function(O) {
    return h.indexOf(O) >= 0;
  });
  x.length === 0 && (x = b);
  var E = x.reduce(function(O, _) {
    return O[_] = Q0(e, {
      placement: _,
      boundary: a,
      rootBoundary: s,
      padding: l
    })[Qu(_)], O;
  }, {});
  return Object.keys(E).sort(function(O, _) {
    return E[O] - E[_];
  });
}
function aEe(e) {
  if (Qu(e) === eN)
    return [];
  var t = iE(e);
  return [rU(e), t, rU(t)];
}
function iEe(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var a = n.mainAxis, s = a === void 0 ? !0 : a, l = n.altAxis, p = l === void 0 ? !0 : l, m = n.fallbackPlacements, h = n.padding, g = n.boundary, b = n.rootBoundary, x = n.altBoundary, E = n.flipVariations, O = E === void 0 ? !0 : E, _ = n.allowedAutoPlacements, P = t.options.placement, M = Qu(P), D = M === P, N = m || (D || !O ? [iE(P)] : aEe(P)), I = [P].concat(N).reduce(function(fe, Ce) {
      return fe.concat(Qu(Ce) === eN ? oEe(t, {
        placement: Ce,
        boundary: g,
        rootBoundary: b,
        padding: h,
        flipVariations: O,
        allowedAutoPlacements: _
      }) : Ce);
    }, []), R = t.rects.reference, j = t.rects.popper, U = /* @__PURE__ */ new Map(), q = !0, J = I[0], H = 0; H < I.length; H++) {
      var Z = I[H], re = Qu(Z), Y = Sy(Z) === by, K = [Ki, rl].indexOf(re) >= 0, Q = K ? "width" : "height", te = Q0(t, {
        placement: Z,
        boundary: g,
        rootBoundary: b,
        altBoundary: x,
        padding: h
      }), ne = K ? Y ? ol : Xi : Y ? rl : Ki;
      R[Q] > j[Q] && (ne = iE(ne));
      var ae = iE(ne), se = [];
      if (s && se.push(te[re] <= 0), p && se.push(te[ne] <= 0, te[ae] <= 0), se.every(function(fe) {
        return fe;
      })) {
        J = Z, q = !1;
        break;
      }
      U.set(Z, se);
    }
    if (q)
      for (var V = O ? 3 : 1, ee = function(Ce) {
        var Se = I.find(function(Te) {
          var pe = U.get(Te);
          if (pe)
            return pe.slice(0, Ce).every(function(ye) {
              return ye;
            });
        });
        if (Se)
          return J = Se, "break";
      }, he = V; he > 0; he--) {
        var ue = ee(he);
        if (ue === "break")
          break;
      }
    t.placement !== J && (t.modifiersData[r]._skip = !0, t.placement = J, t.reset = !0);
  }
}
const sEe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: iEe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function aU(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function iU(e) {
  return [Ki, ol, rl, Xi].some(function(t) {
    return e[t] >= 0;
  });
}
function lEe(e) {
  var t = e.state, n = e.name, r = t.rects.reference, a = t.rects.popper, s = t.modifiersData.preventOverflow, l = Q0(t, {
    elementContext: "reference"
  }), p = Q0(t, {
    altBoundary: !0
  }), m = aU(l, r), h = aU(p, a, s), g = iU(m), b = iU(h);
  t.modifiersData[n] = {
    referenceClippingOffsets: m,
    popperEscapeOffsets: h,
    isReferenceHidden: g,
    hasPopperEscaped: b
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": g,
    "data-popper-escaped": b
  });
}
const uEe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: lEe
};
function cEe(e, t, n) {
  var r = Qu(e), a = [Xi, Ki].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, l = s[0], p = s[1];
  return l = l || 0, p = (p || 0) * a, [Xi, ol].indexOf(r) >= 0 ? {
    x: p,
    y: l
  } : {
    x: l,
    y: p
  };
}
function dEe(e) {
  var t = e.state, n = e.options, r = e.name, a = n.offset, s = a === void 0 ? [0, 0] : a, l = M9.reduce(function(g, b) {
    return g[b] = cEe(b, t.rects, s), g;
  }, {}), p = l[t.placement], m = p.x, h = p.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += m, t.modifiersData.popperOffsets.y += h), t.modifiersData[r] = l;
}
const fEe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: dEe
};
function pEe(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = z9({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const mEe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: pEe,
  data: {}
};
function hEe(e) {
  return e === "x" ? "y" : "x";
}
function vEe(e) {
  var t = e.state, n = e.options, r = e.name, a = n.mainAxis, s = a === void 0 ? !0 : a, l = n.altAxis, p = l === void 0 ? !1 : l, m = n.boundary, h = n.rootBoundary, g = n.altBoundary, b = n.padding, x = n.tether, E = x === void 0 ? !0 : x, O = n.tetherOffset, _ = O === void 0 ? 0 : O, P = Q0(t, {
    boundary: m,
    rootBoundary: h,
    padding: b,
    altBoundary: g
  }), M = Qu(t.placement), D = Sy(t.placement), N = !D, I = rN(M), R = hEe(I), j = t.modifiersData.popperOffsets, U = t.rects.reference, q = t.rects.popper, J = typeof _ == "function" ? _(Object.assign({}, t.rects, {
    placement: t.placement
  })) : _, H = typeof J == "number" ? {
    mainAxis: J,
    altAxis: J
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, J), Z = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, re = {
    x: 0,
    y: 0
  };
  if (j) {
    if (s) {
      var Y, K = I === "y" ? Ki : Xi, Q = I === "y" ? rl : ol, te = I === "y" ? "height" : "width", ne = j[I], ae = ne + P[K], se = ne - P[Q], V = E ? -q[te] / 2 : 0, ee = D === by ? U[te] : q[te], he = D === by ? -q[te] : -U[te], ue = t.elements.arrow, fe = E && ue ? nN(ue) : {
        width: 0,
        height: 0
      }, Ce = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : A9(), Se = Ce[K], Te = Ce[Q], pe = D0(0, U[te], fe[te]), ye = N ? U[te] / 2 - V - pe - Se - H.mainAxis : ee - pe - Se - H.mainAxis, Oe = N ? -U[te] / 2 + V + pe + Te + H.mainAxis : he + pe + Te + H.mainAxis, Fe = t.elements.arrow && ww(t.elements.arrow), me = Fe ? I === "y" ? Fe.clientTop || 0 : Fe.clientLeft || 0 : 0, Pe = (Y = Z == null ? void 0 : Z[I]) != null ? Y : 0, Ee = ne + ye - Pe - me, Ke = ne + Oe - Pe, oe = D0(E ? KC(ae, Ee) : ae, ne, E ? gm(se, Ke) : se);
      j[I] = oe, re[I] = oe - ne;
    }
    if (p) {
      var de, we = I === "x" ? Ki : Xi, Me = I === "x" ? rl : ol, Ae = j[R], je = R === "y" ? "height" : "width", qe = Ae + P[we], ot = Ae - P[Me], et = [Ki, Xi].indexOf(M) !== -1, ct = (de = Z == null ? void 0 : Z[R]) != null ? de : 0, Qt = et ? qe : Ae - U[je] - q[je] - ct + H.altAxis, Ht = et ? Ae + U[je] + q[je] - ct - H.altAxis : ot, kt = E && et ? z1e(Qt, Ae, Ht) : D0(E ? Qt : qe, Ae, E ? Ht : ot);
      j[R] = kt, re[R] = kt - Ae;
    }
    t.modifiersData[r] = re;
  }
}
const yEe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: vEe,
  requiresIfExists: ["offset"]
};
function gEe(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function bEe(e) {
  return e === Ss(e) || !Js(e) ? oN(e) : gEe(e);
}
function wEe(e) {
  var t = e.getBoundingClientRect(), n = wy(t.width) / e.offsetWidth || 1, r = wy(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function xEe(e, t, n) {
  n === void 0 && (n = !1);
  var r = Js(t), a = Js(t) && wEe(t), s = Gf(t), l = xy(e, a, n), p = {
    scrollLeft: 0,
    scrollTop: 0
  }, m = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((tc(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  iN(s)) && (p = bEe(t)), Js(t) ? (m = xy(t, !0), m.x += t.clientLeft, m.y += t.clientTop) : s && (m.x = aN(s))), {
    x: l.left + p.scrollLeft - m.x,
    y: l.top + p.scrollTop - m.y,
    width: l.width,
    height: l.height
  };
}
function SEe(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function a(s) {
    n.add(s.name);
    var l = [].concat(s.requires || [], s.requiresIfExists || []);
    l.forEach(function(p) {
      if (!n.has(p)) {
        var m = t.get(p);
        m && a(m);
      }
    }), r.push(s);
  }
  return e.forEach(function(s) {
    n.has(s.name) || a(s);
  }), r;
}
function EEe(e) {
  var t = SEe(e);
  return N1e.reduce(function(n, r) {
    return n.concat(t.filter(function(a) {
      return a.phase === r;
    }));
  }, []);
}
function CEe(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function TEe(e) {
  var t = e.reduce(function(n, r) {
    var a = n[r.name];
    return n[r.name] = a ? Object.assign({}, a, r, {
      options: Object.assign({}, a.options, r.options),
      data: Object.assign({}, a.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var sU = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function lU() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function _Ee(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, a = t.defaultOptions, s = a === void 0 ? sU : a;
  return function(p, m, h) {
    h === void 0 && (h = s);
    var g = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, sU, s),
      modifiersData: {},
      elements: {
        reference: p,
        popper: m
      },
      attributes: {},
      styles: {}
    }, b = [], x = !1, E = {
      state: g,
      setOptions: function(M) {
        var D = typeof M == "function" ? M(g.options) : M;
        _(), g.options = Object.assign({}, s, g.options, D), g.scrollParents = {
          reference: _m(p) ? $0(p) : p.contextElement ? $0(p.contextElement) : [],
          popper: $0(m)
        };
        var N = EEe(TEe([].concat(r, g.options.modifiers)));
        return g.orderedModifiers = N.filter(function(I) {
          return I.enabled;
        }), O(), E.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!x) {
          var M = g.elements, D = M.reference, N = M.popper;
          if (lU(D, N)) {
            g.rects = {
              reference: xEe(D, ww(N), g.options.strategy === "fixed"),
              popper: nN(N)
            }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function(H) {
              return g.modifiersData[H.name] = Object.assign({}, H.data);
            });
            for (var I = 0; I < g.orderedModifiers.length; I++) {
              if (g.reset === !0) {
                g.reset = !1, I = -1;
                continue;
              }
              var R = g.orderedModifiers[I], j = R.fn, U = R.options, q = U === void 0 ? {} : U, J = R.name;
              typeof j == "function" && (g = j({
                state: g,
                options: q,
                name: J,
                instance: E
              }) || g);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: CEe(function() {
        return new Promise(function(P) {
          E.forceUpdate(), P(g);
        });
      }),
      destroy: function() {
        _(), x = !0;
      }
    };
    if (!lU(p, m))
      return E;
    E.setOptions(h).then(function(P) {
      !x && h.onFirstUpdate && h.onFirstUpdate(P);
    });
    function O() {
      g.orderedModifiers.forEach(function(P) {
        var M = P.name, D = P.options, N = D === void 0 ? {} : D, I = P.effect;
        if (typeof I == "function") {
          var R = I({
            state: g,
            name: M,
            instance: E,
            options: N
          }), j = function() {
          };
          b.push(R || j);
        }
      });
    }
    function _() {
      b.forEach(function(P) {
        return P();
      }), b = [];
    }
    return E;
  };
}
var OEe = [X1e, mEe, G1e, j1e, fEe, sEe, yEe, H1e, uEe], PEe = /* @__PURE__ */ _Ee({
  defaultModifiers: OEe
});
function REe(e) {
  return typeof e == "function" ? e() : e;
}
const XC = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    children: r,
    container: a,
    disablePortal: s = !1
  } = t, [l, p] = C.useState(null), m = yo(/* @__PURE__ */ C.isValidElement(r) ? r.ref : null, n);
  if (ei(() => {
    s || p(REe(a) || document.body);
  }, [a, s]), ei(() => {
    if (l && !s)
      return OD(n, l), () => {
        OD(n, null);
      };
  }, [n, l, s]), s) {
    if (/* @__PURE__ */ C.isValidElement(r)) {
      const h = {
        ref: m
      };
      return /* @__PURE__ */ C.cloneElement(r, h);
    }
    return /* @__PURE__ */ L.jsx(C.Fragment, {
      children: r
    });
  }
  return /* @__PURE__ */ L.jsx(C.Fragment, {
    children: l && /* @__PURE__ */ Py.createPortal(r, l)
  });
});
process.env.NODE_ENV !== "production" && (XC.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The children to render into the `container`.
   */
  children: c.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: c.bool
});
process.env.NODE_ENV !== "production" && (XC["propTypes"] = dT(XC.propTypes));
const V9 = XC;
function kEe(e) {
  return Xt("MuiPopper", e);
}
Bt("MuiPopper", ["root"]);
const DEe = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], $Ee = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function MEe(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function QC(e) {
  return typeof e == "function" ? e() : e;
}
function r_(e) {
  return e.nodeType !== void 0;
}
function NEe(e) {
  return !r_(e);
}
const IEe = () => Kt({
  root: ["root"]
}, b9(kEe)), AEe = {}, jEe = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r;
  const {
    anchorEl: a,
    children: s,
    direction: l,
    disablePortal: p,
    modifiers: m,
    open: h,
    placement: g,
    popperOptions: b,
    popperRef: x,
    slotProps: E = {},
    slots: O = {},
    TransitionProps: _
    // @ts-ignore internal logic
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
  } = t, P = st(t, DEe), M = C.useRef(null), D = yo(M, n), N = C.useRef(null), I = yo(N, x), R = C.useRef(I);
  ei(() => {
    R.current = I;
  }, [I]), C.useImperativeHandle(x, () => N.current, []);
  const j = MEe(g, l), [U, q] = C.useState(j), [J, H] = C.useState(QC(a));
  C.useEffect(() => {
    N.current && N.current.forceUpdate();
  }), C.useEffect(() => {
    a && H(QC(a));
  }, [a]), ei(() => {
    if (!J || !h)
      return;
    const Q = (ae) => {
      q(ae.placement);
    };
    if (process.env.NODE_ENV !== "production" && J && r_(J) && J.nodeType === 1) {
      const ae = J.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && ae.top === 0 && ae.left === 0 && ae.right === 0 && ae.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let te = [{
      name: "preventOverflow",
      options: {
        altBoundary: p
      }
    }, {
      name: "flip",
      options: {
        altBoundary: p
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: ae
      }) => {
        Q(ae);
      }
    }];
    m != null && (te = te.concat(m)), b && b.modifiers != null && (te = te.concat(b.modifiers));
    const ne = PEe(J, M.current, B({
      placement: j
    }, b, {
      modifiers: te
    }));
    return R.current(ne), () => {
      ne.destroy(), R.current(null);
    };
  }, [J, p, m, h, b, j]);
  const Z = {
    placement: U
  };
  _ !== null && (Z.TransitionProps = _);
  const re = IEe(), Y = (r = O.root) != null ? r : "div", K = Gr({
    elementType: Y,
    externalSlotProps: E.root,
    externalForwardedProps: P,
    additionalProps: {
      role: "tooltip",
      ref: D
    },
    ownerState: t,
    className: re.root
  });
  return /* @__PURE__ */ L.jsx(Y, B({}, K, {
    children: typeof s == "function" ? s(Z) : s
  }));
}), U9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: a,
    container: s,
    direction: l = "ltr",
    disablePortal: p = !1,
    keepMounted: m = !1,
    modifiers: h,
    open: g,
    placement: b = "bottom",
    popperOptions: x = AEe,
    popperRef: E,
    style: O,
    transition: _ = !1,
    slotProps: P = {},
    slots: M = {}
  } = t, D = st(t, $Ee), [N, I] = C.useState(!0), R = () => {
    I(!1);
  }, j = () => {
    I(!0);
  };
  if (!m && !g && (!_ || N))
    return null;
  let U;
  if (s)
    U = s;
  else if (r) {
    const H = QC(r);
    U = H && r_(H) ? aa(H).body : aa(null).body;
  }
  const q = !g && m && (!_ || N) ? "none" : void 0, J = _ ? {
    in: g,
    onEnter: R,
    onExited: j
  } : void 0;
  return /* @__PURE__ */ L.jsx(V9, {
    disablePortal: p,
    container: U,
    children: /* @__PURE__ */ L.jsx(jEe, B({
      anchorEl: r,
      direction: l,
      disablePortal: p,
      modifiers: h,
      ref: n,
      open: _ ? !N : g,
      placement: b,
      popperOptions: x,
      popperRef: E,
      slotProps: P,
      slots: M
    }, D, {
      style: B({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: q
      }, O),
      TransitionProps: J,
      children: a
    }))
  });
});
process.env.NODE_ENV !== "production" && (U9.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: cd(c.oneOfType([Zu, c.object, c.func]), (e) => {
    if (e.open) {
      const t = QC(e.anchorEl);
      if (t && r_(t) && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || NEe(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: c.oneOfType([c.node, c.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: c.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: c.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: c.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: c.arrayOf(c.shape({
    data: c.object,
    effect: c.func,
    enabled: c.bool,
    fn: c.func,
    name: c.any,
    options: c.object,
    phase: c.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: c.arrayOf(c.string),
    requiresIfExists: c.arrayOf(c.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: c.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: c.shape({
    modifiers: c.array,
    onFirstUpdate: c.func,
    placement: c.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: c.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: il,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: c.shape({
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: c.shape({
    root: c.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: c.bool
});
const LEe = U9;
function FEe(e) {
  const t = aa(e);
  return t.body === e ? rd(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function M0(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function uU(e) {
  return parseInt(rd(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function zEe(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName) !== -1, r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r;
}
function cU(e, t, n, r, a) {
  const s = [t, n, ...r];
  [].forEach.call(e.children, (l) => {
    const p = s.indexOf(l) === -1, m = !zEe(l);
    p && m && M0(l, a);
  });
}
function Kk(e, t) {
  let n = -1;
  return e.some((r, a) => t(r) ? (n = a, !0) : !1), n;
}
function VEe(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (FEe(r)) {
      const l = g3(aa(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${uU(r) + l}px`;
      const p = aa(r).querySelectorAll(".mui-fixed");
      [].forEach.call(p, (m) => {
        n.push({
          value: m.style.paddingRight,
          property: "padding-right",
          el: m
        }), m.style.paddingRight = `${uU(m) + l}px`;
      });
    }
    let s;
    if (r.parentNode instanceof DocumentFragment)
      s = aa(r).body;
    else {
      const l = r.parentElement, p = rd(r);
      s = (l == null ? void 0 : l.nodeName) === "HTML" && p.getComputedStyle(l).overflowY === "scroll" ? l : r;
    }
    n.push({
      value: s.style.overflow,
      property: "overflow",
      el: s
    }, {
      value: s.style.overflowX,
      property: "overflow-x",
      el: s
    }, {
      value: s.style.overflowY,
      property: "overflow-y",
      el: s
    }), s.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: s,
      el: l,
      property: p
    }) => {
      s ? l.style.setProperty(p, s) : l.style.removeProperty(p);
    });
  };
}
function UEe(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class BEe {
  constructor() {
    this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && M0(t.modalRef, !1);
    const a = UEe(n);
    cU(n, t.mount, t.modalRef, a, !0);
    const s = Kk(this.containers, (l) => l.container === n);
    return s !== -1 ? (this.containers[s].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: a
    }), r);
  }
  mount(t, n) {
    const r = Kk(this.containers, (s) => s.modals.indexOf(t) !== -1), a = this.containers[r];
    a.restore || (a.restore = VEe(a, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const a = Kk(this.containers, (l) => l.modals.indexOf(t) !== -1), s = this.containers[a];
    if (s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(r, 1), s.modals.length === 0)
      s.restore && s.restore(), t.modalRef && M0(t.modalRef, n), cU(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(a, 1);
    else {
      const l = s.modals[s.modals.length - 1];
      l.modalRef && M0(l.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
function HEe(e) {
  return Xt("MuiModal", e);
}
Bt("MuiModal", ["root", "hidden", "backdrop"]);
const WEe = ["children", "closeAfterTransition", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"], YEe = (e) => {
  const {
    open: t,
    exited: n
  } = e;
  return Kt({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, b9(HEe));
};
function qEe(e) {
  return typeof e == "function" ? e() : e;
}
function GEe(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const KEe = new BEe(), B9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a;
  const {
    children: s,
    closeAfterTransition: l = !1,
    container: p,
    disableAutoFocus: m = !1,
    disableEnforceFocus: h = !1,
    disableEscapeKeyDown: g = !1,
    disablePortal: b = !1,
    disableRestoreFocus: x = !1,
    disableScrollLock: E = !1,
    hideBackdrop: O = !1,
    keepMounted: _ = !1,
    // private
    manager: P = KEe,
    onBackdropClick: M,
    onClose: D,
    onKeyDown: N,
    open: I,
    onTransitionEnter: R,
    onTransitionExited: j,
    slotProps: U = {},
    slots: q = {}
  } = t, J = st(t, WEe), H = P, [Z, re] = C.useState(!I), Y = C.useRef({}), K = C.useRef(null), Q = C.useRef(null), te = yo(Q, n), ne = GEe(s), ae = (r = t["aria-hidden"]) != null ? r : !0, se = () => aa(K.current), V = () => (Y.current.modalRef = Q.current, Y.current.mountNode = K.current, Y.current), ee = () => {
    H.mount(V(), {
      disableScrollLock: E
    }), Q.current && (Q.current.scrollTop = 0);
  }, he = Zr(() => {
    const de = qEe(p) || se().body;
    H.add(V(), de), Q.current && ee();
  }), ue = C.useCallback(() => H.isTopModal(V()), [H]), fe = Zr((de) => {
    K.current = de, !(!de || !Q.current) && (I && ue() ? ee() : M0(Q.current, ae));
  }), Ce = C.useCallback(() => {
    H.remove(V(), ae);
  }, [H, ae]);
  C.useEffect(() => () => {
    Ce();
  }, [Ce]), C.useEffect(() => {
    I ? he() : (!ne || !l) && Ce();
  }, [I, Ce, ne, l, he]);
  const Se = B({}, t, {
    closeAfterTransition: l,
    disableAutoFocus: m,
    disableEnforceFocus: h,
    disableEscapeKeyDown: g,
    disablePortal: b,
    disableRestoreFocus: x,
    disableScrollLock: E,
    exited: Z,
    hideBackdrop: O,
    keepMounted: _
  }), Te = YEe(Se), pe = () => {
    re(!1), R && R();
  }, ye = () => {
    re(!0), j && j(), l && Ce();
  }, Oe = (de) => {
    de.target === de.currentTarget && (M && M(de), D && D(de, "backdropClick"));
  }, Fe = (de) => {
    N && N(de), !(de.key !== "Escape" || !ue()) && (g || (de.stopPropagation(), D && D(de, "escapeKeyDown")));
  }, me = {};
  s.props.tabIndex === void 0 && (me.tabIndex = "-1"), ne && (me.onEnter = Jj(pe, s.props.onEnter), me.onExited = Jj(ye, s.props.onExited));
  const Pe = (a = q.root) != null ? a : "div", Ee = Gr({
    elementType: Pe,
    externalSlotProps: U.root,
    externalForwardedProps: J,
    additionalProps: {
      ref: te,
      role: "presentation",
      onKeyDown: Fe
    },
    className: Te.root,
    ownerState: Se
  }), Ke = q.backdrop, oe = Gr({
    elementType: Ke,
    externalSlotProps: U.backdrop,
    additionalProps: {
      "aria-hidden": !0,
      onClick: Oe,
      open: I
    },
    className: Te.backdrop,
    ownerState: Se
  });
  return !_ && !I && (!ne || Z) ? null : /* @__PURE__ */ L.jsx(
    V9,
    {
      ref: fe,
      container: p,
      disablePortal: b,
      children: /* @__PURE__ */ L.jsxs(Pe, B({}, Ee, {
        children: [!O && Ke ? /* @__PURE__ */ L.jsx(Ke, B({}, oe)) : null, /* @__PURE__ */ L.jsx(K0, {
          disableEnforceFocus: h,
          disableAutoFocus: m,
          disableRestoreFocus: x,
          isEnabled: ue,
          open: I,
          children: /* @__PURE__ */ C.cloneElement(s, me)
        })]
      }))
    }
  );
});
process.env.NODE_ENV !== "production" && (B9.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: rw.isRequired,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: c.bool,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: c.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: c.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: c.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: c.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: c.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: c.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: c.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: c.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: c.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: c.shape({
    backdrop: c.oneOfType([c.func, c.object]),
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: c.shape({
    backdrop: c.elementType,
    root: c.elementType
  })
});
const XEe = B9, QEe = ["onChange", "maxRows", "minRows", "style", "value"];
function D1(e) {
  return parseInt(e, 10) || 0;
}
const ZEe = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function dU(e) {
  return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflow;
}
const H9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    onChange: r,
    maxRows: a,
    minRows: s = 1,
    style: l,
    value: p
  } = t, m = st(t, QEe), {
    current: h
  } = C.useRef(p != null), g = C.useRef(null), b = yo(n, g), x = C.useRef(null), E = C.useRef(0), [O, _] = C.useState({
    outerHeightStyle: 0
  }), P = C.useCallback(() => {
    const R = g.current, U = rd(R).getComputedStyle(R);
    if (U.width === "0px")
      return {
        outerHeightStyle: 0
      };
    const q = x.current;
    q.style.width = U.width, q.value = R.value || t.placeholder || "x", q.value.slice(-1) === `
` && (q.value += " ");
    const J = U.boxSizing, H = D1(U.paddingBottom) + D1(U.paddingTop), Z = D1(U.borderBottomWidth) + D1(U.borderTopWidth), re = q.scrollHeight;
    q.value = "x";
    const Y = q.scrollHeight;
    let K = re;
    s && (K = Math.max(Number(s) * Y, K)), a && (K = Math.min(Number(a) * Y, K)), K = Math.max(K, Y);
    const Q = K + (J === "border-box" ? H + Z : 0), te = Math.abs(K - re) <= 1;
    return {
      outerHeightStyle: Q,
      overflow: te
    };
  }, [a, s, t.placeholder]), M = (R, j) => {
    const {
      outerHeightStyle: U,
      overflow: q
    } = j;
    return E.current < 20 && (U > 0 && Math.abs((R.outerHeightStyle || 0) - U) > 1 || R.overflow !== q) ? (E.current += 1, {
      overflow: q,
      outerHeightStyle: U
    }) : (process.env.NODE_ENV !== "production" && E.current === 20 && console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join(`
`)), R);
  }, D = C.useCallback(() => {
    const R = P();
    dU(R) || _((j) => M(j, R));
  }, [P]), N = () => {
    const R = P();
    dU(R) || Py.flushSync(() => {
      _((j) => M(j, R));
    });
  };
  C.useEffect(() => {
    const R = ly(() => {
      E.current = 0, g.current && N();
    });
    let j;
    const U = g.current, q = rd(U);
    return q.addEventListener("resize", R), typeof ResizeObserver < "u" && (j = new ResizeObserver(R), j.observe(U)), () => {
      R.clear(), q.removeEventListener("resize", R), j && j.disconnect();
    };
  }), ei(() => {
    D();
  }), C.useEffect(() => {
    E.current = 0;
  }, [p]);
  const I = (R) => {
    E.current = 0, h || D(), r && r(R);
  };
  return /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [/* @__PURE__ */ L.jsx("textarea", B({
      value: p,
      onChange: I,
      ref: b,
      rows: s,
      style: B({
        height: O.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: O.overflow ? "hidden" : void 0
      }, l)
    }, m)), /* @__PURE__ */ L.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: x,
      tabIndex: -1,
      style: B({}, ZEe.shadow, l, {
        padding: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (H9.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  className: c.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * @ignore
   */
  onChange: c.func,
  /**
   * @ignore
   */
  placeholder: c.string,
  /**
   * @ignore
   */
  style: c.object,
  /**
   * @ignore
   */
  value: c.oneOfType([c.arrayOf(c.string), c.number, c.string])
});
const JEe = H9;
function eCe(e) {
  return Xt("MuiTypography", e);
}
Bt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const tCe = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"], nCe = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: a,
    variant: s,
    classes: l
  } = e, p = {
    root: ["root", s, e.align !== "inherit" && `align${xt(t)}`, n && "gutterBottom", r && "noWrap", a && "paragraph"]
  };
  return Kt(p, eCe, l);
}, rCe = Ge("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${xt(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  margin: 0
}, t.variant && e.typography[t.variant], t.align !== "inherit" && {
  textAlign: t.align
}, t.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, t.gutterBottom && {
  marginBottom: "0.35em"
}, t.paragraph && {
  marginBottom: 16
})), fU = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, oCe = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
}, aCe = (e) => oCe[e] || e, W9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTypography"
  }), a = aCe(r.color), s = U3(B({}, r, {
    color: a
  })), {
    align: l = "inherit",
    className: p,
    component: m,
    gutterBottom: h = !1,
    noWrap: g = !1,
    paragraph: b = !1,
    variant: x = "body1",
    variantMapping: E = fU
  } = s, O = st(s, tCe), _ = B({}, s, {
    align: l,
    color: a,
    className: p,
    component: m,
    gutterBottom: h,
    noWrap: g,
    paragraph: b,
    variant: x,
    variantMapping: E
  }), P = m || (b ? "p" : E[x] || fU[x]) || "span", M = nCe(_);
  return /* @__PURE__ */ L.jsx(rCe, B({
    as: P,
    ref: n,
    ownerState: _,
    className: Wt(M.root, p)
  }, O));
});
process.env.NODE_ENV !== "production" && (W9.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: c.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: c.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: c.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   */
  paragraph: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: c.oneOfType([c.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), c.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: c.object
});
const nc = W9;
function Y9(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = Y9(e[t])) && (r && (r += " "), r += n);
    else
      for (t in e)
        e[t] && (r && (r += " "), r += t);
  return r;
}
function Ao() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = Y9(e)) && (r && (r += " "), r += t);
  return r;
}
const q9 = /* @__PURE__ */ C.createContext();
process.env.NODE_ENV !== "production" && (q9.displayName = "GridContext");
const pU = q9;
function iCe(e) {
  return Xt("MuiGrid", e);
}
const sCe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], lCe = ["column-reverse", "column", "row-reverse", "row"], uCe = ["nowrap", "wrap-reverse", "wrap"], l0 = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], cCe = Bt("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...sCe.map((e) => `spacing-xs-${e}`),
  // direction values
  ...lCe.map((e) => `direction-xs-${e}`),
  // wrap values
  ...uCe.map((e) => `wrap-xs-${e}`),
  // grid sizes for all breakpoints
  ...l0.map((e) => `grid-xs-${e}`),
  ...l0.map((e) => `grid-sm-${e}`),
  ...l0.map((e) => `grid-md-${e}`),
  ...l0.map((e) => `grid-lg-${e}`),
  ...l0.map((e) => `grid-xl-${e}`)
]), Z0 = cCe, dCe = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function ry(e) {
  const t = parseFloat(e);
  return `${t}${String(e).replace(String(t), "") || "px"}`;
}
function fCe({
  theme: e,
  ownerState: t
}) {
  let n;
  return e.breakpoints.keys.reduce((r, a) => {
    let s = {};
    if (t[a] && (n = t[a]), !n)
      return r;
    if (n === !0)
      s = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    else if (n === "auto")
      s = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    else {
      const l = bT({
        values: t.columns,
        breakpoints: e.breakpoints.values
      }), p = typeof l == "object" ? l[a] : l;
      if (p == null)
        return r;
      const m = `${Math.round(n / p * 1e8) / 1e6}%`;
      let h = {};
      if (t.container && t.item && t.columnSpacing !== 0) {
        const g = e.spacing(t.columnSpacing);
        if (g !== "0px") {
          const b = `calc(${m} + ${ry(g)})`;
          h = {
            flexBasis: b,
            maxWidth: b
          };
        }
      }
      s = B({
        flexBasis: m,
        flexGrow: 0,
        maxWidth: m
      }, h);
    }
    return e.breakpoints.values[a] === 0 ? Object.assign(r, s) : r[e.breakpoints.up(a)] = s, r;
  }, {});
}
function pCe({
  theme: e,
  ownerState: t
}) {
  const n = bT({
    values: t.direction,
    breakpoints: e.breakpoints.values
  });
  return nl({
    theme: e
  }, n, (r) => {
    const a = {
      flexDirection: r
    };
    return r.indexOf("column") === 0 && (a[`& > .${Z0.item}`] = {
      maxWidth: "none"
    }), a;
  });
}
function G9({
  breakpoints: e,
  values: t
}) {
  let n = "";
  Object.keys(t).forEach((a) => {
    n === "" && t[a] !== 0 && (n = a);
  });
  const r = Object.keys(e).sort((a, s) => e[a] - e[s]);
  return r.slice(0, r.indexOf(n));
}
function mCe({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    rowSpacing: r
  } = t;
  let a = {};
  if (n && r !== 0) {
    const s = bT({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let l;
    typeof s == "object" && (l = G9({
      breakpoints: e.breakpoints.values,
      values: s
    })), a = nl({
      theme: e
    }, s, (p, m) => {
      var h;
      const g = e.spacing(p);
      return g !== "0px" ? {
        marginTop: `-${ry(g)}`,
        [`& > .${Z0.item}`]: {
          paddingTop: ry(g)
        }
      } : (h = l) != null && h.includes(m) ? {} : {
        marginTop: 0,
        [`& > .${Z0.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return a;
}
function hCe({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    columnSpacing: r
  } = t;
  let a = {};
  if (n && r !== 0) {
    const s = bT({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let l;
    typeof s == "object" && (l = G9({
      breakpoints: e.breakpoints.values,
      values: s
    })), a = nl({
      theme: e
    }, s, (p, m) => {
      var h;
      const g = e.spacing(p);
      return g !== "0px" ? {
        width: `calc(100% + ${ry(g)})`,
        marginLeft: `-${ry(g)}`,
        [`& > .${Z0.item}`]: {
          paddingLeft: ry(g)
        }
      } : (h = l) != null && h.includes(m) ? {} : {
        width: "100%",
        marginLeft: 0,
        [`& > .${Z0.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return a;
}
function vCe(e, t, n = {}) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [n[`spacing-xs-${String(e)}`]];
  const r = [];
  return t.forEach((a) => {
    const s = e[a];
    Number(s) > 0 && r.push(n[`spacing-${a}-${String(s)}`]);
  }), r;
}
const yCe = Ge("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e, {
      container: r,
      direction: a,
      item: s,
      spacing: l,
      wrap: p,
      zeroMinWidth: m,
      breakpoints: h
    } = n;
    let g = [];
    r && (g = vCe(l, h, t));
    const b = [];
    return h.forEach((x) => {
      const E = n[x];
      E && b.push(t[`grid-${x}-${String(E)}`]);
    }), [t.root, r && t.container, s && t.item, m && t.zeroMinWidth, ...g, a !== "row" && t[`direction-xs-${String(a)}`], p !== "wrap" && t[`wrap-xs-${String(p)}`], ...b];
  }
})(({
  ownerState: e
}) => B({
  boxSizing: "border-box"
}, e.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, e.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, e.zeroMinWidth && {
  minWidth: 0
}, e.wrap !== "wrap" && {
  flexWrap: e.wrap
}), pCe, mCe, hCe, fCe);
function gCe(e, t) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [`spacing-xs-${String(e)}`];
  const n = [];
  return t.forEach((r) => {
    const a = e[r];
    if (Number(a) > 0) {
      const s = `spacing-${r}-${String(a)}`;
      n.push(s);
    }
  }), n;
}
const bCe = (e) => {
  const {
    classes: t,
    container: n,
    direction: r,
    item: a,
    spacing: s,
    wrap: l,
    zeroMinWidth: p,
    breakpoints: m
  } = e;
  let h = [];
  n && (h = gCe(s, m));
  const g = [];
  m.forEach((x) => {
    const E = e[x];
    E && g.push(`grid-${x}-${String(E)}`);
  });
  const b = {
    root: ["root", n && "container", a && "item", p && "zeroMinWidth", ...h, r !== "row" && `direction-xs-${String(r)}`, l !== "wrap" && `wrap-xs-${String(l)}`, ...g]
  };
  return Kt(b, iCe, t);
}, N0 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiGrid"
  }), {
    breakpoints: a
  } = Ji(), s = U3(r), {
    className: l,
    columns: p,
    columnSpacing: m,
    component: h = "div",
    container: g = !1,
    direction: b = "row",
    item: x = !1,
    rowSpacing: E,
    spacing: O = 0,
    wrap: _ = "wrap",
    zeroMinWidth: P = !1
  } = s, M = st(s, dCe), D = E || O, N = m || O, I = C.useContext(pU), R = g ? p || 12 : I, j = {}, U = B({}, M);
  a.keys.forEach((H) => {
    M[H] != null && (j[H] = M[H], delete U[H]);
  });
  const q = B({}, s, {
    columns: R,
    container: g,
    direction: b,
    item: x,
    rowSpacing: D,
    columnSpacing: N,
    wrap: _,
    zeroMinWidth: P,
    spacing: O
  }, j, {
    breakpoints: a.keys
  }), J = bCe(q);
  return /* @__PURE__ */ L.jsx(pU.Provider, {
    value: R,
    children: /* @__PURE__ */ L.jsx(yCe, B({
      ownerState: q,
      className: Wt(J.root, l),
      as: h,
      ref: n
    }, U))
  });
});
process.env.NODE_ENV !== "production" && (N0.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The number of columns.
   * @default 12
   */
  columns: c.oneOfType([c.arrayOf(c.number), c.number, c.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: c.oneOfType([c.arrayOf(c.oneOfType([c.number, c.string])), c.number, c.object, c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: c.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: c.oneOfType([c.oneOf(["column-reverse", "column", "row-reverse", "row"]), c.arrayOf(c.oneOf(["column-reverse", "column", "row-reverse", "row"])), c.object]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: c.bool,
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: c.oneOfType([c.oneOf(["auto"]), c.number, c.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: c.oneOfType([c.oneOf(["auto"]), c.number, c.bool]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: c.oneOfType([c.arrayOf(c.oneOfType([c.number, c.string])), c.number, c.object, c.string]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: c.oneOfType([c.oneOf(["auto"]), c.number, c.bool]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: c.oneOfType([c.arrayOf(c.oneOfType([c.number, c.string])), c.number, c.object, c.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: c.oneOf(["nowrap", "wrap-reverse", "wrap"]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: c.oneOfType([c.oneOf(["auto"]), c.number, c.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: c.oneOfType([c.oneOf(["auto"]), c.number, c.bool]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: c.bool
});
if (process.env.NODE_ENV !== "production") {
  const e = Fee("Grid", N0);
  N0["propTypes"] = B({}, N0.propTypes, {
    direction: e("container"),
    lg: e("item"),
    md: e("item"),
    sm: e("item"),
    spacing: e("container"),
    wrap: e("container"),
    xs: e("item"),
    zeroMinWidth: e("item")
  });
}
const wCe = N0;
function K9(e) {
  return Xt("MuiPickersToolbar", e);
}
const xCe = Bt("MuiPickersToolbar", ["root", "content", "penIconButton", "penIconButtonLandscape"]), SCe = (e) => {
  const {
    classes: t,
    isLandscape: n
  } = e;
  return Kt({
    root: ["root"],
    content: ["content"],
    penIconButton: ["penIconButton", n && "penIconButtonLandscape"]
  }, K9, t);
}, ECe = Ge("div", {
  name: "MuiPickersToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "space-between",
  padding: e.spacing(2, 3)
}, t.isLandscape && {
  height: "auto",
  maxWidth: 160,
  padding: 16,
  justifyContent: "flex-start",
  flexWrap: "wrap"
})), CCe = Ge(wCe, {
  name: "MuiPickersToolbar",
  slot: "Content",
  overridesResolver: (e, t) => t.content
})(({
  ownerState: e
}) => B({
  flex: 1
}, !e.isLandscape && {
  alignItems: "center"
})), X9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiPickersToolbar"
  }), {
    children: a,
    className: s,
    isLandscape: l,
    landscapeDirection: p = "column",
    toolbarTitle: m,
    hidden: h,
    titleId: g
  } = r, b = r, x = SCe(b);
  return h ? null : /* @__PURE__ */ L.jsxs(ECe, {
    ref: n,
    className: Ao(x.root, s),
    ownerState: b,
    children: [/* @__PURE__ */ L.jsx(nc, {
      color: "text.secondary",
      variant: "overline",
      id: g,
      children: m
    }), /* @__PURE__ */ L.jsx(CCe, {
      container: !0,
      justifyContent: l ? "flex-start" : "space-between",
      className: x.content,
      ownerState: b,
      direction: l ? p : "row",
      alignItems: l ? "flex-start" : "flex-end",
      children: a
    })]
  });
});
function TCe(e) {
  return Xt("MuiDatePickerToolbar", e);
}
Bt("MuiDatePickerToolbar", ["root", "title"]);
const _Ce = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views"], OCe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    title: ["title"]
  }, TCe, t);
}, PCe = Ge(X9, {
  name: "MuiDatePickerToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), RCe = Ge(nc, {
  name: "MuiDatePickerToolbar",
  slot: "Title",
  overridesResolver: (e, t) => t.title
})(({
  ownerState: e
}) => B({}, e.isLandscape && {
  margin: "auto 16px auto auto"
})), Q9 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDatePickerToolbar"
  }), {
    value: a,
    isLandscape: s,
    toolbarFormat: l,
    toolbarPlaceholder: p = "––",
    views: m
  } = r, h = st(r, _Ce), g = or(), b = es(), x = OCe(r), E = C.useMemo(() => {
    if (!a)
      return p;
    const _ = q0(g, {
      format: l,
      views: m
    }, !0);
    return g.formatByString(a, _);
  }, [a, l, p, g, m]), O = r;
  return /* @__PURE__ */ L.jsx(PCe, B({
    ref: n,
    toolbarTitle: b.datePickerToolbarTitle,
    isLandscape: s,
    className: x.root
  }, h, {
    children: /* @__PURE__ */ L.jsx(RCe, {
      variant: "h4",
      align: s ? "left" : "center",
      ownerState: O,
      className: x.title,
      children: E
    })
  }));
});
process.env.NODE_ENV !== "production" && (Q9.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  classes: c.object,
  /**
   * className applied to the root component.
   */
  className: c.string,
  disabled: c.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: c.bool,
  isLandscape: c.bool.isRequired,
  onChange: c.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: c.func.isRequired,
  readOnly: c.bool,
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  titleId: c.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: c.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: c.node,
  value: c.any,
  /**
   * Currently visible picker view.
   */
  view: c.oneOf(["day", "month", "year"]).isRequired,
  views: c.arrayOf(c.oneOf(["day", "month", "year"]).isRequired).isRequired
});
const o_ = (e) => {
  if (e !== void 0)
    return Object.keys(e).reduce((t, n) => B({}, t, {
      [`${n.slice(0, 1).toLowerCase()}${n.slice(1)}`]: e[n]
    }), {});
};
function Z9(e, t) {
  var n, r, a, s;
  const l = or(), p = Am(), m = Lt({
    props: e,
    name: t
  }), h = C.useMemo(() => {
    var b;
    return ((b = m.localeText) == null ? void 0 : b.toolbarTitle) == null ? m.localeText : B({}, m.localeText, {
      datePickerToolbarTitle: m.localeText.toolbarTitle
    });
  }, [m.localeText]), g = (n = m.slots) != null ? n : o_(m.components);
  return B({}, m, {
    localeText: h
  }, x9({
    views: m.views,
    openTo: m.openTo,
    defaultViews: ["year", "day"],
    defaultOpenTo: "day"
  }), {
    disableFuture: (r = m.disableFuture) != null ? r : !1,
    disablePast: (a = m.disablePast) != null ? a : !1,
    minDate: ni(l, m.minDate, p.minDate),
    maxDate: ni(l, m.maxDate, p.maxDate),
    slots: B({
      toolbar: Q9
    }, g),
    slotProps: (s = m.slotProps) != null ? s : m.componentsProps
  });
}
function sN(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, HC(e, t);
}
function kCe(e, t) {
  return e.classList ? !!t && e.classList.contains(t) : (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") !== -1;
}
function DCe(e, t) {
  e.classList ? e.classList.add(t) : kCe(e, t) || (typeof e.className == "string" ? e.className = e.className + " " + t : e.setAttribute("class", (e.className && e.className.baseVal || "") + " " + t));
}
function mU(e, t) {
  return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function $Ce(e, t) {
  e.classList ? e.classList.remove(t) : typeof e.className == "string" ? e.className = mU(e.className, t) : e.setAttribute("class", mU(e.className && e.className.baseVal || "", t));
}
const hU = {
  disabled: !1
};
var MCe = process.env.NODE_ENV !== "production" ? c.oneOfType([c.number, c.shape({
  enter: c.number,
  exit: c.number,
  appear: c.number
}).isRequired]) : null, NCe = process.env.NODE_ENV !== "production" ? c.oneOfType([c.string, c.shape({
  enter: c.string,
  exit: c.string,
  active: c.string
}), c.shape({
  enter: c.string,
  enterDone: c.string,
  enterActive: c.string,
  exit: c.string,
  exitDone: c.string,
  exitActive: c.string
})]) : null;
const ZC = le.createContext(null);
var J9 = function(t) {
  return t.scrollTop;
}, b0 = "unmounted", sm = "exited", lm = "entering", zv = "entered", d$ = "exiting", hd = /* @__PURE__ */ function(e) {
  sN(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = a, p = l && !l.isMounting ? r.enter : r.appear, m;
    return s.appearStatus = null, r.in ? p ? (m = sm, s.appearStatus = lm) : m = zv : r.unmountOnExit || r.mountOnEnter ? m = b0 : m = sm, s.state = {
      status: m
    }, s.nextCallback = null, s;
  }
  t.getDerivedStateFromProps = function(a, s) {
    var l = a.in;
    return l && s.status === b0 ? {
      status: sm
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(a) {
    var s = null;
    if (a !== this.props) {
      var l = this.state.status;
      this.props.in ? l !== lm && l !== zv && (s = lm) : (l === lm || l === zv) && (s = d$);
    }
    this.updateStatus(!1, s);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var a = this.props.timeout, s, l, p;
    return s = l = p = a, a != null && typeof a != "number" && (s = a.exit, l = a.enter, p = a.appear !== void 0 ? a.appear : l), {
      exit: s,
      enter: l,
      appear: p
    };
  }, n.updateStatus = function(a, s) {
    if (a === void 0 && (a = !1), s !== null)
      if (this.cancelNextCallback(), s === lm) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var l = this.props.nodeRef ? this.props.nodeRef.current : h1.findDOMNode(this);
          l && J9(l);
        }
        this.performEnter(a);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === sm && this.setState({
        status: b0
      });
  }, n.performEnter = function(a) {
    var s = this, l = this.props.enter, p = this.context ? this.context.isMounting : a, m = this.props.nodeRef ? [p] : [h1.findDOMNode(this), p], h = m[0], g = m[1], b = this.getTimeouts(), x = p ? b.appear : b.enter;
    if (!a && !l || hU.disabled) {
      this.safeSetState({
        status: zv
      }, function() {
        s.props.onEntered(h);
      });
      return;
    }
    this.props.onEnter(h, g), this.safeSetState({
      status: lm
    }, function() {
      s.props.onEntering(h, g), s.onTransitionEnd(x, function() {
        s.safeSetState({
          status: zv
        }, function() {
          s.props.onEntered(h, g);
        });
      });
    });
  }, n.performExit = function() {
    var a = this, s = this.props.exit, l = this.getTimeouts(), p = this.props.nodeRef ? void 0 : h1.findDOMNode(this);
    if (!s || hU.disabled) {
      this.safeSetState({
        status: sm
      }, function() {
        a.props.onExited(p);
      });
      return;
    }
    this.props.onExit(p), this.safeSetState({
      status: d$
    }, function() {
      a.props.onExiting(p), a.onTransitionEnd(l.exit, function() {
        a.safeSetState({
          status: sm
        }, function() {
          a.props.onExited(p);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(a, s) {
    s = this.setNextCallback(s), this.setState(a, s);
  }, n.setNextCallback = function(a) {
    var s = this, l = !0;
    return this.nextCallback = function(p) {
      l && (l = !1, s.nextCallback = null, a(p));
    }, this.nextCallback.cancel = function() {
      l = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(a, s) {
    this.setNextCallback(s);
    var l = this.props.nodeRef ? this.props.nodeRef.current : h1.findDOMNode(this), p = a == null && !this.props.addEndListener;
    if (!l || p) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var m = this.props.nodeRef ? [this.nextCallback] : [l, this.nextCallback], h = m[0], g = m[1];
      this.props.addEndListener(h, g);
    }
    a != null && setTimeout(this.nextCallback, a);
  }, n.render = function() {
    var a = this.state.status;
    if (a === b0)
      return null;
    var s = this.props, l = s.children;
    s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef;
    var p = st(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ le.createElement(ZC.Provider, {
        value: null
      }, typeof l == "function" ? l(a, p) : le.cloneElement(le.Children.only(l), p))
    );
  }, t;
}(le.Component);
hd.contextType = ZC;
hd.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: c.shape({
    current: typeof Element > "u" ? c.any : function(e, t, n, r, a, s) {
      var l = e[t];
      return c.instanceOf(l && "ownerDocument" in l ? l.ownerDocument.defaultView.Element : Element)(e, t, n, r, a, s);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: c.oneOfType([c.func.isRequired, c.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: c.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: c.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: c.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: c.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: c.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: c.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var n = MCe;
    t.addEndListener || (n = n.isRequired);
    for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
      a[s - 1] = arguments[s];
    return n.apply(void 0, [t].concat(a));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: c.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: c.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: c.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: c.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: c.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: c.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: c.func
} : {};
function Iv() {
}
hd.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Iv,
  onEntering: Iv,
  onEntered: Iv,
  onExit: Iv,
  onExiting: Iv,
  onExited: Iv
};
hd.UNMOUNTED = b0;
hd.EXITED = sm;
hd.ENTERING = lm;
hd.ENTERED = zv;
hd.EXITING = d$;
const a_ = hd;
var ICe = function(t, n) {
  return t && n && n.split(" ").forEach(function(r) {
    return DCe(t, r);
  });
}, Xk = function(t, n) {
  return t && n && n.split(" ").forEach(function(r) {
    return $Ce(t, r);
  });
}, lN = /* @__PURE__ */ function(e) {
  sN(t, e);
  function t() {
    for (var r, a = arguments.length, s = new Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return r = e.call.apply(e, [this].concat(s)) || this, r.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, r.onEnter = function(p, m) {
      var h = r.resolveArguments(p, m), g = h[0], b = h[1];
      r.removeClasses(g, "exit"), r.addClass(g, b ? "appear" : "enter", "base"), r.props.onEnter && r.props.onEnter(p, m);
    }, r.onEntering = function(p, m) {
      var h = r.resolveArguments(p, m), g = h[0], b = h[1], x = b ? "appear" : "enter";
      r.addClass(g, x, "active"), r.props.onEntering && r.props.onEntering(p, m);
    }, r.onEntered = function(p, m) {
      var h = r.resolveArguments(p, m), g = h[0], b = h[1], x = b ? "appear" : "enter";
      r.removeClasses(g, x), r.addClass(g, x, "done"), r.props.onEntered && r.props.onEntered(p, m);
    }, r.onExit = function(p) {
      var m = r.resolveArguments(p), h = m[0];
      r.removeClasses(h, "appear"), r.removeClasses(h, "enter"), r.addClass(h, "exit", "base"), r.props.onExit && r.props.onExit(p);
    }, r.onExiting = function(p) {
      var m = r.resolveArguments(p), h = m[0];
      r.addClass(h, "exit", "active"), r.props.onExiting && r.props.onExiting(p);
    }, r.onExited = function(p) {
      var m = r.resolveArguments(p), h = m[0];
      r.removeClasses(h, "exit"), r.addClass(h, "exit", "done"), r.props.onExited && r.props.onExited(p);
    }, r.resolveArguments = function(p, m) {
      return r.props.nodeRef ? [r.props.nodeRef.current, p] : [p, m];
    }, r.getClassNames = function(p) {
      var m = r.props.classNames, h = typeof m == "string", g = h && m ? m + "-" : "", b = h ? "" + g + p : m[p], x = h ? b + "-active" : m[p + "Active"], E = h ? b + "-done" : m[p + "Done"];
      return {
        baseClassName: b,
        activeClassName: x,
        doneClassName: E
      };
    }, r;
  }
  var n = t.prototype;
  return n.addClass = function(a, s, l) {
    var p = this.getClassNames(s)[l + "ClassName"], m = this.getClassNames("enter"), h = m.doneClassName;
    s === "appear" && l === "done" && h && (p += " " + h), l === "active" && a && J9(a), p && (this.appliedClasses[s][l] = p, ICe(a, p));
  }, n.removeClasses = function(a, s) {
    var l = this.appliedClasses[s], p = l.base, m = l.active, h = l.done;
    this.appliedClasses[s] = {}, p && Xk(a, p), m && Xk(a, m), h && Xk(a, h);
  }, n.render = function() {
    var a = this.props;
    a.classNames;
    var s = st(a, ["classNames"]);
    return /* @__PURE__ */ le.createElement(a_, B({}, s, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, t;
}(le.Component);
lN.defaultProps = {
  classNames: ""
};
lN.propTypes = process.env.NODE_ENV !== "production" ? B({}, a_.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: NCe,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: c.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: c.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: c.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: c.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: c.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: c.func
}) : {};
const ACe = lN;
function uN(e, t) {
  var n = function(s) {
    return t && C.isValidElement(s) ? t(s) : s;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && C.Children.map(e, function(a) {
    return a;
  }).forEach(function(a) {
    r[a.key] = n(a);
  }), r;
}
function jCe(e, t) {
  e = e || {}, t = t || {};
  function n(g) {
    return g in t ? t[g] : e[g];
  }
  var r = /* @__PURE__ */ Object.create(null), a = [];
  for (var s in e)
    s in t ? a.length && (r[s] = a, a = []) : a.push(s);
  var l, p = {};
  for (var m in t) {
    if (r[m])
      for (l = 0; l < r[m].length; l++) {
        var h = r[m][l];
        p[r[m][l]] = n(h);
      }
    p[m] = n(m);
  }
  for (l = 0; l < a.length; l++)
    p[a[l]] = n(a[l]);
  return p;
}
function mm(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function LCe(e, t) {
  return uN(e.children, function(n) {
    return C.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: mm(n, "appear", e),
      enter: mm(n, "enter", e),
      exit: mm(n, "exit", e)
    });
  });
}
function FCe(e, t, n) {
  var r = uN(e.children), a = jCe(t, r);
  return Object.keys(a).forEach(function(s) {
    var l = a[s];
    if (C.isValidElement(l)) {
      var p = s in t, m = s in r, h = t[s], g = C.isValidElement(h) && !h.props.in;
      m && (!p || g) ? a[s] = C.cloneElement(l, {
        onExited: n.bind(null, l),
        in: !0,
        exit: mm(l, "exit", e),
        enter: mm(l, "enter", e)
      }) : !m && p && !g ? a[s] = C.cloneElement(l, {
        in: !1
      }) : m && p && C.isValidElement(h) && (a[s] = C.cloneElement(l, {
        onExited: n.bind(null, l),
        in: h.props.in,
        exit: mm(l, "exit", e),
        enter: mm(l, "enter", e)
      }));
    }
  }), a;
}
var zCe = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, VCe = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, cN = /* @__PURE__ */ function(e) {
  sN(t, e);
  function t(r, a) {
    var s;
    s = e.call(this, r, a) || this;
    var l = s.handleExited.bind(Ut(s));
    return s.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, s;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(a, s) {
    var l = s.children, p = s.handleExited, m = s.firstRender;
    return {
      children: m ? LCe(a, p) : FCe(a, l, p),
      firstRender: !1
    };
  }, n.handleExited = function(a, s) {
    var l = uN(this.props.children);
    a.key in l || (a.props.onExited && a.props.onExited(s), this.mounted && this.setState(function(p) {
      var m = B({}, p.children);
      return delete m[a.key], {
        children: m
      };
    }));
  }, n.render = function() {
    var a = this.props, s = a.component, l = a.childFactory, p = st(a, ["component", "childFactory"]), m = this.state.contextValue, h = zCe(this.state.children).map(l);
    return delete p.appear, delete p.enter, delete p.exit, s === null ? /* @__PURE__ */ le.createElement(ZC.Provider, {
      value: m
    }, h) : /* @__PURE__ */ le.createElement(ZC.Provider, {
      value: m
    }, /* @__PURE__ */ le.createElement(s, p, h));
  }, t;
}(le.Component);
cN.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: c.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: c.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: c.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: c.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: c.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: c.func
} : {};
cN.defaultProps = VCe;
const dN = cN;
function e7(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: a,
    rippleY: s,
    rippleSize: l,
    in: p,
    onExited: m,
    timeout: h
  } = e, [g, b] = C.useState(!1), x = Wt(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), E = {
    width: l,
    height: l,
    top: -(l / 2) + s,
    left: -(l / 2) + a
  }, O = Wt(n.child, g && n.childLeaving, r && n.childPulsate);
  return !p && !g && b(!0), C.useEffect(() => {
    if (!p && m != null) {
      const _ = setTimeout(m, h);
      return () => {
        clearTimeout(_);
      };
    }
  }, [m, p, h]), /* @__PURE__ */ L.jsx("span", {
    className: x,
    style: E,
    children: /* @__PURE__ */ L.jsx("span", {
      className: O
    })
  });
}
process.env.NODE_ENV !== "production" && (e7.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: c.object.isRequired,
  className: c.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: c.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: c.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: c.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: c.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: c.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: c.number,
  /**
   * exit delay
   */
  timeout: c.number.isRequired
});
const UCe = Bt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Bs = UCe, BCe = ["center", "classes", "className"];
let i_ = (e) => e, vU, yU, gU, bU;
const f$ = 550, HCe = 80, WCe = dd(vU || (vU = i_`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), YCe = dd(yU || (yU = i_`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), qCe = dd(gU || (gU = i_`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), GCe = Ge("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), KCe = Ge(e7, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(bU || (bU = i_`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Bs.rippleVisible, WCe, f$, ({
  theme: e
}) => e.transitions.easing.easeInOut, Bs.ripplePulsate, ({
  theme: e
}) => e.transitions.duration.shorter, Bs.child, Bs.childLeaving, YCe, f$, ({
  theme: e
}) => e.transitions.easing.easeInOut, Bs.childPulsate, qCe, ({
  theme: e
}) => e.transitions.easing.easeInOut), t7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: a = !1,
    classes: s = {},
    className: l
  } = r, p = st(r, BCe), [m, h] = C.useState([]), g = C.useRef(0), b = C.useRef(null);
  C.useEffect(() => {
    b.current && (b.current(), b.current = null);
  }, [m]);
  const x = C.useRef(!1), E = C.useRef(null), O = C.useRef(null), _ = C.useRef(null);
  C.useEffect(() => () => {
    clearTimeout(E.current);
  }, []);
  const P = C.useCallback((I) => {
    const {
      pulsate: R,
      rippleX: j,
      rippleY: U,
      rippleSize: q,
      cb: J
    } = I;
    h((H) => [...H, /* @__PURE__ */ L.jsx(KCe, {
      classes: {
        ripple: Wt(s.ripple, Bs.ripple),
        rippleVisible: Wt(s.rippleVisible, Bs.rippleVisible),
        ripplePulsate: Wt(s.ripplePulsate, Bs.ripplePulsate),
        child: Wt(s.child, Bs.child),
        childLeaving: Wt(s.childLeaving, Bs.childLeaving),
        childPulsate: Wt(s.childPulsate, Bs.childPulsate)
      },
      timeout: f$,
      pulsate: R,
      rippleX: j,
      rippleY: U,
      rippleSize: q
    }, g.current)]), g.current += 1, b.current = J;
  }, [s]), M = C.useCallback((I = {}, R = {}, j = () => {
  }) => {
    const {
      pulsate: U = !1,
      center: q = a || R.pulsate,
      fakeElement: J = !1
      // For test purposes
    } = R;
    if ((I == null ? void 0 : I.type) === "mousedown" && x.current) {
      x.current = !1;
      return;
    }
    (I == null ? void 0 : I.type) === "touchstart" && (x.current = !0);
    const H = J ? null : _.current, Z = H ? H.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let re, Y, K;
    if (q || I === void 0 || I.clientX === 0 && I.clientY === 0 || !I.clientX && !I.touches)
      re = Math.round(Z.width / 2), Y = Math.round(Z.height / 2);
    else {
      const {
        clientX: Q,
        clientY: te
      } = I.touches && I.touches.length > 0 ? I.touches[0] : I;
      re = Math.round(Q - Z.left), Y = Math.round(te - Z.top);
    }
    if (q)
      K = Math.sqrt((2 * Z.width ** 2 + Z.height ** 2) / 3), K % 2 === 0 && (K += 1);
    else {
      const Q = Math.max(Math.abs((H ? H.clientWidth : 0) - re), re) * 2 + 2, te = Math.max(Math.abs((H ? H.clientHeight : 0) - Y), Y) * 2 + 2;
      K = Math.sqrt(Q ** 2 + te ** 2);
    }
    I != null && I.touches ? O.current === null && (O.current = () => {
      P({
        pulsate: U,
        rippleX: re,
        rippleY: Y,
        rippleSize: K,
        cb: j
      });
    }, E.current = setTimeout(() => {
      O.current && (O.current(), O.current = null);
    }, HCe)) : P({
      pulsate: U,
      rippleX: re,
      rippleY: Y,
      rippleSize: K,
      cb: j
    });
  }, [a, P]), D = C.useCallback(() => {
    M({}, {
      pulsate: !0
    });
  }, [M]), N = C.useCallback((I, R) => {
    if (clearTimeout(E.current), (I == null ? void 0 : I.type) === "touchend" && O.current) {
      O.current(), O.current = null, E.current = setTimeout(() => {
        N(I, R);
      });
      return;
    }
    O.current = null, h((j) => j.length > 0 ? j.slice(1) : j), b.current = R;
  }, []);
  return C.useImperativeHandle(n, () => ({
    pulsate: D,
    start: M,
    stop: N
  }), [D, M, N]), /* @__PURE__ */ L.jsx(GCe, B({
    className: Wt(Bs.root, s.root, l),
    ref: _
  }, p, {
    children: /* @__PURE__ */ L.jsx(dN, {
      component: null,
      exit: !0,
      children: m
    })
  }));
});
process.env.NODE_ENV !== "production" && (t7.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: c.bool,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string
});
const XCe = t7;
function QCe(e) {
  return Xt("MuiButtonBase", e);
}
const ZCe = Bt("MuiButtonBase", ["root", "disabled", "focusVisible"]), JCe = ZCe, eTe = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], tTe = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: a
  } = e, l = Kt({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, QCe, a);
  return n && r && (l.root += ` ${r}`), l;
}, nTe = Ge("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${JCe.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), n7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: a,
    centerRipple: s = !1,
    children: l,
    className: p,
    component: m = "button",
    disabled: h = !1,
    disableRipple: g = !1,
    disableTouchRipple: b = !1,
    focusRipple: x = !1,
    LinkComponent: E = "a",
    onBlur: O,
    onClick: _,
    onContextMenu: P,
    onDragLeave: M,
    onFocus: D,
    onFocusVisible: N,
    onKeyDown: I,
    onKeyUp: R,
    onMouseDown: j,
    onMouseLeave: U,
    onMouseUp: q,
    onTouchEnd: J,
    onTouchMove: H,
    onTouchStart: Z,
    tabIndex: re = 0,
    TouchRippleProps: Y,
    touchRippleRef: K,
    type: Q
  } = r, te = st(r, eTe), ne = C.useRef(null), ae = C.useRef(null), se = yo(ae, K), {
    isFocusVisibleRef: V,
    onFocus: ee,
    onBlur: he,
    ref: ue
  } = Gee(), [fe, Ce] = C.useState(!1);
  h && fe && Ce(!1), C.useImperativeHandle(a, () => ({
    focusVisible: () => {
      Ce(!0), ne.current.focus();
    }
  }), []);
  const [Se, Te] = C.useState(!1);
  C.useEffect(() => {
    Te(!0);
  }, []);
  const pe = Se && !g && !h;
  C.useEffect(() => {
    fe && x && !g && Se && ae.current.pulsate();
  }, [g, x, fe, Se]);
  function ye(St, cn, Ne = b) {
    return Zr((Ie) => (cn && cn(Ie), !Ne && ae.current && ae.current[St](Ie), !0));
  }
  const Oe = ye("start", j), Fe = ye("stop", P), me = ye("stop", M), Pe = ye("stop", q), Ee = ye("stop", (St) => {
    fe && St.preventDefault(), U && U(St);
  }), Ke = ye("start", Z), oe = ye("stop", J), de = ye("stop", H), we = ye("stop", (St) => {
    he(St), V.current === !1 && Ce(!1), O && O(St);
  }, !1), Me = Zr((St) => {
    ne.current || (ne.current = St.currentTarget), ee(St), V.current === !0 && (Ce(!0), N && N(St)), D && D(St);
  }), Ae = () => {
    const St = ne.current;
    return m && m !== "button" && !(St.tagName === "A" && St.href);
  }, je = C.useRef(!1), qe = Zr((St) => {
    x && !je.current && fe && ae.current && St.key === " " && (je.current = !0, ae.current.stop(St, () => {
      ae.current.start(St);
    })), St.target === St.currentTarget && Ae() && St.key === " " && St.preventDefault(), I && I(St), St.target === St.currentTarget && Ae() && St.key === "Enter" && !h && (St.preventDefault(), _ && _(St));
  }), ot = Zr((St) => {
    x && St.key === " " && ae.current && fe && !St.defaultPrevented && (je.current = !1, ae.current.stop(St, () => {
      ae.current.pulsate(St);
    })), R && R(St), _ && St.target === St.currentTarget && Ae() && St.key === " " && !St.defaultPrevented && _(St);
  });
  let et = m;
  et === "button" && (te.href || te.to) && (et = E);
  const ct = {};
  et === "button" ? (ct.type = Q === void 0 ? "button" : Q, ct.disabled = h) : (!te.href && !te.to && (ct.role = "button"), h && (ct["aria-disabled"] = h));
  const Qt = yo(n, ue, ne);
  process.env.NODE_ENV !== "production" && C.useEffect(() => {
    pe && !ae.current && console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join(`
`));
  }, [pe]);
  const Ht = B({}, r, {
    centerRipple: s,
    component: m,
    disabled: h,
    disableRipple: g,
    disableTouchRipple: b,
    focusRipple: x,
    tabIndex: re,
    focusVisible: fe
  }), kt = tTe(Ht);
  return /* @__PURE__ */ L.jsxs(nTe, B({
    as: et,
    className: Wt(kt.root, p),
    ownerState: Ht,
    onBlur: we,
    onClick: _,
    onContextMenu: Fe,
    onFocus: Me,
    onKeyDown: qe,
    onKeyUp: ot,
    onMouseDown: Oe,
    onMouseLeave: Ee,
    onMouseUp: Pe,
    onDragLeave: me,
    onTouchEnd: oe,
    onTouchMove: de,
    onTouchStart: Ke,
    ref: Qt,
    tabIndex: h ? -1 : re,
    type: Q
  }, ct, te, {
    children: [l, pe ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ L.jsx(XCe, B({
        ref: se,
        center: s
      }, Y))
    ) : null]
  }));
});
process.env.NODE_ENV !== "production" && (n7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: il,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: c.bool,
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: cT,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: c.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: c.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: c.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: c.string,
  /**
   * @ignore
   */
  href: c.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: c.elementType,
  /**
   * @ignore
   */
  onBlur: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * @ignore
   */
  onContextMenu: c.func,
  /**
   * @ignore
   */
  onDragLeave: c.func,
  /**
   * @ignore
   */
  onFocus: c.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: c.func,
  /**
   * @ignore
   */
  onKeyDown: c.func,
  /**
   * @ignore
   */
  onKeyUp: c.func,
  /**
   * @ignore
   */
  onMouseDown: c.func,
  /**
   * @ignore
   */
  onMouseLeave: c.func,
  /**
   * @ignore
   */
  onMouseUp: c.func,
  /**
   * @ignore
   */
  onTouchEnd: c.func,
  /**
   * @ignore
   */
  onTouchMove: c.func,
  /**
   * @ignore
   */
  onTouchStart: c.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * @default 0
   */
  tabIndex: c.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: c.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: c.oneOfType([c.func, c.shape({
    current: c.shape({
      pulsate: c.func.isRequired,
      start: c.func.isRequired,
      stop: c.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: c.oneOfType([c.oneOf(["button", "reset", "submit"]), c.string])
});
const ld = n7;
function rTe(e) {
  return Xt("MuiIconButton", e);
}
const oTe = Bt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), aTe = oTe, iTe = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"], sTe = (e) => {
  const {
    classes: t,
    disabled: n,
    color: r,
    edge: a,
    size: s
  } = e, l = {
    root: ["root", n && "disabled", r !== "default" && `color${xt(r)}`, a && `edge${xt(a)}`, `size${xt(s)}`]
  };
  return Kt(l, rTe, t);
}, lTe = Ge(ld, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "default" && t[`color${xt(n.color)}`], n.edge && t[`edge${xt(n.edge)}`], t[`size${xt(n.size)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  })
}, !t.disableRipple && {
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.action.active, e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, t.edge === "start" && {
  marginLeft: t.size === "small" ? -3 : -12
}, t.edge === "end" && {
  marginRight: t.size === "small" ? -3 : -12
}), ({
  theme: e,
  ownerState: t
}) => {
  var n;
  const r = (n = (e.vars || e).palette) == null ? void 0 : n[t.color];
  return B({}, t.color === "inherit" && {
    color: "inherit"
  }, t.color !== "inherit" && t.color !== "default" && B({
    color: r == null ? void 0 : r.main
  }, !t.disableRipple && {
    "&:hover": B({}, r && {
      backgroundColor: e.vars ? `rgba(${r.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(r.main, e.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), t.size === "small" && {
    padding: 5,
    fontSize: e.typography.pxToRem(18)
  }, t.size === "large" && {
    padding: 12,
    fontSize: e.typography.pxToRem(28)
  }, {
    [`&.${aTe.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    }
  });
}), r7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: a = !1,
    children: s,
    className: l,
    color: p = "default",
    disabled: m = !1,
    disableFocusRipple: h = !1,
    size: g = "medium"
  } = r, b = st(r, iTe), x = B({}, r, {
    edge: a,
    color: p,
    disabled: m,
    disableFocusRipple: h,
    size: g
  }), E = sTe(x);
  return /* @__PURE__ */ L.jsx(lTe, B({
    className: Wt(E.root, l),
    centerRipple: !0,
    focusRipple: !h,
    disabled: m,
    ref: n,
    ownerState: x
  }, b, {
    children: s
  }));
});
process.env.NODE_ENV !== "production" && (r7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The icon to display.
   */
  children: cd(c.node, (e) => C.Children.toArray(e.children).some((n) => /* @__PURE__ */ C.isValidElement(n) && n.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
`)) : null),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: c.oneOfType([c.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: c.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: c.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: c.oneOf(["end", "start", !1]),
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: c.oneOfType([c.oneOf(["small", "medium", "large"]), c.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const Jc = r7;
function uTe(e) {
  return Xt("MuiSvgIcon", e);
}
Bt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const cTe = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], dTe = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, a = {
    root: ["root", t !== "inherit" && `color${xt(t)}`, `fontSize${xt(n)}`]
  };
  return Kt(a, uTe, r);
}, fTe = Ge("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${xt(n.color)}`], t[`fontSize${xt(n.fontSize)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n, r, a, s, l, p, m, h, g, b, x, E, O, _, P, M, D;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    fill: "currentColor",
    flexShrink: 0,
    transition: (n = e.transitions) == null || (r = n.create) == null ? void 0 : r.call(n, "fill", {
      duration: (a = e.transitions) == null || (s = a.duration) == null ? void 0 : s.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((l = e.typography) == null || (p = l.pxToRem) == null ? void 0 : p.call(l, 20)) || "1.25rem",
      medium: ((m = e.typography) == null || (h = m.pxToRem) == null ? void 0 : h.call(m, 24)) || "1.5rem",
      large: ((g = e.typography) == null || (b = g.pxToRem) == null ? void 0 : b.call(g, 35)) || "2.1875rem"
    }[t.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (x = (E = (e.vars || e).palette) == null || (O = E[t.color]) == null ? void 0 : O.main) != null ? x : {
      action: (_ = (e.vars || e).palette) == null || (P = _.action) == null ? void 0 : P.active,
      disabled: (M = (e.vars || e).palette) == null || (D = M.action) == null ? void 0 : D.disabled,
      inherit: void 0
    }[t.color]
  };
}), fN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: a,
    className: s,
    color: l = "inherit",
    component: p = "svg",
    fontSize: m = "medium",
    htmlColor: h,
    inheritViewBox: g = !1,
    titleAccess: b,
    viewBox: x = "0 0 24 24"
  } = r, E = st(r, cTe), O = B({}, r, {
    color: l,
    component: p,
    fontSize: m,
    instanceFontSize: t.fontSize,
    inheritViewBox: g,
    viewBox: x
  }), _ = {};
  g || (_.viewBox = x);
  const P = dTe(O);
  return /* @__PURE__ */ L.jsxs(fTe, B({
    as: p,
    className: Wt(P.root, s),
    focusable: "false",
    color: h,
    "aria-hidden": b ? void 0 : !0,
    role: b ? "img" : void 0,
    ref: n
  }, _, E, {
    ownerState: O,
    children: [a, b ? /* @__PURE__ */ L.jsx("title", {
      children: b
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (fN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Node passed into the SVG element.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: c.oneOfType([c.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: c.oneOfType([c.oneOf(["inherit", "large", "medium", "small"]), c.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: c.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: c.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: c.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: c.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: c.string
});
fN.muiName = "SvgIcon";
const wU = fN;
function Cs(e, t) {
  function n(r, a) {
    return /* @__PURE__ */ L.jsx(wU, B({
      "data-testid": `${t}Icon`,
      ref: a
    }, r, {
      children: e
    }));
  }
  return process.env.NODE_ENV !== "production" && (n.displayName = `${t}Icon`), n.muiName = wU.muiName, /* @__PURE__ */ C.memo(/* @__PURE__ */ C.forwardRef(n));
}
const pTe = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), mTe = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft"), hTe = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight"), o7 = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
Cs(/* @__PURE__ */ L.jsxs(C.Fragment, {
  children: [/* @__PURE__ */ L.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ L.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
const vTe = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange"), yTe = Cs(/* @__PURE__ */ L.jsxs(C.Fragment, {
  children: [/* @__PURE__ */ L.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ L.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
function gTe(e) {
  return Xt("MuiPickersArrowSwitcher", e);
}
Bt("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
const bTe = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"], wTe = ["ownerState"], xTe = ["ownerState"], STe = Ge("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex"
}), ETe = Ge("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Spacer",
  overridesResolver: (e, t) => t.spacer
})(({
  theme: e
}) => ({
  width: e.spacing(3)
})), xU = Ge(Jc, {
  name: "MuiPickersArrowSwitcher",
  slot: "Button",
  overridesResolver: (e, t) => t.button
})(({
  ownerState: e
}) => B({}, e.hidden && {
  visibility: "hidden"
})), CTe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    spacer: ["spacer"],
    button: ["button"]
  }, gTe, t);
}, a7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l;
  const m = Ji().direction === "rtl", h = Lt({
    props: t,
    name: "MuiPickersArrowSwitcher"
  }), {
    children: g,
    className: b,
    slots: x,
    slotProps: E,
    isNextDisabled: O,
    isNextHidden: _,
    onGoToNext: P,
    nextLabel: M,
    isPreviousDisabled: D,
    isPreviousHidden: N,
    onGoToPrevious: I,
    previousLabel: R
  } = h, j = st(h, bTe), U = h, q = CTe(U), J = {
    isDisabled: O,
    isHidden: _,
    goTo: P,
    label: M
  }, H = {
    isDisabled: D,
    isHidden: N,
    goTo: I,
    label: R
  }, [Z, re] = m ? [J, H] : [H, J], Y = (r = x == null ? void 0 : x.previousIconButton) != null ? r : xU, K = Gr({
    elementType: Y,
    externalSlotProps: E == null ? void 0 : E.previousIconButton,
    additionalProps: {
      size: "medium",
      title: Z.label,
      "aria-label": Z.label,
      disabled: Z.isDisabled,
      edge: "end",
      onClick: Z.goTo
    },
    ownerState: B({}, U, {
      hidden: Z.isHidden
    }),
    className: q.button
  }), Q = (a = x == null ? void 0 : x.nextIconButton) != null ? a : xU, te = Gr({
    elementType: Q,
    externalSlotProps: E == null ? void 0 : E.nextIconButton,
    additionalProps: {
      size: "medium",
      title: re.label,
      "aria-label": re.label,
      disabled: re.isDisabled,
      edge: "start",
      onClick: re.goTo
    },
    ownerState: B({}, U, {
      hidden: re.isHidden
    }),
    className: q.button
  }), ne = (s = x == null ? void 0 : x.leftArrowIcon) != null ? s : mTe, ae = Gr({
    elementType: ne,
    externalSlotProps: E == null ? void 0 : E.leftArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), se = st(ae, wTe), V = (l = x == null ? void 0 : x.rightArrowIcon) != null ? l : hTe, ee = Gr({
    elementType: V,
    externalSlotProps: E == null ? void 0 : E.rightArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), he = st(ee, xTe);
  return /* @__PURE__ */ L.jsxs(STe, B({
    ref: n,
    className: Ao(q.root, b),
    ownerState: U
  }, j, {
    children: [/* @__PURE__ */ L.jsx(Y, B({}, K, {
      children: m ? /* @__PURE__ */ L.jsx(V, B({}, he)) : /* @__PURE__ */ L.jsx(ne, B({}, se))
    })), g ? /* @__PURE__ */ L.jsx(nc, {
      variant: "subtitle1",
      component: "span",
      children: g
    }) : /* @__PURE__ */ L.jsx(ETe, {
      className: q.spacer,
      ownerState: U
    }), /* @__PURE__ */ L.jsx(Q, B({}, te, {
      children: m ? /* @__PURE__ */ L.jsx(ne, B({}, se)) : /* @__PURE__ */ L.jsx(V, B({}, he))
    }))]
  }));
});
function TTe(e) {
  return Xt("MuiDialogContent", e);
}
Bt("MuiDialogContent", ["root", "dividers"]);
const _Te = Bt("MuiDialogTitle", ["root"]), OTe = _Te, PTe = ["className", "dividers"], RTe = (e) => {
  const {
    classes: t,
    dividers: n
  } = e;
  return Kt({
    root: ["root", n && "dividers"]
  }, TTe, t);
}, kTe = Ge("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dividers && t.dividers];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, t.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(e.vars || e).palette.divider}`,
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`
} : {
  [`.${OTe.root} + &`]: {
    paddingTop: 0
  }
})), i7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDialogContent"
  }), {
    className: a,
    dividers: s = !1
  } = r, l = st(r, PTe), p = B({}, r, {
    dividers: s
  }), m = RTe(p);
  return /* @__PURE__ */ L.jsx(kTe, B({
    className: Wt(m.root, a),
    ownerState: p,
    ref: n
  }, l));
});
process.env.NODE_ENV !== "production" && (i7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * Display the top and bottom dividers.
   * @default false
   */
  dividers: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const DTe = i7, s7 = (e) => e.scrollTop;
function JC(e, t) {
  var n, r;
  const {
    timeout: a,
    easing: s,
    style: l = {}
  } = e;
  return {
    duration: (n = l.transitionDuration) != null ? n : typeof a == "number" ? a : a[t.mode] || 0,
    easing: (r = l.transitionTimingFunction) != null ? r : typeof s == "object" ? s[t.mode] : s,
    delay: l.transitionDelay
  };
}
const $Te = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"], MTe = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, l7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Ji(), a = {
    enter: r.transitions.duration.enteringScreen,
    exit: r.transitions.duration.leavingScreen
  }, {
    addEndListener: s,
    appear: l = !0,
    children: p,
    easing: m,
    in: h,
    onEnter: g,
    onEntered: b,
    onEntering: x,
    onExit: E,
    onExited: O,
    onExiting: _,
    style: P,
    timeout: M = a,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: D = a_
  } = t, N = st(t, $Te), I = C.useRef(null), R = yo(I, p.ref, n), j = (K) => (Q) => {
    if (K) {
      const te = I.current;
      Q === void 0 ? K(te) : K(te, Q);
    }
  }, U = j(x), q = j((K, Q) => {
    s7(K);
    const te = JC({
      style: P,
      timeout: M,
      easing: m
    }, {
      mode: "enter"
    });
    K.style.webkitTransition = r.transitions.create("opacity", te), K.style.transition = r.transitions.create("opacity", te), g && g(K, Q);
  }), J = j(b), H = j(_), Z = j((K) => {
    const Q = JC({
      style: P,
      timeout: M,
      easing: m
    }, {
      mode: "exit"
    });
    K.style.webkitTransition = r.transitions.create("opacity", Q), K.style.transition = r.transitions.create("opacity", Q), E && E(K);
  }), re = j(O), Y = (K) => {
    s && s(I.current, K);
  };
  return /* @__PURE__ */ L.jsx(D, B({
    appear: l,
    in: h,
    nodeRef: I,
    onEnter: q,
    onEntered: J,
    onEntering: U,
    onExit: Z,
    onExited: re,
    onExiting: H,
    addEndListener: Y,
    timeout: M
  }, N, {
    children: (K, Q) => /* @__PURE__ */ C.cloneElement(p, B({
      style: B({
        opacity: 0,
        visibility: K === "exited" && !h ? "hidden" : void 0
      }, MTe[K], P, p.props.style),
      ref: R
    }, Q))
  }));
});
process.env.NODE_ENV !== "production" && (l7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: c.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: c.bool,
  /**
   * A single child content element.
   */
  children: rw.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: c.oneOfType([c.shape({
    enter: c.string,
    exit: c.string
  }), c.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: c.bool,
  /**
   * @ignore
   */
  onEnter: c.func,
  /**
   * @ignore
   */
  onEntered: c.func,
  /**
   * @ignore
   */
  onEntering: c.func,
  /**
   * @ignore
   */
  onExit: c.func,
  /**
   * @ignore
   */
  onExited: c.func,
  /**
   * @ignore
   */
  onExiting: c.func,
  /**
   * @ignore
   */
  style: c.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: c.oneOfType([c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })])
});
const xw = l7;
function NTe(e) {
  return Xt("MuiBackdrop", e);
}
Bt("MuiBackdrop", ["root", "invisible"]);
const ITe = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"], ATe = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return Kt({
    root: ["root", n && "invisible"]
  }, NTe, t);
}, jTe = Ge("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})(({
  ownerState: e
}) => B({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, e.invisible && {
  backgroundColor: "transparent"
})), u7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s;
  const l = Lt({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: p,
    className: m,
    component: h = "div",
    components: g = {},
    componentsProps: b = {},
    invisible: x = !1,
    open: E,
    slotProps: O = {},
    slots: _ = {},
    TransitionComponent: P = xw,
    transitionDuration: M
  } = l, D = st(l, ITe), N = B({}, l, {
    component: h,
    invisible: x
  }), I = ATe(N), R = (r = O.root) != null ? r : b.root;
  return /* @__PURE__ */ L.jsx(P, B({
    in: E,
    timeout: M
  }, D, {
    children: /* @__PURE__ */ L.jsx(jTe, B({
      "aria-hidden": !0
    }, R, {
      as: (a = (s = _.root) != null ? s : g.Root) != null ? a : h,
      className: Wt(I.root, m, R == null ? void 0 : R.className),
      ownerState: B({}, N, R == null ? void 0 : R.ownerState),
      classes: I,
      ref: n,
      children: p
    }))
  }));
});
process.env.NODE_ENV !== "production" && (u7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    root: c.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: c.bool,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: c.shape({
    root: c.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    root: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: c.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: c.oneOfType([c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })])
});
const c7 = u7, LTe = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "open", "slotProps", "slots", "theme"], FTe = Ge("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !t.open && t.exited && {
  visibility: "hidden"
})), zTe = Ge(c7, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), d7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l, p, m;
  const h = Lt({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: g = zTe,
    BackdropProps: b,
    classes: x,
    className: E,
    closeAfterTransition: O = !1,
    children: _,
    container: P,
    component: M,
    components: D = {},
    componentsProps: N = {},
    disableAutoFocus: I = !1,
    disableEnforceFocus: R = !1,
    disableEscapeKeyDown: j = !1,
    disablePortal: U = !1,
    disableRestoreFocus: q = !1,
    disableScrollLock: J = !1,
    hideBackdrop: H = !1,
    keepMounted: Z = !1,
    onBackdropClick: re,
    onClose: Y,
    open: K,
    slotProps: Q,
    slots: te,
    // eslint-disable-next-line react/prop-types
    theme: ne
  } = h, ae = st(h, LTe), [se, V] = C.useState(!0), ee = {
    container: P,
    closeAfterTransition: O,
    disableAutoFocus: I,
    disableEnforceFocus: R,
    disableEscapeKeyDown: j,
    disablePortal: U,
    disableRestoreFocus: q,
    disableScrollLock: J,
    hideBackdrop: H,
    keepMounted: Z,
    onBackdropClick: re,
    onClose: Y,
    open: K
  }, he = B({}, h, ee, {
    exited: se
  }), ue = (r = (a = te == null ? void 0 : te.root) != null ? a : D.Root) != null ? r : FTe, fe = (s = (l = te == null ? void 0 : te.backdrop) != null ? l : D.Backdrop) != null ? s : g, Ce = (p = Q == null ? void 0 : Q.root) != null ? p : N.root, Se = (m = Q == null ? void 0 : Q.backdrop) != null ? m : N.backdrop;
  return /* @__PURE__ */ L.jsx(XEe, B({
    slots: {
      root: ue,
      backdrop: fe
    },
    slotProps: {
      root: () => B({}, Vf(Ce, he), !zf(ue) && {
        as: M,
        theme: ne
      }, {
        className: Wt(E, Ce == null ? void 0 : Ce.className, x == null ? void 0 : x.root, !he.open && he.exited && (x == null ? void 0 : x.hidden))
      }),
      backdrop: () => B({}, b, Vf(Se, he), {
        className: Wt(Se == null ? void 0 : Se.className, b == null ? void 0 : b.className, x == null ? void 0 : x.backdrop)
      })
    },
    onTransitionEnter: () => V(!1),
    onTransitionExited: () => V(!0),
    ref: n
  }, ae, ee, {
    children: _
  }));
});
process.env.NODE_ENV !== "production" && (d7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: c.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: c.object,
  /**
   * A single child content element.
   */
  children: rw.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: c.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Backdrop: c.elementType,
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    backdrop: c.oneOfType([c.func, c.object]),
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: c.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: c.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: c.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: c.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: c.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: c.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: c.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: c.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: c.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: c.shape({
    backdrop: c.oneOfType([c.func, c.object]),
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: c.shape({
    backdrop: c.elementType,
    root: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const f7 = d7;
function VTe(e) {
  return Xt("MuiPaper", e);
}
Bt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const UTe = ["className", "component", "elevation", "square", "variant"], BTe = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: a
  } = e, s = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return Kt(s, VTe, a);
}, HTe = Ge("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n;
  return B({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow")
  }, !t.square && {
    borderRadius: e.shape.borderRadius
  }, t.variant === "outlined" && {
    border: `1px solid ${(e.vars || e).palette.divider}`
  }, t.variant === "elevation" && B({
    boxShadow: (e.vars || e).shadows[t.elevation]
  }, !e.vars && e.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${Wn("#fff", LL(t.elevation))}, ${Wn("#fff", LL(t.elevation))})`
  }, e.vars && {
    backgroundImage: (n = e.vars.overlays) == null ? void 0 : n[t.elevation]
  }));
}), p7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiPaper"
  }), {
    className: a,
    component: s = "div",
    elevation: l = 1,
    square: p = !1,
    variant: m = "elevation"
  } = r, h = st(r, UTe), g = B({}, r, {
    component: s,
    elevation: l,
    square: p,
    variant: m
  }), b = BTe(g);
  return process.env.NODE_ENV !== "production" && Ji().shadows[l] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${l}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${l}]\` is defined.`].join(`
`)), /* @__PURE__ */ L.jsx(HTe, B({
    as: s,
    ownerState: g,
    className: Wt(b.root, a),
    ref: n
  }, h));
});
process.env.NODE_ENV !== "production" && (p7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: cd(C0, (e) => {
    const {
      elevation: t,
      variant: n
    } = e;
    return t > 0 && n === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${n}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: c.oneOfType([c.oneOf(["elevation", "outlined"]), c.string])
});
const s_ = p7;
function WTe(e) {
  return Xt("MuiDialog", e);
}
const YTe = Bt("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]), I0 = YTe, m7 = /* @__PURE__ */ C.createContext({});
process.env.NODE_ENV !== "production" && (m7.displayName = "DialogContext");
const qTe = m7, GTe = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"], KTe = Ge(c7, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (e, t) => t.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
}), XTe = (e) => {
  const {
    classes: t,
    scroll: n,
    maxWidth: r,
    fullWidth: a,
    fullScreen: s
  } = e, l = {
    root: ["root"],
    container: ["container", `scroll${xt(n)}`],
    paper: ["paper", `paperScroll${xt(n)}`, `paperWidth${xt(String(r))}`, a && "paperFullWidth", s && "paperFullScreen"]
  };
  return Kt(l, WTe, t);
}, QTe = Ge(f7, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
}), ZTe = Ge("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.container, t[`scroll${xt(n.scroll)}`]];
  }
})(({
  ownerState: e
}) => B({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, e.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, e.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&:after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
})), JTe = Ge(s_, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.paper, t[`scrollPaper${xt(n.scroll)}`], t[`paperWidth${xt(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, t.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, t.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !t.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, t.maxWidth === "xs" && {
  maxWidth: e.breakpoints.unit === "px" ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`,
  [`&.${I0.paperScrollBody}`]: {
    [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, t.maxWidth && t.maxWidth !== "xs" && {
  maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`,
  [`&.${I0.paperScrollBody}`]: {
    [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, t.fullWidth && {
  width: "calc(100% - 64px)"
}, t.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${I0.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
})), h7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDialog"
  }), a = Ji(), s = {
    enter: a.transitions.duration.enteringScreen,
    exit: a.transitions.duration.leavingScreen
  }, {
    "aria-describedby": l,
    "aria-labelledby": p,
    BackdropComponent: m,
    BackdropProps: h,
    children: g,
    className: b,
    disableEscapeKeyDown: x = !1,
    fullScreen: E = !1,
    fullWidth: O = !1,
    maxWidth: _ = "sm",
    onBackdropClick: P,
    onClose: M,
    open: D,
    PaperComponent: N = s_,
    PaperProps: I = {},
    scroll: R = "paper",
    TransitionComponent: j = xw,
    transitionDuration: U = s,
    TransitionProps: q
  } = r, J = st(r, GTe), H = B({}, r, {
    disableEscapeKeyDown: x,
    fullScreen: E,
    fullWidth: O,
    maxWidth: _,
    scroll: R
  }), Z = XTe(H), re = C.useRef(), Y = (ne) => {
    re.current = ne.target === ne.currentTarget;
  }, K = (ne) => {
    re.current && (re.current = null, P && P(ne), M && M(ne, "backdropClick"));
  }, Q = uy(p), te = C.useMemo(() => ({
    titleId: Q
  }), [Q]);
  return /* @__PURE__ */ L.jsx(QTe, B({
    className: Wt(Z.root, b),
    closeAfterTransition: !0,
    components: {
      Backdrop: KTe
    },
    componentsProps: {
      backdrop: B({
        transitionDuration: U,
        as: m
      }, h)
    },
    disableEscapeKeyDown: x,
    onClose: M,
    open: D,
    ref: n,
    onClick: K,
    ownerState: H
  }, J, {
    children: /* @__PURE__ */ L.jsx(j, B({
      appear: !0,
      in: D,
      timeout: U,
      role: "presentation"
    }, q, {
      children: /* @__PURE__ */ L.jsx(ZTe, {
        className: Wt(Z.container),
        onMouseDown: Y,
        ownerState: H,
        children: /* @__PURE__ */ L.jsx(JTe, B({
          as: N,
          elevation: 24,
          role: "dialog",
          "aria-describedby": l,
          "aria-labelledby": Q
        }, I, {
          className: Wt(Z.paper, I.className),
          ownerState: H,
          children: /* @__PURE__ */ L.jsx(qTe.Provider, {
            value: te,
            children: g
          })
        }))
      })
    }))
  }));
});
process.env.NODE_ENV !== "production" && (h7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The id(s) of the element(s) that describe the dialog.
   */
  "aria-describedby": c.string,
  /**
   * The id(s) of the element(s) that label the dialog.
   */
  "aria-labelledby": c.string,
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: c.elementType,
  /**
   * @ignore
   */
  BackdropProps: c.object,
  /**
   * Dialog children, usually the included sub-components.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: c.bool,
  /**
   * If `true`, the dialog is full-screen.
   * @default false
   */
  fullScreen: c.bool,
  /**
   * If `true`, the dialog stretches to `maxWidth`.
   *
   * Notice that the dialog width grow is limited by the default margin.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * Determine the max-width of the dialog.
   * The dialog width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'sm'
   */
  maxWidth: c.oneOfType([c.oneOf(["xs", "sm", "md", "lg", "xl", !1]), c.string]),
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: c.func,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * The component used to render the body of the dialog.
   * @default Paper
   */
  PaperComponent: c.elementType,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: c.object,
  /**
   * Determine the container for scrolling the dialog.
   * @default 'paper'
   */
  scroll: c.oneOf(["body", "paper"]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: c.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: c.oneOfType([c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: c.object
});
const e_e = h7, J0 = 36, l_ = 2, v7 = 320, y7 = 358, t_e = 232, w0 = 48, n_e = Ge(e_e)({
  [`& .${I0.container}`]: {
    outline: 0
  },
  [`& .${I0.paper}`]: {
    outline: 0,
    minWidth: v7
  }
}), r_e = Ge(DTe)({
  "&:first-of-type": {
    padding: 0
  }
});
function o_e(e) {
  var t, n;
  const {
    children: r,
    onDismiss: a,
    open: s,
    slots: l,
    slotProps: p
  } = e, m = (t = l == null ? void 0 : l.dialog) != null ? t : n_e, h = (n = l == null ? void 0 : l.mobileTransition) != null ? n : xw;
  return /* @__PURE__ */ L.jsx(m, B({
    open: s,
    onClose: a
  }, p == null ? void 0 : p.dialog, {
    TransitionComponent: h,
    TransitionProps: p == null ? void 0 : p.mobileTransition,
    PaperComponent: l == null ? void 0 : l.mobilePaper,
    PaperProps: p == null ? void 0 : p.mobilePaper,
    children: /* @__PURE__ */ L.jsx(r_e, {
      children: r
    })
  }));
}
const a_e = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function p$(e) {
  return `scale(${e}, ${e ** 2})`;
}
const i_e = {
  entering: {
    opacity: 1,
    transform: p$(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, Qk = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), pN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    addEndListener: r,
    appear: a = !0,
    children: s,
    easing: l,
    in: p,
    onEnter: m,
    onEntered: h,
    onEntering: g,
    onExit: b,
    onExited: x,
    onExiting: E,
    style: O,
    timeout: _ = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: P = a_
  } = t, M = st(t, a_e), D = C.useRef(), N = C.useRef(), I = Ji(), R = C.useRef(null), j = yo(R, s.ref, n), U = (Q) => (te) => {
    if (Q) {
      const ne = R.current;
      te === void 0 ? Q(ne) : Q(ne, te);
    }
  }, q = U(g), J = U((Q, te) => {
    s7(Q);
    const {
      duration: ne,
      delay: ae,
      easing: se
    } = JC({
      style: O,
      timeout: _,
      easing: l
    }, {
      mode: "enter"
    });
    let V;
    _ === "auto" ? (V = I.transitions.getAutoHeightDuration(Q.clientHeight), N.current = V) : V = ne, Q.style.transition = [I.transitions.create("opacity", {
      duration: V,
      delay: ae
    }), I.transitions.create("transform", {
      duration: Qk ? V : V * 0.666,
      delay: ae,
      easing: se
    })].join(","), m && m(Q, te);
  }), H = U(h), Z = U(E), re = U((Q) => {
    const {
      duration: te,
      delay: ne,
      easing: ae
    } = JC({
      style: O,
      timeout: _,
      easing: l
    }, {
      mode: "exit"
    });
    let se;
    _ === "auto" ? (se = I.transitions.getAutoHeightDuration(Q.clientHeight), N.current = se) : se = te, Q.style.transition = [I.transitions.create("opacity", {
      duration: se,
      delay: ne
    }), I.transitions.create("transform", {
      duration: Qk ? se : se * 0.666,
      delay: Qk ? ne : ne || se * 0.333,
      easing: ae
    })].join(","), Q.style.opacity = 0, Q.style.transform = p$(0.75), b && b(Q);
  }), Y = U(x), K = (Q) => {
    _ === "auto" && (D.current = setTimeout(Q, N.current || 0)), r && r(R.current, Q);
  };
  return C.useEffect(() => () => {
    clearTimeout(D.current);
  }, []), /* @__PURE__ */ L.jsx(P, B({
    appear: a,
    in: p,
    nodeRef: R,
    onEnter: J,
    onEntered: H,
    onEntering: q,
    onExit: re,
    onExited: Y,
    onExiting: Z,
    addEndListener: K,
    timeout: _ === "auto" ? null : _
  }, M, {
    children: (Q, te) => /* @__PURE__ */ C.cloneElement(s, B({
      style: B({
        opacity: 0,
        transform: p$(0.75),
        visibility: Q === "exited" && !p ? "hidden" : void 0
      }, i_e[Q], O, s.props.style),
      ref: j
    }, te))
  }));
});
process.env.NODE_ENV !== "production" && (pN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: c.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: c.bool,
  /**
   * A single child content element.
   */
  children: rw.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: c.oneOfType([c.shape({
    enter: c.string,
    exit: c.string
  }), c.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: c.bool,
  /**
   * @ignore
   */
  onEnter: c.func,
  /**
   * @ignore
   */
  onEntered: c.func,
  /**
   * @ignore
   */
  onEntering: c.func,
  /**
   * @ignore
   */
  onExit: c.func,
  /**
   * @ignore
   */
  onExited: c.func,
  /**
   * @ignore
   */
  onExiting: c.func,
  /**
   * @ignore
   */
  style: c.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: c.oneOfType([c.oneOf(["auto"]), c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })])
});
pN.muiSupportAuto = !0;
const g7 = pN, s_e = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"], l_e = Ge(LEe, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), b7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r;
  const a = RT(), s = Lt({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: l,
    component: p,
    components: m,
    componentsProps: h,
    container: g,
    disablePortal: b,
    keepMounted: x,
    modifiers: E,
    open: O,
    placement: _,
    popperOptions: P,
    popperRef: M,
    transition: D,
    slots: N,
    slotProps: I
  } = s, R = st(s, s_e), j = (r = N == null ? void 0 : N.root) != null ? r : m == null ? void 0 : m.Root, U = B({
    anchorEl: l,
    container: g,
    disablePortal: b,
    keepMounted: x,
    modifiers: E,
    open: O,
    placement: _,
    popperOptions: P,
    popperRef: M,
    transition: D
  }, R);
  return /* @__PURE__ */ L.jsx(l_e, B({
    as: p,
    direction: a == null ? void 0 : a.direction,
    slots: {
      root: j
    },
    slotProps: I ?? h
  }, U, {
    ref: n
  }));
});
process.env.NODE_ENV !== "production" && (b7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: c.oneOfType([Zu, c.object, c.func]),
  /**
   * Popper render function or node.
   */
  children: c.oneOfType([c.node, c.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: c.shape({
    Root: c.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  componentsProps: c.shape({
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: c.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: c.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: c.arrayOf(c.shape({
    data: c.object,
    effect: c.func,
    enabled: c.bool,
    fn: c.func,
    name: c.any,
    options: c.object,
    phase: c.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: c.arrayOf(c.string),
    requiresIfExists: c.arrayOf(c.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: c.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: c.shape({
    modifiers: c.array,
    onFirstUpdate: c.func,
    placement: c.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: c.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: il,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: c.shape({
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: c.shape({
    root: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: c.bool
});
const u_e = b7;
function c_e(e) {
  return Xt("MuiPickersPopper", e);
}
Bt("MuiPickersPopper", ["root", "paper"]);
function d_e(e, t) {
  return Array.isArray(t) ? t.every((n) => e.indexOf(n) !== -1) : e.indexOf(t) !== -1;
}
const f_e = (e, t) => (n) => {
  (n.key === "Enter" || n.key === " ") && (e(n), n.preventDefault(), n.stopPropagation()), t && t(n);
}, eT = (e = document) => {
  const t = e.activeElement;
  return t ? t.shadowRoot ? eT(t.shadowRoot) : t : null;
}, w7 = "@media (pointer: fine)", p_e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    paper: ["paper"]
  }, c_e, t);
}, m_e = Ge(u_e, {
  name: "MuiPickersPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  zIndex: e.zIndex.modal
})), h_e = Ge(s_, {
  name: "MuiPickersPopper",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})(({
  ownerState: e
}) => B({
  transformOrigin: "top center",
  outline: 0
}, e.placement === "top" && {
  transformOrigin: "bottom center"
}));
function v_e(e, t) {
  return t.documentElement.clientWidth < e.clientX || t.documentElement.clientHeight < e.clientY;
}
function y_e(e, t) {
  const n = C.useRef(!1), r = C.useRef(!1), a = C.useRef(null), s = C.useRef(!1);
  C.useEffect(() => {
    if (!e)
      return;
    function m() {
      s.current = !0;
    }
    return document.addEventListener("mousedown", m, !0), document.addEventListener("touchstart", m, !0), () => {
      document.removeEventListener("mousedown", m, !0), document.removeEventListener("touchstart", m, !0), s.current = !1;
    };
  }, [e]);
  const l = Zr((m) => {
    if (!s.current)
      return;
    const h = r.current;
    r.current = !1;
    const g = aa(a.current);
    if (!a.current || // is a TouchEvent?
    "clientX" in m && v_e(m, g))
      return;
    if (n.current) {
      n.current = !1;
      return;
    }
    let b;
    m.composedPath ? b = m.composedPath().indexOf(a.current) > -1 : b = !g.documentElement.contains(m.target) || a.current.contains(m.target), !b && !h && t(m);
  }), p = () => {
    r.current = !0;
  };
  return C.useEffect(() => {
    if (e) {
      const m = aa(a.current), h = () => {
        n.current = !0;
      };
      return m.addEventListener("touchstart", l), m.addEventListener("touchmove", h), () => {
        m.removeEventListener("touchstart", l), m.removeEventListener("touchmove", h);
      };
    }
  }, [e, l]), C.useEffect(() => {
    if (e) {
      const m = aa(a.current);
      return m.addEventListener("click", l), () => {
        m.removeEventListener("click", l), r.current = !1;
      };
    }
  }, [e, l]), [a, p, p];
}
function g_e(e) {
  var t, n, r, a;
  const s = Lt({
    props: e,
    name: "MuiPickersPopper"
  }), {
    anchorEl: l,
    children: p,
    containerRef: m = null,
    shouldRestoreFocus: h,
    onBlur: g,
    onDismiss: b,
    open: x,
    role: E,
    placement: O,
    slots: _,
    slotProps: P
  } = s;
  C.useEffect(() => {
    function ne(ae) {
      x && (ae.key === "Escape" || ae.key === "Esc") && b();
    }
    return document.addEventListener("keydown", ne), () => {
      document.removeEventListener("keydown", ne);
    };
  }, [b, x]);
  const M = C.useRef(null);
  C.useEffect(() => {
    E === "tooltip" || h && !h() || (x ? M.current = eT(document) : M.current && M.current instanceof HTMLElement && setTimeout(() => {
      M.current instanceof HTMLElement && M.current.focus();
    }));
  }, [x, E, h]);
  const [D, N, I] = y_e(x, g ?? b), R = C.useRef(null), j = yo(R, m), U = yo(j, D), q = s, J = p_e(q), H = (ne) => {
    ne.key === "Escape" && (ne.stopPropagation(), b());
  }, Z = (t = _ == null ? void 0 : _.desktopTransition) != null ? t : g7, re = (n = _ == null ? void 0 : _.desktopTrapFocus) != null ? n : K0, Y = (r = _ == null ? void 0 : _.desktopPaper) != null ? r : h_e, K = Gr({
    elementType: Y,
    externalSlotProps: P == null ? void 0 : P.desktopPaper,
    additionalProps: {
      tabIndex: -1,
      elevation: 8,
      ref: U
    },
    className: J.paper,
    ownerState: {}
    // Is overridden below to use `placement
  }), Q = (a = _ == null ? void 0 : _.popper) != null ? a : m_e, te = Gr({
    elementType: Q,
    externalSlotProps: P == null ? void 0 : P.popper,
    additionalProps: {
      transition: !0,
      role: E,
      open: x,
      anchorEl: l,
      placement: O,
      onKeyDown: H
    },
    className: J.root,
    ownerState: s
  });
  return /* @__PURE__ */ L.jsx(Q, B({}, te, {
    children: ({
      TransitionProps: ne,
      placement: ae
    }) => /* @__PURE__ */ L.jsx(re, B({
      open: x,
      disableAutoFocus: !0,
      disableRestoreFocus: !0,
      disableEnforceFocus: E === "tooltip",
      isEnabled: () => !0
    }, P == null ? void 0 : P.desktopTrapFocus, {
      children: /* @__PURE__ */ L.jsx(Z, B({}, ne, P == null ? void 0 : P.desktopTransition, {
        children: /* @__PURE__ */ L.jsx(Y, B({}, K, {
          onClick: (se) => {
            var V;
            N(se), (V = K.onClick) == null || V.call(K, se);
          },
          onTouchStart: (se) => {
            var V;
            I(se), (V = K.onTouchStart) == null || V.call(K, se);
          },
          ownerState: B({}, q, {
            placement: ae
          }),
          children: p
        }))
      }))
    }))
  }));
}
function b_e(e) {
  return Xt("MuiPickersToolbarText", e);
}
const SU = Bt("MuiPickersToolbarText", ["root", "selected"]);
function w_e(e) {
  return Xt("MuiButton", e);
}
const x_e = Bt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), $1 = x_e, x7 = /* @__PURE__ */ C.createContext({});
process.env.NODE_ENV !== "production" && (x7.displayName = "ButtonGroupContext");
const S_e = x7, E_e = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"], C_e = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: r,
    size: a,
    variant: s,
    classes: l
  } = e, p = {
    root: ["root", s, `${s}${xt(t)}`, `size${xt(a)}`, `${s}Size${xt(a)}`, t === "inherit" && "colorInherit", n && "disableElevation", r && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${xt(a)}`],
    endIcon: ["endIcon", `iconSize${xt(a)}`]
  }, m = Kt(p, w_e, l);
  return B({}, l, m);
}, S7 = (e) => B({}, e.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, e.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, e.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), T_e = Ge(ld, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${xt(n.color)}`], t[`size${xt(n.size)}`], t[`${n.variant}Size${xt(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n, r;
  const a = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], s = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return B({}, e.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": B({
      textDecoration: "none",
      backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.text.primary, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "text" && t.color !== "inherit" && {
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "outlined" && t.color !== "inherit" && {
      border: `1px solid ${(e.vars || e).palette[t.color].main}`,
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "contained" && {
      backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : s,
      boxShadow: (e.vars || e).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (e.vars || e).shadows[2],
        backgroundColor: (e.vars || e).palette.grey[300]
      }
    }, t.variant === "contained" && t.color !== "inherit" && {
      backgroundColor: (e.vars || e).palette[t.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (e.vars || e).palette[t.color].main
      }
    }),
    "&:active": B({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[8]
    }),
    [`&.${$1.focusVisible}`]: B({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[6]
    }),
    [`&.${$1.disabled}`]: B({
      color: (e.vars || e).palette.action.disabled
    }, t.variant === "outlined" && {
      border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
    }, t.variant === "contained" && {
      color: (e.vars || e).palette.action.disabled,
      boxShadow: (e.vars || e).shadows[0],
      backgroundColor: (e.vars || e).palette.action.disabledBackground
    })
  }, t.variant === "text" && {
    padding: "6px 8px"
  }, t.variant === "text" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main
  }, t.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, t.variant === "outlined" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main,
    border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${Wn(e.palette[t.color].main, 0.5)}`
  }, t.variant === "contained" && {
    color: e.vars ? (
      // this is safe because grey does not change between default light/dark mode
      e.vars.palette.text.primary
    ) : (n = (r = e.palette).getContrastText) == null ? void 0 : n.call(r, e.palette.grey[300]),
    backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : a,
    boxShadow: (e.vars || e).shadows[2]
  }, t.variant === "contained" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].contrastText,
    backgroundColor: (e.vars || e).palette[t.color].main
  }, t.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, t.size === "small" && t.variant === "text" && {
    padding: "4px 5px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "text" && {
    padding: "8px 11px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "contained" && {
    padding: "4px 10px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "contained" && {
    padding: "8px 22px",
    fontSize: e.typography.pxToRem(15)
  }, t.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState: e
}) => e.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${$1.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${$1.disabled}`]: {
    boxShadow: "none"
  }
}), __e = Ge("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, t[`iconSize${xt(n.size)}`]];
  }
})(({
  ownerState: e
}) => B({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, e.size === "small" && {
  marginLeft: -2
}, S7(e))), O_e = Ge("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, t[`iconSize${xt(n.size)}`]];
  }
})(({
  ownerState: e
}) => B({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, e.size === "small" && {
  marginRight: -2
}, S7(e))), E7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = C.useContext(S_e), a = F$(r, t), s = Lt({
    props: a,
    name: "MuiButton"
  }), {
    children: l,
    color: p = "primary",
    component: m = "button",
    className: h,
    disabled: g = !1,
    disableElevation: b = !1,
    disableFocusRipple: x = !1,
    endIcon: E,
    focusVisibleClassName: O,
    fullWidth: _ = !1,
    size: P = "medium",
    startIcon: M,
    type: D,
    variant: N = "text"
  } = s, I = st(s, E_e), R = B({}, s, {
    color: p,
    component: m,
    disabled: g,
    disableElevation: b,
    disableFocusRipple: x,
    fullWidth: _,
    size: P,
    type: D,
    variant: N
  }), j = C_e(R), U = M && /* @__PURE__ */ L.jsx(__e, {
    className: j.startIcon,
    ownerState: R,
    children: M
  }), q = E && /* @__PURE__ */ L.jsx(O_e, {
    className: j.endIcon,
    ownerState: R,
    children: E
  });
  return /* @__PURE__ */ L.jsxs(T_e, B({
    ownerState: R,
    className: Wt(r.className, j.root, h),
    component: m,
    disabled: g,
    focusRipple: !x,
    focusVisibleClassName: Wt(j.focusVisible, O),
    ref: n,
    type: D
  }, I, {
    classes: j,
    children: [U, l, q]
  }));
});
process.env.NODE_ENV !== "production" && (E7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: c.oneOfType([c.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, no elevation is used.
   * @default false
   */
  disableElevation: c.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: c.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: c.bool,
  /**
   * Element placed after the children.
   */
  endIcon: c.node,
  /**
   * @ignore
   */
  focusVisibleClassName: c.string,
  /**
   * If `true`, the button will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: c.string,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: c.oneOfType([c.oneOf(["small", "medium", "large"]), c.string]),
  /**
   * Element placed before the children.
   */
  startIcon: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * @ignore
   */
  type: c.oneOfType([c.oneOf(["button", "reset", "submit"]), c.string]),
  /**
   * The variant to use.
   * @default 'text'
   */
  variant: c.oneOfType([c.oneOf(["contained", "outlined", "text"]), c.string])
});
const x0 = E7, P_e = ["className", "selected", "value"], R_e = (e) => {
  const {
    classes: t,
    selected: n
  } = e;
  return Kt({
    root: ["root", n && "selected"]
  }, b_e, t);
}, k_e = Ge(nc, {
  name: "MuiPickersToolbarText",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`&.${SU.selected}`]: t.selected
  }]
})(({
  theme: e
}) => ({
  transition: e.transitions.create("color"),
  color: (e.vars || e).palette.text.secondary,
  [`&.${SU.selected}`]: {
    color: (e.vars || e).palette.text.primary
  }
})), C7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiPickersToolbarText"
  }), {
    className: a,
    value: s
  } = r, l = st(r, P_e), p = R_e(r);
  return /* @__PURE__ */ L.jsx(k_e, B({
    ref: n,
    className: Ao(a, p.root),
    component: "span"
  }, l, {
    children: s
  }));
}), D_e = ["align", "className", "selected", "typographyClassName", "value", "variant", "width"], $_e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, K9, t);
}, M_e = Ge(x0, {
  name: "MuiPickersToolbarButton",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  padding: 0,
  minWidth: 16,
  textTransform: "none"
}), Cf = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiPickersToolbarButton"
  }), {
    align: a,
    className: s,
    selected: l,
    typographyClassName: p,
    value: m,
    variant: h,
    width: g
  } = r, b = st(r, D_e), x = $_e(r);
  return /* @__PURE__ */ L.jsx(M_e, B({
    variant: "text",
    ref: n,
    className: Ao(s, x.root)
  }, g ? {
    sx: {
      width: g
    }
  } : {}, b, {
    children: /* @__PURE__ */ L.jsx(C7, {
      align: a,
      className: p,
      variant: h,
      value: m,
      selected: l
    })
  }));
});
var u0 = {}, EU;
function T7() {
  if (EU)
    return u0;
  EU = 1, Object.defineProperty(u0, "__esModule", {
    value: !0
  }), u0.default = void 0;
  var e = n(C);
  function t(s) {
    if (typeof WeakMap != "function")
      return null;
    var l = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap();
    return (t = function(m) {
      return m ? p : l;
    })(s);
  }
  function n(s, l) {
    if (!l && s && s.__esModule)
      return s;
    if (s === null || typeof s != "object" && typeof s != "function")
      return { default: s };
    var p = t(l);
    if (p && p.has(s))
      return p.get(s);
    var m = {}, h = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var g in s)
      if (g !== "default" && Object.prototype.hasOwnProperty.call(s, g)) {
        var b = h ? Object.getOwnPropertyDescriptor(s, g) : null;
        b && (b.get || b.set) ? Object.defineProperty(m, g, b) : m[g] = s[g];
      }
    return m.default = s, p && p.set(s, m), m;
  }
  var a = typeof window < "u" ? e.useLayoutEffect : e.useEffect;
  return u0.default = a, u0;
}
var N_e = T7();
const m$ = /* @__PURE__ */ Uf(N_e);
var _7 = {}, O7 = { exports: {} };
(function(e) {
  function t(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(O7);
var P7 = O7.exports, I_e = P7;
Object.defineProperty(_7, "__esModule", {
  value: !0
});
var Qn = _7.default = L_e, CU = j_e(C), A_e = I_e(T7());
function R7(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (R7 = function(r) {
    return r ? n : t;
  })(e);
}
function j_e(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = R7(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, s) : null;
      l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s];
    }
  return r.default = e, n && n.set(e, r), r;
}
function L_e(e) {
  const t = CU.useRef(e);
  return (0, A_e.default)(() => {
    t.current = e;
  }), CU.useCallback((...n) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...n)
  ), []);
}
var k7 = {}, M1 = {}, TU;
function F_e() {
  if (TU)
    return M1;
  TU = 1, Object.defineProperty(M1, "__esModule", {
    value: !0
  }), M1.default = e;
  function e(t, n) {
    typeof t == "function" ? t(n) : t && (t.current = n);
  }
  return M1;
}
var z_e = P7;
Object.defineProperty(k7, "__esModule", {
  value: !0
});
var u_ = k7.default = H_e, V_e = B_e(C), U_e = z_e(F_e());
function D7(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (D7 = function(r) {
    return r ? n : t;
  })(e);
}
function B_e(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = D7(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, s) : null;
      l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s];
    }
  return r.default = e, n && n.set(e, r), r;
}
function H_e(...e) {
  return V_e.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      (0, U_e.default)(n, t);
    });
  }, e);
}
function $7(e, t, n, r) {
  const {
    value: a,
    onError: s
  } = e, l = Im(), p = C.useRef(r), m = t({
    adapter: l,
    value: a,
    props: e
  });
  return C.useEffect(() => {
    s && !n(m, p.current) && s(m, a), p.current = m;
  }, [n, s, p, m, a]), m;
}
var M7 = {};
Object.defineProperty(M7, "__esModule", {
  value: !0
});
var N7 = M7.default = Y_e, Av = W_e(C);
function I7(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (I7 = function(r) {
    return r ? n : t;
  })(e);
}
function W_e(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = I7(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, s) : null;
      l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s];
    }
  return r.default = e, n && n.set(e, r), r;
}
function Y_e({
  controlled: e,
  default: t,
  name: n,
  state: r = "value"
}) {
  const {
    current: a
  } = Av.useRef(e !== void 0), [s, l] = Av.useState(t), p = a ? e : s;
  if (process.env.NODE_ENV !== "production") {
    Av.useEffect(() => {
      a !== (e !== void 0) && console.error([`MUI: A component is changing the ${a ? "" : "un"}controlled ${r} state of ${n} to be ${a ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${n} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [r, n, e]);
    const {
      current: h
    } = Av.useRef(t);
    Av.useEffect(() => {
      !a && h !== t && console.error([`MUI: A component is changing the default ${r} state of an uncontrolled ${n} after being initialized. To suppress this warning opt to use a controlled ${n}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const m = Av.useCallback((h) => {
    a || l(h);
  }, []);
  return [p, m];
}
const q_e = (e) => {
  var t;
  const n = or(), r = es(), a = Im(), l = Ji().direction === "rtl", {
    valueManager: p,
    fieldValueManager: m,
    valueType: h,
    validator: g,
    internalProps: b,
    internalProps: {
      value: x,
      defaultValue: E,
      referenceDate: O,
      onChange: _,
      format: P,
      formatDensity: M = "dense",
      selectedSections: D,
      onSelectedSectionsChange: N,
      shouldRespectLeadingZeros: I = !1
    }
  } = e, R = C.useRef(E), j = (t = x ?? R.current) != null ? t : p.emptyValue, U = C.useMemo(() => u1e(n), [n]), q = C.useCallback((ue, fe = null) => m.getSectionsFromValue(n, ue, fe, l, (Ce) => K5(n, r, P, Ce, M, I, l)), [m, P, r, l, I, n, M]), J = C.useMemo(() => m.getValueStrFromSections(q(p.emptyValue), l), [m, q, p.emptyValue, l]), [H, Z] = C.useState(() => {
    const ue = q(j);
    Q5(ue, h);
    const fe = {
      sections: ue,
      value: j,
      referenceValue: p.emptyValue,
      tempValueStrAndroid: null
    }, Ce = n1e(ue), Se = p.getInitialReferenceValue({
      referenceDate: O,
      value: j,
      valueType: h,
      utils: n,
      props: b,
      granularity: Ce
    });
    return B({}, fe, {
      referenceValue: Se
    });
  }), [re, Y] = N7({
    controlled: D,
    default: null,
    name: "useField",
    state: "selectedSectionIndexes"
  }), K = (ue) => {
    Y(ue), N == null || N(ue), Z((fe) => B({}, fe, {
      selectedSectionQuery: null
    }));
  }, Q = C.useMemo(() => {
    if (re == null)
      return null;
    if (re === "all")
      return {
        startIndex: 0,
        endIndex: H.sections.length - 1,
        shouldSelectBoundarySelectors: !0
      };
    if (typeof re == "number")
      return {
        startIndex: re,
        endIndex: re
      };
    if (typeof re == "string") {
      const ue = H.sections.findIndex((fe) => fe.type === re);
      return {
        startIndex: ue,
        endIndex: ue
      };
    }
    return re;
  }, [re, H.sections]), te = ({
    value: ue,
    referenceValue: fe,
    sections: Ce
  }) => {
    if (Z((Se) => B({}, Se, {
      sections: Ce,
      value: ue,
      referenceValue: fe,
      tempValueStrAndroid: null
    })), _) {
      const Se = {
        validationError: g({
          adapter: a,
          value: ue,
          props: B({}, b, {
            value: ue
          })
        })
      };
      _(ue, Se);
    }
  }, ne = (ue, fe) => {
    const Ce = [...H.sections];
    return Ce[ue] = B({}, Ce[ue], {
      value: fe,
      modified: !0
    }), _9(Ce, l);
  }, ae = () => {
    p.areValuesEqual(n, H.value, p.emptyValue) || te({
      value: p.emptyValue,
      referenceValue: H.referenceValue,
      sections: q(p.emptyValue)
    });
  }, se = () => {
    if (Q == null)
      return;
    const ue = H.sections[Q.startIndex];
    if (ue.value === "")
      return;
    const fe = m.getActiveDateManager(n, H, ue), Se = fe.getSections(H.sections).filter((Oe) => Oe.value !== "").length === 1, Te = ne(Q.startIndex, ""), pe = Se ? null : n.date(/* @__PURE__ */ new Date("")), ye = fe.getNewValuesFromNewActiveDate(pe);
    (pe != null && !n.isValid(pe)) != (fe.date != null && !n.isValid(fe.date)) ? te(B({}, ye, {
      sections: Te
    })) : Z((Oe) => B({}, Oe, ye, {
      sections: Te,
      tempValueStrAndroid: null
    }));
  }, V = (ue) => {
    const fe = (Te, pe) => {
      const ye = n.parse(Te, P);
      if (ye == null || !n.isValid(ye))
        return null;
      const Oe = K5(n, r, P, ye, M, I, l);
      return J5(n, ye, Oe, pe, !1);
    }, Ce = m.parseValueStr(ue, H.referenceValue, fe), Se = m.updateReferenceValue(n, Ce, H.referenceValue);
    te({
      value: Ce,
      referenceValue: Se,
      sections: q(Ce, H.sections)
    });
  }, ee = ({
    activeSection: ue,
    newSectionValue: fe,
    shouldGoToNextSection: Ce
  }) => {
    Ce && Q && Q.startIndex < H.sections.length - 1 ? K(Q.startIndex + 1) : Q && Q.startIndex !== Q.endIndex && K(Q.startIndex);
    const Se = m.getActiveDateManager(n, H, ue), Te = ne(Q.startIndex, fe), pe = Se.getSections(Te);
    let ye = l$(n, pe), Oe = !1;
    if (!n.isValid(ye)) {
      const Ee = f1e(n, pe, U);
      Ee != null && (Oe = !0, ye = l$(n, Ee));
    }
    let Fe, me;
    if (ye != null && n.isValid(ye)) {
      const Ee = J5(n, ye, pe, Se.referenceDate, !0);
      Fe = Se.getNewValuesFromNewActiveDate(Ee), me = !0;
    } else
      Fe = Se.getNewValuesFromNewActiveDate(ye), me = (ye != null && !n.isValid(ye)) != (Se.date != null && !n.isValid(Se.date));
    const Pe = Oe ? q(Fe.value, H.sections) : Te;
    return me ? te(B({}, Fe, {
      sections: Pe
    })) : Z((Ee) => B({}, Ee, Fe, {
      sections: Pe,
      tempValueStrAndroid: null
    }));
  }, he = (ue) => Z((fe) => B({}, fe, {
    tempValueStrAndroid: ue
  }));
  return C.useEffect(() => {
    let ue = !1;
    p.areValuesEqual(n, H.value, j) ? ue = p.getTimezone(n, H.value) !== p.getTimezone(n, j) : ue = !0, ue && Z((fe) => B({}, fe, {
      value: j,
      referenceValue: m.updateReferenceValue(n, j, fe.referenceValue),
      sections: q(j)
    }));
  }, [j]), C.useEffect(() => {
    const ue = q(H.value);
    Q5(ue, h), Z((fe) => B({}, fe, {
      sections: ue
    }));
  }, [P, n.locale]), {
    state: H,
    selectedSectionIndexes: Q,
    setSelectedSections: K,
    clearValue: ae,
    clearActiveSection: se,
    updateSectionValue: ee,
    updateValueFromValueStr: V,
    setTempAndroidValueStr: he,
    sectionsValueBoundaries: U,
    placeholder: J
  };
}, G_e = 5e3, jv = (e) => e.saveQuery != null, K_e = ({
  sections: e,
  updateSectionValue: t,
  sectionsValueBoundaries: n,
  setTempAndroidValueStr: r
}) => {
  const a = or(), [s, l] = C.useState(null), p = Qn(() => l(null));
  C.useEffect(() => {
    var x;
    s != null && ((x = e[s.sectionIndex]) == null ? void 0 : x.type) !== s.sectionType && p();
  }, [e, s, p]), C.useEffect(() => {
    if (s != null) {
      const x = setTimeout(() => p(), G_e);
      return () => {
        window.clearTimeout(x);
      };
    }
    return () => {
    };
  }, [s, p]);
  const m = ({
    keyPressed: x,
    sectionIndex: E
  }, O, _) => {
    const P = x.toLowerCase(), M = e[E];
    if (s != null && (!_ || _(s.value)) && s.sectionIndex === E) {
      const N = `${s.value}${P}`, I = O(N, M);
      if (!jv(I))
        return l({
          sectionIndex: E,
          value: N,
          sectionType: M.type
        }), I;
    }
    const D = O(P, M);
    return jv(D) && !D.saveQuery ? (p(), null) : (l({
      sectionIndex: E,
      value: P,
      sectionType: M.type
    }), jv(D) ? null : D);
  }, h = (x) => {
    const E = (P, M, D) => {
      const N = M.filter((I) => I.toLowerCase().startsWith(D));
      return N.length === 0 ? {
        saveQuery: !1
      } : {
        sectionValue: N[0],
        shouldGoToNextSection: N.length === 1
      };
    }, O = (P, M, D, N) => {
      const I = (R) => C9(a, M.type, R);
      if (M.contentType === "letter")
        return E(M.format, I(M.format), P);
      if (D && N != null && QM(a, D).contentType === "letter") {
        const R = I(D), j = E(D, R, P);
        return jv(j) ? {
          saveQuery: !1
        } : B({}, j, {
          sectionValue: N(j.sectionValue, R)
        });
      }
      return {
        saveQuery: !1
      };
    };
    return m(x, (P, M) => {
      switch (M.type) {
        case "month": {
          const D = (N) => G5(a, N, a.formats.month, M.format);
          return O(P, M, a.formats.month, D);
        }
        case "weekDay": {
          const D = (N, I) => I.indexOf(N).toString();
          return O(P, M, a.formats.weekday, D);
        }
        case "meridiem":
          return O(P, M);
        default:
          return {
            saveQuery: !1
          };
      }
    });
  }, g = (x) => {
    const E = (_, P) => {
      const M = +`${_}`, D = n[P.type]({
        currentDate: null,
        format: P.format,
        contentType: P.contentType
      });
      if (M > D.maximum)
        return {
          saveQuery: !1
        };
      if (M < D.minimum)
        return {
          saveQuery: !0
        };
      const N = +`${_}0` > D.maximum || _.length === D.maximum.toString().length;
      return {
        sectionValue: ZM(a, M, D, P),
        shouldGoToNextSection: N
      };
    };
    return m(x, (_, P) => {
      if (P.contentType === "digit" || P.contentType === "digit-with-letter")
        return E(_, P);
      if (P.type === "month") {
        const M = P9(a, "digit", "month", "MM"), D = E(_, {
          type: P.type,
          format: "MM",
          hasLeadingZerosInFormat: M,
          hasLeadingZerosInInput: !0,
          contentType: "digit",
          maxLength: 2
        });
        if (jv(D))
          return D;
        const N = G5(a, D.sectionValue, "MM", P.format);
        return B({}, D, {
          sectionValue: N
        });
      }
      if (P.type === "weekDay") {
        const M = E(_, P);
        if (jv(M))
          return M;
        const D = t_(a, P.format)[Number(M.sectionValue) - 1];
        return B({}, M, {
          sectionValue: D
        });
      }
      return {
        saveQuery: !1
      };
    }, (_) => !Number.isNaN(Number(_)));
  };
  return {
    applyCharacterEditing: Qn((x) => {
      const E = e[x.sectionIndex], _ = !Number.isNaN(Number(x.keyPressed)) ? g(x) : h(x);
      _ == null ? r(null) : t({
        activeSection: E,
        newSectionValue: _.sectionValue,
        shouldGoToNextSection: _.shouldGoToNextSection
      });
    }),
    resetCharacterQuery: p
  };
}, X_e = ["onClick", "onKeyDown", "onFocus", "onBlur", "onMouseUp", "onPaste", "error"], A7 = (e) => {
  const t = or(), {
    state: n,
    selectedSectionIndexes: r,
    setSelectedSections: a,
    clearValue: s,
    clearActiveSection: l,
    updateSectionValue: p,
    updateValueFromValueStr: m,
    setTempAndroidValueStr: h,
    sectionsValueBoundaries: g,
    placeholder: b
  } = q_e(e), {
    inputRef: x,
    internalProps: E,
    internalProps: {
      readOnly: O = !1,
      unstableFieldRef: _
    },
    forwardedProps: {
      onClick: P,
      onKeyDown: M,
      onFocus: D,
      onBlur: N,
      onMouseUp: I,
      onPaste: R,
      error: j
    },
    fieldValueManager: U,
    valueManager: q,
    validator: J
  } = e, H = st(e.forwardedProps, X_e), {
    applyCharacterEditing: Z,
    resetCharacterQuery: re
  } = K_e({
    sections: n.sections,
    updateSectionValue: p,
    sectionsValueBoundaries: g,
    setTempAndroidValueStr: h
  }), Y = C.useRef(null), K = u_(x, Y), Q = C.useRef(void 0), ne = Ji().direction === "rtl", ae = C.useMemo(() => p1e(n.sections, ne), [n.sections, ne]), se = () => {
    var Pe;
    if (O) {
      a(null);
      return;
    }
    const Ee = (Pe = Y.current.selectionStart) != null ? Pe : 0;
    let Ke;
    Ee <= n.sections[0].startInInput || Ee >= n.sections[n.sections.length - 1].endInInput ? Ke = 1 : Ke = n.sections.findIndex((de) => de.startInInput - de.startSeparator.length > Ee);
    const oe = Ke === -1 ? n.sections.length - 1 : Ke - 1;
    a(oe);
  }, V = Qn((...Pe) => {
    P == null || P(...Pe), se();
  }), ee = Qn((Pe) => {
    I == null || I(Pe), Pe.preventDefault();
  }), he = Qn((...Pe) => {
    D == null || D(...Pe);
    const Ee = Y.current;
    clearTimeout(Q.current), Q.current = setTimeout(() => {
      !Ee || Ee !== Y.current || r != null || O || (// avoid selecting all sections when focusing empty field without value
      Ee.value.length && Number(Ee.selectionEnd) - Number(Ee.selectionStart) === Ee.value.length ? a("all") : se());
    });
  }), ue = Qn((...Pe) => {
    N == null || N(...Pe), a(null);
  }), fe = Qn((Pe) => {
    if (R == null || R(Pe), O) {
      Pe.preventDefault();
      return;
    }
    const Ee = Pe.clipboardData.getData("text");
    if (r && r.startIndex === r.endIndex) {
      const Ke = n.sections[r.startIndex], oe = /^[a-zA-Z]+$/.test(Ee), de = /^[0-9]+$/.test(Ee), we = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(Ee);
      if (Ke.contentType === "letter" && oe || Ke.contentType === "digit" && de || Ke.contentType === "digit-with-letter" && we)
        return;
      if (oe || de) {
        Pe.preventDefault();
        return;
      }
    }
    Pe.preventDefault(), m(Ee);
  }), Ce = Qn((Pe) => {
    if (O)
      return;
    const Ee = Pe.target.value, Ke = Gv(Ee);
    if (r == null) {
      m(Ke);
      return;
    }
    let oe;
    if (r.startIndex === 0 && r.endIndex === n.sections.length - 1 && Ke.length === 1)
      oe = Ke;
    else {
      const de = Gv(U.getValueStrFromSections(n.sections, ne));
      let we = -1, Me = -1;
      for (let ot = 0; ot < de.length; ot += 1)
        we === -1 && de[ot] !== Ke[ot] && (we = ot), Me === -1 && de[de.length - ot - 1] !== Ke[Ke.length - ot - 1] && (Me = ot);
      const Ae = n.sections[r.startIndex];
      if (we < Ae.start || de.length - Me - 1 > Ae.end)
        return;
      const qe = Ke.length - de.length + Ae.end - Gv(Ae.endSeparator || "").length;
      oe = Ke.slice(Ae.start + Gv(Ae.startSeparator || "").length, qe);
    }
    if (d1e() && oe.length === 0) {
      h(Ee);
      return;
    }
    Z({
      keyPressed: oe,
      sectionIndex: r.startIndex
    });
  }), Se = Qn((Pe) => {
    switch (M == null || M(Pe), !0) {
      case (Pe.key === "a" && (Pe.ctrlKey || Pe.metaKey)): {
        Pe.preventDefault(), a("all");
        break;
      }
      case Pe.key === "ArrowRight": {
        if (Pe.preventDefault(), r == null)
          a(ae.startIndex);
        else if (r.startIndex !== r.endIndex)
          a(r.endIndex);
        else {
          const Ee = ae.neighbors[r.startIndex].rightIndex;
          Ee !== null && a(Ee);
        }
        break;
      }
      case Pe.key === "ArrowLeft": {
        if (Pe.preventDefault(), r == null)
          a(ae.endIndex);
        else if (r.startIndex !== r.endIndex)
          a(r.startIndex);
        else {
          const Ee = ae.neighbors[r.startIndex].leftIndex;
          Ee !== null && a(Ee);
        }
        break;
      }
      case ["Backspace", "Delete"].includes(Pe.key): {
        if (Pe.preventDefault(), O)
          break;
        r == null || r.startIndex === 0 && r.endIndex === n.sections.length - 1 ? s() : l(), re();
        break;
      }
      case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(Pe.key): {
        if (Pe.preventDefault(), O || r == null)
          break;
        const Ee = n.sections[r.startIndex], Ke = U.getActiveDateManager(t, n, Ee), oe = a1e(t, Ee, Pe.key, g, Ke.date);
        p({
          activeSection: Ee,
          newSectionValue: oe,
          shouldGoToNextSection: !1
        });
        break;
      }
    }
  });
  m$(() => {
    if (r == null) {
      Y.current.scrollLeft && (Y.current.scrollLeft = 0);
      return;
    }
    const Pe = n.sections[r.startIndex], Ee = n.sections[r.endIndex];
    let Ke = Pe.startInInput, oe = Ee.endInInput;
    if (r.shouldSelectBoundarySelectors && (Ke -= Pe.startSeparator.length, oe += Ee.endSeparator.length), Ke !== Y.current.selectionStart || oe !== Y.current.selectionEnd) {
      const de = Y.current.scrollTop;
      Y.current && Y.current === eT(document) && Y.current.setSelectionRange(Ke, oe), Y.current.scrollTop = de;
    }
  });
  const Te = $7(B({}, E, {
    value: n.value
  }), J, q.isSameError, q.defaultErrorState), pe = C.useMemo(() => j !== void 0 ? j : q.hasError(Te), [q, Te, j]);
  C.useEffect(() => (Y.current && Y.current === document.activeElement && a("all"), () => window.clearTimeout(Q.current)), []), C.useEffect(() => {
    n.tempValueStrAndroid != null && r != null && (re(), l());
  }, [n.tempValueStrAndroid]);
  const ye = C.useMemo(() => {
    var Pe;
    return (Pe = n.tempValueStrAndroid) != null ? Pe : U.getValueStrFromSections(n.sections, ne);
  }, [n.sections, U, n.tempValueStrAndroid, ne]), Oe = C.useMemo(() => r == null || n.sections[r.startIndex].contentType === "letter" ? "text" : "tel", [r, n.sections]), me = !(Y.current && Y.current === eT(document)) && q.areValuesEqual(t, n.value, q.emptyValue);
  return C.useImperativeHandle(_, () => ({
    getSections: () => n.sections,
    getActiveSectionIndex: () => {
      var Pe, Ee;
      const Ke = (Pe = Y.current.selectionStart) != null ? Pe : 0, oe = (Ee = Y.current.selectionEnd) != null ? Ee : 0;
      if (Ke === 0 && oe === 0)
        return null;
      const de = Ke <= n.sections[0].startInInput ? 1 : n.sections.findIndex((we) => we.startInInput - we.startSeparator.length > Ke);
      return de === -1 ? n.sections.length - 1 : de - 1;
    },
    setSelectedSections: (Pe) => a(Pe)
  })), B({
    placeholder: b,
    autoComplete: "off"
  }, H, {
    value: me ? "" : ye,
    inputMode: Oe,
    readOnly: O,
    onClick: V,
    onFocus: he,
    onBlur: ue,
    onPaste: fe,
    onChange: Ce,
    onKeyDown: Se,
    onMouseUp: ee,
    error: pe,
    ref: K
  });
}, Q_e = ({
  open: e,
  onOpen: t,
  onClose: n
}) => {
  const r = C.useRef(typeof e == "boolean").current, [a, s] = C.useState(!1);
  C.useEffect(() => {
    if (r) {
      if (typeof e != "boolean")
        throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
      s(e);
    }
  }, [r, e]);
  const l = C.useCallback((p) => {
    r || s(p), p && t && t(), !p && n && n();
  }, [r, t, n]);
  return {
    isOpen: a,
    setIsOpen: l
  };
}, Z_e = (e) => {
  const {
    action: t,
    hasChanged: n,
    dateState: r,
    isControlled: a
  } = e, s = !a && !r.hasBeenModifiedSinceMount;
  return t.name === "setValueFromField" ? !0 : t.name === "setValueFromAction" ? s && ["accept", "today", "clear"].includes(t.pickerAction) ? !0 : n(r.lastPublishedValue) : t.name === "setValueFromView" && t.selectionState !== "shallow" ? s ? !0 : n(r.lastPublishedValue) : !1;
}, J_e = (e) => {
  const {
    action: t,
    hasChanged: n,
    dateState: r,
    isControlled: a,
    closeOnSelect: s
  } = e, l = !a && !r.hasBeenModifiedSinceMount;
  return t.name === "setValueFromAction" ? l && ["accept", "today", "clear"].includes(t.pickerAction) ? !0 : n(r.lastCommittedValue) : t.name === "setValueFromView" && t.selectionState === "finish" && s ? l ? !0 : n(r.lastCommittedValue) : !1;
}, eOe = (e) => {
  const {
    action: t,
    closeOnSelect: n
  } = e;
  return t.name === "setValueFromAction" ? !0 : t.name === "setValueFromView" ? t.selectionState === "finish" && n : !1;
}, tOe = ({
  props: e,
  valueManager: t,
  valueType: n,
  wrapperVariant: r,
  validator: a
}) => {
  const {
    onAccept: s,
    onChange: l,
    value: p,
    defaultValue: m,
    closeOnSelect: h = r === "desktop",
    selectedSections: g,
    onSelectedSectionsChange: b
  } = e, {
    current: x
  } = C.useRef(m), {
    current: E
  } = C.useRef(p !== void 0);
  process.env.NODE_ENV !== "production" && (C.useEffect(() => {
    E !== (p !== void 0) && console.error([`MUI: A component is changing the ${E ? "" : "un"}controlled value of a picker to be ${E ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", "Decide between using a controlled or uncontrolled valuefor the lifetime of the component.", "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
  }, [p]), C.useEffect(() => {
    !E && x !== m && console.error(["MUI: A component is changing the defaultValue of an uncontrolled picker after being initialized. To suppress this warning opt to use a controlled value."].join(`
`));
  }, [JSON.stringify(x)]));
  const O = or(), _ = Im(), [P, M] = tl({
    controlled: g,
    default: null,
    name: "usePickerValue",
    state: "selectedSections"
  }), {
    isOpen: D,
    setIsOpen: N
  } = Q_e(e), [I, R] = C.useState(() => {
    let ue;
    return p !== void 0 ? ue = p : x !== void 0 ? ue = x : ue = t.emptyValue, {
      draft: ue,
      lastPublishedValue: ue,
      lastCommittedValue: ue,
      lastControlledValue: p,
      hasBeenModifiedSinceMount: !1
    };
  });
  $7(B({}, e, {
    value: I.draft
  }), a, t.isSameError, t.defaultErrorState);
  const j = Qn((ue) => {
    const fe = {
      action: ue,
      dateState: I,
      hasChanged: (pe) => !t.areValuesEqual(O, ue.value, pe),
      isControlled: E,
      closeOnSelect: h
    }, Ce = Z_e(fe), Se = J_e(fe), Te = eOe(fe);
    if (R((pe) => B({}, pe, {
      draft: ue.value,
      lastPublishedValue: Ce ? ue.value : pe.lastPublishedValue,
      lastCommittedValue: Se ? ue.value : pe.lastCommittedValue,
      hasBeenModifiedSinceMount: !0
    })), Ce && l) {
      const ye = {
        validationError: ue.name === "setValueFromField" ? ue.context.validationError : a({
          adapter: _,
          value: ue.value,
          props: B({}, e, {
            value: ue.value
          })
        })
      };
      l(ue.value, ye);
    }
    Se && s && s(ue.value), Te && N(!1);
  });
  if (p !== void 0 && (I.lastControlledValue === void 0 || !t.areValuesEqual(O, I.lastControlledValue, p))) {
    const ue = t.areValuesEqual(O, I.draft, p);
    R((fe) => B({}, fe, {
      lastControlledValue: p
    }, ue ? {} : {
      lastCommittedValue: p,
      lastPublishedValue: p,
      draft: p,
      hasBeenModifiedSinceMount: !0
    }));
  }
  const U = Qn(() => {
    j({
      value: t.emptyValue,
      name: "setValueFromAction",
      pickerAction: "clear"
    });
  }), q = Qn(() => {
    j({
      value: I.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "accept"
    });
  }), J = Qn(() => {
    j({
      value: I.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "dismiss"
    });
  }), H = Qn(() => {
    j({
      value: I.lastCommittedValue,
      name: "setValueFromAction",
      pickerAction: "cancel"
    });
  }), Z = Qn(() => {
    j({
      value: t.getTodayValue(O, n),
      name: "setValueFromAction",
      pickerAction: "today"
    });
  }), re = Qn(() => N(!0)), Y = Qn(() => N(!1)), K = Qn((ue, fe = "partial") => j({
    name: "setValueFromView",
    value: ue,
    selectionState: fe
  })), Q = Qn((ue, fe) => j({
    name: "setValueFromField",
    value: ue,
    context: fe
  })), te = Qn((ue) => {
    M(ue), b == null || b(ue);
  }), ne = {
    onClear: U,
    onAccept: q,
    onDismiss: J,
    onCancel: H,
    onSetToday: Z,
    onOpen: re,
    onClose: Y
  }, ae = {
    value: I.draft,
    onChange: Q,
    selectedSections: P,
    onSelectedSectionsChange: te
  }, se = C.useMemo(() => t.cleanValue(O, I.draft), [O, t, I.draft]), V = {
    value: se,
    onChange: K,
    onClose: Y,
    open: D,
    onSelectedSectionsChange: te
  }, he = B({}, ne, {
    value: se,
    onChange: K,
    isValid: (ue) => {
      const fe = a({
        adapter: _,
        value: ue,
        props: B({}, e, {
          value: ue
        })
      });
      return !t.hasError(fe);
    }
  });
  return {
    open: D,
    fieldProps: ae,
    viewProps: V,
    layoutProps: he,
    actions: ne
  };
};
let Zk = !1;
function c_({
  onChange: e,
  onViewChange: t,
  openTo: n,
  view: r,
  views: a,
  autoFocus: s,
  focusedView: l,
  onFocusedViewChange: p
}) {
  var m, h;
  process.env.NODE_ENV !== "production" && (Zk || (r != null && !a.includes(r) && (console.warn(`MUI: \`view="${r}"\` is not a valid prop.`, `It must be an element of \`views=["${a.join('", "')}"]\`.`), Zk = !0), r == null && n != null && !a.includes(n) && (console.warn(`MUI: \`openTo="${n}"\` is not a valid prop.`, `It must be an element of \`views=["${a.join('", "')}"]\`.`), Zk = !0)));
  const g = C.useRef(n), b = C.useRef(a), x = C.useRef(a.includes(n) ? n : a[0]), [E, O] = tl({
    name: "useViews",
    state: "view",
    controlled: r,
    default: x.current
  }), _ = C.useRef(s ? E : null), [P, M] = tl({
    name: "useViews",
    state: "focusedView",
    controlled: l,
    default: _.current
  });
  C.useEffect(() => {
    (g.current && g.current !== n || b.current && b.current.some((H) => !a.includes(H))) && (O(a.includes(n) ? n : a[0]), b.current = a, g.current = n);
  }, [n, O, E, a]);
  const D = a.indexOf(E), N = (m = a[D - 1]) != null ? m : null, I = (h = a[D + 1]) != null ? h : null, R = Qn((H, Z) => {
    M(Z ? H : (re) => H === re ? null : re), p == null || p(H, Z);
  }), j = Qn((H) => {
    H !== E && (O(H), R(H, !0), t && t(H));
  }), U = Qn(() => {
    I && j(I), R(I, !0);
  }), q = Qn((H, Z, re) => {
    const Y = Z === "finish", K = re ? (
      // handles case like `DateTimePicker`, where a view might return a `finish` selection state
      // but we it's not the final view given all `views` -> overall selection state should be `partial`.
      a.indexOf(re) < a.length - 1
    ) : !!I;
    e(H, Y && K ? "partial" : Z), Y && U();
  }), J = Qn((H, Z, re) => {
    e(H, Z ? "partial" : "finish", re), Z && (j(Z), R(Z, !0));
  });
  return {
    view: E,
    setView: j,
    focusedView: P,
    setFocusedView: R,
    nextView: I,
    previousView: N,
    defaultView: x.current,
    goToNextView: U,
    setValueAndGoToNextView: q,
    setValueAndGoToView: J
  };
}
const nOe = ["className", "sx"], rOe = ({
  props: e,
  propsFromPickerValue: t,
  additionalViewProps: n,
  inputRef: r,
  autoFocusView: a
}) => {
  const {
    onChange: s,
    open: l,
    onSelectedSectionsChange: p,
    onClose: m
  } = t, {
    views: h,
    openTo: g,
    onViewChange: b,
    disableOpenPicker: x,
    viewRenderers: E
  } = e, O = st(e, nOe), {
    view: _,
    setView: P,
    defaultView: M,
    focusedView: D,
    setFocusedView: N,
    setValueAndGoToNextView: I
  } = c_({
    view: void 0,
    views: h,
    openTo: g,
    onChange: s,
    onViewChange: b,
    autoFocus: a
  }), {
    hasUIView: R,
    viewModeLookup: j
  } = C.useMemo(() => h.reduce((Y, K) => {
    let Q;
    return x ? Q = "field" : E[K] != null ? Q = "UI" : Q = "field", Y.viewModeLookup[K] = Q, Q === "UI" && (Y.hasUIView = !0), Y;
  }, {
    hasUIView: !1,
    viewModeLookup: {}
  }), [x, E, h]), U = C.useMemo(() => h.reduce((Y, K) => E[K] != null && GC(K) ? Y + 1 : Y, 0), [E, h]), q = j[_], J = Qn(() => q === "UI"), [H, Z] = C.useState(q === "UI" ? _ : null);
  return H !== _ && j[_] === "UI" && Z(_), m$(() => {
    q === "field" && l && (m(), p("hours"), setTimeout(() => {
      r == null || r.current.focus();
    }));
  }, [_]), m$(() => {
    if (!l)
      return;
    let Y = _;
    q === "field" && H != null && (Y = H), Y !== M && j[Y] === "UI" && j[M] === "UI" && (Y = M), Y !== _ && P(Y), N(Y, !0);
  }, [l]), {
    hasUIView: R,
    shouldRestoreFocus: J,
    layoutProps: {
      views: h,
      view: H,
      onViewChange: P
    },
    renderCurrentView: () => {
      if (H == null)
        return null;
      const Y = E[H];
      return Y == null ? null : Y(B({}, O, n, t, {
        views: h,
        onChange: I,
        view: H,
        onViewChange: P,
        focusedView: D,
        onFocusedViewChange: N,
        showViewSwitcher: U > 1,
        timeViewsCount: U
      }));
    }
  };
};
function _U() {
  return typeof window > "u" ? "portrait" : window.screen && window.screen.orientation && window.screen.orientation.angle ? Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait" : window.orientation && Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
}
const oOe = (e, t) => {
  const [n, r] = C.useState(_U);
  return ei(() => {
    const s = () => {
      r(_U());
    };
    return window.addEventListener("orientationchange", s), () => {
      window.removeEventListener("orientationchange", s);
    };
  }, []), d_e(e, ["hours", "minutes", "seconds"]) ? !1 : (t || n) === "landscape";
}, aOe = ({
  props: e,
  propsFromPickerValue: t,
  propsFromPickerViews: n,
  wrapperVariant: r
}) => {
  const {
    orientation: a
  } = e, s = oOe(n.views, a);
  return {
    layoutProps: B({}, n, t, {
      isLandscape: s,
      wrapperVariant: r,
      disabled: e.disabled,
      readOnly: e.readOnly
    })
  };
}, iOe = (e, t = "warning") => {
  let n = !1;
  const r = Array.isArray(e) ? e.join(`
`) : e;
  return () => {
    n || (n = !0, t === "error" ? console.error(r) : console.warn(r));
  };
}, sOe = iOe(["The `renderInput` prop has been removed in version 6.0 of the Date and Time Pickers.", "You can replace it with the `textField` component slot in most cases.", "For more information, please have a look at the migration guide (https://mui.com/x/migration/migration-pickers-v5/#input-renderer-required-in-v5)."]), j7 = ({
  props: e,
  valueManager: t,
  valueType: n,
  wrapperVariant: r,
  inputRef: a,
  additionalViewProps: s,
  validator: l,
  autoFocusView: p
}) => {
  process.env.NODE_ENV !== "production" && e.renderInput != null && sOe();
  const m = tOe({
    props: e,
    valueManager: t,
    valueType: n,
    wrapperVariant: r,
    validator: l
  }), h = rOe({
    props: e,
    inputRef: a,
    additionalViewProps: s,
    autoFocusView: p,
    propsFromPickerValue: m.viewProps
  }), g = aOe({
    props: e,
    wrapperVariant: r,
    propsFromPickerValue: m.layoutProps,
    propsFromPickerViews: h.layoutProps
  });
  return {
    // Picker value
    open: m.open,
    actions: m.actions,
    fieldProps: m.fieldProps,
    // Picker views
    renderCurrentView: h.renderCurrentView,
    hasUIView: h.hasUIView,
    shouldRestoreFocus: h.shouldRestoreFocus,
    // Picker layout
    layoutProps: g.layoutProps
  };
};
function L7(e) {
  return Xt("MuiPickersLayout", e);
}
const Jk = Bt("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "shortcuts"]);
function lOe(e) {
  return Xt("MuiDialogActions", e);
}
Bt("MuiDialogActions", ["root", "spacing"]);
const uOe = ["className", "disableSpacing"], cOe = (e) => {
  const {
    classes: t,
    disableSpacing: n
  } = e;
  return Kt({
    root: ["root", !n && "spacing"]
  }, lOe, t);
}, dOe = Ge("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disableSpacing && t.spacing];
  }
})(({
  ownerState: e
}) => B({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !e.disableSpacing && {
  "& > :not(:first-of-type)": {
    marginLeft: 8
  }
})), F7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDialogActions"
  }), {
    className: a,
    disableSpacing: s = !1
  } = r, l = st(r, uOe), p = B({}, r, {
    disableSpacing: s
  }), m = cOe(p);
  return /* @__PURE__ */ L.jsx(dOe, B({
    className: Wt(m.root, a),
    ownerState: p,
    ref: n
  }, l));
});
process.env.NODE_ENV !== "production" && (F7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, the actions do not have additional margin.
   * @default false
   */
  disableSpacing: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const fOe = F7, pOe = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
function z7(e) {
  const {
    onAccept: t,
    onClear: n,
    onCancel: r,
    onSetToday: a,
    actions: s
  } = e, l = st(e, pOe), p = es();
  if (s == null || s.length === 0)
    return null;
  const m = s == null ? void 0 : s.map((h) => {
    switch (h) {
      case "clear":
        return /* @__PURE__ */ L.jsx(x0, {
          onClick: n,
          children: p.clearButtonLabel
        }, h);
      case "cancel":
        return /* @__PURE__ */ L.jsx(x0, {
          onClick: r,
          children: p.cancelButtonLabel
        }, h);
      case "accept":
        return /* @__PURE__ */ L.jsx(x0, {
          onClick: t,
          children: p.okButtonLabel
        }, h);
      case "today":
        return /* @__PURE__ */ L.jsx(x0, {
          onClick: a,
          children: p.todayButtonLabel
        }, h);
      default:
        return null;
    }
  });
  return /* @__PURE__ */ L.jsx(fOe, B({}, l, {
    children: m
  }));
}
process.env.NODE_ENV !== "production" && (z7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Ordered array of actions to display.
   * If empty, does not display that action bar.
   * @default `['cancel', 'accept']` for mobile and `[]` for desktop
   */
  actions: c.arrayOf(c.oneOf(["accept", "cancel", "clear", "today"]).isRequired),
  /**
   * If `true`, the actions do not have additional margin.
   * @default false
   */
  disableSpacing: c.bool,
  onAccept: c.func.isRequired,
  onCancel: c.func.isRequired,
  onClear: c.func.isRequired,
  onSetToday: c.func.isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const V7 = /* @__PURE__ */ C.createContext({});
process.env.NODE_ENV !== "production" && (V7.displayName = "ListContext");
const bm = V7;
function mOe(e) {
  return Xt("MuiList", e);
}
Bt("MuiList", ["root", "padding", "dense", "subheader"]);
const hOe = ["children", "className", "component", "dense", "disablePadding", "subheader"], vOe = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: a
  } = e;
  return Kt({
    root: ["root", !n && "padding", r && "dense", a && "subheader"]
  }, mOe, t);
}, yOe = Ge("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})(({
  ownerState: e
}) => B({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !e.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, e.subheader && {
  paddingTop: 0
})), U7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiList"
  }), {
    children: a,
    className: s,
    component: l = "ul",
    dense: p = !1,
    disablePadding: m = !1,
    subheader: h
  } = r, g = st(r, hOe), b = C.useMemo(() => ({
    dense: p
  }), [p]), x = B({}, r, {
    component: l,
    dense: p,
    disablePadding: m
  }), E = vOe(x);
  return /* @__PURE__ */ L.jsx(bm.Provider, {
    value: b,
    children: /* @__PURE__ */ L.jsxs(yOe, B({
      as: l,
      className: Wt(E.root, s),
      ref: n,
      ownerState: x
    }, g, {
      children: [h, a]
    }))
  });
});
process.env.NODE_ENV !== "production" && (U7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: c.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: c.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const B7 = U7;
function gOe(e) {
  return Xt("MuiListItem", e);
}
const bOe = Bt("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]), Vv = bOe, wOe = Bt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]), xOe = wOe;
function SOe(e) {
  return Xt("MuiListItemSecondaryAction", e);
}
Bt("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const EOe = ["className"], COe = (e) => {
  const {
    disableGutters: t,
    classes: n
  } = e;
  return Kt({
    root: ["root", t && "disableGutters"]
  }, SOe, n);
}, TOe = Ge("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.disableGutters && t.disableGutters];
  }
})(({
  ownerState: e
}) => B({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)"
}, e.disableGutters && {
  right: 0
})), mN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiListItemSecondaryAction"
  }), {
    className: a
  } = r, s = st(r, EOe), l = C.useContext(bm), p = B({}, r, {
    disableGutters: l.disableGutters
  }), m = COe(p);
  return /* @__PURE__ */ L.jsx(TOe, B({
    className: Wt(m.root, a),
    ownerState: p,
    ref: n
  }, s));
});
process.env.NODE_ENV !== "production" && (mN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally an `IconButton` or selection control.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
mN.muiName = "ListItemSecondaryAction";
const _Oe = mN, OOe = ["className"], POe = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"], ROe = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.button && t.button, n.hasSecondaryAction && t.secondaryAction];
}, kOe = (e) => {
  const {
    alignItems: t,
    button: n,
    classes: r,
    dense: a,
    disabled: s,
    disableGutters: l,
    disablePadding: p,
    divider: m,
    hasSecondaryAction: h,
    selected: g
  } = e;
  return Kt({
    root: ["root", a && "dense", !l && "gutters", !p && "padding", m && "divider", s && "disabled", n && "button", t === "flex-start" && "alignItemsFlexStart", h && "secondaryAction", g && "selected"],
    container: ["container"]
  }, gOe, r);
}, DOe = Ge("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: ROe
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left"
}, !t.disablePadding && B({
  paddingTop: 8,
  paddingBottom: 8
}, t.dense && {
  paddingTop: 4,
  paddingBottom: 4
}, !t.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, !!t.secondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}), !!t.secondaryAction && {
  [`& > .${xOe.root}`]: {
    paddingRight: 48
  }
}, {
  [`&.${Vv.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${Vv.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${Vv.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${Vv.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  }
}, t.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, t.divider && {
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
  backgroundClip: "padding-box"
}, t.button && {
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${Vv.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  }
}, t.hasSecondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
})), $Oe = Ge("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (e, t) => t.container
})({
  position: "relative"
}), H7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiListItem"
  }), {
    alignItems: a = "center",
    autoFocus: s = !1,
    button: l = !1,
    children: p,
    className: m,
    component: h,
    components: g = {},
    componentsProps: b = {},
    ContainerComponent: x = "li",
    ContainerProps: {
      className: E
    } = {},
    dense: O = !1,
    disabled: _ = !1,
    disableGutters: P = !1,
    disablePadding: M = !1,
    divider: D = !1,
    focusVisibleClassName: N,
    secondaryAction: I,
    selected: R = !1,
    slotProps: j = {},
    slots: U = {}
  } = r, q = st(r.ContainerProps, OOe), J = st(r, POe), H = C.useContext(bm), Z = C.useMemo(() => ({
    dense: O || H.dense || !1,
    alignItems: a,
    disableGutters: P
  }), [a, H.dense, O, P]), re = C.useRef(null);
  ei(() => {
    s && (re.current ? re.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a ListItem whose component has not been rendered."));
  }, [s]);
  const Y = C.Children.toArray(p), K = Y.length && E0(Y[Y.length - 1], ["ListItemSecondaryAction"]), Q = B({}, r, {
    alignItems: a,
    autoFocus: s,
    button: l,
    dense: Z.dense,
    disabled: _,
    disableGutters: P,
    disablePadding: M,
    divider: D,
    hasSecondaryAction: K,
    selected: R
  }), te = kOe(Q), ne = yo(re, n), ae = U.root || g.Root || DOe, se = j.root || b.root || {}, V = B({
    className: Wt(te.root, se.className, m),
    disabled: _
  }, J);
  let ee = h || "li";
  return l && (V.component = h || "div", V.focusVisibleClassName = Wt(Vv.focusVisible, N), ee = ld), K ? (ee = !V.component && !h ? "div" : ee, x === "li" && (ee === "li" ? ee = "div" : V.component === "li" && (V.component = "div")), /* @__PURE__ */ L.jsx(bm.Provider, {
    value: Z,
    children: /* @__PURE__ */ L.jsxs($Oe, B({
      as: x,
      className: Wt(te.container, E),
      ref: ne,
      ownerState: Q
    }, q, {
      children: [/* @__PURE__ */ L.jsx(ae, B({}, se, !zf(ae) && {
        as: ee,
        ownerState: B({}, Q, se.ownerState)
      }, V, {
        children: Y
      })), Y.pop()]
    }))
  })) : /* @__PURE__ */ L.jsx(bm.Provider, {
    value: Z,
    children: /* @__PURE__ */ L.jsxs(ae, B({}, se, {
      as: ee,
      ref: ne
    }, !zf(ae) && {
      ownerState: B({}, Q, se.ownerState)
    }, V, {
      children: [Y, I && /* @__PURE__ */ L.jsx(_Oe, {
        children: I
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" && (H7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Defines the `align-items` style property.
   * @default 'center'
   */
  alignItems: c.oneOf(["center", "flex-start"]),
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  autoFocus: c.bool,
  /**
   * If `true`, the list item is a button (using `ButtonBase`). Props intended
   * for `ButtonBase` can then be applied to `ListItem`.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  button: c.bool,
  /**
   * The content of the component if a `ListItemSecondaryAction` is used it must
   * be the last child.
   */
  children: cd(c.node, (e) => {
    const t = C.Children.toArray(e.children);
    let n = -1;
    for (let r = t.length - 1; r >= 0; r -= 1) {
      const a = t[r];
      if (E0(a, ["ListItemSecondaryAction"])) {
        n = r;
        break;
      }
    }
    return n !== -1 && n !== t.length - 1 ? new Error("MUI: You used an element after ListItemSecondaryAction. For ListItem to detect that it has a secondary action you must pass it as the last child to ListItem.") : null;
  }),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    root: c.object
  }),
  /**
   * The container component used when a `ListItemSecondaryAction` is the last child.
   * @default 'li'
   * @deprecated
   */
  ContainerComponent: cT,
  /**
   * Props applied to the container component if used.
   * @default {}
   * @deprecated
   */
  ContainerProps: c.object,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent List component.
   * @default false
   */
  dense: c.bool,
  /**
   * If `true`, the component is disabled.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  disabled: c.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: c.bool,
  /**
   * If `true`, all padding is removed.
   * @default false
   */
  disablePadding: c.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the list item.
   * @default false
   */
  divider: c.bool,
  /**
   * @ignore
   */
  focusVisibleClassName: c.string,
  /**
   * The element to display at the end of ListItem.
   */
  secondaryAction: c.node,
  /**
   * Use to apply selected styling.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  selected: c.bool,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: c.shape({
    root: c.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    root: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const MOe = H7, NOe = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function IOe(e) {
  return Xt("MuiChip", e);
}
const AOe = Bt("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]), hr = AOe, jOe = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"], LOe = (e) => {
  const {
    classes: t,
    disabled: n,
    size: r,
    color: a,
    iconColor: s,
    onDelete: l,
    clickable: p,
    variant: m
  } = e, h = {
    root: ["root", m, n && "disabled", `size${xt(r)}`, `color${xt(a)}`, p && "clickable", p && `clickableColor${xt(a)}`, l && "deletable", l && `deletableColor${xt(a)}`, `${m}${xt(a)}`],
    label: ["label", `label${xt(r)}`],
    avatar: ["avatar", `avatar${xt(r)}`, `avatarColor${xt(a)}`],
    icon: ["icon", `icon${xt(r)}`, `iconColor${xt(s)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${xt(r)}`, `deleteIconColor${xt(a)}`, `deleteIcon${xt(m)}Color${xt(a)}`]
  };
  return Kt(h, IOe, t);
}, FOe = Ge("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e, {
      color: r,
      iconColor: a,
      clickable: s,
      onDelete: l,
      size: p,
      variant: m
    } = n;
    return [{
      [`& .${hr.avatar}`]: t.avatar
    }, {
      [`& .${hr.avatar}`]: t[`avatar${xt(p)}`]
    }, {
      [`& .${hr.avatar}`]: t[`avatarColor${xt(r)}`]
    }, {
      [`& .${hr.icon}`]: t.icon
    }, {
      [`& .${hr.icon}`]: t[`icon${xt(p)}`]
    }, {
      [`& .${hr.icon}`]: t[`iconColor${xt(a)}`]
    }, {
      [`& .${hr.deleteIcon}`]: t.deleteIcon
    }, {
      [`& .${hr.deleteIcon}`]: t[`deleteIcon${xt(p)}`]
    }, {
      [`& .${hr.deleteIcon}`]: t[`deleteIconColor${xt(r)}`]
    }, {
      [`& .${hr.deleteIcon}`]: t[`deleteIcon${xt(m)}Color${xt(r)}`]
    }, t.root, t[`size${xt(p)}`], t[`color${xt(r)}`], s && t.clickable, s && r !== "default" && t[`clickableColor${xt(r)})`], l && t.deletable, l && r !== "default" && t[`deletableColor${xt(r)}`], t[m], t[`${m}${xt(r)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  const n = e.palette.mode === "light" ? e.palette.grey[700] : e.palette.grey[300];
  return B({
    maxWidth: "100%",
    fontFamily: e.typography.fontFamily,
    fontSize: e.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (e.vars || e).palette.text.primary,
    backgroundColor: (e.vars || e).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: e.transitions.create(["background-color", "box-shadow"]),
    // label will inherit this from root, then `clickable` class overrides this for both
    cursor: "default",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${hr.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${hr.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : n,
      fontSize: e.typography.pxToRem(12)
    },
    [`& .${hr.avatarColorPrimary}`]: {
      color: (e.vars || e).palette.primary.contrastText,
      backgroundColor: (e.vars || e).palette.primary.dark
    },
    [`& .${hr.avatarColorSecondary}`]: {
      color: (e.vars || e).palette.secondary.contrastText,
      backgroundColor: (e.vars || e).palette.secondary.dark
    },
    [`& .${hr.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: e.typography.pxToRem(10)
    },
    [`& .${hr.icon}`]: B({
      marginLeft: 5,
      marginRight: -6
    }, t.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, t.iconColor === t.color && B({
      color: e.vars ? e.vars.palette.Chip.defaultIconColor : n
    }, t.color !== "default" && {
      color: "inherit"
    })),
    [`& .${hr.deleteIcon}`]: B({
      WebkitTapHighlightColor: "transparent",
      color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : Wn(e.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : Wn(e.palette.text.primary, 0.4)
      }
    }, t.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, t.color !== "default" && {
      color: e.vars ? `rgba(${e.vars.palette[t.color].contrastTextChannel} / 0.7)` : Wn(e.palette[t.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (e.vars || e).palette[t.color].contrastText
      }
    })
  }, t.size === "small" && {
    height: 24
  }, t.color !== "default" && {
    backgroundColor: (e.vars || e).palette[t.color].main,
    color: (e.vars || e).palette[t.color].contrastText
  }, t.onDelete && {
    [`&.${hr.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Wn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  }, t.onDelete && t.color !== "default" && {
    [`&.${hr.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette[t.color].dark
    }
  });
}, ({
  theme: e,
  ownerState: t
}) => B({}, t.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Wn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
  },
  [`&.${hr.focusVisible}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Wn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (e.vars || e).shadows[1]
  }
}, t.clickable && t.color !== "default" && {
  [`&:hover, &.${hr.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette[t.color].dark
  }
}), ({
  theme: e,
  ownerState: t
}) => B({}, t.variant === "outlined" && {
  backgroundColor: "transparent",
  border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === "light" ? e.palette.grey[400] : e.palette.grey[700]}`,
  [`&.${hr.clickable}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${hr.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`& .${hr.avatar}`]: {
    marginLeft: 4
  },
  [`& .${hr.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${hr.icon}`]: {
    marginLeft: 4
  },
  [`& .${hr.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${hr.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${hr.deleteIconSmall}`]: {
    marginRight: 3
  }
}, t.variant === "outlined" && t.color !== "default" && {
  color: (e.vars || e).palette[t.color].main,
  border: `1px solid ${e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : Wn(e.palette[t.color].main, 0.7)}`,
  [`&.${hr.clickable}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette[t.color].main, e.palette.action.hoverOpacity)
  },
  [`&.${hr.focusVisible}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.focusOpacity})` : Wn(e.palette[t.color].main, e.palette.action.focusOpacity)
  },
  [`& .${hr.deleteIcon}`]: {
    color: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : Wn(e.palette[t.color].main, 0.7),
    "&:hover, &:active": {
      color: (e.vars || e).palette[t.color].main
    }
  }
})), zOe = Ge("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e, {
      size: r
    } = n;
    return [t.label, t[`label${xt(r)}`]];
  }
})(({
  ownerState: e
}) => B({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, e.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}));
function OU(e) {
  return e.key === "Backspace" || e.key === "Delete";
}
const W7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiChip"
  }), {
    avatar: a,
    className: s,
    clickable: l,
    color: p = "default",
    component: m,
    deleteIcon: h,
    disabled: g = !1,
    icon: b,
    label: x,
    onClick: E,
    onDelete: O,
    onKeyDown: _,
    onKeyUp: P,
    size: M = "medium",
    variant: D = "filled",
    tabIndex: N,
    skipFocusWhenDisabled: I = !1
    // TODO v6: Rename to `focusableWhenDisabled`.
  } = r, R = st(r, jOe), j = C.useRef(null), U = yo(j, n), q = (se) => {
    se.stopPropagation(), O && O(se);
  }, J = (se) => {
    se.currentTarget === se.target && OU(se) && se.preventDefault(), _ && _(se);
  }, H = (se) => {
    se.currentTarget === se.target && (O && OU(se) ? O(se) : se.key === "Escape" && j.current && j.current.blur()), P && P(se);
  }, Z = l !== !1 && E ? !0 : l, re = Z || O ? ld : m || "div", Y = B({}, r, {
    component: re,
    disabled: g,
    size: M,
    color: p,
    iconColor: /* @__PURE__ */ C.isValidElement(b) && b.props.color || p,
    onDelete: !!O,
    clickable: Z,
    variant: D
  }), K = LOe(Y), Q = re === ld ? B({
    component: m || "div",
    focusVisibleClassName: K.focusVisible
  }, O && {
    disableRipple: !0
  }) : {};
  let te = null;
  O && (te = h && /* @__PURE__ */ C.isValidElement(h) ? /* @__PURE__ */ C.cloneElement(h, {
    className: Wt(h.props.className, K.deleteIcon),
    onClick: q
  }) : /* @__PURE__ */ L.jsx(NOe, {
    className: Wt(K.deleteIcon),
    onClick: q
  }));
  let ne = null;
  a && /* @__PURE__ */ C.isValidElement(a) && (ne = /* @__PURE__ */ C.cloneElement(a, {
    className: Wt(K.avatar, a.props.className)
  }));
  let ae = null;
  return b && /* @__PURE__ */ C.isValidElement(b) && (ae = /* @__PURE__ */ C.cloneElement(b, {
    className: Wt(K.icon, b.props.className)
  })), process.env.NODE_ENV !== "production" && ne && ae && console.error("MUI: The Chip component can not handle the avatar and the icon prop at the same time. Pick one."), /* @__PURE__ */ L.jsxs(FOe, B({
    as: re,
    className: Wt(K.root, s),
    disabled: Z && g ? !0 : void 0,
    onClick: E,
    onKeyDown: J,
    onKeyUp: H,
    ref: U,
    tabIndex: I && g ? -1 : N,
    ownerState: Y
  }, Q, R, {
    children: [ne || ae, /* @__PURE__ */ L.jsx(zOe, {
      className: Wt(K.label),
      ownerState: Y,
      children: x
    }), te]
  }));
});
process.env.NODE_ENV !== "production" && (W7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The Avatar element to display.
   */
  avatar: c.element,
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: y3,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, the chip will appear clickable, and will raise when pressed,
   * even if the onClick prop is not defined.
   * If `false`, the chip will not appear clickable, even if onClick prop is defined.
   * This can be used, for example,
   * along with the component prop to indicate an anchor Chip is clickable.
   * Note: this controls the UI and does not affect the onClick event.
   */
  clickable: c.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: c.oneOfType([c.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * Override the default delete icon element. Shown only if `onDelete` is set.
   */
  deleteIcon: c.element,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * Icon element.
   */
  icon: c.element,
  /**
   * The content of the component.
   */
  label: c.node,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * Callback fired when the delete icon is clicked.
   * If set, the delete icon will be shown.
   */
  onDelete: c.func,
  /**
   * @ignore
   */
  onKeyDown: c.func,
  /**
   * @ignore
   */
  onKeyUp: c.func,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: c.oneOfType([c.oneOf(["medium", "small"]), c.string]),
  /**
   * If `true`, allows the disabled chip to escape focus.
   * If `false`, allows the disabled chip to receive focus.
   * @default false
   */
  skipFocusWhenDisabled: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * @ignore
   */
  tabIndex: c.number,
  /**
   * The variant to use.
   * @default 'filled'
   */
  variant: c.oneOfType([c.oneOf(["filled", "outlined"]), c.string])
});
const VOe = W7, UOe = ["items", "isLandscape", "onChange", "isValid"];
function Y7(e) {
  const {
    items: t,
    onChange: n,
    isValid: r
  } = e, a = st(e, UOe);
  if (t == null || t.length === 0)
    return null;
  const s = t.map((l) => {
    const p = l.getValue({
      isValid: r
    });
    return {
      label: l.label,
      onClick: () => {
        n(p);
      },
      disabled: !r(p)
    };
  });
  return /* @__PURE__ */ L.jsx(B7, B({
    dense: !0,
    sx: [{
      maxHeight: y7,
      maxWidth: 200,
      overflow: "auto"
    }, ...Array.isArray(a.sx) ? a.sx : [a.sx]]
  }, a, {
    children: s.map((l) => /* @__PURE__ */ L.jsx(MOe, {
      children: /* @__PURE__ */ L.jsx(VOe, B({}, l))
    }, l.label))
  }));
}
process.env.NODE_ENV !== "production" && (Y7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  className: c.string,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: c.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: c.bool,
  isLandscape: c.bool.isRequired,
  isValid: c.func.isRequired,
  /**
   * Ordered array of shortcuts to display.
   * If empty, does not display the shortcuts.
   * @default `[]`
   */
  items: c.arrayOf(c.shape({
    getValue: c.func.isRequired,
    label: c.string.isRequired
  })),
  onChange: c.func.isRequired,
  style: c.object,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
function BOe(e) {
  return e.view !== null;
}
const HOe = (e) => {
  const {
    classes: t,
    isLandscape: n
  } = e;
  return Kt({
    root: ["root", n && "landscape"],
    contentWrapper: ["contentWrapper"],
    toolbar: ["toolbar"],
    actionBar: ["actionBar"],
    tabs: ["tabs"],
    landscape: ["landscape"],
    shortcuts: ["shortcuts"]
  }, L7, t);
}, WOe = (e) => {
  var t, n;
  const {
    wrapperVariant: r,
    onAccept: a,
    onClear: s,
    onCancel: l,
    onSetToday: p,
    view: m,
    views: h,
    onViewChange: g,
    value: b,
    onChange: x,
    isValid: E,
    isLandscape: O,
    disabled: _,
    readOnly: P,
    children: M,
    components: D,
    componentsProps: N,
    slots: I,
    slotProps: R
    // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
    // The true type should be
    // - For pickers value: TDate | null
    // - For rangepickers value: [TDate | null, TDate | null]
  } = e, j = I ?? o_(D), U = R ?? N, q = HOe(e), J = (t = j == null ? void 0 : j.actionBar) != null ? t : z7, H = Gr({
    elementType: J,
    externalSlotProps: U == null ? void 0 : U.actionBar,
    additionalProps: {
      onAccept: a,
      onClear: s,
      onCancel: l,
      onSetToday: p,
      actions: r === "desktop" ? [] : ["cancel", "accept"],
      className: q.actionBar
    },
    ownerState: B({}, e, {
      wrapperVariant: r
    })
  }), Z = /* @__PURE__ */ L.jsx(J, B({}, H)), re = j == null ? void 0 : j.toolbar, Y = Gr({
    elementType: re,
    externalSlotProps: U == null ? void 0 : U.toolbar,
    additionalProps: {
      isLandscape: O,
      onChange: x,
      value: b,
      view: m,
      onViewChange: g,
      views: h,
      disabled: _,
      readOnly: P,
      className: q.toolbar
    },
    ownerState: B({}, e, {
      wrapperVariant: r
    })
  }), K = BOe(Y) && re ? /* @__PURE__ */ L.jsx(re, B({}, Y)) : null, Q = M, te = j == null ? void 0 : j.tabs, ne = m && te ? /* @__PURE__ */ L.jsx(te, B({
    view: m,
    onViewChange: g
  }, U == null ? void 0 : U.tabs)) : null, ae = (n = j == null ? void 0 : j.shortcuts) != null ? n : Y7, se = Gr({
    elementType: ae,
    externalSlotProps: U == null ? void 0 : U.shortcuts,
    additionalProps: {
      isValid: E,
      isLandscape: O,
      onChange: x,
      className: q.shortcuts
    },
    ownerState: {
      isValid: E,
      isLandscape: O,
      onChange: x,
      className: q.shortcuts,
      wrapperVariant: r
    }
  }), V = m && ae ? /* @__PURE__ */ L.jsx(ae, B({}, se)) : null;
  return {
    toolbar: K,
    content: Q,
    tabs: ne,
    actionBar: Z,
    shortcuts: V
  };
}, YOe = WOe, qOe = (e) => {
  const {
    isLandscape: t,
    classes: n
  } = e;
  return Kt({
    root: ["root", t && "landscape"],
    contentWrapper: ["contentWrapper"]
  }, L7, n);
}, q7 = Ge("div", {
  name: "MuiPickersLayout",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => ({
  display: "grid",
  gridAutoColumns: "max-content auto max-content",
  gridAutoRows: "max-content auto max-content",
  [`& .${Jk.toolbar}`]: t.isLandscape ? {
    gridColumn: e.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  } : {
    gridColumn: "2 / 4",
    gridRow: 1
  },
  [`.${Jk.shortcuts}`]: t.isLandscape ? {
    gridColumn: "2 / 4",
    gridRow: 1
  } : {
    gridColumn: e.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  },
  [`& .${Jk.actionBar}`]: {
    gridColumn: "1 / 4",
    gridRow: 3
  }
}));
q7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: c.elementType,
  ownerState: c.shape({
    isLandscape: c.bool.isRequired
  }).isRequired,
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
};
const GOe = Ge("div", {
  name: "MuiPickersLayout",
  slot: "ContentWrapper",
  overridesResolver: (e, t) => t.contentWrapper
})({
  gridColumn: 2,
  gridRow: 2,
  display: "flex",
  flexDirection: "column"
}), hN = function(t) {
  const n = Lt({
    props: t,
    name: "MuiPickersLayout"
  }), {
    toolbar: r,
    content: a,
    tabs: s,
    actionBar: l,
    shortcuts: p
  } = YOe(n), {
    sx: m,
    className: h,
    isLandscape: g,
    ref: b,
    wrapperVariant: x
  } = n, E = n, O = qOe(E);
  return /* @__PURE__ */ L.jsxs(q7, {
    ref: b,
    sx: m,
    className: Ao(h, O.root),
    ownerState: E,
    children: [g ? p : r, g ? r : p, /* @__PURE__ */ L.jsx(GOe, {
      className: O.contentWrapper,
      children: x === "desktop" ? /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [a, s]
      }) : /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [s, a]
      })
    }), l]
  });
};
process.env.NODE_ENV !== "production" && (hN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  children: c.node,
  classes: c.object,
  className: c.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  disabled: c.bool,
  isLandscape: c.bool.isRequired,
  isValid: c.func.isRequired,
  onAccept: c.func.isRequired,
  onCancel: c.func.isRequired,
  onChange: c.func.isRequired,
  onClear: c.func.isRequired,
  onClose: c.func.isRequired,
  onDismiss: c.func.isRequired,
  onOpen: c.func.isRequired,
  onSetToday: c.func.isRequired,
  onViewChange: c.func.isRequired,
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  value: c.any,
  view: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  views: c.arrayOf(c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired).isRequired,
  wrapperVariant: c.oneOf(["desktop", "mobile"])
});
function KOe(e, {
  disableFuture: t,
  maxDate: n
}) {
  const r = or();
  return C.useMemo(() => {
    const a = r.date(), s = r.startOfMonth(t && r.isBefore(a, n) ? a : n);
    return !r.isAfter(s, e);
  }, [t, n, e, r]);
}
function XOe(e, {
  disablePast: t,
  minDate: n
}) {
  const r = or();
  return C.useMemo(() => {
    const a = r.date(), s = r.startOfMonth(t && r.isAfter(a, n) ? a : n);
    return !r.isBefore(s, e);
  }, [t, n, e, r]);
}
function vN(e, t, n, r) {
  const a = or(), s = e1e(e, a), l = C.useCallback((p) => {
    const m = e == null ? null : t1e(e, p, !!t, a);
    n(m, r ?? "partial");
  }, [t, e, n, r, a]);
  return {
    meridiemMode: s,
    handleMeridiemChange: l
  };
}
const h$ = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"], v$ = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableClock", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"], G7 = ["minDateTime", "maxDateTime"], QOe = [...h$, ...v$, ...G7], d_ = (e) => QOe.reduce((t, n) => (e.hasOwnProperty(n) && (t[n] = e[n]), t), {}), ZOe = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "readOnly", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef"], K7 = (e, t) => {
  const n = B({}, e), r = {}, a = (s) => {
    n.hasOwnProperty(s) && (r[s] = n[s], delete n[s]);
  };
  return ZOe.forEach(a), t === "date" ? h$.forEach(a) : t === "time" ? v$.forEach(a) : t === "date-time" && (h$.forEach(a), v$.forEach(a), G7.forEach(a)), {
    forwardedProps: n,
    internalProps: r
  };
}, JOe = typeof navigator < "u" && /(android)/i.test(navigator.userAgent), Sw = ({
  props: e,
  value: t,
  adapter: n
}) => {
  if (t === null)
    return null;
  const r = n.utils.date(), a = ni(n.utils, e.minDate, n.defaultDates.minDate), s = ni(n.utils, e.maxDate, n.defaultDates.maxDate);
  switch (!0) {
    case !n.utils.isValid(t):
      return "invalidDate";
    case !!(e.shouldDisableDate && e.shouldDisableDate(t)):
      return "shouldDisableDate";
    case !!(e.shouldDisableMonth && e.shouldDisableMonth(t)):
      return "shouldDisableMonth";
    case !!(e.shouldDisableYear && e.shouldDisableYear(t)):
      return "shouldDisableYear";
    case !!(e.disableFuture && n.utils.isAfterDay(t, r)):
      return "disableFuture";
    case !!(e.disablePast && n.utils.isBeforeDay(t, r)):
      return "disablePast";
    case !!(a && n.utils.isBeforeDay(t, a)):
      return "minDate";
    case !!(s && n.utils.isAfterDay(t, s)):
      return "maxDate";
    default:
      return null;
  }
}, ePe = ({
  adapter: e,
  value: t,
  props: n
}) => {
  const {
    minTime: r,
    maxTime: a,
    minutesStep: s,
    shouldDisableClock: l,
    shouldDisableTime: p,
    disableIgnoringDatePartForTimeValidation: m = !1,
    disablePast: h,
    disableFuture: g
  } = n, b = e.utils.date(), x = e.utils.date(t), E = e_(m, e.utils);
  if (t === null)
    return null;
  switch (!0) {
    case !e.utils.isValid(t):
      return "invalidDate";
    case !!(r && E(r, t)):
      return "minTime";
    case !!(a && E(t, a)):
      return "maxTime";
    case !!(g && e.utils.isAfter(x, b)):
      return "disableFuture";
    case !!(h && e.utils.isBefore(x, b)):
      return "disablePast";
    case !!(p && p(t, "hours")):
      return "shouldDisableTime-hours";
    case !!(p && p(t, "minutes")):
      return "shouldDisableTime-minutes";
    case !!(p && p(t, "seconds")):
      return "shouldDisableTime-seconds";
    case !!(l && l(e.utils.getHours(t), "hours")):
      return "shouldDisableClock-hours";
    case !!(l && l(e.utils.getMinutes(t), "minutes")):
      return "shouldDisableClock-minutes";
    case !!(l && l(e.utils.getSeconds(t), "seconds")):
      return "shouldDisableClock-seconds";
    case !!(s && e.utils.getMinutes(t) % s !== 0):
      return "minutesStep";
    default:
      return null;
  }
}, yN = ({
  props: e,
  value: t,
  adapter: n
}) => {
  const r = Sw({
    adapter: n,
    value: t,
    props: e
  });
  return r !== null ? r : ePe({
    adapter: n,
    value: t,
    props: e
  });
}, tPe = (e) => Xt("MuiPickersFadeTransitionGroup", e);
Bt("MuiPickersFadeTransitionGroup", ["root"]);
const nPe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, tPe, t);
}, PU = 500, rPe = Ge(dN, {
  name: "MuiPickersFadeTransitionGroup",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "block",
  position: "relative"
});
function X7(e) {
  const t = Lt({
    props: e,
    name: "MuiPickersFadeTransitionGroup"
  }), {
    children: n,
    className: r,
    reduceAnimations: a,
    transKey: s
  } = t, l = nPe(t);
  return a ? n : /* @__PURE__ */ L.jsx(rPe, {
    className: Ao(l.root, r),
    children: /* @__PURE__ */ L.jsx(xw, {
      appear: !1,
      mountOnEnter: !0,
      unmountOnExit: !0,
      timeout: {
        appear: PU,
        enter: PU / 2,
        exit: 0
      },
      children: n
    }, s)
  });
}
const oPe = (e) => Xt("MuiPickersCalendarHeader", e), aPe = Bt("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]), iPe = ["ownerState"], sPe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  }, oPe, t);
}, lPe = Ge("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 16,
  marginBottom: 8,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 30,
  minHeight: 30
}), uPe = Ge("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (e, t) => t.labelContainer
})(({
  theme: e
}) => B({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, e.typography.body1, {
  fontWeight: e.typography.fontWeightMedium
})), cPe = Ge("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (e, t) => t.label
})({
  marginRight: 6
}), dPe = Ge(Jc, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (e, t) => t.switchViewButton
})(({
  ownerState: e
}) => B({
  marginRight: "auto"
}, e.view === "year" && {
  [`.${aPe.switchViewIcon}`]: {
    transform: "rotate(180deg)"
  }
})), fPe = Ge(pTe, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (e, t) => t.switchViewIcon
})(({
  theme: e
}) => ({
  willChange: "transform",
  transition: e.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
function pPe(e) {
  var t, n;
  const r = es(), a = or(), s = Lt({
    props: e,
    name: "MuiPickersCalendarHeader"
  }), {
    slots: l,
    slotProps: p,
    currentMonth: m,
    disabled: h,
    disableFuture: g,
    disablePast: b,
    maxDate: x,
    minDate: E,
    onMonthChange: O,
    onViewChange: _,
    view: P,
    reduceAnimations: M,
    views: D,
    labelId: N
  } = s, I = s, R = sPe(s), j = (t = l == null ? void 0 : l.switchViewButton) != null ? t : dPe, U = Gr({
    elementType: j,
    externalSlotProps: p == null ? void 0 : p.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": r.calendarViewSwitchingButtonAriaLabel(P)
    },
    ownerState: I,
    className: R.switchViewButton
  }), q = (n = l == null ? void 0 : l.switchViewIcon) != null ? n : fPe, J = Gr({
    elementType: q,
    externalSlotProps: p == null ? void 0 : p.switchViewIcon,
    ownerState: void 0,
    className: R.switchViewIcon
  }), H = st(J, iPe), Z = () => O(a.addMonths(m, 1), "left"), re = () => O(a.addMonths(m, -1), "right"), Y = KOe(m, {
    disableFuture: g,
    maxDate: x
  }), K = XOe(m, {
    disablePast: b,
    minDate: E
  }), Q = () => {
    if (!(D.length === 1 || !_ || h))
      if (D.length === 2)
        _(D.find((te) => te !== P) || D[0]);
      else {
        const te = D.indexOf(P) !== 0 ? 0 : 1;
        _(D[te]);
      }
  };
  return D.length === 1 && D[0] === "year" ? null : /* @__PURE__ */ L.jsxs(lPe, {
    ownerState: I,
    className: R.root,
    children: [/* @__PURE__ */ L.jsxs(uPe, {
      role: "presentation",
      onClick: Q,
      ownerState: I,
      "aria-live": "polite",
      className: R.labelContainer,
      children: [/* @__PURE__ */ L.jsx(X7, {
        reduceAnimations: M,
        transKey: a.format(m, "monthAndYear"),
        children: /* @__PURE__ */ L.jsx(cPe, {
          id: N,
          ownerState: I,
          className: R.label,
          children: a.format(m, "monthAndYear")
        })
      }), D.length > 1 && !h && /* @__PURE__ */ L.jsx(j, B({}, U, {
        children: /* @__PURE__ */ L.jsx(q, B({}, H))
      }))]
    }), /* @__PURE__ */ L.jsx(xw, {
      in: P === "day",
      children: /* @__PURE__ */ L.jsx(a7, {
        slots: l,
        slotProps: p,
        onGoToPrevious: re,
        isPreviousDisabled: K,
        previousLabel: r.previousMonth,
        onGoToNext: Z,
        isNextDisabled: Y,
        nextLabel: r.nextMonth
      })
    })]
  });
}
function mPe(e) {
  return Xt("MuiPickersDay", e);
}
const tm = Bt("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]), hPe = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"], vPe = (e) => {
  const {
    selected: t,
    disableMargin: n,
    disableHighlightToday: r,
    today: a,
    disabled: s,
    outsideCurrentMonth: l,
    showDaysOutsideCurrentMonth: p,
    classes: m
  } = e;
  return Kt({
    root: ["root", t && "selected", s && "disabled", !n && "dayWithMargin", !r && a && "today", l && p && "dayOutsideMonth", l && !p && "hiddenDaySpacingFiller"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  }, mPe, m);
}, Q7 = ({
  theme: e,
  ownerState: t
}) => B({}, e.typography.caption, {
  width: J0,
  height: J0,
  borderRadius: "50%",
  padding: 0,
  // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
  backgroundColor: "transparent",
  color: (e.vars || e).palette.text.primary,
  "@media (pointer: fine)": {
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.primary.main, e.palette.action.hoverOpacity)
    }
  },
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.focusOpacity})` : Wn(e.palette.primary.main, e.palette.action.focusOpacity),
    [`&.${tm.selected}`]: {
      willChange: "background-color",
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  },
  [`&.${tm.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    fontWeight: e.typography.fontWeightMedium,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      willChange: "background-color",
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  },
  [`&.${tm.disabled}:not(.${tm.selected})`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${tm.disabled}&.${tm.selected}`]: {
    opacity: 0.6
  }
}, !t.disableMargin && {
  margin: `0 ${l_}px`
}, t.outsideCurrentMonth && t.showDaysOutsideCurrentMonth && {
  color: (e.vars || e).palette.text.secondary
}, !t.disableHighlightToday && t.today && {
  [`&:not(.${tm.selected})`]: {
    border: `1px solid ${(e.vars || e).palette.text.secondary}`
  }
}), Z7 = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, !n.disableMargin && t.dayWithMargin, !n.disableHighlightToday && n.today && t.today, !n.outsideCurrentMonth && n.showDaysOutsideCurrentMonth && t.dayOutsideMonth, n.outsideCurrentMonth && !n.showDaysOutsideCurrentMonth && t.hiddenDaySpacingFiller];
}, yPe = Ge(ld, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: Z7
})(Q7), gPe = Ge("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: Z7
})(({
  theme: e,
  ownerState: t
}) => B({}, Q7({
  theme: e,
  ownerState: t
}), {
  // visibility: 'hidden' does not work here as it hides the element from screen readers as well
  opacity: 0,
  pointerEvents: "none"
})), c0 = () => {
}, J7 = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiPickersDay"
  }), {
    autoFocus: a = !1,
    className: s,
    day: l,
    disabled: p = !1,
    disableHighlightToday: m = !1,
    disableMargin: h = !1,
    isAnimating: g,
    onClick: b,
    onDaySelect: x,
    onFocus: E = c0,
    onBlur: O = c0,
    onKeyDown: _ = c0,
    onMouseDown: P = c0,
    onMouseEnter: M = c0,
    outsideCurrentMonth: D,
    selected: N = !1,
    showDaysOutsideCurrentMonth: I = !1,
    children: R,
    today: j = !1
  } = r, U = st(r, hPe), q = B({}, r, {
    autoFocus: a,
    disabled: p,
    disableHighlightToday: m,
    disableMargin: h,
    selected: N,
    showDaysOutsideCurrentMonth: I,
    today: j
  }), J = vPe(q), H = or(), Z = C.useRef(null), re = yo(Z, n);
  ei(() => {
    a && !p && !g && !D && Z.current.focus();
  }, [a, p, g, D]);
  const Y = (Q) => {
    P(Q), D && Q.preventDefault();
  }, K = (Q) => {
    p || x(l), D && Q.currentTarget.focus(), b && b(Q);
  };
  return D && !I ? /* @__PURE__ */ L.jsx(gPe, {
    className: Ao(J.root, J.hiddenDaySpacingFiller, s),
    ownerState: q,
    role: U.role
  }) : /* @__PURE__ */ L.jsx(yPe, B({
    className: Ao(J.root, s),
    ref: re,
    centerRipple: !0,
    disabled: p,
    tabIndex: N ? 0 : -1,
    onKeyDown: (Q) => _(Q, l),
    onFocus: (Q) => E(Q, l),
    onBlur: (Q) => O(Q, l),
    onMouseEnter: (Q) => M(Q, l),
    onClick: K,
    onMouseDown: Y
  }, U, {
    ownerState: q,
    children: R || H.format(l, "dayOfMonth")
  }));
});
process.env.NODE_ENV !== "production" && (J7.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: c.oneOfType([c.func, c.shape({
    current: c.shape({
      focusVisible: c.func.isRequired
    })
  })]),
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  className: c.string,
  /**
   * The date to show.
   */
  day: c.any.isRequired,
  /**
   * If `true`, renders as disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, days are rendering without margin. Useful for displaying linked range of days.
   * @default false
   */
  disableMargin: c.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: c.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: c.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: c.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: c.string,
  isAnimating: c.bool,
  /**
   * If `true`, day is the first visible cell of the month.
   * Either the first day of the month or the first day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isFirstVisibleCell: c.bool.isRequired,
  /**
   * If `true`, day is the last visible cell of the month.
   * Either the last day of the month or the last day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isLastVisibleCell: c.bool.isRequired,
  onBlur: c.func,
  onDaySelect: c.func.isRequired,
  onFocus: c.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: c.func,
  onKeyDown: c.func,
  onMouseEnter: c.func,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: c.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: c.bool,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  style: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * @default 0
   */
  tabIndex: c.number,
  /**
   * If `true`, renders as today date.
   * @default false
   */
  today: c.bool,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: c.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: c.oneOfType([c.func, c.shape({
    current: c.shape({
      pulsate: c.func.isRequired,
      start: c.func.isRequired,
      stop: c.func.isRequired
    })
  })])
});
const bPe = /* @__PURE__ */ C.memo(J7), wPe = (e) => Xt("MuiPickersSlideTransition", e), Us = Bt("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]), xPe = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"], SPe = (e) => {
  const {
    classes: t,
    slideDirection: n
  } = e, r = {
    root: ["root"],
    exit: ["slideExit"],
    enterActive: ["slideEnterActive"],
    enter: [`slideEnter-${n}`],
    exitActive: [`slideExitActiveLeft-${n}`]
  };
  return Kt(r, wPe, t);
}, eY = 350, EPe = Ge(dN, {
  name: "MuiPickersSlideTransition",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`.${Us["slideEnter-left"]}`]: t["slideEnter-left"]
  }, {
    [`.${Us["slideEnter-right"]}`]: t["slideEnter-right"]
  }, {
    [`.${Us.slideEnterActive}`]: t.slideEnterActive
  }, {
    [`.${Us.slideExit}`]: t.slideExit
  }, {
    [`.${Us["slideExitActiveLeft-left"]}`]: t["slideExitActiveLeft-left"]
  }, {
    [`.${Us["slideExitActiveLeft-right"]}`]: t["slideExitActiveLeft-right"]
  }]
})(({
  theme: e
}) => {
  const t = e.transitions.create("transform", {
    duration: eY,
    easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
  });
  return {
    display: "block",
    position: "relative",
    overflowX: "hidden",
    "& > *": {
      position: "absolute",
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${Us["slideEnter-left"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      zIndex: 1
    },
    [`& .${Us["slideEnter-right"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      zIndex: 1
    },
    [`& .${Us.slideEnterActive}`]: {
      transform: "translate(0%)",
      transition: t
    },
    [`& .${Us.slideExit}`]: {
      transform: "translate(0%)"
    },
    [`& .${Us["slideExitActiveLeft-left"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      transition: t,
      zIndex: 0
    },
    [`& .${Us["slideExitActiveLeft-right"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      transition: t,
      zIndex: 0
    }
  };
});
function CPe(e) {
  const t = Lt({
    props: e,
    name: "MuiPickersSlideTransition"
  }), {
    children: n,
    className: r,
    reduceAnimations: a,
    transKey: s
    // extracting `classes` from `other`
  } = t, l = st(t, xPe), p = SPe(t);
  if (a)
    return /* @__PURE__ */ L.jsx("div", {
      className: Ao(p.root, r),
      children: n
    });
  const m = {
    exit: p.exit,
    enterActive: p.enterActive,
    enter: p.enter,
    exitActive: p.exitActive
  };
  return /* @__PURE__ */ L.jsx(EPe, {
    className: Ao(p.root, r),
    childFactory: (h) => /* @__PURE__ */ C.cloneElement(h, {
      classNames: m
    }),
    role: "presentation",
    children: /* @__PURE__ */ L.jsx(ACe, B({
      mountOnEnter: !0,
      unmountOnExit: !0,
      timeout: eY,
      classNames: m
    }, l, {
      children: n
    }), s)
  });
}
const tY = ({
  shouldDisableDate: e,
  shouldDisableMonth: t,
  shouldDisableYear: n,
  minDate: r,
  maxDate: a,
  disableFuture: s,
  disablePast: l
}) => {
  const p = Im();
  return C.useCallback((m) => Sw({
    adapter: p,
    value: m,
    props: {
      shouldDisableDate: e,
      shouldDisableMonth: t,
      shouldDisableYear: n,
      minDate: r,
      maxDate: a,
      disableFuture: s,
      disablePast: l
    }
  }) !== null, [p, e, t, n, r, a, s, l]);
}, TPe = (e) => Xt("MuiDayCalendar", e);
Bt("MuiDayCalendar", ["header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
const _Pe = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], OPe = ["ownerState"], PPe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    header: ["header"],
    weekDayLabel: ["weekDayLabel"],
    loadingContainer: ["loadingContainer"],
    slideTransition: ["slideTransition"],
    monthContainer: ["monthContainer"],
    weekContainer: ["weekContainer"],
    weekNumberLabel: ["weekNumberLabel"],
    weekNumber: ["weekNumber"]
  }, TPe, t);
}, RPe = (e) => e.charAt(0).toUpperCase(), nY = (J0 + l_ * 2) * 6, kPe = Ge("div", {
  name: "MuiDayCalendar",
  slot: "Header",
  overridesResolver: (e, t) => t.header
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}), DPe = Ge(nc, {
  name: "MuiDayCalendar",
  slot: "WeekDayLabel",
  overridesResolver: (e, t) => t.weekDayLabel
})(({
  theme: e
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: (e.vars || e).palette.text.secondary
})), $Pe = Ge(nc, {
  name: "MuiDayPicker",
  slot: "WeekNumberLabel",
  overridesResolver: (e, t) => t.weekNumberLabel
})(({
  theme: e
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: e.palette.text.disabled
})), MPe = Ge(nc, {
  name: "MuiDayPicker",
  slot: "WeekNumber",
  overridesResolver: (e, t) => t.weekNumber
})(({
  theme: e
}) => B({}, e.typography.caption, {
  width: J0,
  height: J0,
  padding: 0,
  margin: `0 ${l_}px`,
  color: e.palette.text.disabled,
  fontSize: "0.75rem",
  alignItems: "center",
  justifyContent: "center",
  display: "inline-flex"
})), NPe = Ge("div", {
  name: "MuiDayCalendar",
  slot: "LoadingContainer",
  overridesResolver: (e, t) => t.loadingContainer
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  minHeight: nY
}), IPe = Ge(CPe, {
  name: "MuiDayCalendar",
  slot: "SlideTransition",
  overridesResolver: (e, t) => t.slideTransition
})({
  minHeight: nY
}), APe = Ge("div", {
  name: "MuiDayCalendar",
  slot: "MonthContainer",
  overridesResolver: (e, t) => t.monthContainer
})({
  overflow: "hidden"
}), jPe = Ge("div", {
  name: "MuiDayCalendar",
  slot: "WeekContainer",
  overridesResolver: (e, t) => t.weekContainer
})({
  margin: `${l_}px 0`,
  display: "flex",
  justifyContent: "center"
});
function LPe(e) {
  var t, n, r;
  let {
    parentProps: a,
    day: s,
    focusableDay: l,
    selectedDays: p,
    isDateDisabled: m,
    currentMonthNumber: h,
    isViewFocused: g
  } = e, b = st(e, _Pe);
  const x = or(), E = jm(), {
    disabled: O,
    disableHighlightToday: _,
    isMonthSwitchingAnimating: P,
    showDaysOutsideCurrentMonth: M,
    components: D,
    componentsProps: N,
    slots: I,
    slotProps: R
  } = a, j = l !== null && x.isSameDay(s, l), U = p.some((te) => x.isSameDay(te, s)), q = x.isSameDay(s, E), J = (t = (n = I == null ? void 0 : I.day) != null ? n : D == null ? void 0 : D.Day) != null ? t : bPe, H = Gr({
    elementType: J,
    externalSlotProps: (r = R == null ? void 0 : R.day) != null ? r : N == null ? void 0 : N.day,
    additionalProps: B({
      disableHighlightToday: _,
      showDaysOutsideCurrentMonth: M,
      role: "gridcell",
      isAnimating: P,
      // it is used in date range dragging logic by accessing `dataset.timestamp`
      "data-timestamp": x.toJsDate(s).valueOf()
    }, b),
    ownerState: B({}, a, {
      day: s,
      selected: U
    })
  }), Z = st(H, OPe), re = C.useMemo(() => O || m(s), [O, m, s]), Y = C.useMemo(() => x.getMonth(s) !== h, [x, s, h]), K = C.useMemo(() => {
    const te = x.startOfMonth(x.setMonth(s, h));
    return M ? x.isSameDay(s, x.startOfWeek(te)) : x.isSameDay(s, te);
  }, [h, s, M, x]), Q = C.useMemo(() => {
    const te = x.endOfMonth(x.setMonth(s, h));
    return M ? x.isSameDay(s, x.endOfWeek(te)) : x.isSameDay(s, te);
  }, [h, s, M, x]);
  return /* @__PURE__ */ L.jsx(J, B({}, Z, {
    day: s,
    disabled: re,
    autoFocus: g && j,
    today: q,
    outsideCurrentMonth: Y,
    isFirstVisibleCell: K,
    isLastVisibleCell: Q,
    selected: U,
    tabIndex: j ? 0 : -1,
    "aria-selected": U,
    "aria-current": q ? "date" : void 0
  }));
}
function FPe(e) {
  const t = jm(), n = or(), r = Lt({
    props: e,
    name: "MuiDayCalendar"
  }), a = PPe(r), l = Ji().direction === "rtl", {
    onFocusedDayChange: p,
    className: m,
    currentMonth: h,
    selectedDays: g,
    focusedDay: b,
    loading: x,
    onSelectedDaysChange: E,
    onMonthSwitchingAnimationEnd: O,
    readOnly: _,
    reduceAnimations: P,
    renderLoading: M = () => /* @__PURE__ */ L.jsx("span", {
      children: "..."
    }),
    slideDirection: D,
    TransitionProps: N,
    disablePast: I,
    disableFuture: R,
    minDate: j,
    maxDate: U,
    shouldDisableDate: q,
    shouldDisableMonth: J,
    shouldDisableYear: H,
    dayOfWeekFormatter: Z = RPe,
    hasFocus: re,
    onFocusedViewChange: Y,
    gridLabelId: K,
    displayWeekNumber: Q,
    fixedWeekNumber: te,
    autoFocus: ne
  } = r, ae = tY({
    shouldDisableDate: q,
    shouldDisableMonth: J,
    shouldDisableYear: H,
    minDate: j,
    maxDate: U,
    disablePast: I,
    disableFuture: R
  }), se = es(), [V, ee] = tl({
    name: "DayCalendar",
    state: "hasFocus",
    controlled: re,
    default: ne ?? !1
  }), [he, ue] = C.useState(() => b || t), fe = Qn((oe) => {
    _ || E(oe);
  }), Ce = (oe) => {
    ae(oe) || (p(oe), ue(oe), Y == null || Y(!0), ee(!0));
  }, Se = Qn((oe, de) => {
    switch (oe.key) {
      case "ArrowUp":
        Ce(n.addDays(de, -7)), oe.preventDefault();
        break;
      case "ArrowDown":
        Ce(n.addDays(de, 7)), oe.preventDefault();
        break;
      case "ArrowLeft": {
        const we = n.addDays(de, l ? 1 : -1), Me = n.addMonths(de, l ? 1 : -1), Ae = k0({
          utils: n,
          date: we,
          minDate: l ? we : n.startOfMonth(Me),
          maxDate: l ? n.endOfMonth(Me) : we,
          isDateDisabled: ae
        });
        Ce(Ae || we), oe.preventDefault();
        break;
      }
      case "ArrowRight": {
        const we = n.addDays(de, l ? -1 : 1), Me = n.addMonths(de, l ? -1 : 1), Ae = k0({
          utils: n,
          date: we,
          minDate: l ? n.startOfMonth(Me) : we,
          maxDate: l ? we : n.endOfMonth(Me),
          isDateDisabled: ae
        });
        Ce(Ae || we), oe.preventDefault();
        break;
      }
      case "Home":
        Ce(n.startOfWeek(de)), oe.preventDefault();
        break;
      case "End":
        Ce(n.endOfWeek(de)), oe.preventDefault();
        break;
      case "PageUp":
        Ce(n.addMonths(de, 1)), oe.preventDefault();
        break;
      case "PageDown":
        Ce(n.addMonths(de, -1)), oe.preventDefault();
        break;
    }
  }), Te = Qn((oe, de) => Ce(de)), pe = Qn((oe, de) => {
    V && n.isSameDay(he, de) && (Y == null || Y(!1));
  }), ye = n.getMonth(h), Oe = C.useMemo(() => g.filter((oe) => !!oe).map((oe) => n.startOfDay(oe)), [n, g]), Fe = ye, me = C.useMemo(() => /* @__PURE__ */ C.createRef(), [Fe]), Pe = n.startOfWeek(t), Ee = C.useMemo(() => {
    const oe = n.startOfMonth(h), de = n.endOfMonth(h);
    return ae(he) || n.isAfterDay(he, de) || n.isBeforeDay(he, oe) ? k0({
      utils: n,
      date: he,
      minDate: oe,
      maxDate: de,
      disablePast: I,
      disableFuture: R,
      isDateDisabled: ae
    }) : he;
  }, [h, R, I, he, ae, n]), Ke = C.useMemo(() => {
    const oe = n.getWeekArray(h);
    let de = n.addMonths(h, 1);
    for (; te && oe.length < te; ) {
      const we = n.getWeekArray(de), Me = n.isSameDay(oe[oe.length - 1][0], we[0][0]);
      we.slice(Me ? 1 : 0).forEach((Ae) => {
        oe.length < te && oe.push(Ae);
      }), de = n.addMonths(de, 1);
    }
    return oe;
  }, [h, te, n]);
  return /* @__PURE__ */ L.jsxs("div", {
    role: "grid",
    "aria-labelledby": K,
    children: [/* @__PURE__ */ L.jsxs(kPe, {
      role: "row",
      className: a.header,
      children: [Q && /* @__PURE__ */ L.jsx($Pe, {
        variant: "caption",
        role: "columnheader",
        "aria-label": se.calendarWeekNumberHeaderLabel,
        className: a.weekNumberLabel,
        children: se.calendarWeekNumberHeaderText
      }), n.getWeekdays().map((oe, de) => {
        var we;
        return /* @__PURE__ */ L.jsx(DPe, {
          variant: "caption",
          role: "columnheader",
          "aria-label": n.format(n.addDays(Pe, de), "weekday"),
          className: a.weekDayLabel,
          children: (we = Z == null ? void 0 : Z(oe)) != null ? we : oe
        }, oe + de.toString());
      })]
    }), x ? /* @__PURE__ */ L.jsx(NPe, {
      className: a.loadingContainer,
      children: M()
    }) : /* @__PURE__ */ L.jsx(IPe, B({
      transKey: Fe,
      onExited: O,
      reduceAnimations: P,
      slideDirection: D,
      className: Ao(m, a.slideTransition)
    }, N, {
      nodeRef: me,
      children: /* @__PURE__ */ L.jsx(APe, {
        ref: me,
        role: "rowgroup",
        className: a.monthContainer,
        children: Ke.map((oe, de) => /* @__PURE__ */ L.jsxs(jPe, {
          role: "row",
          className: a.weekContainer,
          "aria-rowindex": de + 1,
          children: [Q && /* @__PURE__ */ L.jsx(MPe, {
            className: a.weekNumber,
            role: "rowheader",
            "aria-label": se.calendarWeekNumberAriaLabelText(n.getWeekNumber(oe[0])),
            children: se.calendarWeekNumberText(n.getWeekNumber(oe[0]))
          }), oe.map((we, Me) => /* @__PURE__ */ L.jsx(LPe, {
            parentProps: r,
            day: we,
            selectedDays: Oe,
            focusableDay: Ee,
            onKeyDown: Se,
            onFocus: Te,
            onBlur: pe,
            onDaySelect: fe,
            isDateDisabled: ae,
            currentMonthNumber: ye,
            isViewFocused: V,
            "aria-colindex": Me + 1
          }, we.toString()))]
        }, `week-${oe[0]}`))
      })
    }))]
  });
}
const zPe = (e, t, n) => (r, a) => {
  switch (a.type) {
    case "changeMonth":
      return B({}, r, {
        slideDirection: a.direction,
        currentMonth: a.newMonth,
        isMonthSwitchingAnimating: !e
      });
    case "finishMonthSwitchingAnimation":
      return B({}, r, {
        isMonthSwitchingAnimating: !1
      });
    case "changeFocusedDay": {
      if (r.focusedDay != null && a.focusedDay != null && n.isSameDay(a.focusedDay, r.focusedDay))
        return r;
      const s = a.focusedDay != null && !t && !n.isSameMonth(r.currentMonth, a.focusedDay);
      return B({}, r, {
        focusedDay: a.focusedDay,
        isMonthSwitchingAnimating: s && !e && !a.withoutMonthSwitchingAnimation,
        currentMonth: s ? n.startOfMonth(a.focusedDay) : r.currentMonth,
        slideDirection: a.focusedDay != null && n.isAfterDay(a.focusedDay, r.currentMonth) ? "left" : "right"
      });
    }
    default:
      throw new Error("missing support");
  }
}, VPe = ({
  value: e,
  defaultCalendarMonth: t,
  disableFuture: n,
  disablePast: r,
  disableSwitchToMonthOnDayFocus: a = !1,
  maxDate: s,
  minDate: l,
  onMonthChange: p,
  reduceAnimations: m,
  shouldDisableDate: h
}) => {
  var g;
  const b = jm(), x = or(), E = C.useRef(zPe(!!m, a, x)).current, [O, _] = C.useReducer(E, {
    isMonthSwitchingAnimating: !1,
    focusedDay: e || b,
    currentMonth: x.startOfMonth((g = e ?? t) != null ? g : XSe(x, b, l, s)),
    slideDirection: "left"
  }), P = C.useCallback((R) => {
    _(B({
      type: "changeMonth"
    }, R)), p && p(R.newMonth);
  }, [p]), M = C.useCallback((R) => {
    const j = R;
    x.isSameMonth(j, O.currentMonth) || P({
      newMonth: x.startOfMonth(j),
      direction: x.isAfterDay(j, O.currentMonth) ? "left" : "right"
    });
  }, [O.currentMonth, P, x]), D = tY({
    shouldDisableDate: h,
    minDate: l,
    maxDate: s,
    disableFuture: n,
    disablePast: r
  }), N = C.useCallback(() => {
    _({
      type: "finishMonthSwitchingAnimation"
    });
  }, []), I = Qn((R, j) => {
    D(R) || _({
      type: "changeFocusedDay",
      focusedDay: R,
      withoutMonthSwitchingAnimation: j
    });
  });
  return {
    calendarState: O,
    changeMonth: M,
    changeFocusedDay: I,
    isDateDisabled: D,
    onMonthSwitchingAnimationEnd: N,
    handleChangeMonth: P
  };
}, rY = /* @__PURE__ */ C.createContext(void 0);
process.env.NODE_ENV !== "production" && (rY.displayName = "FormControlContext");
const f_ = rY;
function Lm() {
  return C.useContext(f_);
}
function UPe(e) {
  return Xt("MuiInputAdornment", e);
}
const BPe = Bt("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]), RU = BPe;
var kU;
const HPe = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"], WPe = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, t[`position${xt(n.position)}`], n.disablePointerEvents === !0 && t.disablePointerEvents, t[n.variant]];
}, YPe = (e) => {
  const {
    classes: t,
    disablePointerEvents: n,
    hiddenLabel: r,
    position: a,
    size: s,
    variant: l
  } = e, p = {
    root: ["root", n && "disablePointerEvents", a && `position${xt(a)}`, l, r && "hiddenLabel", s && `size${xt(s)}`]
  };
  return Kt(p, UPe, t);
}, qPe = Ge("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: WPe
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "flex",
  height: "0.01em",
  // Fix IE11 flexbox alignment. To remove at some point.
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (e.vars || e).palette.action.active
}, t.variant === "filled" && {
  // Styles applied to the root element if `variant="filled"`.
  [`&.${RU.positionStart}&:not(.${RU.hiddenLabel})`]: {
    marginTop: 16
  }
}, t.position === "start" && {
  // Styles applied to the root element if `position="start"`.
  marginRight: 8
}, t.position === "end" && {
  // Styles applied to the root element if `position="end"`.
  marginLeft: 8
}, t.disablePointerEvents === !0 && {
  // Styles applied to the root element if `disablePointerEvents={true}`.
  pointerEvents: "none"
})), oY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiInputAdornment"
  }), {
    children: a,
    className: s,
    component: l = "div",
    disablePointerEvents: p = !1,
    disableTypography: m = !1,
    position: h,
    variant: g
  } = r, b = st(r, HPe), x = Lm() || {};
  let E = g;
  g && x.variant && process.env.NODE_ENV !== "production" && g === x.variant && console.error("MUI: The `InputAdornment` variant infers the variant prop you do not have to provide one."), x && !E && (E = x.variant);
  const O = B({}, r, {
    hiddenLabel: x.hiddenLabel,
    size: x.size,
    disablePointerEvents: p,
    position: h,
    variant: E
  }), _ = YPe(O);
  return /* @__PURE__ */ L.jsx(f_.Provider, {
    value: null,
    children: /* @__PURE__ */ L.jsx(qPe, B({
      as: l,
      ownerState: O,
      className: Wt(_.root, s),
      ref: n
    }, b, {
      children: typeof a == "string" && !m ? /* @__PURE__ */ L.jsx(nc, {
        color: "text.secondary",
        children: a
      }) : /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [h === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          kU || (kU = /* @__PURE__ */ L.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : null, a]
      })
    }))
  });
});
process.env.NODE_ENV !== "production" && (oY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally an `IconButton` or string.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * Disable pointer events on the root.
   * This allows for the content of the adornment to focus the `input` on click.
   * @default false
   */
  disablePointerEvents: c.bool,
  /**
   * If children is a string then disable wrapping in a Typography component.
   * @default false
   */
  disableTypography: c.bool,
  /**
   * The position this adornment should appear relative to the `Input`.
   */
  position: c.oneOf(["end", "start"]).isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   * Note: If you are using the `TextField` component or the `FormControl` component
   * you do not have to set this manually.
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
const GPe = oY;
var aY = {};
Object.defineProperty(aY, "__esModule", {
  value: !0
});
var iY = aY.default = QPe, y$ = KPe(C);
function sY(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (sY = function(r) {
    return r ? n : t;
  })(e);
}
function KPe(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = sY(t);
  if (n && n.has(e))
    return n.get(e);
  var r = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, s) : null;
      l && (l.get || l.set) ? Object.defineProperty(r, s, l) : r[s] = e[s];
    }
  return r.default = e, n && n.set(e, r), r;
}
let DU = 0;
function XPe(e) {
  const [t, n] = y$.useState(e), r = e || t;
  return y$.useEffect(() => {
    t == null && (DU += 1, n(`mui-${DU}`));
  }, [t]), r;
}
const $U = y$["useId".toString()];
function QPe(e) {
  if ($U !== void 0) {
    const t = $U();
    return e ?? t;
  }
  return XPe(e);
}
const ZPe = ["props", "getOpenDialogAriaText"], JPe = ["ownerState"], eRe = ["ownerState"], lY = (e) => {
  var t, n, r, a, s;
  let {
    props: l,
    getOpenDialogAriaText: p
  } = e, m = st(e, ZPe);
  const {
    slots: h,
    slotProps: g,
    className: b,
    sx: x,
    format: E,
    formatDensity: O,
    label: _,
    inputRef: P,
    readOnly: M,
    disabled: D,
    autoFocus: N,
    localeText: I
  } = l, R = or(), j = C.useRef(null), U = C.useRef(null), q = iY(), J = (t = g == null || (n = g.toolbar) == null ? void 0 : n.hidden) != null ? t : !1, {
    open: H,
    actions: Z,
    hasUIView: re,
    layoutProps: Y,
    renderCurrentView: K,
    shouldRestoreFocus: Q,
    fieldProps: te
  } = j7(B({}, m, {
    props: l,
    inputRef: j,
    autoFocusView: !0,
    additionalViewProps: {},
    wrapperVariant: "desktop"
  })), ne = (r = h.inputAdornment) != null ? r : GPe, ae = Gr({
    elementType: ne,
    externalSlotProps: g == null ? void 0 : g.inputAdornment,
    additionalProps: {
      position: "end"
    },
    ownerState: l
  }), se = st(ae, JPe), V = (a = h.openPickerButton) != null ? a : Jc, ee = Gr({
    elementType: V,
    externalSlotProps: g == null ? void 0 : g.openPickerButton,
    additionalProps: {
      disabled: D || M,
      onClick: Z.onOpen,
      "aria-label": p(te.value, R),
      edge: se.position
    },
    ownerState: l
  }), he = st(ee, eRe), ue = h.openPickerIcon, fe = h.field, Ce = Gr({
    elementType: fe,
    externalSlotProps: g == null ? void 0 : g.field,
    additionalProps: B({}, te, J && {
      id: q
    }, {
      readOnly: M,
      disabled: D,
      className: b,
      sx: x,
      format: E,
      formatDensity: O,
      label: _,
      autoFocus: N && !l.open,
      focused: H ? !0 : void 0
    }),
    ownerState: l
  });
  re && (Ce.InputProps = B({}, Ce.InputProps, {
    ref: U,
    [`${se.position}Adornment`]: /* @__PURE__ */ L.jsx(ne, B({}, se, {
      children: /* @__PURE__ */ L.jsx(V, B({}, he, {
        children: /* @__PURE__ */ L.jsx(ue, B({}, g == null ? void 0 : g.openPickerIcon))
      }))
    }))
  }));
  const Se = B({
    textField: h.textField
  }, Ce.slots), Te = (s = h.layout) != null ? s : hN, pe = u_(j, Ce.inputRef, P);
  let ye = q;
  J && (_ ? ye = `${q}-label` : ye = void 0);
  const Oe = B({}, g, {
    toolbar: B({}, g == null ? void 0 : g.toolbar, {
      titleId: q
    }),
    popper: B({
      "aria-labelledby": ye
    }, g == null ? void 0 : g.popper)
  });
  return {
    renderPicker: () => /* @__PURE__ */ L.jsxs(gw, {
      localeText: I,
      children: [/* @__PURE__ */ L.jsx(fe, B({}, Ce, {
        slots: Se,
        slotProps: Oe,
        inputRef: pe
      })), /* @__PURE__ */ L.jsx(g_e, B({
        role: "dialog",
        placement: "bottom-start",
        anchorEl: U.current
      }, Z, {
        open: H,
        slots: h,
        slotProps: Oe,
        shouldRestoreFocus: Q,
        children: /* @__PURE__ */ L.jsx(Te, B({}, Y, Oe == null ? void 0 : Oe.layout, {
          slots: h,
          slotProps: Oe,
          children: K()
        }))
      }))]
    })
  };
};
function Iy({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, a) => (r[a] = e[a], n && typeof e[a] > "u" && (r[a] = n[a]), r), {});
}
function uY(e) {
  return /* @__PURE__ */ L.jsx(V3, B({}, e, {
    defaultTheme: DT,
    themeId: cy
  }));
}
process.env.NODE_ENV !== "production" && (uY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The styles you want to apply globally.
   */
  styles: c.oneOfType([c.array, c.func, c.number, c.object, c.string, c.bool])
});
function MU(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function tT(e, t = !1) {
  return e && (MU(e.value) && e.value !== "" || t && MU(e.defaultValue) && e.defaultValue !== "");
}
function tRe(e) {
  return e.startAdornment;
}
function nRe(e) {
  return Xt("MuiInputBase", e);
}
const rRe = Bt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]), Ey = rRe, oRe = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"], p_ = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${xt(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, m_ = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, aRe = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: a,
    endAdornment: s,
    focused: l,
    formControl: p,
    fullWidth: m,
    hiddenLabel: h,
    multiline: g,
    readOnly: b,
    size: x,
    startAdornment: E,
    type: O
  } = e, _ = {
    root: ["root", `color${xt(n)}`, r && "disabled", a && "error", m && "fullWidth", l && "focused", p && "formControl", x === "small" && "sizeSmall", g && "multiline", E && "adornedStart", s && "adornedEnd", h && "hiddenLabel", b && "readOnly"],
    input: ["input", r && "disabled", O === "search" && "inputTypeSearch", g && "inputMultiline", x === "small" && "inputSizeSmall", h && "inputHiddenLabel", E && "inputAdornedStart", s && "inputAdornedEnd", b && "readOnly"]
  };
  return Kt(_, nRe, t);
}, h_ = Ge("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: p_
})(({
  theme: e,
  ownerState: t
}) => B({}, e.typography.body1, {
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Ey.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  }
}, t.multiline && B({
  padding: "4px 0 5px"
}, t.size === "small" && {
  paddingTop: 1
}), t.fullWidth && {
  width: "100%"
})), v_ = Ge("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: m_
})(({
  theme: e,
  ownerState: t
}) => {
  const n = e.palette.mode === "light", r = B({
    color: "currentColor"
  }, e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  }, {
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }), a = {
    opacity: "0 !important"
  }, s = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  };
  return B({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": r,
    "&::-moz-placeholder": r,
    // Firefox 19+
    "&:-ms-input-placeholder": r,
    // IE11
    "&::-ms-input-placeholder": r,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Ey.formControl} &`]: {
      "&::-webkit-input-placeholder": a,
      "&::-moz-placeholder": a,
      // Firefox 19+
      "&:-ms-input-placeholder": a,
      // IE11
      "&::-ms-input-placeholder": a,
      // Edge
      "&:focus::-webkit-input-placeholder": s,
      "&:focus::-moz-placeholder": s,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": s,
      // IE11
      "&:focus::-ms-input-placeholder": s
      // Edge
    },
    [`&.${Ey.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, t.size === "small" && {
    paddingTop: 1
  }, t.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, t.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
}), iRe = /* @__PURE__ */ L.jsx(uY, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
}), cY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r;
  const a = Lt({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": s,
    autoComplete: l,
    autoFocus: p,
    className: m,
    components: h = {},
    componentsProps: g = {},
    defaultValue: b,
    disabled: x,
    disableInjectingGlobalStyles: E,
    endAdornment: O,
    fullWidth: _ = !1,
    id: P,
    inputComponent: M = "input",
    inputProps: D = {},
    inputRef: N,
    maxRows: I,
    minRows: R,
    multiline: j = !1,
    name: U,
    onBlur: q,
    onChange: J,
    onClick: H,
    onFocus: Z,
    onKeyDown: re,
    onKeyUp: Y,
    placeholder: K,
    readOnly: Q,
    renderSuffix: te,
    rows: ne,
    slotProps: ae = {},
    slots: se = {},
    startAdornment: V,
    type: ee = "text",
    value: he
  } = a, ue = st(a, oRe), fe = D.value != null ? D.value : he, {
    current: Ce
  } = C.useRef(fe != null), Se = C.useRef(), Te = C.useCallback((kt) => {
    process.env.NODE_ENV !== "production" && kt && kt.nodeName !== "INPUT" && !kt.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), pe = yo(Se, N, D.ref, Te), [ye, Oe] = C.useState(!1), Fe = Lm();
  process.env.NODE_ENV !== "production" && C.useEffect(() => {
    if (Fe)
      return Fe.registerEffect();
  }, [Fe]);
  const me = Iy({
    props: a,
    muiFormControl: Fe,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  me.focused = Fe ? Fe.focused : ye, C.useEffect(() => {
    !Fe && x && ye && (Oe(!1), q && q());
  }, [Fe, x, ye, q]);
  const Pe = Fe && Fe.onFilled, Ee = Fe && Fe.onEmpty, Ke = C.useCallback((kt) => {
    tT(kt) ? Pe && Pe() : Ee && Ee();
  }, [Pe, Ee]);
  ei(() => {
    Ce && Ke({
      value: fe
    });
  }, [fe, Ke, Ce]);
  const oe = (kt) => {
    if (me.disabled) {
      kt.stopPropagation();
      return;
    }
    Z && Z(kt), D.onFocus && D.onFocus(kt), Fe && Fe.onFocus ? Fe.onFocus(kt) : Oe(!0);
  }, de = (kt) => {
    q && q(kt), D.onBlur && D.onBlur(kt), Fe && Fe.onBlur ? Fe.onBlur(kt) : Oe(!1);
  }, we = (kt, ...St) => {
    if (!Ce) {
      const cn = kt.target || Se.current;
      if (cn == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : jf(1));
      Ke({
        value: cn.value
      });
    }
    D.onChange && D.onChange(kt, ...St), J && J(kt, ...St);
  };
  C.useEffect(() => {
    Ke(Se.current);
  }, []);
  const Me = (kt) => {
    Se.current && kt.currentTarget === kt.target && Se.current.focus(), H && !me.disabled && H(kt);
  };
  let Ae = M, je = D;
  j && Ae === "input" && (ne ? (process.env.NODE_ENV !== "production" && (R || I) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), je = B({
    type: void 0,
    minRows: ne,
    maxRows: ne
  }, je)) : je = B({
    type: void 0,
    maxRows: I,
    minRows: R
  }, je), Ae = JEe);
  const qe = (kt) => {
    Ke(kt.animationName === "mui-auto-fill-cancel" ? Se.current : {
      value: "x"
    });
  };
  C.useEffect(() => {
    Fe && Fe.setAdornedStart(!!V);
  }, [Fe, V]);
  const ot = B({}, a, {
    color: me.color || "primary",
    disabled: me.disabled,
    endAdornment: O,
    error: me.error,
    focused: me.focused,
    formControl: Fe,
    fullWidth: _,
    hiddenLabel: me.hiddenLabel,
    multiline: j,
    size: me.size,
    startAdornment: V,
    type: ee
  }), et = aRe(ot), ct = se.root || h.Root || h_, Qt = ae.root || g.root || {}, Ht = se.input || h.Input || v_;
  return je = B({}, je, (r = ae.input) != null ? r : g.input), /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [!E && iRe, /* @__PURE__ */ L.jsxs(ct, B({}, Qt, !zf(ct) && {
      ownerState: B({}, ot, Qt.ownerState)
    }, {
      ref: n,
      onClick: Me
    }, ue, {
      className: Wt(et.root, Qt.className, m, Q && "MuiInputBase-readOnly"),
      children: [V, /* @__PURE__ */ L.jsx(f_.Provider, {
        value: null,
        children: /* @__PURE__ */ L.jsx(Ht, B({
          ownerState: ot,
          "aria-invalid": me.error,
          "aria-describedby": s,
          autoComplete: l,
          autoFocus: p,
          defaultValue: b,
          disabled: me.disabled,
          id: P,
          onAnimationStart: qe,
          name: U,
          placeholder: K,
          readOnly: Q,
          required: me.required,
          rows: ne,
          value: fe,
          onKeyDown: re,
          onKeyUp: Y,
          type: ee
        }, je, !zf(Ht) && {
          as: Ae,
          ownerState: B({}, ot, je.ownerState)
        }, {
          ref: pe,
          className: Wt(et.input, je.className, Q && "MuiInputBase-readOnly"),
          onBlur: de,
          onChange: we,
          onFocus: oe
        }))
      }), O, te ? te(B({}, me, {
        startAdornment: V
      })) : null]
    }))]
  });
});
process.env.NODE_ENV !== "production" && (cY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  "aria-describedby": c.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: c.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Input: c.elementType,
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: c.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: c.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: c.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: c.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The id of the `input` element.
   */
  id: c.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: cT,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: il,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: c.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: c.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: c.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * @ignore
   */
  onFocus: c.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: c.func,
  /**
   * @ignore
   */
  onKeyDown: c.func,
  /**
   * @ignore
   */
  onKeyUp: c.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: c.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: c.bool,
  /**
   * @ignore
   */
  renderSuffix: c.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: c.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: c.oneOfType([c.number, c.string]),
  /**
   * The size of the component.
   */
  size: c.oneOfType([c.oneOf(["medium", "small"]), c.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    input: c.elementType,
    root: c.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: c.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: c.any
});
const y_ = cY;
function sRe(e) {
  return Xt("MuiInput", e);
}
const lRe = B({}, Ey, Bt("MuiInput", ["root", "underline", "input"])), d0 = lRe, uRe = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"], cRe = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, a = Kt({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, sRe, t);
  return B({}, t, a);
}, dRe = Ge(h_, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...p_(e, t), !n.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  let r = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (r = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), B({
    position: "relative"
  }, t.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(e.vars || e).palette[t.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${d0.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${d0.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${r}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${d0.disabled}, .${d0.error}):before`]: {
      borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${r}`
      }
    },
    [`&.${d0.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
}), fRe = Ge(v_, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: m_
})({}), gN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l;
  const p = Lt({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: m,
    components: h = {},
    componentsProps: g,
    fullWidth: b = !1,
    inputComponent: x = "input",
    multiline: E = !1,
    slotProps: O,
    slots: _ = {},
    type: P = "text"
  } = p, M = st(p, uRe), D = cRe(p), I = {
    root: {
      ownerState: {
        disableUnderline: m
      }
    }
  }, R = O ?? g ? Ks(O ?? g, I) : I, j = (r = (a = _.root) != null ? a : h.Root) != null ? r : dRe, U = (s = (l = _.input) != null ? l : h.Input) != null ? s : fRe;
  return /* @__PURE__ */ L.jsx(y_, B({
    slots: {
      root: j,
      input: U
    },
    slotProps: R,
    fullWidth: b,
    inputComponent: x,
    multiline: E,
    ref: n,
    type: P
  }, M, {
    classes: D
  }));
});
process.env.NODE_ENV !== "production" && (gN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: c.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary"]), c.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Input: c.elementType,
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: c.bool,
  /**
   * If `true`, the `input` will not have an underline.
   */
  disableUnderline: c.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: c.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: c.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The id of the `input` element.
   */
  id: c.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: c.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: il,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: c.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: c.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: c.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: c.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: c.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: c.oneOfType([c.number, c.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    input: c.elementType,
    root: c.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: c.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: c.any
});
gN.muiName = "Input";
const dY = gN;
function pRe(e) {
  return Xt("MuiFilledInput", e);
}
const mRe = B({}, Ey, Bt("MuiFilledInput", ["root", "underline", "input"])), nm = mRe, hRe = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"], vRe = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, a = Kt({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, pRe, t);
  return B({}, t, a);
}, yRe = Ge(h_, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...p_(e, t), !n.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var n;
  const r = e.palette.mode === "light", a = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", s = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", l = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", p = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return B({
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : l,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s
      }
    },
    [`&.${nm.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s
    },
    [`&.${nm.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : p
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(n = (e.vars || e).palette[t.color || "primary"]) == null ? void 0 : n.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${nm.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${nm.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : a}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${nm.disabled}, .${nm.error}):before`]: {
      borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
    },
    [`&.${nm.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, t.startAdornment && {
    paddingLeft: 12
  }, t.endAdornment && {
    paddingRight: 12
  }, t.multiline && B({
    padding: "25px 12px 8px"
  }, t.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, t.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
}), gRe = Ge(v_, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: m_
})(({
  theme: e,
  ownerState: t
}) => B({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, t.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, t.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
}, t.hiddenLabel && t.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
})), bN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l;
  const p = Lt({
    props: t,
    name: "MuiFilledInput"
  }), {
    components: m = {},
    componentsProps: h,
    fullWidth: g = !1,
    // declare here to prevent spreading to DOM
    inputComponent: b = "input",
    multiline: x = !1,
    slotProps: E,
    slots: O = {},
    type: _ = "text"
  } = p, P = st(p, hRe), M = B({}, p, {
    fullWidth: g,
    inputComponent: b,
    multiline: x,
    type: _
  }), D = vRe(p), N = {
    root: {
      ownerState: M
    },
    input: {
      ownerState: M
    }
  }, I = E ?? h ? Ks(E ?? h, N) : N, R = (r = (a = O.root) != null ? a : m.Root) != null ? r : yRe, j = (s = (l = O.input) != null ? l : m.Input) != null ? s : gRe;
  return /* @__PURE__ */ L.jsx(y_, B({
    slots: {
      root: R,
      input: j
    },
    componentsProps: I,
    fullWidth: g,
    inputComponent: b,
    multiline: x,
    ref: n,
    type: _
  }, P, {
    classes: D
  }));
});
process.env.NODE_ENV !== "production" && (bN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: c.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary"]), c.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Input: c.elementType,
    Root: c.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: c.bool,
  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: c.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: c.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: c.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: c.bool,
  /**
   * The id of the `input` element.
   */
  id: c.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: c.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: il,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: c.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: c.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: c.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: c.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: c.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: c.oneOfType([c.number, c.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: c.shape({
    input: c.object,
    root: c.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    input: c.elementType,
    root: c.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: c.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: c.any
});
bN.muiName = "Input";
const fY = bN;
var NU;
const bRe = ["children", "classes", "className", "label", "notched"], wRe = Ge("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), xRe = Ge("legend")(({
  ownerState: e,
  theme: t
}) => B({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !e.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: t.transitions.create("width", {
    duration: 150,
    easing: t.transitions.easing.easeOut
  })
}, e.withLabel && B({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: t.transitions.create("max-width", {
    duration: 50,
    easing: t.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, e.notched && {
  maxWidth: "100%",
  transition: t.transitions.create("max-width", {
    duration: 100,
    easing: t.transitions.easing.easeOut,
    delay: 50
  })
})));
function pY(e) {
  const {
    className: t,
    label: n,
    notched: r
  } = e, a = st(e, bRe), s = n != null && n !== "", l = B({}, e, {
    notched: r,
    withLabel: s
  });
  return /* @__PURE__ */ L.jsx(wRe, B({
    "aria-hidden": !0,
    className: t,
    ownerState: l
  }, a, {
    children: /* @__PURE__ */ L.jsx(xRe, {
      ownerState: l,
      children: s ? /* @__PURE__ */ L.jsx("span", {
        children: n
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        NU || (NU = /* @__PURE__ */ L.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  }));
}
process.env.NODE_ENV !== "production" && (pY.propTypes = {
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The label.
   */
  label: c.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: c.bool.isRequired,
  /**
   * @ignore
   */
  style: c.object
});
function SRe(e) {
  return Xt("MuiOutlinedInput", e);
}
const ERe = B({}, Ey, Bt("MuiOutlinedInput", ["root", "notchedOutline", "input"])), Tf = ERe, CRe = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"], TRe = (e) => {
  const {
    classes: t
  } = e, r = Kt({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, SRe, t);
  return B({}, t, r);
}, _Re = Ge(h_, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: p_
})(({
  theme: e,
  ownerState: t
}) => {
  const n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return B({
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${Tf.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Tf.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : n
      }
    },
    [`&.${Tf.focused} .${Tf.notchedOutline}`]: {
      borderColor: (e.vars || e).palette[t.color].main,
      borderWidth: 2
    },
    [`&.${Tf.error} .${Tf.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.error.main
    },
    [`&.${Tf.disabled} .${Tf.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.action.disabled
    }
  }, t.startAdornment && {
    paddingLeft: 14
  }, t.endAdornment && {
    paddingRight: 14
  }, t.multiline && B({
    padding: "16.5px 14px"
  }, t.size === "small" && {
    padding: "8.5px 14px"
  }));
}), ORe = Ge(pY, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
}), PRe = Ge(v_, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: m_
})(({
  theme: e,
  ownerState: t
}) => B({
  padding: "16.5px 14px"
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  padding: "8.5px 14px"
}, t.multiline && {
  padding: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
})), wN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l, p;
  const m = Lt({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: h = {},
    fullWidth: g = !1,
    inputComponent: b = "input",
    label: x,
    multiline: E = !1,
    notched: O,
    slots: _ = {},
    type: P = "text"
  } = m, M = st(m, CRe), D = TRe(m), N = Lm(), I = Iy({
    props: m,
    muiFormControl: N,
    states: ["required"]
  }), R = B({}, m, {
    color: I.color || "primary",
    disabled: I.disabled,
    error: I.error,
    focused: I.focused,
    formControl: N,
    fullWidth: g,
    hiddenLabel: I.hiddenLabel,
    multiline: E,
    size: I.size,
    type: P
  }), j = (r = (a = _.root) != null ? a : h.Root) != null ? r : _Re, U = (s = (l = _.input) != null ? l : h.Input) != null ? s : PRe;
  return /* @__PURE__ */ L.jsx(y_, B({
    slots: {
      root: j,
      input: U
    },
    renderSuffix: (q) => /* @__PURE__ */ L.jsx(ORe, {
      ownerState: R,
      className: D.notchedOutline,
      label: x != null && x !== "" && I.required ? p || (p = /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [x, " ", "*"]
      })) : x,
      notched: typeof O < "u" ? O : !!(q.startAdornment || q.filled || q.focused)
    }),
    fullWidth: g,
    inputComponent: b,
    multiline: E,
    ref: n,
    type: P
  }, M, {
    classes: B({}, D, {
      notchedOutline: null
    })
  }));
});
process.env.NODE_ENV !== "production" && (wN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: c.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary"]), c.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: c.shape({
    Input: c.elementType,
    Root: c.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: c.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: c.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: c.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The id of the `input` element.
   */
  id: c.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: c.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: il,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: c.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: c.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: c.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: c.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: c.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: c.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: c.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: c.oneOfType([c.number, c.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: c.shape({
    input: c.elementType,
    root: c.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: c.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: c.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: c.any
});
wN.muiName = "Input";
const mY = wN;
function RRe(e) {
  return Xt("MuiFormLabel", e);
}
const kRe = Bt("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), A0 = kRe, DRe = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"], $Re = (e) => {
  const {
    classes: t,
    color: n,
    focused: r,
    disabled: a,
    error: s,
    filled: l,
    required: p
  } = e, m = {
    root: ["root", `color${xt(n)}`, a && "disabled", s && "error", l && "filled", r && "focused", p && "required"],
    asterisk: ["asterisk", s && "error"]
  };
  return Kt(m, RRe, t);
}, MRe = Ge("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => B({}, t.root, e.color === "secondary" && t.colorSecondary, e.filled && t.filled)
})(({
  theme: e,
  ownerState: t
}) => B({
  color: (e.vars || e).palette.text.secondary
}, e.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${A0.focused}`]: {
    color: (e.vars || e).palette[t.color].main
  },
  [`&.${A0.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${A0.error}`]: {
    color: (e.vars || e).palette.error.main
  }
})), NRe = Ge("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (e, t) => t.asterisk
})(({
  theme: e
}) => ({
  [`&.${A0.error}`]: {
    color: (e.vars || e).palette.error.main
  }
})), hY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: a,
    className: s,
    component: l = "label"
  } = r, p = st(r, DRe), m = Lm(), h = Iy({
    props: r,
    muiFormControl: m,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), g = B({}, r, {
    color: h.color || "primary",
    component: l,
    disabled: h.disabled,
    error: h.error,
    filled: h.filled,
    focused: h.focused,
    required: h.required
  }), b = $Re(g);
  return /* @__PURE__ */ L.jsxs(MRe, B({
    as: l,
    ownerState: g,
    className: Wt(b.root, s),
    ref: n
  }, p, {
    children: [a, h.required && /* @__PURE__ */ L.jsxs(NRe, {
      ownerState: g,
      "aria-hidden": !0,
      className: b.asterisk,
      children: [" ", "*"]
    })]
  }));
});
process.env.NODE_ENV !== "production" && (hY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: c.oneOfType([c.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: c.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: c.bool,
  /**
   * If `true`, the label should use filled classes key.
   */
  filled: c.bool,
  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: c.bool,
  /**
   * If `true`, the label will indicate that the `input` is required.
   */
  required: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const IRe = hY;
function ARe(e) {
  return Xt("MuiInputLabel", e);
}
Bt("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const jRe = ["disableAnimation", "margin", "shrink", "variant", "className"], LRe = (e) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: a,
    disableAnimation: s,
    variant: l,
    required: p
  } = e, h = Kt({
    root: ["root", n && "formControl", !s && "animated", a && "shrink", r === "small" && "sizeSmall", l],
    asterisk: [p && "asterisk"]
  }, ARe, t);
  return B({}, t, h);
}, FRe = Ge(IRe, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${A0.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, t[n.variant]];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, t.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, t.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, t.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !t.disableAnimation && {
  transition: e.transitions.create(["color", "transform", "max-width"], {
    duration: e.transitions.duration.shorter,
    easing: e.transitions.easing.easeOut
  })
}, t.variant === "filled" && B({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, t.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, t.shrink && B({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, t.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), t.variant === "outlined" && B({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, t.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, t.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  // Theoretically, we should have (8+5)*2/0.75 = 34px
  // but it feels a better when it bleeds a bit on the left, so 32px.
  maxWidth: "calc(133% - 32px)",
  transform: "translate(14px, -9px) scale(0.75)"
}))), vY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: a = !1,
    shrink: s,
    className: l
  } = r, p = st(r, jRe), m = Lm();
  let h = s;
  typeof h > "u" && m && (h = m.filled || m.focused || m.adornedStart);
  const g = Iy({
    props: r,
    muiFormControl: m,
    states: ["size", "variant", "required"]
  }), b = B({}, r, {
    disableAnimation: a,
    formControl: m,
    shrink: h,
    size: g.size,
    variant: g.variant,
    required: g.required
  }), x = LRe(b);
  return /* @__PURE__ */ L.jsx(FRe, B({
    "data-shrink": h,
    ownerState: b,
    ref: n,
    className: Wt(x.root, l)
  }, p, {
    classes: x
  }));
});
process.env.NODE_ENV !== "production" && (vY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: c.oneOfType([c.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), c.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: c.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: c.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: c.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: c.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: c.oneOf(["dense"]),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: c.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: c.bool,
  /**
   * The size of the component.
   * @default 'normal'
   */
  size: c.oneOfType([c.oneOf(["normal", "small"]), c.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
const zRe = vY;
function VRe(e) {
  return Xt("MuiFormControl", e);
}
Bt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const URe = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"], BRe = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, a = {
    root: ["root", n !== "none" && `margin${xt(n)}`, r && "fullWidth"]
  };
  return Kt(a, VRe, t);
}, HRe = Ge("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => B({}, t.root, t[`margin${xt(e.margin)}`], e.fullWidth && t.fullWidth)
})(({
  ownerState: e
}) => B({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, e.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, e.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, e.fullWidth && {
  width: "100%"
})), yY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiFormControl"
  }), {
    children: a,
    className: s,
    color: l = "primary",
    component: p = "div",
    disabled: m = !1,
    error: h = !1,
    focused: g,
    fullWidth: b = !1,
    hiddenLabel: x = !1,
    margin: E = "none",
    required: O = !1,
    size: _ = "medium",
    variant: P = "outlined"
  } = r, M = st(r, URe), D = B({}, r, {
    color: l,
    component: p,
    disabled: m,
    error: h,
    fullWidth: b,
    hiddenLabel: x,
    margin: E,
    required: O,
    size: _,
    variant: P
  }), N = BRe(D), [I, R] = C.useState(() => {
    let Y = !1;
    return a && C.Children.forEach(a, (K) => {
      if (!E0(K, ["Input", "Select"]))
        return;
      const Q = E0(K, ["Select"]) ? K.props.input : K;
      Q && tRe(Q.props) && (Y = !0);
    }), Y;
  }), [j, U] = C.useState(() => {
    let Y = !1;
    return a && C.Children.forEach(a, (K) => {
      E0(K, ["Input", "Select"]) && (tT(K.props, !0) || tT(K.props.inputProps, !0)) && (Y = !0);
    }), Y;
  }), [q, J] = C.useState(!1);
  m && q && J(!1);
  const H = g !== void 0 && !m ? g : q;
  let Z;
  if (process.env.NODE_ENV !== "production") {
    const Y = C.useRef(!1);
    Z = () => (Y.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), Y.current = !0, () => {
      Y.current = !1;
    });
  }
  const re = C.useMemo(() => ({
    adornedStart: I,
    setAdornedStart: R,
    color: l,
    disabled: m,
    error: h,
    filled: j,
    focused: H,
    fullWidth: b,
    hiddenLabel: x,
    size: _,
    onBlur: () => {
      J(!1);
    },
    onEmpty: () => {
      U(!1);
    },
    onFilled: () => {
      U(!0);
    },
    onFocus: () => {
      J(!0);
    },
    registerEffect: Z,
    required: O,
    variant: P
  }), [I, l, m, h, j, H, b, x, Z, O, _, P]);
  return /* @__PURE__ */ L.jsx(f_.Provider, {
    value: re,
    children: /* @__PURE__ */ L.jsx(HRe, B({
      as: p,
      ownerState: D,
      className: Wt(N.root, s),
      ref: n
    }, M, {
      children: a
    }))
  });
});
process.env.NODE_ENV !== "production" && (yY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: c.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: c.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: c.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: c.oneOf(["dense", "none", "normal"]),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: c.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: c.oneOfType([c.oneOf(["medium", "small"]), c.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
const WRe = yY;
function YRe(e) {
  return Xt("MuiFormHelperText", e);
}
const qRe = Bt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]), IU = qRe;
var AU;
const GRe = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"], KRe = (e) => {
  const {
    classes: t,
    contained: n,
    size: r,
    disabled: a,
    error: s,
    filled: l,
    focused: p,
    required: m
  } = e, h = {
    root: ["root", a && "disabled", s && "error", r && `size${xt(r)}`, n && "contained", p && "focused", l && "filled", m && "required"]
  };
  return Kt(h, YRe, t);
}, XRe = Ge("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${xt(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  color: (e.vars || e).palette.text.secondary
}, e.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${IU.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${IU.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}, t.size === "small" && {
  marginTop: 4
}, t.contained && {
  marginLeft: 14,
  marginRight: 14
})), gY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: a,
    className: s,
    component: l = "p"
  } = r, p = st(r, GRe), m = Lm(), h = Iy({
    props: r,
    muiFormControl: m,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), g = B({}, r, {
    component: l,
    contained: h.variant === "filled" || h.variant === "outlined",
    variant: h.variant,
    size: h.size,
    disabled: h.disabled,
    error: h.error,
    filled: h.filled,
    focused: h.focused,
    required: h.required
  }), b = KRe(g);
  return /* @__PURE__ */ L.jsx(XRe, B({
    as: l,
    ownerState: g,
    className: Wt(b.root, s),
    ref: n
  }, p, {
    children: a === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      AU || (AU = /* @__PURE__ */ L.jsx("span", {
        className: "notranslate",
        children: "​"
      }))
    ) : a
  }));
});
process.env.NODE_ENV !== "production" && (gY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: c.bool,
  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: c.bool,
  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: c.bool,
  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: c.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: c.oneOf(["dense"]),
  /**
   * If `true`, the helper text should use required classes key.
   */
  required: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   */
  variant: c.oneOfType([c.oneOf(["filled", "outlined", "standard"]), c.string])
});
const QRe = gY, ZRe = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function eD(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function jU(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function bY(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.indexOf(t.keys.join("")) === 0;
}
function f0(e, t, n, r, a, s) {
  let l = !1, p = a(e, t, t ? n : !1);
  for (; p; ) {
    if (p === e.firstChild) {
      if (l)
        return !1;
      l = !0;
    }
    const m = r ? !1 : p.disabled || p.getAttribute("aria-disabled") === "true";
    if (!p.hasAttribute("tabindex") || !bY(p, s) || m)
      p = a(e, p, n);
    else
      return p.focus(), !0;
  }
  return !1;
}
const wY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: r,
    autoFocus: a = !1,
    autoFocusItem: s = !1,
    children: l,
    className: p,
    disabledItemsFocusable: m = !1,
    disableListWrap: h = !1,
    onKeyDown: g,
    variant: b = "selectedMenu"
  } = t, x = st(t, ZRe), E = C.useRef(null), O = C.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  ei(() => {
    a && E.current.focus();
  }, [a]), C.useImperativeHandle(r, () => ({
    adjustStyleForScrollbar: (N, I) => {
      const R = !E.current.style.width;
      if (N.clientHeight < E.current.clientHeight && R) {
        const j = `${g3(aa(N))}px`;
        E.current.style[I.direction === "rtl" ? "paddingLeft" : "paddingRight"] = j, E.current.style.width = `calc(100% + ${j})`;
      }
      return E.current;
    }
  }), []);
  const _ = (N) => {
    const I = E.current, R = N.key, j = aa(I).activeElement;
    if (R === "ArrowDown")
      N.preventDefault(), f0(I, j, h, m, eD);
    else if (R === "ArrowUp")
      N.preventDefault(), f0(I, j, h, m, jU);
    else if (R === "Home")
      N.preventDefault(), f0(I, null, h, m, eD);
    else if (R === "End")
      N.preventDefault(), f0(I, null, h, m, jU);
    else if (R.length === 1) {
      const U = O.current, q = R.toLowerCase(), J = performance.now();
      U.keys.length > 0 && (J - U.lastTime > 500 ? (U.keys = [], U.repeating = !0, U.previousKeyMatched = !0) : U.repeating && q !== U.keys[0] && (U.repeating = !1)), U.lastTime = J, U.keys.push(q);
      const H = j && !U.repeating && bY(j, U);
      U.previousKeyMatched && (H || f0(I, j, !1, m, eD, U)) ? N.preventDefault() : U.previousKeyMatched = !1;
    }
    g && g(N);
  }, P = yo(E, n);
  let M = -1;
  C.Children.forEach(l, (N, I) => {
    if (!/* @__PURE__ */ C.isValidElement(N)) {
      M === I && (M += 1, M >= l.length && (M = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && sy.isFragment(N) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), N.props.disabled || (b === "selectedMenu" && N.props.selected || M === -1) && (M = I), M === I && (N.props.disabled || N.props.muiSkipListHighlight || N.type.muiSkipListHighlight) && (M += 1, M >= l.length && (M = -1));
  });
  const D = C.Children.map(l, (N, I) => {
    if (I === M) {
      const R = {};
      return s && (R.autoFocus = !0), N.props.tabIndex === void 0 && b === "selectedMenu" && (R.tabIndex = 0), /* @__PURE__ */ C.cloneElement(N, R);
    }
    return N;
  });
  return /* @__PURE__ */ L.jsx(B7, B({
    role: "menu",
    ref: P,
    className: p,
    onKeyDown: _,
    tabIndex: a ? 0 : -1
  }, x, {
    children: D
  }));
});
process.env.NODE_ENV !== "production" && (wY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: c.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: c.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: c.node,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: c.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: c.bool,
  /**
   * @ignore
   */
  onKeyDown: c.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: c.oneOf(["menu", "selectedMenu"])
});
const xY = wY;
function JRe(e) {
  return Xt("MuiPopover", e);
}
Bt("MuiPopover", ["root", "paper"]);
const eke = ["onEntering"], tke = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"], nke = ["slotProps"];
function LU(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function FU(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function zU(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function sE(e) {
  return typeof e == "function" ? e() : e;
}
const rke = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    paper: ["paper"]
  }, JRe, t);
}, oke = Ge(f7, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), SY = Ge(s_, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), EY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s;
  const l = Lt({
    props: t,
    name: "MuiPopover"
  }), {
    action: p,
    anchorEl: m,
    anchorOrigin: h = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: g,
    anchorReference: b = "anchorEl",
    children: x,
    className: E,
    container: O,
    elevation: _ = 8,
    marginThreshold: P = 16,
    open: M,
    PaperProps: D = {},
    slots: N,
    slotProps: I,
    transformOrigin: R = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: j = g7,
    transitionDuration: U = "auto",
    TransitionProps: {
      onEntering: q
    } = {}
  } = l, J = st(l.TransitionProps, eke), H = st(l, tke), Z = (r = I == null ? void 0 : I.paper) != null ? r : D, re = C.useRef(), Y = yo(re, Z.ref), K = B({}, l, {
    anchorOrigin: h,
    anchorReference: b,
    elevation: _,
    marginThreshold: P,
    externalPaperSlotProps: Z,
    transformOrigin: R,
    TransitionComponent: j,
    transitionDuration: U,
    TransitionProps: J
  }), Q = rke(K), te = C.useCallback(() => {
    if (b === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (g || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), g;
    const me = sE(m), Pe = me && me.nodeType === 1 ? me : aa(re.current).body, Ee = Pe.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const Ke = Pe.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && Ke.top === 0 && Ke.left === 0 && Ke.right === 0 && Ke.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: Ee.top + LU(Ee, h.vertical),
      left: Ee.left + FU(Ee, h.horizontal)
    };
  }, [m, h.horizontal, h.vertical, g, b]), ne = C.useCallback((me) => ({
    vertical: LU(me, R.vertical),
    horizontal: FU(me, R.horizontal)
  }), [R.horizontal, R.vertical]), ae = C.useCallback((me) => {
    const Pe = {
      width: me.offsetWidth,
      height: me.offsetHeight
    }, Ee = ne(Pe);
    if (b === "none")
      return {
        top: null,
        left: null,
        transformOrigin: zU(Ee)
      };
    const Ke = te();
    let oe = Ke.top - Ee.vertical, de = Ke.left - Ee.horizontal;
    const we = oe + Pe.height, Me = de + Pe.width, Ae = rd(sE(m)), je = Ae.innerHeight - P, qe = Ae.innerWidth - P;
    if (oe < P) {
      const ot = oe - P;
      oe -= ot, Ee.vertical += ot;
    } else if (we > je) {
      const ot = we - je;
      oe -= ot, Ee.vertical += ot;
    }
    if (process.env.NODE_ENV !== "production" && Pe.height > je && Pe.height && je && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${Pe.height - je}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), de < P) {
      const ot = de - P;
      de -= ot, Ee.horizontal += ot;
    } else if (Me > qe) {
      const ot = Me - qe;
      de -= ot, Ee.horizontal += ot;
    }
    return {
      top: `${Math.round(oe)}px`,
      left: `${Math.round(de)}px`,
      transformOrigin: zU(Ee)
    };
  }, [m, b, te, ne, P]), [se, V] = C.useState(M), ee = C.useCallback(() => {
    const me = re.current;
    if (!me)
      return;
    const Pe = ae(me);
    Pe.top !== null && (me.style.top = Pe.top), Pe.left !== null && (me.style.left = Pe.left), me.style.transformOrigin = Pe.transformOrigin, V(!0);
  }, [ae]), he = (me, Pe) => {
    q && q(me, Pe), ee();
  }, ue = () => {
    V(!1);
  };
  C.useEffect(() => {
    M && ee();
  }), C.useImperativeHandle(p, () => M ? {
    updatePosition: () => {
      ee();
    }
  } : null, [M, ee]), C.useEffect(() => {
    if (!M)
      return;
    const me = ly(() => {
      ee();
    }), Pe = rd(m);
    return Pe.addEventListener("resize", me), () => {
      me.clear(), Pe.removeEventListener("resize", me);
    };
  }, [m, M, ee]);
  let fe = U;
  U === "auto" && !j.muiSupportAuto && (fe = void 0);
  const Ce = O || (m ? aa(sE(m)).body : void 0), Se = (a = N == null ? void 0 : N.root) != null ? a : oke, Te = (s = N == null ? void 0 : N.paper) != null ? s : SY, pe = Gr({
    elementType: Te,
    externalSlotProps: B({}, Z, {
      style: se ? Z.style : B({}, Z.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation: _,
      ref: Y
    },
    ownerState: K,
    className: Wt(Q.paper, Z == null ? void 0 : Z.className)
  }), ye = Gr({
    elementType: Se,
    externalSlotProps: (I == null ? void 0 : I.root) || {},
    externalForwardedProps: H,
    additionalProps: {
      ref: n,
      slotProps: {
        backdrop: {
          invisible: !0
        }
      },
      container: Ce,
      open: M
    },
    ownerState: K,
    className: Wt(Q.root, E)
  }), {
    slotProps: Oe
  } = ye, Fe = st(ye, nke);
  return /* @__PURE__ */ L.jsx(Se, B({}, Fe, !zf(Se) && {
    slotProps: Oe
  }, {
    children: /* @__PURE__ */ L.jsx(j, B({
      appear: !0,
      in: M,
      onEntering: he,
      onExited: ue,
      timeout: fe
    }, J, {
      children: /* @__PURE__ */ L.jsx(Te, B({}, pe, {
        children: x
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" && (EY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: il,
  /**
   * An HTML element, [PopoverVirtualElement](/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: cd(c.oneOfType([Zu, c.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = sE(e.anchorEl);
      if (t && t.nodeType === 1) {
        const n = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && n.top === 0 && n.left === 0 && n.right === 0 && n.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: c.shape({
    horizontal: c.oneOfType([c.oneOf(["center", "left", "right"]), c.number]).isRequired,
    vertical: c.oneOfType([c.oneOf(["bottom", "center", "top"]), c.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: c.shape({
    left: c.number.isRequired,
    top: c.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: c.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: c.oneOfType([Zu, c.func]),
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: C0,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * @default 16
   */
  marginThreshold: c.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overriden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: c.shape({
    component: cT
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: c.shape({
    paper: c.oneOfType([c.func, c.object]),
    root: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: c.shape({
    paper: c.elementType,
    root: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: c.shape({
    horizontal: c.oneOfType([c.oneOf(["center", "left", "right"]), c.number]).isRequired,
    vertical: c.oneOfType([c.oneOf(["bottom", "center", "top"]), c.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: c.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: c.oneOfType([c.oneOf(["auto"]), c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: c.object
});
const ake = EY;
function ike(e) {
  return Xt("MuiMenu", e);
}
Bt("MuiMenu", ["root", "paper", "list"]);
const ske = ["onEntering"], lke = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"], uke = {
  vertical: "top",
  horizontal: "right"
}, cke = {
  vertical: "top",
  horizontal: "left"
}, dke = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, ike, t);
}, fke = Ge(ake, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), pke = Ge(SY, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), mke = Ge(xY, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), CY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: a = !0,
    children: s,
    disableAutoFocusItem: l = !1,
    MenuListProps: p = {},
    onClose: m,
    open: h,
    PaperProps: g = {},
    PopoverClasses: b,
    transitionDuration: x = "auto",
    TransitionProps: {
      onEntering: E
    } = {},
    variant: O = "selectedMenu"
  } = r, _ = st(r.TransitionProps, ske), P = st(r, lke), M = Ji(), D = M.direction === "rtl", N = B({}, r, {
    autoFocus: a,
    disableAutoFocusItem: l,
    MenuListProps: p,
    onEntering: E,
    PaperProps: g,
    transitionDuration: x,
    TransitionProps: _,
    variant: O
  }), I = dke(N), R = a && !l && h, j = C.useRef(null), U = (H, Z) => {
    j.current && j.current.adjustStyleForScrollbar(H, M), E && E(H, Z);
  }, q = (H) => {
    H.key === "Tab" && (H.preventDefault(), m && m(H, "tabKeyDown"));
  };
  let J = -1;
  return C.Children.map(s, (H, Z) => {
    /* @__PURE__ */ C.isValidElement(H) && (process.env.NODE_ENV !== "production" && sy.isFragment(H) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), H.props.disabled || (O === "selectedMenu" && H.props.selected || J === -1) && (J = Z));
  }), /* @__PURE__ */ L.jsx(fke, B({
    onClose: m,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: D ? "right" : "left"
    },
    transformOrigin: D ? uke : cke,
    slots: {
      paper: pke
    },
    slotProps: {
      paper: B({}, g, {
        classes: B({}, g.classes, {
          root: I.paper
        })
      })
    },
    className: I.root,
    open: h,
    ref: n,
    transitionDuration: x,
    TransitionProps: B({
      onEntering: U
    }, _),
    ownerState: N
  }, P, {
    classes: b,
    children: /* @__PURE__ */ L.jsx(mke, B({
      onKeyDown: q,
      actions: j,
      autoFocus: a && (J === -1 || l),
      autoFocusItem: R,
      variant: O
    }, p, {
      className: Wt(I.list, p.className),
      children: s
    }))
  }));
});
process.env.NODE_ENV !== "production" && (CY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: c.oneOfType([Zu, c.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: c.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: c.bool,
  /**
   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: c.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: c.object,
  /**
   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.
   */
  PopoverClasses: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: c.oneOfType([c.oneOf(["auto"]), c.number, c.shape({
    appear: c.number,
    enter: c.number,
    exit: c.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: c.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: c.oneOf(["menu", "selectedMenu"])
});
const hke = CY;
function vke(e) {
  return Xt("MuiNativeSelect", e);
}
const yke = Bt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), xN = yke, gke = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"], bke = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, p = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${xt(n)}`, s && "iconOpen", r && "disabled"]
  };
  return Kt(p, vke, t);
}, TY = ({
  ownerState: e,
  theme: t
}) => B({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": B({}, t.vars ? {
    backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: t.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${xN.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (t.vars || t).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, e.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, e.variant === "outlined" && {
  borderRadius: (t.vars || t).shape.borderRadius,
  "&:focus": {
    borderRadius: (t.vars || t).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
}), wke = Ge("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: ac,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${xN.multiple}`]: t.multiple
    }];
  }
})(TY), _Y = ({
  ownerState: e,
  theme: t
}) => B({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (t.vars || t).palette.action.active,
  [`&.${xN.disabled}`]: {
    color: (t.vars || t).palette.action.disabled
  }
}, e.open && {
  transform: "rotate(180deg)"
}, e.variant === "filled" && {
  right: 7
}, e.variant === "outlined" && {
  right: 7
}), xke = Ge("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${xt(n.variant)}`], n.open && t.iconOpen];
  }
})(_Y), OY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: a,
    error: s,
    IconComponent: l,
    inputRef: p,
    variant: m = "standard"
  } = t, h = st(t, gke), g = B({}, t, {
    disabled: a,
    variant: m,
    error: s
  }), b = bke(g);
  return /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [/* @__PURE__ */ L.jsx(wke, B({
      ownerState: g,
      className: Wt(b.select, r),
      disabled: a,
      ref: p || n
    }, h)), t.multiple ? null : /* @__PURE__ */ L.jsx(xke, {
      as: l,
      ownerState: g,
      className: b.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (OY.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: c.object,
  /**
   * The CSS class name of the select element.
   */
  className: c.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: c.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: c.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: c.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: il,
  /**
   * @ignore
   */
  multiple: c.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: c.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * The input value.
   */
  value: c.any,
  /**
   * The variant to use.
   */
  variant: c.oneOf(["standard", "outlined", "filled"])
});
const Ske = OY;
function Eke(e) {
  return Xt("MuiSelect", e);
}
const Cke = Bt("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), p0 = Cke;
var VU;
const Tke = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"], _ke = Ge("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${p0.select}`]: t.select
      },
      {
        [`&.${p0.select}`]: t[n.variant]
      },
      {
        [`&.${p0.error}`]: t.error
      },
      {
        [`&.${p0.multiple}`]: t.multiple
      }
    ];
  }
})(TY, {
  // Win specificity over the input base
  [`&.${p0.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), Oke = Ge("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${xt(n.variant)}`], n.open && t.iconOpen];
  }
})(_Y), Pke = Ge("input", {
  shouldForwardProp: (e) => goe(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function UU(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function Rke(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const kke = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: a,
    open: s,
    error: l
  } = e, p = {
    select: ["select", n, r && "disabled", a && "multiple", l && "error"],
    icon: ["icon", `icon${xt(n)}`, s && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return Kt(p, Eke, t);
}, PY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    "aria-describedby": r,
    "aria-label": a,
    autoFocus: s,
    autoWidth: l,
    children: p,
    className: m,
    defaultOpen: h,
    defaultValue: g,
    disabled: b,
    displayEmpty: x,
    error: E = !1,
    IconComponent: O,
    inputRef: _,
    labelId: P,
    MenuProps: M = {},
    multiple: D,
    name: N,
    onBlur: I,
    onChange: R,
    onClose: j,
    onFocus: U,
    onOpen: q,
    open: J,
    readOnly: H,
    renderValue: Z,
    SelectDisplayProps: re = {},
    tabIndex: Y,
    value: K,
    variant: Q = "standard"
  } = t, te = st(t, Tke), [ne, ae] = tl({
    controlled: K,
    default: g,
    name: "Select"
  }), [se, V] = tl({
    controlled: J,
    default: h,
    name: "Select"
  }), ee = C.useRef(null), he = C.useRef(null), [ue, fe] = C.useState(null), {
    current: Ce
  } = C.useRef(J != null), [Se, Te] = C.useState(), pe = yo(n, _), ye = C.useCallback((Ne) => {
    he.current = Ne, Ne && fe(Ne);
  }, []), Oe = ue == null ? void 0 : ue.parentNode;
  C.useImperativeHandle(pe, () => ({
    focus: () => {
      he.current.focus();
    },
    node: ee.current,
    value: ne
  }), [ne]), C.useEffect(() => {
    h && se && ue && !Ce && (Te(l ? null : Oe.clientWidth), he.current.focus());
  }, [ue, l]), C.useEffect(() => {
    s && he.current.focus();
  }, [s]), C.useEffect(() => {
    if (!P)
      return;
    const Ne = aa(he.current).getElementById(P);
    if (Ne) {
      const Ie = () => {
        getSelection().isCollapsed && he.current.focus();
      };
      return Ne.addEventListener("click", Ie), () => {
        Ne.removeEventListener("click", Ie);
      };
    }
  }, [P]);
  const Fe = (Ne, Ie) => {
    Ne ? q && q(Ie) : j && j(Ie), Ce || (Te(l ? null : Oe.clientWidth), V(Ne));
  }, me = (Ne) => {
    Ne.button === 0 && (Ne.preventDefault(), he.current.focus(), Fe(!0, Ne));
  }, Pe = (Ne) => {
    Fe(!1, Ne);
  }, Ee = C.Children.toArray(p), Ke = (Ne) => {
    const Ie = Ee.find((Je) => Je.props.value === Ne.target.value);
    Ie !== void 0 && (ae(Ie.props.value), R && R(Ne, Ie));
  }, oe = (Ne) => (Ie) => {
    let Je;
    if (Ie.currentTarget.hasAttribute("tabindex")) {
      if (D) {
        Je = Array.isArray(ne) ? ne.slice() : [];
        const pt = ne.indexOf(Ne.props.value);
        pt === -1 ? Je.push(Ne.props.value) : Je.splice(pt, 1);
      } else
        Je = Ne.props.value;
      if (Ne.props.onClick && Ne.props.onClick(Ie), ne !== Je && (ae(Je), R)) {
        const pt = Ie.nativeEvent || Ie, ht = new pt.constructor(pt.type, pt);
        Object.defineProperty(ht, "target", {
          writable: !0,
          value: {
            value: Je,
            name: N
          }
        }), R(ht, Ne);
      }
      D || Fe(!1, Ie);
    }
  }, de = (Ne) => {
    H || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].indexOf(Ne.key) !== -1 && (Ne.preventDefault(), Fe(!0, Ne));
  }, we = ue !== null && se, Me = (Ne) => {
    !we && I && (Object.defineProperty(Ne, "target", {
      writable: !0,
      value: {
        value: ne,
        name: N
      }
    }), I(Ne));
  };
  delete te["aria-invalid"];
  let Ae, je;
  const qe = [];
  let ot = !1, et = !1;
  (tT({
    value: ne
  }) || x) && (Z ? Ae = Z(ne) : ot = !0);
  const ct = Ee.map((Ne) => {
    if (!/* @__PURE__ */ C.isValidElement(Ne))
      return null;
    process.env.NODE_ENV !== "production" && sy.isFragment(Ne) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let Ie;
    if (D) {
      if (!Array.isArray(ne))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : jf(2));
      Ie = ne.some((Je) => UU(Je, Ne.props.value)), Ie && ot && qe.push(Ne.props.children);
    } else
      Ie = UU(ne, Ne.props.value), Ie && ot && (je = Ne.props.children);
    return Ie && (et = !0), /* @__PURE__ */ C.cloneElement(Ne, {
      "aria-selected": Ie ? "true" : "false",
      onClick: oe(Ne),
      onKeyUp: (Je) => {
        Je.key === " " && Je.preventDefault(), Ne.props.onKeyUp && Ne.props.onKeyUp(Je);
      },
      role: "option",
      selected: Ie,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": Ne.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && C.useEffect(() => {
    if (!et && !D && ne !== "") {
      const Ne = Ee.map((Ie) => Ie.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${ne}\` for the select ${N ? `(name="${N}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${Ne.filter((Ie) => Ie != null).map((Ie) => `\`${Ie}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [et, Ee, D, N, ne]), ot && (D ? qe.length === 0 ? Ae = null : Ae = qe.reduce((Ne, Ie, Je) => (Ne.push(Ie), Je < qe.length - 1 && Ne.push(", "), Ne), []) : Ae = je);
  let Qt = Se;
  !l && Ce && ue && (Qt = Oe.clientWidth);
  let Ht;
  typeof Y < "u" ? Ht = Y : Ht = b ? null : 0;
  const kt = re.id || (N ? `mui-component-select-${N}` : void 0), St = B({}, t, {
    variant: Q,
    value: ne,
    open: we,
    error: E
  }), cn = kke(St);
  return /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [/* @__PURE__ */ L.jsx(_ke, B({
      ref: ye,
      tabIndex: Ht,
      role: "button",
      "aria-disabled": b ? "true" : void 0,
      "aria-expanded": we ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": a,
      "aria-labelledby": [P, kt].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      onKeyDown: de,
      onMouseDown: b || H ? null : me,
      onBlur: Me,
      onFocus: U
    }, re, {
      ownerState: St,
      className: Wt(re.className, cn.select, m),
      id: kt,
      children: Rke(Ae) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        VU || (VU = /* @__PURE__ */ L.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : Ae
    })), /* @__PURE__ */ L.jsx(Pke, B({
      "aria-invalid": E,
      value: Array.isArray(ne) ? ne.join(",") : ne,
      name: N,
      ref: ee,
      "aria-hidden": !0,
      onChange: Ke,
      tabIndex: -1,
      disabled: b,
      className: cn.nativeInput,
      autoFocus: s,
      ownerState: St
    }, te)), /* @__PURE__ */ L.jsx(Oke, {
      as: O,
      className: cn.icon,
      ownerState: St
    }), /* @__PURE__ */ L.jsx(hke, B({
      id: `menu-${N || ""}`,
      anchorEl: Oe,
      open: we,
      onClose: Pe,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, M, {
      MenuListProps: B({
        "aria-labelledby": P,
        role: "listbox",
        disableListWrap: !0
      }, M.MenuListProps),
      PaperProps: B({}, M.PaperProps, {
        style: B({
          minWidth: Qt
        }, M.PaperProps != null ? M.PaperProps.style : null)
      }),
      children: ct
    }))]
  });
});
process.env.NODE_ENV !== "production" && (PY.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": c.string,
  /**
   * @ignore
   */
  "aria-label": c.string,
  /**
   * @ignore
   */
  autoFocus: c.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: c.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: c.object,
  /**
   * The CSS class name of the select element.
   */
  className: c.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: c.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: c.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: c.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: c.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: c.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: il,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: c.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: c.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: c.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: c.string,
  /**
   * @ignore
   */
  onBlur: c.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: c.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: c.func,
  /**
   * @ignore
   */
  onFocus: c.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: c.func,
  /**
   * If `true`, the component is shown.
   */
  open: c.bool,
  /**
   * @ignore
   */
  readOnly: c.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: c.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: c.object,
  /**
   * @ignore
   */
  tabIndex: c.oneOfType([c.number, c.string]),
  /**
   * @ignore
   */
  type: c.any,
  /**
   * The input value.
   */
  value: c.any,
  /**
   * The variant to use.
   */
  variant: c.oneOf(["standard", "outlined", "filled"])
});
const Dke = PY, $ke = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), Mke = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], Nke = (e) => {
  const {
    classes: t
  } = e;
  return t;
}, SN = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => ac(e) && e !== "variant",
  slot: "Root"
}, Ike = Ge(dY, SN)(""), Ake = Ge(mY, SN)(""), jke = Ge(fY, SN)(""), EN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: a = !1,
    children: s,
    classes: l = {},
    className: p,
    defaultOpen: m = !1,
    displayEmpty: h = !1,
    IconComponent: g = $ke,
    id: b,
    input: x,
    inputProps: E,
    label: O,
    labelId: _,
    MenuProps: P,
    multiple: M = !1,
    native: D = !1,
    onClose: N,
    onOpen: I,
    open: R,
    renderValue: j,
    SelectDisplayProps: U,
    variant: q = "outlined"
  } = r, J = st(r, Mke), H = D ? Ske : Dke, Z = Lm(), re = Iy({
    props: r,
    muiFormControl: Z,
    states: ["variant", "error"]
  }), Y = re.variant || q, K = B({}, r, {
    variant: Y,
    classes: l
  }), Q = Nke(K), te = x || {
    standard: /* @__PURE__ */ L.jsx(Ike, {
      ownerState: K
    }),
    outlined: /* @__PURE__ */ L.jsx(Ake, {
      label: O,
      ownerState: K
    }),
    filled: /* @__PURE__ */ L.jsx(jke, {
      ownerState: K
    })
  }[Y], ne = yo(n, te.ref);
  return /* @__PURE__ */ L.jsx(C.Fragment, {
    children: /* @__PURE__ */ C.cloneElement(te, B({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: H,
      inputProps: B({
        children: s,
        error: re.error,
        IconComponent: g,
        variant: Y,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: M
      }, D ? {
        id: b
      } : {
        autoWidth: a,
        defaultOpen: m,
        displayEmpty: h,
        labelId: _,
        MenuProps: P,
        onClose: N,
        onOpen: I,
        open: R,
        renderValue: j,
        SelectDisplayProps: B({
          id: b
        }, U)
      }, E, {
        classes: E ? Ks(Q, E.classes) : Q
      }, x ? x.props.inputProps : {})
    }, M && D && Y === "outlined" ? {
      notched: !0
    } : {}, {
      ref: ne,
      className: Wt(te.props.className, p)
    }, !x && {
      variant: Y
    }, J))
  });
});
process.env.NODE_ENV !== "production" && (EN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: c.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * ⚠️The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: c.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   * ⚠️ When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: c.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: c.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: c.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: c.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: c.object,
  /**
   * See [OutlinedInput#label](/material-ui/api/outlined-input/#props)
   */
  label: c.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: c.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: c.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: c.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: c.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<T>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: c.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapses).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: c.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: c.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: c.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: c.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: c.oneOfType([c.oneOf([""]), c.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
EN.muiName = "Select";
const RY = EN;
function Lke(e) {
  return Xt("MuiTextField", e);
}
Bt("MuiTextField", ["root"]);
const Fke = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"], zke = {
  standard: dY,
  filled: fY,
  outlined: mY
}, Vke = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, Lke, t);
}, Uke = Ge(WRe, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), kY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: a,
    autoFocus: s = !1,
    children: l,
    className: p,
    color: m = "primary",
    defaultValue: h,
    disabled: g = !1,
    error: b = !1,
    FormHelperTextProps: x,
    fullWidth: E = !1,
    helperText: O,
    id: _,
    InputLabelProps: P,
    inputProps: M,
    InputProps: D,
    inputRef: N,
    label: I,
    maxRows: R,
    minRows: j,
    multiline: U = !1,
    name: q,
    onBlur: J,
    onChange: H,
    onClick: Z,
    onFocus: re,
    placeholder: Y,
    required: K = !1,
    rows: Q,
    select: te = !1,
    SelectProps: ne,
    type: ae,
    value: se,
    variant: V = "outlined"
  } = r, ee = st(r, Fke), he = B({}, r, {
    autoFocus: s,
    color: m,
    disabled: g,
    error: b,
    fullWidth: E,
    multiline: U,
    required: K,
    select: te,
    variant: V
  }), ue = Vke(he);
  process.env.NODE_ENV !== "production" && te && !l && console.error("MUI: `children` must be passed when using the `TextField` component with `select`.");
  const fe = {};
  V === "outlined" && (P && typeof P.shrink < "u" && (fe.notched = P.shrink), fe.label = I), te && ((!ne || !ne.native) && (fe.id = void 0), fe["aria-describedby"] = void 0);
  const Ce = uy(_), Se = O && Ce ? `${Ce}-helper-text` : void 0, Te = I && Ce ? `${Ce}-label` : void 0, pe = zke[V], ye = /* @__PURE__ */ L.jsx(pe, B({
    "aria-describedby": Se,
    autoComplete: a,
    autoFocus: s,
    defaultValue: h,
    fullWidth: E,
    multiline: U,
    name: q,
    rows: Q,
    maxRows: R,
    minRows: j,
    type: ae,
    value: se,
    id: Ce,
    inputRef: N,
    onBlur: J,
    onChange: H,
    onFocus: re,
    onClick: Z,
    placeholder: Y,
    inputProps: M
  }, fe, D));
  return /* @__PURE__ */ L.jsxs(Uke, B({
    className: Wt(ue.root, p),
    disabled: g,
    error: b,
    fullWidth: E,
    ref: n,
    required: K,
    color: m,
    variant: V,
    ownerState: he
  }, ee, {
    children: [I != null && I !== "" && /* @__PURE__ */ L.jsx(zRe, B({
      htmlFor: Ce,
      id: Te
    }, P, {
      children: I
    })), te ? /* @__PURE__ */ L.jsx(RY, B({
      "aria-describedby": Se,
      id: Ce,
      labelId: Te,
      value: se,
      input: ye
    }, ne, {
      children: l
    })) : ye, O && /* @__PURE__ */ L.jsx(QRe, B({
      id: Se
    }, x, {
      children: O
    }))]
  }));
});
process.env.NODE_ENV !== "production" && (kY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: c.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: c.bool,
  /**
   * @ignore
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: c.oneOfType([c.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), c.string]),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: c.bool,
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: c.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The helper text content.
   */
  helperText: c.node,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: c.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: c.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: c.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: il,
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: c.oneOf(["dense", "none", "normal"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: c.oneOfType([c.number, c.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: c.oneOfType([c.number, c.string]),
  /**
   * If `true`, a `textarea` element is rendered instead of an input.
   * @default false
   */
  multiline: c.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  /**
   * @ignore
   */
  onBlur: c.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * @ignore
   */
  onFocus: c.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: c.string,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: c.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: c.oneOfType([c.number, c.string]),
  /**
   * Render a [`Select`](/material-ui/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   * @default false
   */
  select: c.bool,
  /**
   * Props applied to the [`Select`](/material-ui/api/select/) element.
   */
  SelectProps: c.object,
  /**
   * The size of the component.
   */
  size: c.oneOfType([c.oneOf(["medium", "small"]), c.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: c.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: c.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
const DY = kY, Bke = (e) => {
  var t, n, r;
  const a = or(), s = Am();
  return B({}, e, {
    disablePast: (t = e.disablePast) != null ? t : !1,
    disableFuture: (n = e.disableFuture) != null ? n : !1,
    format: (r = e.format) != null ? r : a.formats.keyboardDate,
    minDate: ni(a, e.minDate, s.minDate),
    maxDate: ni(a, e.maxDate, s.maxDate)
  });
}, Hke = ({
  props: e,
  inputRef: t
}) => {
  const n = Bke(e), {
    forwardedProps: r,
    internalProps: a
  } = K7(n, "date");
  return A7({
    inputRef: t,
    forwardedProps: r,
    internalProps: a,
    valueManager: Ny,
    fieldValueManager: R9,
    validator: Sw,
    valueType: "date"
  });
}, Wke = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"], Yke = ["inputRef"], qke = ["ref", "onPaste", "inputMode", "readOnly"], CN = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s;
  const l = Lt({
    props: t,
    name: "MuiDateField"
  }), {
    components: p,
    componentsProps: m,
    slots: h,
    slotProps: g,
    InputProps: b,
    inputProps: x
  } = l, E = st(l, Wke), O = l, _ = (r = (a = h == null ? void 0 : h.textField) != null ? a : p == null ? void 0 : p.TextField) != null ? r : DY, P = Gr({
    elementType: _,
    externalSlotProps: (s = g == null ? void 0 : g.textField) != null ? s : m == null ? void 0 : m.textField,
    externalForwardedProps: E,
    ownerState: O
  }), {
    inputRef: M
  } = P, D = st(P, Yke);
  D.inputProps = B({}, D.inputProps, x), D.InputProps = B({}, D.InputProps, b);
  const N = Hke({
    props: D,
    inputRef: M
  }), {
    ref: I,
    onPaste: R,
    inputMode: j,
    readOnly: U
  } = N, q = st(N, qke);
  return /* @__PURE__ */ L.jsx(_, B({
    ref: n
  }, q, {
    InputProps: B({}, q.InputProps, {
      readOnly: U
    }),
    inputProps: B({}, q.inputProps, {
      inputMode: j,
      onPaste: R,
      ref: I
    })
  }));
});
process.env.NODE_ENV !== "production" && (CN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: c.bool,
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: c.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: c.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: c.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The helper text content.
   */
  helperText: c.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: c.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: c.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: c.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: c.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.any.isRequired
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: c.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  onBlur: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  onFocus: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: c.bool,
  /**
   * The date used to generate a part of the date-time that is not present in the format when both `value` and `defaultValue` are not present.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: c.any,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: c.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default `false`
   */
  shouldRespectLeadingZeros: c.bool,
  /**
   * The size of the component.
   */
  size: c.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  style: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: c.oneOfType([c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
function Gke(e) {
  return Xt("MuiPickersMonth", e);
}
const N1 = Bt("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]), Kke = ["autoFocus", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "monthsPerRow"], Xke = (e) => {
  const {
    disabled: t,
    selected: n,
    classes: r
  } = e;
  return Kt({
    root: ["root"],
    monthButton: ["monthButton", t && "disabled", n && "selected"]
  }, Gke, r);
}, Qke = Ge("div", {
  name: "MuiPickersMonth",
  slot: "Root",
  overridesResolver: (e, t) => [t.root]
})(({
  ownerState: e
}) => ({
  flexBasis: e.monthsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), Zke = Ge("button", {
  name: "MuiPickersMonth",
  slot: "MonthButton",
  overridesResolver: (e, t) => [t.monthButton, {
    [`&.${N1.disabled}`]: t.disabled
  }, {
    [`&.${N1.selected}`]: t.selected
  }]
})(({
  theme: e
}) => B({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, e.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${N1.disabled}`]: {
    color: (e.vars || e).palette.text.secondary
  },
  [`&.${N1.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  }
})), Jke = /* @__PURE__ */ C.memo(function(t) {
  const n = Lt({
    props: t,
    name: "MuiPickersMonth"
  }), {
    autoFocus: r,
    children: a,
    disabled: s,
    value: l,
    tabIndex: p,
    onClick: m,
    onKeyDown: h,
    onFocus: g,
    onBlur: b,
    "aria-current": x
    // We don't want to forward this prop to the root element
  } = n, E = st(n, Kke), O = C.useRef(null), _ = Xke(n);
  return ei(() => {
    if (r) {
      var P;
      (P = O.current) == null || P.focus();
    }
  }, [r]), /* @__PURE__ */ L.jsx(Qke, B({
    className: _.root,
    ownerState: n
  }, E, {
    children: /* @__PURE__ */ L.jsx(Zke, {
      ref: O,
      disabled: s,
      type: "button",
      tabIndex: s ? -1 : p,
      "aria-current": x,
      onClick: (P) => m(P, l),
      onKeyDown: (P) => h(P, l),
      onFocus: (P) => g(P, l),
      onBlur: (P) => b(P, l),
      className: _.monthButton,
      ownerState: n,
      children: a
    })
  }));
});
function eDe(e) {
  return Xt("MuiMonthCalendar", e);
}
Bt("MuiMonthCalendar", ["root"]);
const tDe = ["className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow"], nDe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, eDe, t);
};
function rDe(e, t) {
  const n = or(), r = Am(), a = Lt({
    props: e,
    name: t
  });
  return B({
    disableFuture: !1,
    disablePast: !1
  }, a, {
    minDate: ni(n, a.minDate, r.minDate),
    maxDate: ni(n, a.maxDate, r.maxDate)
  });
}
const oDe = Ge("div", {
  name: "MuiMonthCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  padding: "0 4px",
  width: 320
}), $Y = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = jm(), a = lw(), s = or(), l = rDe(t, "MuiMonthCalendar"), {
    className: p,
    value: m,
    defaultValue: h,
    disabled: g,
    disableFuture: b,
    disablePast: x,
    maxDate: E,
    minDate: O,
    onChange: _,
    shouldDisableMonth: P,
    readOnly: M,
    disableHighlightToday: D,
    autoFocus: N = !1,
    onMonthFocus: I,
    hasFocus: R,
    onFocusedViewChange: j,
    monthsPerRow: U = 3
  } = l, q = st(l, tDe), J = l, H = nDe(J), [Z, re] = tl({
    name: "MonthCalendar",
    state: "value",
    controlled: m,
    default: h ?? null
  }), Y = C.useMemo(() => s.getMonth(r), [s, r]), K = C.useMemo(() => Z ?? s.startOfMonth(r), [r, s, Z]), Q = C.useMemo(() => Z != null ? s.getMonth(Z) : D ? null : s.getMonth(r), [r, Z, s, D]), [te, ne] = C.useState(() => Q || Y), [ae, se] = tl({
    name: "MonthCalendar",
    state: "hasFocus",
    controlled: R,
    default: N ?? !1
  }), V = Zr((Te) => {
    se(Te), j && j(Te);
  }), ee = C.useCallback((Te) => {
    const pe = s.startOfMonth(x && s.isAfter(r, O) ? r : O), ye = s.startOfMonth(b && s.isBefore(r, E) ? r : E);
    return s.isBefore(Te, pe) || s.isAfter(Te, ye) ? !0 : P ? P(Te) : !1;
  }, [b, x, E, O, r, P, s]), he = Zr((Te, pe) => {
    if (M)
      return;
    const ye = s.setMonth(K, pe);
    re(ye), _ == null || _(ye);
  }), ue = Zr((Te) => {
    ee(s.setMonth(K, Te)) || (ne(Te), V(!0), I && I(Te));
  });
  C.useEffect(() => {
    ne((Te) => Q !== null && Te !== Q ? Q : Te);
  }, [Q]);
  const fe = Zr((Te, pe) => {
    switch (Te.key) {
      case "ArrowUp":
        ue((12 + pe - 3) % 12), Te.preventDefault();
        break;
      case "ArrowDown":
        ue((12 + pe + 3) % 12), Te.preventDefault();
        break;
      case "ArrowLeft":
        ue((12 + pe + (a.direction === "ltr" ? -1 : 1)) % 12), Te.preventDefault();
        break;
      case "ArrowRight":
        ue((12 + pe + (a.direction === "ltr" ? 1 : -1)) % 12), Te.preventDefault();
        break;
    }
  }), Ce = Zr((Te, pe) => {
    ue(pe);
  }), Se = Zr((Te, pe) => {
    te === pe && V(!1);
  });
  return /* @__PURE__ */ L.jsx(oDe, B({
    ref: n,
    className: Ao(H.root, p),
    ownerState: J
  }, q, {
    children: XM(s, K).map((Te) => {
      const pe = s.getMonth(Te), ye = s.format(Te, "monthShort"), Oe = pe === Q, Fe = g || ee(Te);
      return /* @__PURE__ */ L.jsx(Jke, {
        selected: Oe,
        value: pe,
        onClick: he,
        onKeyDown: fe,
        autoFocus: ae && pe === te,
        disabled: Fe,
        tabIndex: pe === te ? 0 : -1,
        onFocus: Ce,
        onBlur: Se,
        "aria-current": Y === pe ? "date" : void 0,
        monthsPerRow: U,
        children: ye
      }, ye);
    })
  }));
});
process.env.NODE_ENV !== "production" && ($Y.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * className applied to the root element.
   */
  className: c.string,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true` picker is disabled
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  hasFocus: c.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   */
  onChange: c.func,
  onFocusedViewChange: c.func,
  onMonthFocus: c.func,
  /**
   * If `true` picker is readonly
   */
  readOnly: c.bool,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any
});
function aDe(e) {
  return Xt("MuiPickersYear", e);
}
const I1 = Bt("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]), iDe = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow"], sDe = (e) => {
  const {
    disabled: t,
    selected: n,
    classes: r
  } = e;
  return Kt({
    root: ["root"],
    yearButton: ["yearButton", t && "disabled", n && "selected"]
  }, aDe, r);
}, lDe = Ge("div", {
  name: "MuiPickersYear",
  slot: "Root",
  overridesResolver: (e, t) => [t.root]
})(({
  ownerState: e
}) => ({
  flexBasis: e.yearsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), uDe = Ge("button", {
  name: "MuiPickersYear",
  slot: "YearButton",
  overridesResolver: (e, t) => [t.yearButton, {
    [`&.${I1.disabled}`]: t.disabled
  }, {
    [`&.${I1.selected}`]: t.selected
  }]
})(({
  theme: e
}) => B({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, e.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.focusOpacity})` : Wn(e.palette.action.active, e.palette.action.focusOpacity)
  },
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${I1.disabled}`]: {
    color: (e.vars || e).palette.text.secondary
  },
  [`&.${I1.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  }
})), cDe = /* @__PURE__ */ C.memo(function(t) {
  const n = Lt({
    props: t,
    name: "MuiPickersYear"
  }), {
    autoFocus: r,
    className: a,
    children: s,
    disabled: l,
    value: p,
    tabIndex: m,
    onClick: h,
    onKeyDown: g,
    onFocus: b,
    onBlur: x,
    "aria-current": E
    // We don't want to forward this prop to the root element
  } = n, O = st(n, iDe), _ = C.useRef(null), P = sDe(n);
  return C.useEffect(() => {
    r && _.current.focus();
  }, [r]), /* @__PURE__ */ L.jsx(lDe, B({
    className: Ao(P.root, a),
    ownerState: n
  }, O, {
    children: /* @__PURE__ */ L.jsx(uDe, {
      ref: _,
      disabled: l,
      type: "button",
      tabIndex: l ? -1 : m,
      "aria-current": E,
      onClick: (M) => h(M, p),
      onKeyDown: (M) => g(M, p),
      onFocus: (M) => b(M, p),
      onBlur: (M) => x(M, p),
      className: P.yearButton,
      ownerState: n,
      children: s
    })
  }));
});
function dDe(e) {
  return Xt("MuiYearCalendar", e);
}
Bt("MuiYearCalendar", ["root"]);
const fDe = ["autoFocus", "className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow"], pDe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, dDe, t);
};
function mDe(e, t) {
  const n = or(), r = Am(), a = Lt({
    props: e,
    name: t
  });
  return B({
    disablePast: !1,
    disableFuture: !1
  }, a, {
    minDate: ni(n, a.minDate, r.minDate),
    maxDate: ni(n, a.maxDate, r.maxDate)
  });
}
const hDe = Ge("div", {
  name: "MuiYearCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  padding: "0 4px",
  width: 320,
  maxHeight: 304
}), MY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = jm(), a = lw(), s = or(), l = mDe(t, "MuiYearCalendar"), {
    autoFocus: p,
    className: m,
    value: h,
    defaultValue: g,
    disabled: b,
    disableFuture: x,
    disablePast: E,
    maxDate: O,
    minDate: _,
    onChange: P,
    readOnly: M,
    shouldDisableYear: D,
    disableHighlightToday: N,
    onYearFocus: I,
    hasFocus: R,
    onFocusedViewChange: j,
    yearsPerRow: U = 3
  } = l, q = st(l, fDe), J = l, H = pDe(J), [Z, re] = tl({
    name: "YearCalendar",
    state: "value",
    controlled: h,
    default: g ?? null
  }), Y = C.useMemo(() => Z ?? s.startOfYear(r), [r, s, Z]), K = C.useMemo(() => s.getYear(r), [s, r]), Q = C.useMemo(() => Z != null ? s.getYear(Z) : N ? null : s.getYear(r), [r, Z, s, N]), [te, ne] = C.useState(() => Q || K), [ae, se] = tl({
    name: "YearCalendar",
    state: "hasFocus",
    controlled: R,
    default: p ?? !1
  }), V = Zr((ye) => {
    se(ye), j && j(ye);
  }), ee = C.useCallback((ye) => !!(E && s.isBeforeYear(ye, r) || x && s.isAfterYear(ye, r) || _ && s.isBeforeYear(ye, _) || O && s.isAfterYear(ye, O) || D && D(ye)), [x, E, O, _, r, D, s]), he = Zr((ye, Oe) => {
    if (M)
      return;
    const Fe = s.setYear(Y, Oe);
    re(Fe), P == null || P(Fe);
  }), ue = Zr((ye) => {
    ee(s.setYear(Y, ye)) || (ne(ye), V(!0), I == null || I(ye));
  });
  C.useEffect(() => {
    ne((ye) => Q !== null && ye !== Q ? Q : ye);
  }, [Q]);
  const fe = Zr((ye, Oe) => {
    switch (ye.key) {
      case "ArrowUp":
        ue(Oe - U), ye.preventDefault();
        break;
      case "ArrowDown":
        ue(Oe + U), ye.preventDefault();
        break;
      case "ArrowLeft":
        ue(Oe + (a.direction === "ltr" ? -1 : 1)), ye.preventDefault();
        break;
      case "ArrowRight":
        ue(Oe + (a.direction === "ltr" ? 1 : -1)), ye.preventDefault();
        break;
    }
  }), Ce = Zr((ye, Oe) => {
    ue(Oe);
  }), Se = Zr((ye, Oe) => {
    te === Oe && V(!1);
  }), Te = C.useRef(null), pe = yo(n, Te);
  return C.useEffect(() => {
    if (p || Te.current === null)
      return;
    const ye = Te.current.querySelector('[tabindex="0"]');
    if (!ye)
      return;
    const Oe = ye.offsetHeight, Fe = ye.offsetTop, me = Te.current.clientHeight, Pe = Te.current.scrollTop, Ee = Fe + Oe;
    Oe > me || Fe < Pe || (Te.current.scrollTop = Ee - me / 2 - Oe / 2);
  }, [p]), /* @__PURE__ */ L.jsx(hDe, B({
    ref: pe,
    className: Ao(H.root, m),
    ownerState: J
  }, q, {
    children: s.getYearRange(_, O).map((ye) => {
      const Oe = s.getYear(ye), Fe = Oe === Q, me = b || ee(ye);
      return /* @__PURE__ */ L.jsx(cDe, {
        selected: Fe,
        value: Oe,
        onClick: he,
        onKeyDown: fe,
        autoFocus: ae && Oe === te,
        disabled: me,
        tabIndex: Oe === te ? 0 : -1,
        onFocus: Ce,
        onBlur: Se,
        "aria-current": K === Oe ? "date" : void 0,
        yearsPerRow: U,
        children: s.format(ye, "year")
      }, s.format(ye, "year"));
    })
  }));
});
process.env.NODE_ENV !== "production" && (MY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * className applied to the root element.
   */
  className: c.string,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true` picker is disabled
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  hasFocus: c.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   */
  onChange: c.func,
  onFocusedViewChange: c.func,
  onYearFocus: c.func,
  /**
   * If `true` picker is readonly
   */
  readOnly: c.bool,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: c.oneOf([3, 4])
});
const TN = Ge("div")({
  overflow: "hidden",
  width: v7,
  maxHeight: y7,
  display: "flex",
  flexDirection: "column",
  margin: "0 auto"
}), vDe = (e) => Xt("MuiDateCalendar", e);
Bt("MuiDateCalendar", ["root", "viewTransitionContainer"]);
const yDe = ["autoFocus", "onViewChange", "value", "defaultValue", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "components", "componentsProps", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow"], gDe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  }, vDe, t);
};
function bDe(e, t) {
  const n = or(), r = Am(), a = Lt({
    props: e,
    name: t
  });
  return B({
    loading: !1,
    disablePast: !1,
    disableFuture: !1,
    openTo: "day",
    views: ["year", "day"],
    reduceAnimations: JOe,
    renderLoading: () => /* @__PURE__ */ L.jsx("span", {
      children: "..."
    })
  }, a, {
    minDate: ni(n, a.minDate, r.minDate),
    maxDate: ni(n, a.maxDate, r.maxDate)
  });
}
const wDe = Ge(TN, {
  name: "MuiDateCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "column"
}), xDe = Ge(X7, {
  name: "MuiDateCalendar",
  slot: "ViewTransitionContainer",
  overridesResolver: (e, t) => t.viewTransitionContainer
})({}), _N = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = or(), a = uy(), s = bDe(t, "MuiDateCalendar"), {
    autoFocus: l,
    onViewChange: p,
    value: m,
    defaultValue: h,
    disableFuture: g,
    disablePast: b,
    defaultCalendarMonth: x,
    onChange: E,
    onYearChange: O,
    onMonthChange: _,
    reduceAnimations: P,
    shouldDisableDate: M,
    shouldDisableMonth: D,
    shouldDisableYear: N,
    view: I,
    views: R,
    openTo: j,
    className: U,
    disabled: q,
    readOnly: J,
    minDate: H,
    maxDate: Z,
    disableHighlightToday: re,
    focusedView: Y,
    onFocusedViewChange: K,
    showDaysOutsideCurrentMonth: Q,
    fixedWeekNumber: te,
    dayOfWeekFormatter: ne,
    components: ae,
    componentsProps: se,
    slots: V,
    slotProps: ee,
    loading: he,
    renderLoading: ue,
    displayWeekNumber: fe,
    yearsPerRow: Ce,
    monthsPerRow: Se
  } = s, Te = st(s, yDe), [pe, ye] = tl({
    name: "DateCalendar",
    state: "value",
    controlled: m,
    default: h ?? null
  }), Oe = Zr((vt, Nt) => {
    ye(vt), E == null || E(vt, Nt);
  }), {
    view: Fe,
    setView: me,
    focusedView: Pe,
    setFocusedView: Ee,
    goToNextView: Ke,
    setValueAndGoToNextView: oe
  } = c_({
    view: I,
    views: R,
    openTo: j,
    onChange: Oe,
    onViewChange: p,
    autoFocus: l,
    focusedView: Y,
    onFocusedViewChange: K
  }), {
    calendarState: de,
    changeFocusedDay: we,
    changeMonth: Me,
    handleChangeMonth: Ae,
    isDateDisabled: je,
    onMonthSwitchingAnimationEnd: qe
  } = VPe({
    value: pe,
    defaultCalendarMonth: x,
    reduceAnimations: P,
    onMonthChange: _,
    minDate: H,
    maxDate: Z,
    shouldDisableDate: M,
    disablePast: b,
    disableFuture: g
  }), ot = Zr((vt) => {
    const Nt = r.startOfMonth(vt), Tn = r.endOfMonth(vt), bt = je(vt) ? k0({
      utils: r,
      date: vt,
      minDate: r.isBefore(H, Nt) ? Nt : H,
      maxDate: r.isAfter(Z, Tn) ? Tn : Z,
      disablePast: b,
      disableFuture: g,
      isDateDisabled: je
    }) : vt;
    bt ? (oe(bt, "finish"), _ == null || _(Nt)) : (Ke(), Me(Nt)), we(bt, !0);
  }), et = Zr((vt) => {
    const Nt = r.startOfYear(vt), Tn = r.endOfYear(vt), bt = je(vt) ? k0({
      utils: r,
      date: vt,
      minDate: r.isBefore(H, Nt) ? Nt : H,
      maxDate: r.isAfter(Z, Tn) ? Tn : Z,
      disablePast: b,
      disableFuture: g,
      isDateDisabled: je
    }) : vt;
    bt ? (oe(bt, "finish"), O == null || O(bt)) : (Ke(), Me(Nt)), we(bt, !0);
  }), ct = Zr((vt) => Oe(pe && vt ? s$(r, vt, pe) : vt, "finish"));
  C.useEffect(() => {
    pe != null && r.isValid(pe) && Me(pe);
  }, [pe]);
  const Qt = s, Ht = gDe(Qt), kt = {
    disablePast: b,
    disableFuture: g,
    maxDate: Z,
    minDate: H
  }, St = q && pe || H, cn = q && pe || Z, Ne = {
    disableHighlightToday: re,
    readOnly: J,
    disabled: q
  }, Ie = `${a}-grid-label`, Je = Pe !== null, pt = C.useRef(Fe);
  C.useEffect(() => {
    pt.current !== Fe && (Pe === pt.current && Ee(Fe, !0), pt.current = Fe);
  }, [Pe, Ee, Fe]);
  const ht = C.useMemo(() => [pe], [pe]);
  return /* @__PURE__ */ L.jsxs(wDe, B({
    ref: n,
    className: Ao(Ht.root, U),
    ownerState: Qt
  }, Te, {
    children: [/* @__PURE__ */ L.jsx(pPe, {
      views: R,
      view: Fe,
      currentMonth: de.currentMonth,
      onViewChange: me,
      onMonthChange: (vt, Nt) => Ae({
        newMonth: vt,
        direction: Nt
      }),
      minDate: St,
      maxDate: cn,
      disabled: q,
      disablePast: b,
      disableFuture: g,
      reduceAnimations: P,
      labelId: Ie,
      slots: V,
      slotProps: ee
    }), /* @__PURE__ */ L.jsx(xDe, {
      reduceAnimations: P,
      className: Ht.viewTransitionContainer,
      transKey: Fe,
      ownerState: Qt,
      children: /* @__PURE__ */ L.jsxs("div", {
        children: [Fe === "year" && /* @__PURE__ */ L.jsx(MY, B({}, kt, Ne, {
          value: pe,
          onChange: et,
          shouldDisableYear: N,
          hasFocus: Je,
          onFocusedViewChange: (vt) => Ee("year", vt),
          yearsPerRow: Ce
        })), Fe === "month" && /* @__PURE__ */ L.jsx($Y, B({}, kt, Ne, {
          hasFocus: Je,
          className: U,
          value: pe,
          onChange: ot,
          shouldDisableMonth: D,
          onFocusedViewChange: (vt) => Ee("month", vt),
          monthsPerRow: Se
        })), Fe === "day" && /* @__PURE__ */ L.jsx(FPe, B({}, de, kt, Ne, {
          onMonthSwitchingAnimationEnd: qe,
          onFocusedDayChange: we,
          reduceAnimations: P,
          selectedDays: ht,
          onSelectedDaysChange: ct,
          shouldDisableDate: M,
          shouldDisableMonth: D,
          shouldDisableYear: N,
          hasFocus: Je,
          onFocusedViewChange: (vt) => Ee("day", vt),
          gridLabelId: Ie,
          showDaysOutsideCurrentMonth: Q,
          fixedWeekNumber: te,
          dayOfWeekFormatter: ne,
          displayWeekNumber: fe,
          components: ae,
          componentsProps: se,
          slots: V,
          slotProps: ee,
          loading: he,
          renderLoading: ue
        }))]
      })
    })]
  }));
});
process.env.NODE_ENV !== "production" && (_N.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  classes: c.object,
  className: c.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Controlled focused view.
   */
  focusedView: c.oneOf(["day", "month", "year"]),
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   */
  onChange: c.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "month", "year"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "month", "year"]),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: c.oneOf([3, 4])
});
const el = ({
  view: e,
  onViewChange: t,
  views: n,
  focusedView: r,
  onFocusedViewChange: a,
  value: s,
  defaultValue: l,
  onChange: p,
  className: m,
  classes: h,
  disableFuture: g,
  disablePast: b,
  minDate: x,
  maxDate: E,
  shouldDisableDate: O,
  shouldDisableMonth: _,
  shouldDisableYear: P,
  reduceAnimations: M,
  onMonthChange: D,
  monthsPerRow: N,
  onYearChange: I,
  yearsPerRow: R,
  defaultCalendarMonth: j,
  components: U,
  componentsProps: q,
  slots: J,
  slotProps: H,
  loading: Z,
  renderLoading: re,
  disableHighlightToday: Y,
  readOnly: K,
  disabled: Q,
  showDaysOutsideCurrentMonth: te,
  dayOfWeekFormatter: ne,
  sx: ae,
  autoFocus: se,
  fixedWeekNumber: V,
  displayWeekNumber: ee
}) => /* @__PURE__ */ L.jsx(_N, {
  view: e,
  onViewChange: t,
  views: n.filter(ny),
  focusedView: r && ny(r) ? r : null,
  onFocusedViewChange: a,
  value: s,
  defaultValue: l,
  onChange: p,
  className: m,
  classes: h,
  disableFuture: g,
  disablePast: b,
  minDate: x,
  maxDate: E,
  shouldDisableDate: O,
  shouldDisableMonth: _,
  shouldDisableYear: P,
  reduceAnimations: M,
  onMonthChange: D,
  monthsPerRow: N,
  onYearChange: I,
  yearsPerRow: R,
  defaultCalendarMonth: j,
  components: U,
  componentsProps: q,
  slots: J,
  slotProps: H,
  loading: Z,
  renderLoading: re,
  disableHighlightToday: Y,
  readOnly: K,
  disabled: Q,
  showDaysOutsideCurrentMonth: te,
  dayOfWeekFormatter: ne,
  sx: ae,
  autoFocus: se,
  fixedWeekNumber: V,
  displayWeekNumber: ee
}), NY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a;
  const s = es(), l = or(), p = Z9(t, "MuiDesktopDatePicker"), m = B({
    day: el,
    month: el,
    year: el
  }, p.viewRenderers), h = B({}, p, {
    viewRenderers: m,
    format: q0(l, p, !1),
    yearsPerRow: (r = p.yearsPerRow) != null ? r : 4,
    slots: B({
      openPickerIcon: o7,
      field: CN
    }, p.slots),
    slotProps: B({}, p.slotProps, {
      field: (b) => {
        var x;
        return B({}, Vf((x = p.slotProps) == null ? void 0 : x.field, b), d_(p), {
          ref: n
        });
      },
      toolbar: B({
        hidden: !0
      }, (a = p.slotProps) == null ? void 0 : a.toolbar)
    })
  }), {
    renderPicker: g
  } = lY({
    props: h,
    valueManager: Ny,
    valueType: "date",
    getOpenDialogAriaText: s.openDatePickerDialogue,
    validator: Sw
  });
  return g();
});
NY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    month: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: c.oneOf([3, 4])
};
const SDe = ["props", "getOpenDialogAriaText"], IY = (e) => {
  var t, n, r;
  let {
    props: a,
    getOpenDialogAriaText: s
  } = e, l = st(e, SDe);
  const {
    slots: p,
    slotProps: m,
    className: h,
    sx: g,
    format: b,
    formatDensity: x,
    label: E,
    inputRef: O,
    readOnly: _,
    disabled: P,
    localeText: M
  } = a, D = or(), N = C.useRef(null), I = iY(), R = (t = m == null || (n = m.toolbar) == null ? void 0 : n.hidden) != null ? t : !1, {
    open: j,
    actions: U,
    layoutProps: q,
    renderCurrentView: J,
    fieldProps: H
  } = j7(B({}, l, {
    props: a,
    inputRef: N,
    autoFocusView: !0,
    additionalViewProps: {},
    wrapperVariant: "mobile"
  })), Z = p.field, re = Gr({
    elementType: Z,
    externalSlotProps: m == null ? void 0 : m.field,
    additionalProps: B({}, H, R && {
      id: I
    }, !(P || _) && {
      onClick: U.onOpen,
      onKeyDown: f_e(U.onOpen)
    }, {
      readOnly: _ ?? !0,
      disabled: P,
      className: h,
      sx: g,
      format: b,
      formatDensity: x,
      label: E
    }),
    ownerState: a
  });
  re.inputProps = B({}, re.inputProps, {
    "aria-label": s(H.value, D)
  });
  const Y = B({
    textField: p.textField
  }, re.slots), K = (r = p.layout) != null ? r : hN, Q = u_(N, re.inputRef, O);
  let te = I;
  R && (E ? te = `${I}-label` : te = void 0);
  const ne = B({}, m, {
    toolbar: B({}, m == null ? void 0 : m.toolbar, {
      titleId: I
    }),
    mobilePaper: B({
      "aria-labelledby": te
    }, m == null ? void 0 : m.mobilePaper)
  });
  return {
    renderPicker: () => /* @__PURE__ */ L.jsxs(gw, {
      localeText: M,
      children: [/* @__PURE__ */ L.jsx(Z, B({}, re, {
        slots: Y,
        slotProps: ne,
        inputRef: Q
      })), /* @__PURE__ */ L.jsx(o_e, B({}, U, {
        open: j,
        slots: p,
        slotProps: ne,
        children: /* @__PURE__ */ L.jsx(K, B({}, q, ne == null ? void 0 : ne.layout, {
          slots: p,
          slotProps: ne,
          children: J()
        }))
      }))]
    })
  };
}, AY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r;
  const a = es(), s = or(), l = Z9(t, "MuiMobileDatePicker"), p = B({
    day: el,
    month: el,
    year: el
  }, l.viewRenderers), m = B({}, l, {
    viewRenderers: p,
    format: q0(s, l, !1),
    slots: B({
      field: CN
    }, l.slots),
    slotProps: B({}, l.slotProps, {
      field: (g) => {
        var b;
        return B({}, Vf((b = l.slotProps) == null ? void 0 : b.field, g), d_(l), {
          ref: n
        });
      },
      toolbar: B({
        hidden: !1
      }, (r = l.slotProps) == null ? void 0 : r.toolbar)
    })
  }), {
    renderPicker: h
  } = IY({
    props: m,
    valueManager: Ny,
    valueType: "date",
    getOpenDialogAriaText: a.openDatePickerDialogue,
    validator: Sw
  });
  return h();
});
AY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    month: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: c.oneOf([3, 4])
};
const EDe = ["desktopModeMediaQuery"], jY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDatePicker"
  }), {
    desktopModeMediaQuery: a = w7
  } = r, s = st(r, EDe);
  return g9(a, {
    defaultMatches: !0
  }) ? /* @__PURE__ */ L.jsx(NY, B({
    ref: n
  }, s)) : /* @__PURE__ */ L.jsx(AY, B({
    ref: n
  }, s));
});
process.env.NODE_ENV !== "production" && (jY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: c.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    month: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4 on desktop, 3 on mobile
   */
  yearsPerRow: c.oneOf([3, 4])
});
function CDe({ control: e, name: t, PopperProps: n, ...r }) {
  const {
    field: { ref: a, ...s },
    fieldState: { error: l }
  } = md({
    name: t,
    control: e
  }), p = Da(), m = C.useRef(), h = p.fn.variant({
    variant: "default",
    color: p.colors[p.primaryColor][p.fn.primaryShade()]
  });
  return /* @__PURE__ */ L.jsx(gw, { dateAdapter: v9, children: /* @__PURE__ */ L.jsx(
    jY,
    {
      components: {
        OpenPickerIcon: M8
      },
      OpenPickerButtonProps: {
        sx: {
          padding: 0,
          marginLeft: "-18px",
          color: p.colors.gray[7]
        }
      },
      PopperProps: {
        anchorEl: m.current,
        sx: {
          "& .Mui-selected": {
            backgroundColor: `${h.background} !important`,
            ...p.fn.hover({
              backgroundColor: `${h.hover} !important`
            })
          }
        },
        ...n
      },
      renderInput: ({ inputProps: g, ...b }) => /* @__PURE__ */ L.jsx(
        HT,
        {
          label: r.label,
          ref: m,
          error: !!l,
          rightSection: b.InputProps.endAdornment,
          ...g
        }
      ),
      inputRef: a,
      ...s,
      onChange: (g) => {
        s.onChange(g.toISOString().split("T")[0]);
      },
      ...r
    }
  ) });
}
const TDe = (e) => {
  var t, n, r, a, s, l, p, m;
  const h = or(), g = Am(), x = ((t = e.ampm) != null ? t : h.is12HourCycleInCurrentLocale()) ? h.formats.keyboardDateTime12h : h.formats.keyboardDateTime24h;
  return B({}, e, {
    disablePast: (n = e.disablePast) != null ? n : !1,
    disableFuture: (r = e.disableFuture) != null ? r : !1,
    format: (a = e.format) != null ? a : x,
    disableIgnoringDatePartForTimeValidation: !!(e.minDateTime || e.maxDateTime),
    minDate: ni(h, (s = e.minDateTime) != null ? s : e.minDate, g.minDate),
    maxDate: ni(h, (l = e.maxDateTime) != null ? l : e.maxDate, g.maxDate),
    minTime: (p = e.minDateTime) != null ? p : e.minTime,
    maxTime: (m = e.maxDateTime) != null ? m : e.maxTime
  });
}, _De = ({
  props: e,
  inputRef: t
}) => {
  const n = TDe(e), {
    forwardedProps: r,
    internalProps: a
  } = K7(n, "date-time");
  return A7({
    inputRef: t,
    forwardedProps: r,
    internalProps: a,
    valueManager: Ny,
    fieldValueManager: R9,
    validator: yN,
    valueType: "date-time"
  });
}, ODe = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"], PDe = ["inputRef"], RDe = ["ref", "onPaste", "inputMode", "readOnly"], ON = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s;
  const l = Lt({
    props: t,
    name: "MuiDateTimeField"
  }), {
    components: p,
    componentsProps: m,
    slots: h,
    slotProps: g,
    InputProps: b,
    inputProps: x
  } = l, E = st(l, ODe), O = l, _ = (r = (a = h == null ? void 0 : h.textField) != null ? a : p == null ? void 0 : p.TextField) != null ? r : DY, P = Gr({
    elementType: _,
    externalSlotProps: (s = g == null ? void 0 : g.textField) != null ? s : m == null ? void 0 : m.textField,
    externalForwardedProps: E,
    ownerState: O
  }), {
    inputRef: M
  } = P, D = st(P, PDe);
  D.inputProps = B({}, D.inputProps, x), D.InputProps = B({}, D.InputProps, b);
  const N = _De({
    props: D,
    inputRef: M
  }), {
    ref: I,
    onPaste: R,
    inputMode: j,
    readOnly: U
  } = N, q = st(N, RDe);
  return /* @__PURE__ */ L.jsx(_, B({
    ref: n
  }, q, {
    InputProps: B({}, q.InputProps, {
      readOnly: U
    }),
    inputProps: B({}, q.inputProps, {
      inputMode: j,
      onPaste: R,
      ref: I
    })
  }));
});
process.env.NODE_ENV !== "production" && (ON.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: c.bool,
  className: c.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: c.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: c.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: c.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: c.bool,
  /**
   * The helper text content.
   */
  helperText: c.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: c.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: c.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: c.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: c.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: c.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.any.isRequired
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: c.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: c.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Name attribute of the `input` element.
   */
  name: c.string,
  onBlur: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  onFocus: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: c.bool,
  /**
   * The date used to generate a part of the date-time that is not present in the format when both `value` and `defaultValue` are not present.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: c.any,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: c.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default `false`
   */
  shouldRespectLeadingZeros: c.bool,
  /**
   * The size of the component.
   */
  size: c.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  style: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: c.oneOfType([c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: c.oneOf(["filled", "outlined", "standard"])
});
function kDe(e) {
  return Xt("MuiTab", e);
}
const DDe = Bt("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]), rm = DDe, $De = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"], MDe = (e) => {
  const {
    classes: t,
    textColor: n,
    fullWidth: r,
    wrapped: a,
    icon: s,
    label: l,
    selected: p,
    disabled: m
  } = e, h = {
    root: ["root", s && l && "labelIcon", `textColor${xt(n)}`, r && "fullWidth", a && "wrapped", p && "selected", m && "disabled"],
    iconWrapper: ["iconWrapper"]
  };
  return Kt(h, kDe, t);
}, NDe = Ge(ld, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.label && n.icon && t.labelIcon, t[`textColor${xt(n.textColor)}`], n.fullWidth && t.fullWidth, n.wrapped && t.wrapped];
  }
})(({
  theme: e,
  ownerState: t
}) => B({}, e.typography.button, {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center"
}, t.label && {
  flexDirection: t.iconPosition === "top" || t.iconPosition === "bottom" ? "column" : "row"
}, {
  lineHeight: 1.25
}, t.icon && t.label && {
  minHeight: 72,
  paddingTop: 9,
  paddingBottom: 9,
  [`& > .${rm.iconWrapper}`]: B({}, t.iconPosition === "top" && {
    marginBottom: 6
  }, t.iconPosition === "bottom" && {
    marginTop: 6
  }, t.iconPosition === "start" && {
    marginRight: e.spacing(1)
  }, t.iconPosition === "end" && {
    marginLeft: e.spacing(1)
  })
}, t.textColor === "inherit" && {
  color: "inherit",
  opacity: 0.6,
  // same opacity as theme.palette.text.secondary
  [`&.${rm.selected}`]: {
    opacity: 1
  },
  [`&.${rm.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  }
}, t.textColor === "primary" && {
  color: (e.vars || e).palette.text.secondary,
  [`&.${rm.selected}`]: {
    color: (e.vars || e).palette.primary.main
  },
  [`&.${rm.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  }
}, t.textColor === "secondary" && {
  color: (e.vars || e).palette.text.secondary,
  [`&.${rm.selected}`]: {
    color: (e.vars || e).palette.secondary.main
  },
  [`&.${rm.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  }
}, t.fullWidth && {
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: 0,
  maxWidth: "none"
}, t.wrapped && {
  fontSize: e.typography.pxToRem(12)
})), LY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTab"
  }), {
    className: a,
    disabled: s = !1,
    disableFocusRipple: l = !1,
    // eslint-disable-next-line react/prop-types
    fullWidth: p,
    icon: m,
    iconPosition: h = "top",
    // eslint-disable-next-line react/prop-types
    indicator: g,
    label: b,
    onChange: x,
    onClick: E,
    onFocus: O,
    // eslint-disable-next-line react/prop-types
    selected: _,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus: P,
    // eslint-disable-next-line react/prop-types
    textColor: M = "inherit",
    value: D,
    wrapped: N = !1
  } = r, I = st(r, $De), R = B({}, r, {
    disabled: s,
    disableFocusRipple: l,
    selected: _,
    icon: !!m,
    iconPosition: h,
    label: !!b,
    fullWidth: p,
    textColor: M,
    wrapped: N
  }), j = MDe(R), U = m && b && /* @__PURE__ */ C.isValidElement(m) ? /* @__PURE__ */ C.cloneElement(m, {
    className: Wt(j.iconWrapper, m.props.className)
  }) : m, q = (H) => {
    !_ && x && x(H, D), E && E(H);
  }, J = (H) => {
    P && !_ && x && x(H, D), O && O(H);
  };
  return /* @__PURE__ */ L.jsxs(NDe, B({
    focusRipple: !l,
    className: Wt(j.root, a),
    ref: n,
    role: "tab",
    "aria-selected": _,
    disabled: s,
    onClick: q,
    onFocus: J,
    ownerState: R,
    tabIndex: _ ? 0 : -1
  }, I, {
    children: [h === "top" || h === "start" ? /* @__PURE__ */ L.jsxs(C.Fragment, {
      children: [U, b]
    }) : /* @__PURE__ */ L.jsxs(C.Fragment, {
      children: [b, U]
    }), g]
  }));
});
process.env.NODE_ENV !== "production" && (LY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: y3,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: c.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: c.bool,
  /**
   * The icon to display.
   */
  icon: c.oneOfType([c.element, c.string]),
  /**
   * The position of the icon relative to the label.
   * @default 'top'
   */
  iconPosition: c.oneOf(["bottom", "end", "start", "top"]),
  /**
   * The label element.
   */
  label: c.node,
  /**
   * @ignore
   */
  onChange: c.func,
  /**
   * @ignore
   */
  onClick: c.func,
  /**
   * @ignore
   */
  onFocus: c.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * You can provide your own value. Otherwise, we fallback to the child position index.
   */
  value: c.any,
  /**
   * Tab labels appear in a single row.
   * They can use a second line if needed.
   * @default false
   */
  wrapped: c.bool
});
const BU = LY;
function IDe(e) {
  return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2;
}
function ADe(e, t, n, r = {}, a = () => {
}) {
  const {
    ease: s = IDe,
    duration: l = 300
    // standard
  } = r;
  let p = null;
  const m = t[e];
  let h = !1;
  const g = () => {
    h = !0;
  }, b = (x) => {
    if (h) {
      a(new Error("Animation cancelled"));
      return;
    }
    p === null && (p = x);
    const E = Math.min(1, (x - p) / l);
    if (t[e] = s(E) * (n - m) + m, E >= 1) {
      requestAnimationFrame(() => {
        a(null);
      });
      return;
    }
    requestAnimationFrame(b);
  };
  return m === n ? (a(new Error("Element already at target position")), g) : (requestAnimationFrame(b), g);
}
const jDe = ["onChange"], LDe = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function FY(e) {
  const {
    onChange: t
  } = e, n = st(e, jDe), r = C.useRef(), a = C.useRef(null), s = () => {
    r.current = a.current.offsetHeight - a.current.clientHeight;
  };
  return ei(() => {
    const l = ly(() => {
      const m = r.current;
      s(), m !== r.current && t(r.current);
    }), p = rd(a.current);
    return p.addEventListener("resize", l), () => {
      l.clear(), p.removeEventListener("resize", l);
    };
  }, [t]), C.useEffect(() => {
    s(), t(r.current);
  }, [t]), /* @__PURE__ */ L.jsx("div", B({
    style: LDe,
    ref: a
  }, n));
}
process.env.NODE_ENV !== "production" && (FY.propTypes = {
  onChange: c.func.isRequired
});
const g$ = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft"), b$ = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function FDe(e) {
  return Xt("MuiTabScrollButton", e);
}
const zDe = Bt("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]), VDe = zDe, UDe = ["className", "slots", "slotProps", "direction", "orientation", "disabled"], BDe = (e) => {
  const {
    classes: t,
    orientation: n,
    disabled: r
  } = e;
  return Kt({
    root: ["root", n, r && "disabled"]
  }, FDe, t);
}, HDe = Ge(ld, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.orientation && t[n.orientation]];
  }
})(({
  ownerState: e
}) => B({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${VDe.disabled}`]: {
    opacity: 0
  }
}, e.orientation === "vertical" && {
  width: "100%",
  height: 40,
  "& svg": {
    transform: `rotate(${e.isRtl ? -90 : 90}deg)`
  }
})), zY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a;
  const s = Lt({
    props: t,
    name: "MuiTabScrollButton"
  }), {
    className: l,
    slots: p = {},
    slotProps: m = {},
    direction: h
  } = s, g = st(s, UDe), x = Ji().direction === "rtl", E = B({
    isRtl: x
  }, s), O = BDe(E), _ = (r = p.StartScrollButtonIcon) != null ? r : g$, P = (a = p.EndScrollButtonIcon) != null ? a : b$, M = Gr({
    elementType: _,
    externalSlotProps: m.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: E
  }), D = Gr({
    elementType: P,
    externalSlotProps: m.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: E
  });
  return /* @__PURE__ */ L.jsx(HDe, B({
    component: "div",
    className: Wt(O.root, l),
    ref: n,
    role: null,
    ownerState: E,
    tabIndex: null
  }, g, {
    children: h === "left" ? /* @__PURE__ */ L.jsx(_, B({}, M)) : /* @__PURE__ */ L.jsx(P, B({}, D))
  }));
});
process.env.NODE_ENV !== "production" && (zY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The direction the button should indicate.
   */
  direction: c.oneOf(["left", "right"]).isRequired,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * The component orientation (layout flow direction).
   */
  orientation: c.oneOf(["horizontal", "vertical"]).isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: c.shape({
    endScrollButtonIcon: c.oneOfType([c.func, c.object]),
    startScrollButtonIcon: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: c.shape({
    EndScrollButtonIcon: c.elementType,
    StartScrollButtonIcon: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const WDe = zY;
function YDe(e) {
  return Xt("MuiTabs", e);
}
const qDe = Bt("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]), lE = qDe, GDe = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"], HU = (e, t) => e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e.firstChild, WU = (e, t) => e === t ? e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e.lastChild, A1 = (e, t, n) => {
  let r = !1, a = n(e, t);
  for (; a; ) {
    if (a === e.firstChild) {
      if (r)
        return;
      r = !0;
    }
    const s = a.disabled || a.getAttribute("aria-disabled") === "true";
    if (!a.hasAttribute("tabindex") || s)
      a = n(e, a);
    else {
      a.focus();
      return;
    }
  }
}, KDe = (e) => {
  const {
    vertical: t,
    fixed: n,
    hideScrollbar: r,
    scrollableX: a,
    scrollableY: s,
    centered: l,
    scrollButtonsHideMobile: p,
    classes: m
  } = e;
  return Kt({
    root: ["root", t && "vertical"],
    scroller: ["scroller", n && "fixed", r && "hideScrollbar", a && "scrollableX", s && "scrollableY"],
    flexContainer: ["flexContainer", t && "flexContainerVertical", l && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", p && "scrollButtonsHideMobile"],
    scrollableX: [a && "scrollableX"],
    hideScrollbar: [r && "hideScrollbar"]
  }, YDe, m);
}, XDe = Ge("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${lE.scrollButtons}`]: t.scrollButtons
    }, {
      [`& .${lE.scrollButtons}`]: n.scrollButtonsHideMobile && t.scrollButtonsHideMobile
    }, t.root, n.vertical && t.vertical];
  }
})(({
  ownerState: e,
  theme: t
}) => B({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex"
}, e.vertical && {
  flexDirection: "column"
}, e.scrollButtonsHideMobile && {
  [`& .${lE.scrollButtons}`]: {
    [t.breakpoints.down("sm")]: {
      display: "none"
    }
  }
})), QDe = Ge("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.scroller, n.fixed && t.fixed, n.hideScrollbar && t.hideScrollbar, n.scrollableX && t.scrollableX, n.scrollableY && t.scrollableY];
  }
})(({
  ownerState: e
}) => B({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap"
}, e.fixed && {
  overflowX: "hidden",
  width: "100%"
}, e.hideScrollbar && {
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}, e.scrollableX && {
  overflowX: "auto",
  overflowY: "hidden"
}, e.scrollableY && {
  overflowY: "auto",
  overflowX: "hidden"
})), ZDe = Ge("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.flexContainer, n.vertical && t.flexContainerVertical, n.centered && t.centered];
  }
})(({
  ownerState: e
}) => B({
  display: "flex"
}, e.vertical && {
  flexDirection: "column"
}, e.centered && {
  justifyContent: "center"
})), JDe = Ge("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (e, t) => t.indicator
})(({
  ownerState: e,
  theme: t
}) => B({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: t.transitions.create()
}, e.indicatorColor === "primary" && {
  backgroundColor: (t.vars || t).palette.primary.main
}, e.indicatorColor === "secondary" && {
  backgroundColor: (t.vars || t).palette.secondary.main
}, e.vertical && {
  height: "100%",
  width: 2,
  right: 0
})), e$e = Ge(FY, {
  name: "MuiTabs",
  slot: "ScrollbarSize"
})({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}), YU = {};
let qU = !1;
const VY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTabs"
  }), a = Ji(), s = a.direction === "rtl", {
    "aria-label": l,
    "aria-labelledby": p,
    action: m,
    centered: h = !1,
    children: g,
    className: b,
    component: x = "div",
    allowScrollButtonsMobile: E = !1,
    indicatorColor: O = "primary",
    onChange: _,
    orientation: P = "horizontal",
    ScrollButtonComponent: M = WDe,
    scrollButtons: D = "auto",
    selectionFollowsFocus: N,
    slots: I = {},
    slotProps: R = {},
    TabIndicatorProps: j = {},
    TabScrollButtonProps: U = {},
    textColor: q = "primary",
    value: J,
    variant: H = "standard",
    visibleScrollbar: Z = !1
  } = r, re = st(r, GDe), Y = H === "scrollable", K = P === "vertical", Q = K ? "scrollTop" : "scrollLeft", te = K ? "top" : "left", ne = K ? "bottom" : "right", ae = K ? "clientHeight" : "clientWidth", se = K ? "height" : "width", V = B({}, r, {
    component: x,
    allowScrollButtonsMobile: E,
    indicatorColor: O,
    orientation: P,
    vertical: K,
    scrollButtons: D,
    textColor: q,
    variant: H,
    visibleScrollbar: Z,
    fixed: !Y,
    hideScrollbar: Y && !Z,
    scrollableX: Y && !K,
    scrollableY: Y && K,
    centered: h && !Y,
    scrollButtonsHideMobile: !E
  }), ee = KDe(V), he = Gr({
    elementType: I.StartScrollButtonIcon,
    externalSlotProps: R.startScrollButtonIcon,
    ownerState: V
  }), ue = Gr({
    elementType: I.EndScrollButtonIcon,
    externalSlotProps: R.endScrollButtonIcon,
    ownerState: V
  });
  process.env.NODE_ENV !== "production" && h && Y && console.error('MUI: You can not use the `centered={true}` and `variant="scrollable"` properties at the same time on a `Tabs` component.');
  const [fe, Ce] = C.useState(!1), [Se, Te] = C.useState(YU), [pe, ye] = C.useState({
    start: !1,
    end: !1
  }), [Oe, Fe] = C.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  }), me = /* @__PURE__ */ new Map(), Pe = C.useRef(null), Ee = C.useRef(null), Ke = () => {
    const Ie = Pe.current;
    let Je;
    if (Ie) {
      const ht = Ie.getBoundingClientRect();
      Je = {
        clientWidth: Ie.clientWidth,
        scrollLeft: Ie.scrollLeft,
        scrollTop: Ie.scrollTop,
        scrollLeftNormalized: rL(Ie, a.direction),
        scrollWidth: Ie.scrollWidth,
        top: ht.top,
        bottom: ht.bottom,
        left: ht.left,
        right: ht.right
      };
    }
    let pt;
    if (Ie && J !== !1) {
      const ht = Ee.current.children;
      if (ht.length > 0) {
        const vt = ht[me.get(J)];
        process.env.NODE_ENV !== "production" && (vt || console.error(["MUI: The `value` provided to the Tabs component is invalid.", `None of the Tabs' children match with "${J}".`, me.keys ? `You can provide one of the following values: ${Array.from(me.keys()).join(", ")}.` : null].join(`
`))), pt = vt ? vt.getBoundingClientRect() : null, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && !qU && pt && pt.width === 0 && pt.height === 0 && // if the whole Tabs component is hidden, don't warn
        Je.clientWidth !== 0 && (Je = null, console.error(["MUI: The `value` provided to the Tabs component is invalid.", `The Tab with this \`value\` ("${J}") is not part of the document layout.`, "Make sure the tab item is present in the document or that it's not `display: none`."].join(`
`)), qU = !0);
      }
    }
    return {
      tabsMeta: Je,
      tabMeta: pt
    };
  }, oe = Zr(() => {
    const {
      tabsMeta: Ie,
      tabMeta: Je
    } = Ke();
    let pt = 0, ht;
    if (K)
      ht = "top", Je && Ie && (pt = Je.top - Ie.top + Ie.scrollTop);
    else if (ht = s ? "right" : "left", Je && Ie) {
      const Nt = s ? Ie.scrollLeftNormalized + Ie.clientWidth - Ie.scrollWidth : Ie.scrollLeft;
      pt = (s ? -1 : 1) * (Je[ht] - Ie[ht] + Nt);
    }
    const vt = {
      [ht]: pt,
      // May be wrong until the font is loaded.
      [se]: Je ? Je[se] : 0
    };
    if (isNaN(Se[ht]) || isNaN(Se[se]))
      Te(vt);
    else {
      const Nt = Math.abs(Se[ht] - vt[ht]), Tn = Math.abs(Se[se] - vt[se]);
      (Nt >= 1 || Tn >= 1) && Te(vt);
    }
  }), de = (Ie, {
    animation: Je = !0
  } = {}) => {
    Je ? ADe(Q, Pe.current, Ie, {
      duration: a.transitions.duration.standard
    }) : Pe.current[Q] = Ie;
  }, we = (Ie) => {
    let Je = Pe.current[Q];
    K ? Je += Ie : (Je += Ie * (s ? -1 : 1), Je *= s && b3() === "reverse" ? -1 : 1), de(Je);
  }, Me = () => {
    const Ie = Pe.current[ae];
    let Je = 0;
    const pt = Array.from(Ee.current.children);
    for (let ht = 0; ht < pt.length; ht += 1) {
      const vt = pt[ht];
      if (Je + vt[ae] > Ie) {
        ht === 0 && (Je = Ie);
        break;
      }
      Je += vt[ae];
    }
    return Je;
  }, Ae = () => {
    we(-1 * Me());
  }, je = () => {
    we(Me());
  }, qe = C.useCallback((Ie) => {
    Fe({
      overflow: null,
      scrollbarWidth: Ie
    });
  }, []), ot = () => {
    const Ie = {};
    Ie.scrollbarSizeListener = Y ? /* @__PURE__ */ L.jsx(e$e, {
      onChange: qe,
      className: Wt(ee.scrollableX, ee.hideScrollbar)
    }) : null;
    const Je = pe.start || pe.end, pt = Y && (D === "auto" && Je || D === !0);
    return Ie.scrollButtonStart = pt ? /* @__PURE__ */ L.jsx(M, B({
      slots: {
        StartScrollButtonIcon: I.StartScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: he
      },
      orientation: P,
      direction: s ? "right" : "left",
      onClick: Ae,
      disabled: !pe.start
    }, U, {
      className: Wt(ee.scrollButtons, U.className)
    })) : null, Ie.scrollButtonEnd = pt ? /* @__PURE__ */ L.jsx(M, B({
      slots: {
        EndScrollButtonIcon: I.EndScrollButtonIcon
      },
      slotProps: {
        endScrollButtonIcon: ue
      },
      orientation: P,
      direction: s ? "left" : "right",
      onClick: je,
      disabled: !pe.end
    }, U, {
      className: Wt(ee.scrollButtons, U.className)
    })) : null, Ie;
  }, et = Zr((Ie) => {
    const {
      tabsMeta: Je,
      tabMeta: pt
    } = Ke();
    if (!(!pt || !Je)) {
      if (pt[te] < Je[te]) {
        const ht = Je[Q] + (pt[te] - Je[te]);
        de(ht, {
          animation: Ie
        });
      } else if (pt[ne] > Je[ne]) {
        const ht = Je[Q] + (pt[ne] - Je[ne]);
        de(ht, {
          animation: Ie
        });
      }
    }
  }), ct = Zr(() => {
    if (Y && D !== !1) {
      const {
        scrollTop: Ie,
        scrollHeight: Je,
        clientHeight: pt,
        scrollWidth: ht,
        clientWidth: vt
      } = Pe.current;
      let Nt, Tn;
      if (K)
        Nt = Ie > 1, Tn = Ie < Je - pt - 1;
      else {
        const bt = rL(Pe.current, a.direction);
        Nt = s ? bt < ht - vt - 1 : bt > 1, Tn = s ? bt > 1 : bt < ht - vt - 1;
      }
      (Nt !== pe.start || Tn !== pe.end) && ye({
        start: Nt,
        end: Tn
      });
    }
  });
  C.useEffect(() => {
    const Ie = ly(() => {
      Pe.current && (oe(), ct());
    }), Je = rd(Pe.current);
    Je.addEventListener("resize", Ie);
    let pt;
    return typeof ResizeObserver < "u" && (pt = new ResizeObserver(Ie), Array.from(Ee.current.children).forEach((ht) => {
      pt.observe(ht);
    })), () => {
      Ie.clear(), Je.removeEventListener("resize", Ie), pt && pt.disconnect();
    };
  }, [oe, ct]);
  const Qt = C.useMemo(() => ly(() => {
    ct();
  }), [ct]);
  C.useEffect(() => () => {
    Qt.clear();
  }, [Qt]), C.useEffect(() => {
    Ce(!0);
  }, []), C.useEffect(() => {
    oe(), ct();
  }), C.useEffect(() => {
    et(YU !== Se);
  }, [et, Se]), C.useImperativeHandle(m, () => ({
    updateIndicator: oe,
    updateScrollButtons: ct
  }), [oe, ct]);
  const Ht = /* @__PURE__ */ L.jsx(JDe, B({}, j, {
    className: Wt(ee.indicator, j.className),
    ownerState: V,
    style: B({}, Se, j.style)
  }));
  let kt = 0;
  const St = C.Children.map(g, (Ie) => {
    if (!/* @__PURE__ */ C.isValidElement(Ie))
      return null;
    process.env.NODE_ENV !== "production" && sy.isFragment(Ie) && console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    const Je = Ie.props.value === void 0 ? kt : Ie.props.value;
    me.set(Je, kt);
    const pt = Je === J;
    return kt += 1, /* @__PURE__ */ C.cloneElement(Ie, B({
      fullWidth: H === "fullWidth",
      indicator: pt && !fe && Ht,
      selected: pt,
      selectionFollowsFocus: N,
      onChange: _,
      textColor: q,
      value: Je
    }, kt === 1 && J === !1 && !Ie.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  }), cn = (Ie) => {
    const Je = Ee.current, pt = aa(Je).activeElement;
    if (pt.getAttribute("role") !== "tab")
      return;
    let vt = P === "horizontal" ? "ArrowLeft" : "ArrowUp", Nt = P === "horizontal" ? "ArrowRight" : "ArrowDown";
    switch (P === "horizontal" && s && (vt = "ArrowRight", Nt = "ArrowLeft"), Ie.key) {
      case vt:
        Ie.preventDefault(), A1(Je, pt, WU);
        break;
      case Nt:
        Ie.preventDefault(), A1(Je, pt, HU);
        break;
      case "Home":
        Ie.preventDefault(), A1(Je, null, HU);
        break;
      case "End":
        Ie.preventDefault(), A1(Je, null, WU);
        break;
    }
  }, Ne = ot();
  return /* @__PURE__ */ L.jsxs(XDe, B({
    className: Wt(ee.root, b),
    ownerState: V,
    ref: n,
    as: x
  }, re, {
    children: [Ne.scrollButtonStart, Ne.scrollbarSizeListener, /* @__PURE__ */ L.jsxs(QDe, {
      className: ee.scroller,
      ownerState: V,
      style: {
        overflow: Oe.overflow,
        [K ? `margin${s ? "Left" : "Right"}` : "marginBottom"]: Z ? void 0 : -Oe.scrollbarWidth
      },
      ref: Pe,
      onScroll: Qt,
      children: [/* @__PURE__ */ L.jsx(ZDe, {
        "aria-label": l,
        "aria-labelledby": p,
        "aria-orientation": P === "vertical" ? "vertical" : null,
        className: ee.flexContainer,
        ownerState: V,
        onKeyDown: cn,
        ref: Ee,
        role: "tablist",
        children: St
      }), fe && Ht]
    }), Ne.scrollButtonEnd]
  }));
});
process.env.NODE_ENV !== "production" && (VY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when the component mounts.
   * This is useful when you want to trigger an action programmatically.
   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`
   *
   * @param {object} actions This object contains all possible actions
   * that can be triggered programmatically.
   */
  action: il,
  /**
   * If `true`, the scroll buttons aren't forced hidden on mobile.
   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.
   * @default false
   */
  allowScrollButtonsMobile: c.bool,
  /**
   * The label for the Tabs as a string.
   */
  "aria-label": c.string,
  /**
   * An id or list of ids separated by a space that label the Tabs.
   */
  "aria-labelledby": c.string,
  /**
   * If `true`, the tabs are centered.
   * This prop is intended for large views.
   * @default false
   */
  centered: c.bool,
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * Determines the color of the indicator.
   * @default 'primary'
   */
  indicatorColor: c.oneOfType([c.oneOf(["primary", "secondary"]), c.string]),
  /**
   * Callback fired when the value changes.
   *
   * @param {React.SyntheticEvent} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {any} value We default to the index of the child (number)
   */
  onChange: c.func,
  /**
   * The component orientation (layout flow direction).
   * @default 'horizontal'
   */
  orientation: c.oneOf(["horizontal", "vertical"]),
  /**
   * The component used to render the scroll buttons.
   * @default TabScrollButton
   */
  ScrollButtonComponent: c.elementType,
  /**
   * Determine behavior of scroll buttons when tabs are set to scroll:
   *
   * - `auto` will only present them when not all the items are visible.
   * - `true` will always present them.
   * - `false` will never present them.
   *
   * By default the scroll buttons are hidden on mobile.
   * This behavior can be disabled with `allowScrollButtonsMobile`.
   * @default 'auto'
   */
  scrollButtons: c.oneOf(["auto", !1, !0]),
  /**
   * If `true` the selected tab changes on focus. Otherwise it only
   * changes on activation.
   */
  selectionFollowsFocus: c.bool,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: c.shape({
    endScrollButtonIcon: c.oneOfType([c.func, c.object]),
    startScrollButtonIcon: c.oneOfType([c.func, c.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: c.shape({
    EndScrollButtonIcon: c.elementType,
    StartScrollButtonIcon: c.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Props applied to the tab indicator element.
   * @default  {}
   */
  TabIndicatorProps: c.object,
  /**
   * Props applied to the [`TabScrollButton`](/material-ui/api/tab-scroll-button/) element.
   * @default {}
   */
  TabScrollButtonProps: c.object,
  /**
   * Determines the color of the `Tab`.
   * @default 'primary'
   */
  textColor: c.oneOf(["inherit", "primary", "secondary"]),
  /**
   * The value of the currently selected `Tab`.
   * If you don't want any selected `Tab`, you can set this prop to `false`.
   */
  value: c.any,
  /**
   * Determines additional display behavior of the tabs:
   *
   *  - `scrollable` will invoke scrolling properties and allow for horizontally
   *  scrolling (or swiping) of the tab bar.
   *  -`fullWidth` will make the tabs grow to use all the available space,
   *  which should be used for small views, like on mobile.
   *  - `standard` will render the default state.
   * @default 'standard'
   */
  variant: c.oneOf(["fullWidth", "scrollable", "standard"]),
  /**
   * If `true`, the scrollbar is visible. It can be useful when displaying
   * a long vertical list of tabs.
   * @default false
   */
  visibleScrollbar: c.bool
});
const t$e = VY;
function n$e(e) {
  return Xt("MuiDateTimePickerTabs", e);
}
Bt("MuiDateTimePickerTabs", ["root"]);
const r$e = (e) => ny(e) ? "date" : "time", o$e = (e) => e === "date" ? "day" : "hours", a$e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, n$e, t);
}, i$e = Ge(t$e, {
  name: "MuiDateTimePickerTabs",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  boxShadow: `0 -1px 0 0 inset ${(e.vars || e).palette.divider}`,
  "&:last-child": {
    boxShadow: `0 1px 0 0 inset ${(e.vars || e).palette.divider}`,
    [`& .${lE.indicator}`]: {
      bottom: "auto",
      top: 0
    }
  }
})), UY = function(t) {
  const n = Lt({
    props: t,
    name: "MuiDateTimePickerTabs"
  }), {
    dateIcon: r = /* @__PURE__ */ L.jsx(vTe, {}),
    onViewChange: a,
    timeIcon: s = /* @__PURE__ */ L.jsx(yTe, {}),
    view: l,
    hidden: p = typeof window > "u" || window.innerHeight < 667
  } = n, m = es(), h = a$e(n), g = (b, x) => {
    a(o$e(x));
  };
  return p ? null : /* @__PURE__ */ L.jsxs(i$e, {
    ownerState: n,
    variant: "fullWidth",
    value: r$e(l),
    onChange: g,
    className: h.root,
    children: [/* @__PURE__ */ L.jsx(BU, {
      value: "date",
      "aria-label": m.dateTableLabel,
      icon: /* @__PURE__ */ L.jsx(C.Fragment, {
        children: r
      })
    }), /* @__PURE__ */ L.jsx(BU, {
      value: "time",
      "aria-label": m.timeTableLabel,
      icon: /* @__PURE__ */ L.jsx(C.Fragment, {
        children: s
      })
    })]
  });
};
process.env.NODE_ENV !== "production" && (UY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * Date tab icon.
   * @default DateRange
   */
  dateIcon: c.node,
  /**
   * Toggles visibility of the tabs allowing view switching.
   * @default `window.innerHeight < 667` for `DesktopDateTimePicker` and `MobileDateTimePicker`, `displayStaticWrapperAs === 'desktop'` for `StaticDateTimePicker`
   */
  hidden: c.bool,
  /**
   * Callback called when a tab is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: c.func.isRequired,
  /**
   * Time tab icon.
   * @default Time
   */
  timeIcon: c.node,
  /**
   * Currently visible picker view.
   */
  view: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired
});
function s$e(e) {
  return Xt("MuiDateTimePickerToolbar", e);
}
const tD = Bt("MuiDateTimePickerToolbar", ["root", "dateContainer", "timeContainer", "timeDigitsContainer", "separator", "timeLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]), l$e = ["ampm", "ampmInClock", "value", "onChange", "view", "isLandscape", "onViewChange", "toolbarFormat", "toolbarPlaceholder", "views", "disabled", "readOnly", "toolbarVariant"], u$e = (e) => {
  const {
    classes: t,
    theme: n,
    isLandscape: r
  } = e, a = {
    root: ["root"],
    dateContainer: ["dateContainer"],
    timeContainer: ["timeContainer", n.direction === "rtl" && "timeLabelReverse"],
    timeDigitsContainer: ["timeDigitsContainer", n.direction === "rtl" && "timeLabelReverse"],
    separator: ["separator"],
    ampmSelection: ["ampmSelection", r && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return Kt(a, s$e, t);
}, BY = Ge(X9, {
  name: "MuiDateTimePickerToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => ({
  paddingLeft: t.toolbarVariant === "desktop" && !t.isLandscape ? 24 : 16,
  paddingRight: t.toolbarVariant === "desktop" && !t.isLandscape ? 0 : 16,
  borderBottom: t.toolbarVariant === "desktop" ? `1px solid ${(e.vars || e).palette.divider}` : void 0,
  borderRight: t.toolbarVariant === "desktop" && t.isLandscape ? `1px solid ${(e.vars || e).palette.divider}` : void 0,
  justifyContent: "space-around",
  position: "relative",
  [`& .${xCe.penIconButton}`]: B({
    position: "absolute",
    top: 8
  }, e.direction === "rtl" ? {
    left: 8
  } : {
    right: 8
  })
}));
BY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: c.elementType,
  classes: c.object,
  className: c.string,
  isLandscape: c.bool.isRequired,
  isMobileKeyboardViewOpen: c.bool,
  landscapeDirection: c.oneOf(["column", "row"]),
  ownerState: c.object.isRequired,
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  toggleMobileKeyboardView: c.func,
  toolbarTitle: c.node,
  viewType: c.oneOf(["date", "time"])
};
const c$e = Ge("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "DateContainer",
  overridesResolver: (e, t) => t.dateContainer
})({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start"
}), HY = Ge("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeContainer",
  overridesResolver: (e, t) => t.timeContainer
})(({
  theme: e,
  ownerState: t
}) => {
  const n = t.isLandscape && t.toolbarVariant !== "desktop" ? "column" : "row";
  return B({
    display: "flex",
    flexDirection: n
  }, t.toolbarVariant === "desktop" && B({}, !t.isLandscape && {
    gap: 9,
    marginRight: 4,
    alignSelf: "flex-end"
  }), e.direction === "rtl" && {
    flexDirection: `${n}-reverse`
  });
}), d$e = Ge("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeDigitsContainer",
  overridesResolver: (e, t) => t.timeDigitsContainer
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "flex"
}, t.toolbarVariant === "desktop" && {
  gap: 1.5
}, e.direction === "rtl" && {
  flexDirection: "row-reverse"
}));
HY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: c.elementType,
  ownerState: c.object.isRequired,
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
};
const GU = Ge(C7, {
  name: "MuiDateTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (e, t) => t.separator
})(({
  ownerState: e
}) => ({
  margin: e.toolbarVariant === "desktop" ? 0 : "0 4px 0 2px",
  cursor: "default"
})), f$e = Ge("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (e, t) => [{
    [`.${tD.ampmLabel}`]: t.ampmLabel
  }, {
    [`&.${tD.ampmLandscape}`]: t.ampmLandscape
  }, t.ampmSelection]
})(({
  ownerState: e
}) => B({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12
}, e.isLandscape && {
  margin: "4px 0 auto",
  flexDirection: "row",
  justifyContent: "space-around",
  width: "100%"
}, {
  [`& .${tD.ampmLabel}`]: {
    fontSize: 17
  }
}));
function WY(e) {
  const t = Lt({
    props: e,
    name: "MuiDateTimePickerToolbar"
  }), {
    ampm: n,
    ampmInClock: r,
    value: a,
    onChange: s,
    view: l,
    isLandscape: p,
    onViewChange: m,
    toolbarFormat: h,
    toolbarPlaceholder: g = "––",
    views: b,
    disabled: x,
    readOnly: E,
    toolbarVariant: O = "mobile"
  } = t, _ = st(t, l$e), P = t, M = or(), {
    meridiemMode: D,
    handleMeridiemChange: N
  } = vN(a, n, s), I = !!(n && !r), R = O === "desktop", j = es(), U = Ji(), q = u$e(B({}, P, {
    theme: U
  })), J = (Z) => n ? M.format(Z, "hours12h") : M.format(Z, "hours24h"), H = C.useMemo(() => a ? h ? M.formatByString(a, h) : M.format(a, "shortDate") : g, [a, h, g, M]);
  return /* @__PURE__ */ L.jsxs(BY, B({
    toolbarTitle: j.dateTimePickerToolbarTitle,
    isLandscape: p,
    className: q.root
  }, _, {
    ownerState: P,
    children: [/* @__PURE__ */ L.jsxs(c$e, {
      className: q.dateContainer,
      ownerState: P,
      children: [b.includes("year") && /* @__PURE__ */ L.jsx(Cf, {
        tabIndex: -1,
        variant: "subtitle1",
        onClick: () => m("year"),
        selected: l === "year",
        value: a ? M.format(a, "year") : "–"
      }), b.includes("day") && /* @__PURE__ */ L.jsx(Cf, {
        tabIndex: -1,
        variant: R ? "h5" : "h4",
        onClick: () => m("day"),
        selected: l === "day",
        value: H
      })]
    }), /* @__PURE__ */ L.jsxs(HY, {
      className: q.timeContainer,
      ownerState: P,
      children: [/* @__PURE__ */ L.jsxs(d$e, {
        className: q.timeDigitsContainer,
        ownerState: P,
        children: [b.includes("hours") && /* @__PURE__ */ L.jsx(Cf, {
          variant: R ? "h5" : "h3",
          width: R && !p ? w0 : void 0,
          onClick: () => m("hours"),
          selected: l === "hours",
          value: a ? J(a) : "--"
        }), b.includes("minutes") && /* @__PURE__ */ L.jsxs(C.Fragment, {
          children: [/* @__PURE__ */ L.jsx(GU, {
            variant: R ? "h5" : "h3",
            value: ":",
            className: q.separator,
            ownerState: P
          }), /* @__PURE__ */ L.jsx(Cf, {
            variant: R ? "h5" : "h3",
            width: R && !p ? w0 : void 0,
            onClick: () => m("minutes"),
            selected: l === "minutes",
            value: a ? M.format(a, "minutes") : "--"
          })]
        }), b.includes("seconds") && /* @__PURE__ */ L.jsxs(C.Fragment, {
          children: [/* @__PURE__ */ L.jsx(GU, {
            variant: R ? "h5" : "h3",
            value: ":",
            className: q.separator,
            ownerState: P
          }), /* @__PURE__ */ L.jsx(Cf, {
            variant: R ? "h5" : "h3",
            width: R && !p ? w0 : void 0,
            onClick: () => m("seconds"),
            selected: l === "seconds",
            value: a ? M.format(a, "seconds") : "--"
          })]
        })]
      }), I && !R && /* @__PURE__ */ L.jsxs(f$e, {
        className: q.ampmSelection,
        ownerState: P,
        children: [/* @__PURE__ */ L.jsx(Cf, {
          variant: "subtitle2",
          selected: D === "am",
          typographyClassName: q.ampmLabel,
          value: M.getMeridiemText("am"),
          onClick: E ? void 0 : () => N("am"),
          disabled: x
        }), /* @__PURE__ */ L.jsx(Cf, {
          variant: "subtitle2",
          selected: D === "pm",
          typographyClassName: q.ampmLabel,
          value: M.getMeridiemText("pm"),
          onClick: E ? void 0 : () => N("pm"),
          disabled: x
        })]
      }), n && R && /* @__PURE__ */ L.jsx(Cf, {
        variant: "h5",
        onClick: () => m("meridiem"),
        selected: l === "meridiem",
        value: a && D ? M.getMeridiemText(D) : "--",
        width: w0
      })]
    })]
  }));
}
process.env.NODE_ENV !== "production" && (WY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ampm: c.bool,
  ampmInClock: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * className applied to the root component.
   */
  className: c.string,
  disabled: c.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: c.bool,
  isLandscape: c.bool.isRequired,
  onChange: c.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: c.func.isRequired,
  readOnly: c.bool,
  titleId: c.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: c.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: c.node,
  toolbarVariant: c.oneOf(["desktop", "mobile"]),
  value: c.any,
  /**
   * Currently visible picker view.
   */
  view: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired,
  views: c.arrayOf(c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired).isRequired
});
function YY(e, t) {
  var n, r, a, s, l, p, m, h, g, b, x;
  const E = or(), O = Am(), _ = Lt({
    props: e,
    name: t
  }), P = (n = _.ampm) != null ? n : E.is12HourCycleInCurrentLocale(), M = C.useMemo(() => {
    var I;
    return ((I = _.localeText) == null ? void 0 : I.toolbarTitle) == null ? _.localeText : B({}, _.localeText, {
      dateTimePickerToolbarTitle: _.localeText.toolbarTitle
    });
  }, [_.localeText]), D = (r = _.slots) != null ? r : o_(_.components), N = (a = _.slotProps) != null ? a : _.componentsProps;
  return B({}, _, x9({
    views: _.views,
    openTo: _.openTo,
    defaultViews: ["year", "day", "hours", "minutes"],
    defaultOpenTo: "day"
  }), {
    ampm: P,
    localeText: M,
    orientation: (s = _.orientation) != null ? s : "portrait",
    // TODO: Remove from public API
    disableIgnoringDatePartForTimeValidation: (l = _.disableIgnoringDatePartForTimeValidation) != null ? l : !!(_.minDateTime || _.maxDateTime || // allow time clock to correctly check time validity: https://github.com/mui/mui-x/issues/8520
    _.disablePast || _.disableFuture),
    disableFuture: (p = _.disableFuture) != null ? p : !1,
    disablePast: (m = _.disablePast) != null ? m : !1,
    minDate: ni(E, (h = _.minDateTime) != null ? h : _.minDate, O.minDate),
    maxDate: ni(E, (g = _.maxDateTime) != null ? g : _.maxDate, O.maxDate),
    minTime: (b = _.minDateTime) != null ? b : _.minTime,
    maxTime: (x = _.maxDateTime) != null ? x : _.maxTime,
    slots: B({
      toolbar: WY,
      tabs: UY
    }, D),
    slotProps: B({}, N, {
      toolbar: B({
        ampm: P
      }, N == null ? void 0 : N.toolbar)
    })
  });
}
function p$e(e) {
  return Xt("MuiDivider", e);
}
const m$e = Bt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), KU = m$e, h$e = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"], v$e = (e) => {
  const {
    absolute: t,
    children: n,
    classes: r,
    flexItem: a,
    light: s,
    orientation: l,
    textAlign: p,
    variant: m
  } = e;
  return Kt({
    root: ["root", t && "absolute", m, s && "light", l === "vertical" && "vertical", a && "flexItem", n && "withChildren", n && l === "vertical" && "withChildrenVertical", p === "right" && l !== "vertical" && "textAlignRight", p === "left" && l !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", l === "vertical" && "wrapperVertical"]
  }, p$e, r);
}, y$e = Ge("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin"
}, t.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, t.light && {
  borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : Wn(e.palette.divider, 0.08)
}, t.variant === "inset" && {
  marginLeft: 72
}, t.variant === "middle" && t.orientation === "horizontal" && {
  marginLeft: e.spacing(2),
  marginRight: e.spacing(2)
}, t.variant === "middle" && t.orientation === "vertical" && {
  marginTop: e.spacing(1),
  marginBottom: e.spacing(1)
}, t.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, t.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  ownerState: e
}) => B({}, e.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  "&::before, &::after": {
    content: '""',
    alignSelf: "center"
  }
}), ({
  theme: e,
  ownerState: t
}) => B({}, t.children && t.orientation !== "vertical" && {
  "&::before, &::after": {
    width: "100%",
    borderTop: `thin solid ${(e.vars || e).palette.divider}`
  }
}), ({
  theme: e,
  ownerState: t
}) => B({}, t.children && t.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    borderLeft: `thin solid ${(e.vars || e).palette.divider}`
  }
}), ({
  ownerState: e
}) => B({}, e.textAlign === "right" && e.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, e.textAlign === "left" && e.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
})), g$e = Ge("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`
}, t.orientation === "vertical" && {
  paddingTop: `calc(${e.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${e.spacing(1)} * 1.2)`
})), qY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDivider"
  }), {
    absolute: a = !1,
    children: s,
    className: l,
    component: p = s ? "div" : "hr",
    flexItem: m = !1,
    light: h = !1,
    orientation: g = "horizontal",
    role: b = p !== "hr" ? "separator" : void 0,
    textAlign: x = "center",
    variant: E = "fullWidth"
  } = r, O = st(r, h$e), _ = B({}, r, {
    absolute: a,
    component: p,
    flexItem: m,
    light: h,
    orientation: g,
    role: b,
    textAlign: x,
    variant: E
  }), P = v$e(_);
  return /* @__PURE__ */ L.jsx(y$e, B({
    as: p,
    className: Wt(P.root, l),
    role: b,
    ref: n,
    ownerState: _
  }, O, {
    children: s ? /* @__PURE__ */ L.jsx(g$e, {
      className: P.wrapper,
      ownerState: _,
      children: s
    }) : null
  }));
});
process.env.NODE_ENV !== "production" && (qY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Absolutely position the element.
   * @default false
   */
  absolute: c.bool,
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, a vertical divider will have the correct height when used in flex container.
   * (By default, a vertical divider will have a calculated height of `0px` if it is the child of a flex container.)
   * @default false
   */
  flexItem: c.bool,
  /**
   * If `true`, the divider will have a lighter color.
   * @default false
   */
  light: c.bool,
  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: c.oneOf(["horizontal", "vertical"]),
  /**
   * @ignore
   */
  role: c.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The text alignment.
   * @default 'center'
   */
  textAlign: c.oneOf(["center", "left", "right"]),
  /**
   * The variant to use.
   * @default 'fullWidth'
   */
  variant: c.oneOfType([c.oneOf(["fullWidth", "inset", "middle"]), c.string])
});
const XU = qY;
function b$e(e) {
  return Xt("MuiMultiSectionDigitalClock", e);
}
Bt("MuiMultiSectionDigitalClock", ["root"]);
const w$e = Bt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), QU = w$e, x$e = Bt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), ZU = x$e;
function S$e(e) {
  return Xt("MuiMenuItem", e);
}
const E$e = Bt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), m0 = E$e, C$e = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"], T$e = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, _$e = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: a,
    selected: s,
    classes: l
  } = e, m = Kt({
    root: ["root", n && "dense", t && "disabled", !a && "gutters", r && "divider", s && "selected"]
  }, S$e, l);
  return B({}, l, m);
}, O$e = Ge(ld, {
  shouldForwardProp: (e) => ac(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: T$e
})(({
  theme: e,
  ownerState: t
}) => B({}, e.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !t.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, t.divider && {
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${m0.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${m0.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${m0.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Wn(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${m0.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${m0.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${KU.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${KU.inset}`]: {
    marginLeft: 52
  },
  [`& .${ZU.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${ZU.inset}`]: {
    paddingLeft: 36
  },
  [`& .${QU.root}`]: {
    minWidth: 36
  }
}, !t.dense && {
  [e.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, t.dense && B({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, e.typography.body2, {
  [`& .${QU.root} svg`]: {
    fontSize: "1.25rem"
  }
}))), GY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: a = !1,
    component: s = "li",
    dense: l = !1,
    divider: p = !1,
    disableGutters: m = !1,
    focusVisibleClassName: h,
    role: g = "menuitem",
    tabIndex: b,
    className: x
  } = r, E = st(r, C$e), O = C.useContext(bm), _ = C.useMemo(() => ({
    dense: l || O.dense || !1,
    disableGutters: m
  }), [O.dense, l, m]), P = C.useRef(null);
  ei(() => {
    a && (P.current ? P.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [a]);
  const M = B({}, r, {
    dense: _.dense,
    divider: p,
    disableGutters: m
  }), D = _$e(r), N = yo(P, n);
  let I;
  return r.disabled || (I = b !== void 0 ? b : -1), /* @__PURE__ */ L.jsx(bm.Provider, {
    value: _,
    children: /* @__PURE__ */ L.jsx(O$e, B({
      ref: N,
      role: g,
      tabIndex: I,
      component: s,
      focusVisibleClassName: Wt(D.focusVisible, h),
      className: Wt(D.root, x)
    }, E, {
      ownerState: M,
      classes: D
    }))
  });
});
process.env.NODE_ENV !== "production" && (GY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: c.bool,
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: c.bool,
  /**
   * @ignore
   */
  disabled: c.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: c.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: c.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: c.string,
  /**
   * @ignore
   */
  role: c.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * @default 0
   */
  tabIndex: c.number
});
const KY = GY;
function P$e(e) {
  return Xt("MuiMultiSectionDigitalClock", e);
}
const R$e = Bt("MuiMultiSectionDigitalClock", ["root", "item"]), k$e = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"], D$e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    item: ["item"]
  }, P$e, t);
}, $$e = Ge(xY, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => ({
  maxHeight: t_e,
  width: 56,
  padding: 0,
  overflow: "hidden",
  scrollBehavior: t.alreadyRendered ? "smooth" : "auto",
  "&:hover": {
    overflowY: "auto"
  },
  "&:not(:first-of-type)": {
    borderLeft: `1px solid ${(e.vars || e).palette.divider}`
  },
  "&:after": {
    display: "block",
    content: '""',
    // subtracting the height of one item, extra margin and borders to make sure the max height is correct
    height: "calc(100% - 40px - 6px)"
  }
})), M$e = Ge(KY, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Item",
  overridesResolver: (e, t) => t.item
})(({
  theme: e
}) => ({
  padding: 8,
  margin: "2px 4px",
  width: w0,
  justifyContent: "center",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : Wn(e.palette.primary.main, e.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (e.vars || e).palette.primary.main,
    color: (e.vars || e).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.focusOpacity})` : Wn(e.palette.primary.main, e.palette.action.focusOpacity)
  }
})), N$e = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r;
  const a = C.useRef(null), s = u_(n, a), l = Lt({
    props: t,
    name: "MuiMultiSectionDigitalClockSection"
  }), {
    autoFocus: p,
    onChange: m,
    className: h,
    disabled: g,
    readOnly: b,
    items: x,
    active: E,
    slots: O,
    slotProps: _,
    skipDisabled: P
  } = l, M = st(l, k$e), D = C.useMemo(() => B({}, l, {
    alreadyRendered: !!a.current
  }), [l]), N = D$e(D), I = (r = O == null ? void 0 : O.digitalClockSectionItem) != null ? r : M$e;
  return C.useEffect(() => {
    if (a.current === null)
      return;
    const R = a.current.querySelector('[role="option"][aria-selected="true"]');
    if (!R)
      return;
    E && p && R.focus();
    const j = R.offsetTop;
    a.current.scrollTop = j - 4;
  }), /* @__PURE__ */ L.jsx($$e, B({
    ref: s,
    className: Ao(N.root, h),
    ownerState: D,
    autoFocusItem: p && E,
    role: "listbox"
  }, M, {
    children: x.map((R) => {
      var j, U;
      if (P && (j = R.isDisabled) != null && j.call(R, R.value))
        return null;
      const q = R.isSelected(R.value);
      return /* @__PURE__ */ L.jsx(I, B({
        onClick: () => !b && m(R.value),
        selected: q,
        disabled: g ?? ((U = R.isDisabled) == null ? void 0 : U.call(R, R.value)),
        disableRipple: b,
        role: "option",
        "aria-disabled": b,
        "aria-label": R.ariaLabel,
        "aria-selected": q
      }, _ == null ? void 0 : _.digitalClockSectionItem, {
        children: R.label
      }), R.label);
    })
  }));
}), I$e = ({
  now: e,
  value: t,
  utils: n,
  ampm: r,
  isDisabled: a,
  resolveAriaLabel: s,
  timeStep: l
}) => {
  const p = t ? n.getHours(t) : null, m = [], h = (b) => p === null ? !1 : r ? b === 12 ? p === 12 || p === 0 : p === b || p - 12 === b : p === b, g = r ? 11 : 23;
  for (let b = 0; b <= g; b += l) {
    let x = n.format(n.setHours(e, b), r ? "hours12h" : "hours24h");
    const E = s(parseInt(x, 10).toString());
    x = n.formatNumber(x), m.push({
      value: b,
      label: x,
      isSelected: h,
      isDisabled: a,
      ariaLabel: E
    });
  }
  return m;
}, JU = ({
  value: e,
  isDisabled: t,
  timeStep: n,
  resolveLabel: r,
  resolveAriaLabel: a,
  hasValue: s = !0
}) => {
  const l = (p) => e === null ? !1 : s && e === p;
  return [...Array.from({
    length: Math.ceil(60 / n)
  }, (p, m) => {
    const h = n * m;
    return {
      value: h,
      label: r(h),
      isDisabled: t,
      isSelected: l,
      ariaLabel: a(h.toString())
    };
  })];
}, A$e = ["ampm", "timeSteps", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "onChange", "defaultValue", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled"], j$e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"]
  }, b$e, t);
}, L$e = Ge(TN, {
  name: "MuiMultiSectionDigitalClock",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  display: "flex",
  flexDirection: "row",
  width: "100%",
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`
})), XY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = jm(), a = or(), s = es(), l = Lt({
    props: t,
    name: "MuiMultiSectionDigitalClock"
  }), {
    ampm: p = a.is12HourCycleInCurrentLocale(),
    timeSteps: m,
    autoFocus: h,
    components: g,
    componentsProps: b,
    slots: x,
    slotProps: E,
    value: O,
    disableIgnoringDatePartForTimeValidation: _ = !1,
    maxTime: P,
    minTime: M,
    disableFuture: D,
    disablePast: N,
    minutesStep: I = 1,
    shouldDisableClock: R,
    shouldDisableTime: j,
    onChange: U,
    defaultValue: q,
    view: J,
    views: H = ["hours", "minutes"],
    openTo: Z,
    onViewChange: re,
    focusedView: Y,
    onFocusedViewChange: K,
    className: Q,
    disabled: te,
    readOnly: ne,
    skipDisabled: ae = !1
  } = l, se = st(l, A$e), V = C.useMemo(() => B({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, m), [m]), [ee, he] = N7({
    name: "MultiSectionDigitalClock",
    state: "value",
    controlled: O,
    default: q ?? null
  }), ue = Qn((we, Me, Ae) => {
    he(we), U == null || U(we, Me, Ae);
  }), fe = C.useMemo(() => !p || !H.includes("hours") || H.includes("meridiem") ? H : [...H, "meridiem"], [p, H]), {
    view: Ce,
    setValueAndGoToView: Se,
    focusedView: Te
  } = c_({
    view: J,
    views: fe,
    openTo: Z,
    onViewChange: re,
    onChange: ue,
    focusedView: Y,
    onFocusedViewChange: K
  }), pe = C.useMemo(() => ee || a.setSeconds(a.setMinutes(a.setHours(r, 0), 0), 0), [ee, r, a]), ye = Qn((we) => {
    Se(we, null, "meridiem");
  }), {
    meridiemMode: Oe,
    handleMeridiemChange: Fe
  } = vN(pe, p, ye, "finish"), me = C.useCallback((we, Me) => {
    const Ae = e_(_, a), je = Me === "hours" || Me === "minutes" && fe.includes("seconds"), qe = ({
      start: et,
      end: ct
    }) => !(M && Ae(M, ct) || P && Ae(et, P) || D && Ae(et, r) || N && Ae(r, je ? ct : et)), ot = (et, ct = 1) => {
      if (et % ct !== 0 || R != null && R(et, Me))
        return !1;
      if (j)
        switch (Me) {
          case "hours":
            return !j(a.setHours(pe, et), "hours");
          case "minutes":
            return !j(a.setMinutes(pe, et), "minutes");
          case "seconds":
            return !j(a.setSeconds(pe, et), "seconds");
          default:
            return !1;
        }
      return !0;
    };
    switch (Me) {
      case "hours": {
        const et = G0(we, Oe, p), ct = a.setHours(pe, et), Qt = a.setSeconds(a.setMinutes(ct, 0), 0), Ht = a.setSeconds(a.setMinutes(ct, 59), 59);
        return !qe({
          start: Qt,
          end: Ht
        }) || !ot(et);
      }
      case "minutes": {
        const et = a.setMinutes(pe, we), ct = a.setSeconds(et, 0), Qt = a.setSeconds(et, 59);
        return !qe({
          start: ct,
          end: Qt
        }) || !ot(we, I);
      }
      case "seconds": {
        const et = a.setSeconds(pe, we);
        return !qe({
          start: et,
          end: et
        }) || !ot(we);
      }
      default:
        throw new Error("not supported");
    }
  }, [p, pe, _, P, Oe, M, I, R, j, a, D, N, r, fe]), Pe = Qn((we, Me) => {
    const Ae = fe.indexOf(we), je = fe[Ae + 1];
    Se(Me, je, we);
  }), Ee = C.useCallback((we) => {
    switch (we) {
      case "hours":
        return {
          onChange: (Me) => {
            const Ae = G0(Me, Oe, p);
            Pe("hours", a.setHours(pe, Ae));
          },
          items: I$e({
            now: r,
            value: ee,
            ampm: p,
            utils: a,
            isDisabled: (Me) => te || me(Me, "hours"),
            timeStep: V.hours,
            resolveAriaLabel: s.hoursClockNumberText
          })
        };
      case "minutes":
        return {
          onChange: (Me) => {
            Pe("minutes", a.setMinutes(pe, Me));
          },
          items: JU({
            value: a.getMinutes(pe),
            isDisabled: (Me) => te || me(Me, "minutes"),
            resolveLabel: (Me) => a.format(a.setMinutes(r, Me), "minutes"),
            timeStep: V.minutes,
            hasValue: !!ee,
            resolveAriaLabel: s.minutesClockNumberText
          })
        };
      case "seconds":
        return {
          onChange: (Me) => {
            Pe("seconds", a.setSeconds(pe, Me));
          },
          items: JU({
            value: a.getSeconds(pe),
            isDisabled: (Me) => te || me(Me, "seconds"),
            resolveLabel: (Me) => a.format(a.setSeconds(r, Me), "seconds"),
            timeStep: V.seconds,
            hasValue: !!ee,
            resolveAriaLabel: s.secondsClockNumberText
          })
        };
      case "meridiem": {
        const Me = a.getMeridiemText("am"), Ae = a.getMeridiemText("pm");
        return {
          onChange: Fe,
          items: [{
            value: "am",
            label: Me,
            isSelected: () => !!ee && Oe === "am",
            ariaLabel: Me
          }, {
            value: "pm",
            label: Ae,
            isSelected: () => !!ee && Oe === "pm",
            ariaLabel: Ae
          }]
        };
      }
      default:
        throw new Error(`Unknown view: ${we} found.`);
    }
  }, [r, ee, p, a, V.hours, V.minutes, V.seconds, s.hoursClockNumberText, s.minutesClockNumberText, s.secondsClockNumberText, Oe, Pe, pe, te, me, Fe]), Ke = C.useMemo(() => fe.reduce((we, Me) => B({}, we, {
    [Me]: Ee(Me)
  }), {}), [fe, Ee]), oe = l, de = j$e(oe);
  return /* @__PURE__ */ L.jsx(L$e, B({
    ref: n,
    className: Ao(de.root, Q),
    ownerState: oe,
    role: "group"
  }, se, {
    children: Object.entries(Ke).map(([we, Me]) => /* @__PURE__ */ L.jsx(N$e, {
      items: Me.items,
      onChange: Me.onChange,
      active: Ce === we,
      autoFocus: h ?? Te === we,
      disabled: te,
      readOnly: ne,
      slots: x ?? g,
      slotProps: E ?? b,
      skipDisabled: ae,
      "aria-label": s.selectViewText(we)
    }, we))
  }));
});
process.env.NODE_ENV !== "production" && (XY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  className: c.string,
  /**
   * Overrideable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker views and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * Controlled focused view.
   */
  focusedView: c.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: c.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * If `true`, the picker views and text field are read-only.
   * @default false
   */
  readOnly: c.bool,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overrideable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: c.shape({
    hours: c.number,
    minutes: c.number,
    seconds: c.number
  }),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["hours", "meridiem", "minutes", "seconds"]).isRequired)
});
const F$e = Ge("div")({
  display: "flex",
  margin: "0 auto"
}), om = ({
  view: e,
  onViewChange: t,
  views: n,
  focusedView: r,
  onFocusedViewChange: a,
  value: s,
  defaultValue: l,
  onChange: p,
  className: m,
  classes: h,
  disableFuture: g,
  disablePast: b,
  minDate: x,
  minTime: E,
  maxDate: O,
  maxTime: _,
  shouldDisableDate: P,
  shouldDisableMonth: M,
  shouldDisableYear: D,
  shouldDisableTime: N,
  shouldDisableClock: I,
  reduceAnimations: R,
  minutesStep: j,
  ampm: U,
  onMonthChange: q,
  monthsPerRow: J,
  onYearChange: H,
  yearsPerRow: Z,
  defaultCalendarMonth: re,
  components: Y,
  componentsProps: K,
  slots: Q,
  slotProps: te,
  loading: ne,
  renderLoading: ae,
  disableHighlightToday: se,
  readOnly: V,
  disabled: ee,
  showDaysOutsideCurrentMonth: he,
  dayOfWeekFormatter: ue,
  sx: fe,
  autoFocus: Ce,
  fixedWeekNumber: Se,
  displayWeekNumber: Te,
  disableIgnoringDatePartForTimeValidation: pe,
  timeSteps: ye,
  skipDisabled: Oe,
  timeViewsCount: Fe
}) => {
  var me, Pe, Ee;
  const Ke = !!((me = Vf((Ee = te == null ? void 0 : te.actionBar) != null ? Ee : K == null ? void 0 : K.actionBar, {})) != null && (Pe = me.actions) != null && Pe.length);
  return /* @__PURE__ */ L.jsxs(C.Fragment, {
    children: [/* @__PURE__ */ L.jsxs(F$e, {
      children: [/* @__PURE__ */ L.jsx(_N, {
        view: ny(e) ? e : "day",
        onViewChange: t,
        views: n.filter(ny),
        focusedView: r && ny(r) ? r : null,
        onFocusedViewChange: a,
        value: s,
        defaultValue: l,
        onChange: p,
        className: m,
        classes: h,
        disableFuture: g,
        disablePast: b,
        minDate: x,
        maxDate: O,
        shouldDisableDate: P,
        shouldDisableMonth: M,
        shouldDisableYear: D,
        reduceAnimations: R,
        onMonthChange: q,
        monthsPerRow: J,
        onYearChange: H,
        yearsPerRow: Z,
        defaultCalendarMonth: re,
        components: Y,
        componentsProps: K,
        slots: Q,
        slotProps: te,
        loading: ne,
        renderLoading: ae,
        disableHighlightToday: se,
        readOnly: V,
        disabled: ee,
        showDaysOutsideCurrentMonth: he,
        dayOfWeekFormatter: ue,
        sx: fe,
        autoFocus: Ce,
        fixedWeekNumber: Se,
        displayWeekNumber: Te
      }), Fe > 0 && /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [/* @__PURE__ */ L.jsx(XU, {
          orientation: "vertical"
        }), /* @__PURE__ */ L.jsx(XY, {
          view: Gk(e) ? e : "hours",
          onViewChange: t,
          focusedView: r && Gk(r) ? r : null,
          onFocusedViewChange: a,
          views: n.filter(Gk),
          value: s,
          defaultValue: l,
          onChange: p,
          className: m,
          classes: h,
          disableFuture: g,
          disablePast: b,
          minTime: E,
          maxTime: _,
          shouldDisableTime: N,
          shouldDisableClock: I,
          minutesStep: j,
          ampm: U,
          components: Y,
          componentsProps: K,
          slots: Q,
          slotProps: te,
          readOnly: V,
          disabled: ee,
          sx: B({
            borderBottom: 0,
            width: "auto",
            [`.${R$e.root}`]: {
              maxHeight: "100%"
            }
          }, Array.isArray(fe) ? fe : [fe]),
          autoFocus: Ce,
          disableIgnoringDatePartForTimeValidation: pe,
          timeSteps: ye,
          skipDisabled: Oe
        })]
      })]
    }), Ke && /* @__PURE__ */ L.jsx(XU, {})]
  });
}, z$e = ["views", "format"], QY = (e, t) => {
  let {
    views: n,
    format: r
  } = t, a = st(t, z$e);
  if (r)
    return r;
  const s = [], l = [];
  if (n.forEach((h) => {
    GC(h) ? l.push(h) : s.push(h);
  }), l.length === 0)
    return q0(e, B({
      views: s
    }, a), !1);
  if (s.length === 0)
    return q5(e, B({
      views: l
    }, a));
  const p = q5(e, B({
    views: l
  }, a));
  return `${q0(e, B({
    views: s
  }, a), !1)} ${p}`;
}, ZY = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s, l, p;
  const m = es(), h = or(), g = YY(t, "MuiDesktopDateTimePicker"), b = B({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, g.timeSteps), x = !g.viewRenderers || Object.keys(g.viewRenderers).length === 0, E = (
    // we can only ensure the expected two-column layout if none of the renderers are overridden
    x ? {
      day: om,
      month: om,
      year: om,
      hours: om,
      minutes: om,
      seconds: om,
      meridiem: om
    } : B({
      day: el,
      month: el,
      year: el,
      hours: null,
      minutes: null,
      seconds: null,
      meridiem: null
    }, g.viewRenderers)
  ), O = (r = g.ampmInClock) != null ? r : !0, _ = x ? ["accept"] : [], P = B({}, g, {
    viewRenderers: E,
    format: QY(h, g),
    views: g.ampm ? [...g.views, "meridiem"] : g.views,
    yearsPerRow: (a = g.yearsPerRow) != null ? a : 4,
    ampmInClock: O,
    timeSteps: b,
    slots: B({
      field: ON,
      openPickerIcon: o7
    }, g.slots),
    slotProps: B({}, g.slotProps, {
      field: (D) => {
        var N;
        return B({}, Vf((N = g.slotProps) == null ? void 0 : N.field, D), d_(g), {
          ref: n
        });
      },
      toolbar: B({
        hidden: !0,
        ampmInClock: O,
        toolbarVariant: x ? "desktop" : "mobile"
      }, (s = g.slotProps) == null ? void 0 : s.toolbar),
      tabs: B({
        hidden: !0
      }, (l = g.slotProps) == null ? void 0 : l.tabs),
      actionBar: B({
        actions: _
      }, (p = g.slotProps) == null ? void 0 : p.actionBar)
    })
  }), {
    renderPicker: M
  } = lY({
    props: P,
    valueManager: Ny,
    valueType: "date-time",
    getOpenDialogAriaText: m.openDatePickerDialogue,
    validator: yN
  });
  return M();
});
ZY.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: c.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: c.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: c.shape({
    hours: c.number,
    minutes: c.number,
    seconds: c.number
  }),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    hours: c.func,
    meridiem: c.func,
    minutes: c.func,
    month: c.func,
    seconds: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: c.oneOf([3, 4])
};
function V$e(e) {
  return Xt("MuiTimeClock", e);
}
Bt("MuiTimeClock", ["root", "arrowSwitcher"]);
const Cy = 220, If = 36, ew = {
  x: Cy / 2,
  y: Cy / 2
}, JY = {
  x: ew.x,
  y: 0
}, U$e = JY.x - ew.x, B$e = JY.y - ew.y, H$e = (e) => e * (180 / Math.PI), eq = (e, t, n) => {
  const r = t - ew.x, a = n - ew.y, s = Math.atan2(U$e, B$e) - Math.atan2(r, a);
  let l = H$e(s);
  l = Math.round(l / e) * e, l %= 360;
  const p = Math.floor(l / e) || 0, m = r ** 2 + a ** 2, h = Math.sqrt(m);
  return {
    value: p,
    distance: h
  };
}, W$e = (e, t, n = 1) => {
  const r = n * 6;
  let {
    value: a
  } = eq(r, e, t);
  return a = a * n % 60, a;
}, Y$e = (e, t, n) => {
  const {
    value: r,
    distance: a
  } = eq(30, e, t);
  let s = r || 12;
  return n ? s %= 12 : a < Cy / 2 - If && (s += 12, s %= 24), s;
};
function q$e(e) {
  return Xt("MuiClockPointer", e);
}
Bt("MuiClockPointer", ["root", "thumb"]);
const G$e = ["className", "hasSelected", "isInner", "type", "viewValue"], K$e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    thumb: ["thumb"]
  }, q$e, t);
}, X$e = Ge("div", {
  name: "MuiClockPointer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => B({
  width: 2,
  backgroundColor: (e.vars || e).palette.primary.main,
  position: "absolute",
  left: "calc(50% - 1px)",
  bottom: "50%",
  transformOrigin: "center bottom 0px"
}, t.shouldAnimate && {
  transition: e.transitions.create(["transform", "height"])
})), Q$e = Ge("div", {
  name: "MuiClockPointer",
  slot: "Thumb",
  overridesResolver: (e, t) => t.thumb
})(({
  theme: e,
  ownerState: t
}) => B({
  width: 4,
  height: 4,
  backgroundColor: (e.vars || e).palette.primary.contrastText,
  borderRadius: "50%",
  position: "absolute",
  top: -21,
  left: `calc(50% - ${If / 2}px)`,
  border: `${(If - 4) / 2}px solid ${(e.vars || e).palette.primary.main}`,
  boxSizing: "content-box"
}, t.hasSelected && {
  backgroundColor: (e.vars || e).palette.primary.main
}));
function Z$e(e) {
  const t = Lt({
    props: e,
    name: "MuiClockPointer"
  }), {
    className: n,
    isInner: r,
    type: a,
    viewValue: s
  } = t, l = st(t, G$e), p = C.useRef(a);
  C.useEffect(() => {
    p.current = a;
  }, [a]);
  const m = B({}, t, {
    shouldAnimate: p.current !== a
  }), h = K$e(m), g = () => {
    let x = 360 / (a === "hours" ? 12 : 60) * s;
    return a === "hours" && s > 12 && (x -= 360), {
      height: Math.round((r ? 0.26 : 0.4) * Cy),
      transform: `rotateZ(${x}deg)`
    };
  };
  return /* @__PURE__ */ L.jsx(X$e, B({
    style: g(),
    className: Ao(n, h.root),
    ownerState: m
  }, l, {
    children: /* @__PURE__ */ L.jsx(Q$e, {
      ownerState: m,
      className: h.thumb
    })
  }));
}
function J$e(e) {
  return Xt("MuiClock", e);
}
Bt("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton"]);
const eMe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    clock: ["clock"],
    wrapper: ["wrapper"],
    squareMask: ["squareMask"],
    pin: ["pin"],
    amButton: ["amButton"],
    pmButton: ["pmButton"]
  }, J$e, t);
}, tMe = Ge("div", {
  name: "MuiClock",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  margin: e.spacing(2)
})), nMe = Ge("div", {
  name: "MuiClock",
  slot: "Clock",
  overridesResolver: (e, t) => t.clock
})({
  backgroundColor: "rgba(0,0,0,.07)",
  borderRadius: "50%",
  height: 220,
  width: 220,
  flexShrink: 0,
  position: "relative",
  pointerEvents: "none"
}), rMe = Ge("div", {
  name: "MuiClock",
  slot: "Wrapper",
  overridesResolver: (e, t) => t.wrapper
})({
  "&:focus": {
    outline: "none"
  }
}), oMe = Ge("div", {
  name: "MuiClock",
  slot: "SquareMask",
  overridesResolver: (e, t) => t.squareMask
})(({
  ownerState: e
}) => B({
  width: "100%",
  height: "100%",
  position: "absolute",
  pointerEvents: "auto",
  outline: 0,
  // Disable scroll capabilities.
  touchAction: "none",
  userSelect: "none"
}, e.disabled ? {} : {
  "@media (pointer: fine)": {
    cursor: "pointer",
    borderRadius: "50%"
  },
  "&:active": {
    cursor: "move"
  }
})), aMe = Ge("div", {
  name: "MuiClock",
  slot: "Pin",
  overridesResolver: (e, t) => t.pin
})(({
  theme: e
}) => ({
  width: 6,
  height: 6,
  borderRadius: "50%",
  backgroundColor: (e.vars || e).palette.primary.main,
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)"
})), iMe = Ge(Jc, {
  name: "MuiClock",
  slot: "AmButton",
  overridesResolver: (e, t) => t.amButton
})(({
  theme: e,
  ownerState: t
}) => B({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  left: 8
}, t.meridiemMode === "am" && {
  backgroundColor: (e.vars || e).palette.primary.main,
  color: (e.vars || e).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (e.vars || e).palette.primary.light
  }
})), sMe = Ge(Jc, {
  name: "MuiClock",
  slot: "PmButton",
  overridesResolver: (e, t) => t.pmButton
})(({
  theme: e,
  ownerState: t
}) => B({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  right: 8
}, t.meridiemMode === "pm" && {
  backgroundColor: (e.vars || e).palette.primary.main,
  color: (e.vars || e).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (e.vars || e).palette.primary.light
  }
}));
function lMe(e) {
  const t = Lt({
    props: e,
    name: "MuiClock"
  }), {
    ampm: n,
    ampmInClock: r,
    autoFocus: a,
    children: s,
    value: l,
    handleMeridiemChange: p,
    isTimeDisabled: m,
    meridiemMode: h,
    minutesStep: g = 1,
    onChange: b,
    selectedId: x,
    type: E,
    viewValue: O,
    disabled: _,
    readOnly: P,
    className: M
  } = t, D = t, N = or(), I = es(), R = C.useRef(!1), j = eMe(D), U = m(O, E), q = !n && E === "hours" && (O < 1 || O > 12), J = (se, V) => {
    _ || P || m(se, E) || b(se, V);
  }, H = (se, V) => {
    let {
      offsetX: ee,
      offsetY: he
    } = se;
    if (ee === void 0) {
      const fe = se.target.getBoundingClientRect();
      ee = se.changedTouches[0].clientX - fe.left, he = se.changedTouches[0].clientY - fe.top;
    }
    const ue = E === "seconds" || E === "minutes" ? W$e(ee, he, g) : Y$e(ee, he, !!n);
    J(ue, V);
  }, Z = (se) => {
    R.current = !0, H(se, "shallow");
  }, re = (se) => {
    R.current && (H(se, "finish"), R.current = !1);
  }, Y = (se) => {
    se.buttons > 0 && H(se.nativeEvent, "shallow");
  }, K = (se) => {
    R.current && (R.current = !1), H(se.nativeEvent, "finish");
  }, Q = C.useMemo(() => E === "hours" ? !0 : O % 5 === 0, [E, O]), te = E === "minutes" ? g : 1, ne = C.useRef(null);
  ei(() => {
    a && ne.current.focus();
  }, [a]);
  const ae = (se) => {
    if (!R.current)
      switch (se.key) {
        case "Home":
          J(0, "partial"), se.preventDefault();
          break;
        case "End":
          J(E === "minutes" ? 59 : 23, "partial"), se.preventDefault();
          break;
        case "ArrowUp":
          J(O + te, "partial"), se.preventDefault();
          break;
        case "ArrowDown":
          J(O - te, "partial"), se.preventDefault();
          break;
      }
  };
  return /* @__PURE__ */ L.jsxs(tMe, {
    className: Ao(M, j.root),
    children: [/* @__PURE__ */ L.jsxs(nMe, {
      className: j.clock,
      children: [/* @__PURE__ */ L.jsx(oMe, {
        onTouchMove: Z,
        onTouchEnd: re,
        onMouseUp: K,
        onMouseMove: Y,
        ownerState: {
          disabled: _
        },
        className: j.squareMask
      }), !U && /* @__PURE__ */ L.jsxs(C.Fragment, {
        children: [/* @__PURE__ */ L.jsx(aMe, {
          className: j.pin
        }), l != null && /* @__PURE__ */ L.jsx(Z$e, {
          type: E,
          viewValue: O,
          isInner: q,
          hasSelected: Q
        })]
      }), /* @__PURE__ */ L.jsx(rMe, {
        "aria-activedescendant": x,
        "aria-label": I.clockLabelText(E, l, N),
        ref: ne,
        role: "listbox",
        onKeyDown: ae,
        tabIndex: 0,
        className: j.wrapper,
        children: s
      })]
    }), n && r && /* @__PURE__ */ L.jsxs(C.Fragment, {
      children: [/* @__PURE__ */ L.jsx(iMe, {
        onClick: P ? void 0 : () => p("am"),
        disabled: _ || h === null,
        ownerState: D,
        className: j.amButton,
        children: /* @__PURE__ */ L.jsx(nc, {
          variant: "caption",
          children: "AM"
        })
      }), /* @__PURE__ */ L.jsx(sMe, {
        disabled: _ || h === null,
        onClick: P ? void 0 : () => p("pm"),
        ownerState: D,
        className: j.pmButton,
        children: /* @__PURE__ */ L.jsx(nc, {
          variant: "caption",
          children: "PM"
        })
      })]
    })]
  });
}
function uMe(e) {
  return Xt("MuiClockNumber", e);
}
const j1 = Bt("MuiClockNumber", ["root", "selected", "disabled"]), cMe = ["className", "disabled", "index", "inner", "label", "selected"], dMe = (e) => {
  const {
    classes: t,
    selected: n,
    disabled: r
  } = e;
  return Kt({
    root: ["root", n && "selected", r && "disabled"]
  }, uMe, t);
}, fMe = Ge("span", {
  name: "MuiClockNumber",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`&.${j1.disabled}`]: t.disabled
  }, {
    [`&.${j1.selected}`]: t.selected
  }]
})(({
  theme: e,
  ownerState: t
}) => B({
  height: If,
  width: If,
  position: "absolute",
  left: `calc((100% - ${If}px) / 2)`,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  color: (e.vars || e).palette.text.primary,
  fontFamily: e.typography.fontFamily,
  "&:focused": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  [`&.${j1.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText
  },
  [`&.${j1.disabled}`]: {
    pointerEvents: "none",
    color: (e.vars || e).palette.text.disabled
  }
}, t.inner && B({}, e.typography.body2, {
  color: (e.vars || e).palette.text.secondary
})));
function tq(e) {
  const t = Lt({
    props: e,
    name: "MuiClockNumber"
  }), {
    className: n,
    disabled: r,
    index: a,
    inner: s,
    label: l,
    selected: p
  } = t, m = st(t, cMe), h = t, g = dMe(h), b = a % 12 / 12 * Math.PI * 2 - Math.PI / 2, x = (Cy - If - 2) / 2 * (s ? 0.65 : 1), E = Math.round(Math.cos(b) * x), O = Math.round(Math.sin(b) * x);
  return /* @__PURE__ */ L.jsx(fMe, B({
    className: Ao(n, g.root),
    "aria-disabled": r ? !0 : void 0,
    "aria-selected": p ? !0 : void 0,
    role: "option",
    style: {
      transform: `translate(${E}px, ${O + (Cy - If) / 2}px`
    },
    ownerState: h
  }, m, {
    children: l
  }));
}
const pMe = ({
  ampm: e,
  value: t,
  getClockNumberText: n,
  isDisabled: r,
  selectedId: a,
  utils: s
}) => {
  const l = t ? s.getHours(t) : null, p = [], m = e ? 1 : 0, h = e ? 12 : 23, g = (b) => l === null ? !1 : e ? b === 12 ? l === 12 || l === 0 : l === b || l - 12 === b : l === b;
  for (let b = m; b <= h; b += 1) {
    let x = b.toString();
    b === 0 && (x = "00");
    const E = !e && (b === 0 || b > 12);
    x = s.formatNumber(x);
    const O = g(b);
    p.push(/* @__PURE__ */ L.jsx(tq, {
      id: O ? a : void 0,
      index: b,
      inner: E,
      selected: O,
      disabled: r(b),
      label: x,
      "aria-label": n(x)
    }, b));
  }
  return p;
}, eB = ({
  utils: e,
  value: t,
  isDisabled: n,
  getClockNumberText: r,
  selectedId: a
}) => {
  const s = e.formatNumber;
  return [[5, s("05")], [10, s("10")], [15, s("15")], [20, s("20")], [25, s("25")], [30, s("30")], [35, s("35")], [40, s("40")], [45, s("45")], [50, s("50")], [55, s("55")], [0, s("00")]].map(([l, p], m) => {
    const h = l === t;
    return /* @__PURE__ */ L.jsx(tq, {
      label: p,
      id: h ? a : void 0,
      index: m + 1,
      inner: !1,
      disabled: n(l),
      selected: h,
      "aria-label": r(p)
    }, l);
  });
}, mMe = ["ampm", "ampmInClock", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "showViewSwitcher", "onChange", "defaultValue", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly"], hMe = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    arrowSwitcher: ["arrowSwitcher"]
  }, V$e, t);
}, vMe = Ge(TN, {
  name: "MuiTimeClock",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "column",
  position: "relative"
}), yMe = Ge(a7, {
  name: "MuiTimeClock",
  slot: "ArrowSwitcher",
  overridesResolver: (e, t) => t.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
}), nq = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = es(), a = jm(), s = or(), l = Lt({
    props: t,
    name: "MuiTimeClock"
  }), {
    ampm: p = s.is12HourCycleInCurrentLocale(),
    ampmInClock: m = !1,
    autoFocus: h,
    components: g,
    componentsProps: b,
    slots: x,
    slotProps: E,
    value: O,
    disableIgnoringDatePartForTimeValidation: _ = !1,
    maxTime: P,
    minTime: M,
    disableFuture: D,
    disablePast: N,
    minutesStep: I = 1,
    shouldDisableClock: R,
    shouldDisableTime: j,
    showViewSwitcher: U,
    onChange: q,
    defaultValue: J,
    view: H,
    views: Z = ["hours", "minutes"],
    openTo: re,
    onViewChange: Y,
    focusedView: K,
    onFocusedViewChange: Q,
    className: te,
    disabled: ne,
    readOnly: ae
  } = l, se = st(l, mMe), V = x ?? o_(g), ee = E ?? b, [he, ue] = tl({
    name: "DateCalendar",
    state: "value",
    controlled: O,
    default: J ?? null
  }), fe = Qn((we, Me) => {
    ue(we), q == null || q(we, Me);
  }), {
    view: Ce,
    setView: Se,
    previousView: Te,
    nextView: pe,
    setValueAndGoToNextView: ye
  } = c_({
    view: H,
    views: Z,
    openTo: re,
    onViewChange: Y,
    onChange: fe,
    focusedView: K,
    onFocusedViewChange: Q
  }), Oe = C.useMemo(() => he || s.setSeconds(s.setMinutes(s.setHours(a, 0), 0), 0), [he, a, s]), {
    meridiemMode: Fe,
    handleMeridiemChange: me
  } = vN(Oe, p, ye), Pe = C.useCallback((we, Me) => {
    const Ae = e_(_, s), je = Me === "hours" || Me === "minutes" && Z.includes("seconds"), qe = ({
      start: et,
      end: ct
    }) => !(M && Ae(M, ct) || P && Ae(et, P) || D && Ae(et, a) || N && Ae(a, je ? ct : et)), ot = (et, ct = 1) => {
      if (et % ct !== 0 || R != null && R(et, Me))
        return !1;
      if (j)
        switch (Me) {
          case "hours":
            return !j(s.setHours(Oe, et), "hours");
          case "minutes":
            return !j(s.setMinutes(Oe, et), "minutes");
          case "seconds":
            return !j(s.setSeconds(Oe, et), "seconds");
          default:
            return !1;
        }
      return !0;
    };
    switch (Me) {
      case "hours": {
        const et = G0(we, Fe, p), ct = s.setHours(Oe, et), Qt = s.setSeconds(s.setMinutes(ct, 0), 0), Ht = s.setSeconds(s.setMinutes(ct, 59), 59);
        return !qe({
          start: Qt,
          end: Ht
        }) || !ot(et);
      }
      case "minutes": {
        const et = s.setMinutes(Oe, we), ct = s.setSeconds(et, 0), Qt = s.setSeconds(et, 59);
        return !qe({
          start: ct,
          end: Qt
        }) || !ot(we, I);
      }
      case "seconds": {
        const et = s.setSeconds(Oe, we);
        return !qe({
          start: et,
          end: et
        }) || !ot(we);
      }
      default:
        throw new Error("not supported");
    }
  }, [p, Oe, _, P, Fe, M, I, R, j, s, D, N, a, Z]), Ee = uy(), Ke = C.useMemo(() => {
    switch (Ce) {
      case "hours": {
        const we = (Me, Ae) => {
          const je = G0(Me, Fe, p);
          ye(s.setHours(Oe, je), Ae);
        };
        return {
          onChange: we,
          viewValue: s.getHours(Oe),
          children: pMe({
            value: he,
            utils: s,
            ampm: p,
            onChange: we,
            getClockNumberText: r.hoursClockNumberText,
            isDisabled: (Me) => ne || Pe(Me, "hours"),
            selectedId: Ee
          })
        };
      }
      case "minutes": {
        const we = s.getMinutes(Oe), Me = (Ae, je) => {
          ye(s.setMinutes(Oe, Ae), je);
        };
        return {
          viewValue: we,
          onChange: Me,
          children: eB({
            utils: s,
            value: we,
            onChange: Me,
            getClockNumberText: r.minutesClockNumberText,
            isDisabled: (Ae) => ne || Pe(Ae, "minutes"),
            selectedId: Ee
          })
        };
      }
      case "seconds": {
        const we = s.getSeconds(Oe), Me = (Ae, je) => {
          ye(s.setSeconds(Oe, Ae), je);
        };
        return {
          viewValue: we,
          onChange: Me,
          children: eB({
            utils: s,
            value: we,
            onChange: Me,
            getClockNumberText: r.secondsClockNumberText,
            isDisabled: (Ae) => ne || Pe(Ae, "seconds"),
            selectedId: Ee
          })
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [Ce, s, he, p, r.hoursClockNumberText, r.minutesClockNumberText, r.secondsClockNumberText, Fe, ye, Oe, Pe, Ee, ne]), oe = l, de = hMe(oe);
  return /* @__PURE__ */ L.jsxs(vMe, B({
    ref: n,
    className: Ao(de.root, te),
    ownerState: oe
  }, se, {
    children: [/* @__PURE__ */ L.jsx(lMe, B({
      autoFocus: h ?? !!K,
      ampmInClock: m && Z.includes("hours"),
      value: he,
      type: Ce,
      ampm: p,
      minutesStep: I,
      isTimeDisabled: Pe,
      meridiemMode: Fe,
      handleMeridiemChange: me,
      selectedId: Ee,
      disabled: ne,
      readOnly: ae
    }, Ke)), U && /* @__PURE__ */ L.jsx(yMe, {
      className: de.arrowSwitcher,
      slots: V,
      slotProps: ee,
      onGoToPrevious: () => Se(Te),
      isPreviousDisabled: !Te,
      previousLabel: r.openPreviousView,
      onGoToNext: () => Se(pe),
      isNextDisabled: !pe,
      nextLabel: r.openNextView,
      ownerState: oe
    })]
  }));
});
process.env.NODE_ENV !== "production" && (nq.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default false
   */
  ampmInClock: c.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  className: c.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker views and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * Controlled focused view.
   */
  focusedView: c.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: c.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["hours", "minutes", "seconds"]),
  /**
   * If `true`, the picker views and text field are read-only.
   * @default false
   */
  readOnly: c.bool,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  showViewSwitcher: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["hours", "minutes", "seconds"]).isRequired)
});
const nD = ({
  view: e,
  onViewChange: t,
  focusedView: n,
  onFocusedViewChange: r,
  views: a,
  value: s,
  defaultValue: l,
  onChange: p,
  className: m,
  classes: h,
  disableFuture: g,
  disablePast: b,
  minTime: x,
  maxTime: E,
  shouldDisableTime: O,
  shouldDisableClock: _,
  minutesStep: P,
  ampm: M,
  ampmInClock: D,
  components: N,
  componentsProps: I,
  slots: R,
  slotProps: j,
  readOnly: U,
  disabled: q,
  sx: J,
  autoFocus: H,
  showViewSwitcher: Z,
  disableIgnoringDatePartForTimeValidation: re
}) => /* @__PURE__ */ L.jsx(nq, {
  view: e,
  onViewChange: t,
  focusedView: n && GC(n) ? n : null,
  onFocusedViewChange: r,
  views: a.filter(GC),
  value: s,
  defaultValue: l,
  onChange: p,
  className: m,
  classes: h,
  disableFuture: g,
  disablePast: b,
  minTime: x,
  maxTime: E,
  shouldDisableTime: O,
  shouldDisableClock: _,
  minutesStep: P,
  ampm: M,
  ampmInClock: D,
  components: N,
  componentsProps: I,
  slots: R,
  slotProps: j,
  readOnly: U,
  disabled: q,
  sx: J,
  autoFocus: H,
  showViewSwitcher: Z,
  disableIgnoringDatePartForTimeValidation: re
}), rq = /* @__PURE__ */ C.forwardRef(function(t, n) {
  var r, a, s;
  const l = es(), p = or(), m = YY(t, "MuiMobileDateTimePicker"), h = B({
    day: el,
    month: el,
    year: el,
    hours: nD,
    minutes: nD,
    seconds: nD
  }, m.viewRenderers), g = (r = m.ampmInClock) != null ? r : !1, b = B({}, m, {
    viewRenderers: h,
    format: QY(p, m),
    ampmInClock: g,
    slots: B({
      field: ON
    }, m.slots),
    slotProps: B({}, m.slotProps, {
      field: (E) => {
        var O;
        return B({}, Vf((O = m.slotProps) == null ? void 0 : O.field, E), d_(m), {
          ref: n
        });
      },
      toolbar: B({
        hidden: !1,
        ampmInClock: g
      }, (a = m.slotProps) == null ? void 0 : a.toolbar),
      tabs: B({
        hidden: !1
      }, (s = m.slotProps) == null ? void 0 : s.tabs)
    })
  }), {
    renderPicker: x
  } = IY({
    props: b,
    valueManager: Ny,
    valueType: "date-time",
    getOpenDialogAriaText: l.openDatePickerDialogue,
    validator: yN
  });
  return x();
});
rq.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: c.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: c.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    hours: c.func,
    minutes: c.func,
    month: c.func,
    seconds: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: c.oneOf([3, 4])
};
const gMe = ["desktopModeMediaQuery"], oq = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiDateTimePicker"
  }), {
    desktopModeMediaQuery: a = w7
  } = r, s = st(r, gMe);
  return g9(a, {
    defaultMatches: !0
  }) ? /* @__PURE__ */ L.jsx(ZY, B({
    ref: n
  }, s)) : /* @__PURE__ */ L.jsx(rq, B({
    ref: n
  }, s));
});
process.env.NODE_ENV !== "production" && (oq.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: c.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: c.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: c.bool,
  /**
   * Class name applied to the root element.
   */
  className: c.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: c.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: c.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: c.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: c.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: c.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: c.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: c.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: c.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: c.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: c.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: c.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: c.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: c.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: c.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: c.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: c.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: c.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: c.oneOfType([c.func, c.shape({
    current: c.object
  })]),
  /**
   * The label content.
   */
  label: c.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: c.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: c.object,
  /**
   * Maximal selectable date.
   */
  maxDate: c.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: c.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: c.any,
  /**
   * Minimal selectable date.
   */
  minDate: c.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: c.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: c.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: c.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: c.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: c.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: c.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: c.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: c.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: c.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: c.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: c.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: c.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: c.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: c.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: c.oneOf(["landscape", "portrait"]),
  readOnly: c.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: c.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: c.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: c.oneOfType([c.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), c.number, c.shape({
    endIndex: c.number.isRequired,
    startIndex: c.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: c.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: c.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: c.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: c.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: c.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: c.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: c.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: c.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: c.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: c.shape({
    hours: c.number,
    minutes: c.number,
    seconds: c.number
  }),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: c.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: c.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: c.shape({
    day: c.func,
    hours: c.func,
    meridiem: c.func,
    minutes: c.func,
    month: c.func,
    seconds: c.func,
    year: c.func
  }),
  /**
   * Available views.
   */
  views: c.arrayOf(c.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4 on desktop, 3 on mobile
   */
  yearsPerRow: c.oneOf([3, 4])
});
function bMe({ control: e, name: t, PopperProps: n, ...r }) {
  const {
    field: { ref: a, ...s },
    fieldState: { error: l }
  } = md({
    name: t,
    control: e
  }), p = Da(), m = C.useRef(), h = p.fn.variant({
    variant: "default",
    color: p.colors[p.primaryColor][p.fn.primaryShade()]
  });
  return /* @__PURE__ */ L.jsx(gw, { dateAdapter: v9, children: /* @__PURE__ */ L.jsx(
    oq,
    {
      components: {
        OpenPickerIcon: M8
      },
      OpenPickerButtonProps: {
        sx: {
          padding: 0,
          marginLeft: "-18px",
          color: p.colors.gray[7]
        }
      },
      PopperProps: {
        anchorEl: m.current,
        sx: {
          "& .Mui-selected": {
            backgroundColor: `${h.background} !important`,
            ...p.fn.hover({
              backgroundColor: `${h.hover} !important`
            })
          }
        },
        ...n
      },
      renderInput: ({ ref: g, inputProps: b, disabled: x, onChange: E, value: O, ..._ }) => /* @__PURE__ */ L.jsx(
        HT,
        {
          ref: m,
          label: r.label,
          error: !!l,
          rightSection: _.InputProps.endAdornment,
          ...b
        }
      ),
      inputRef: a,
      ...s,
      onChange: (g) => {
        s.onChange(g);
      },
      ...r
    }
  ) });
}
function wMe({ control: e, name: t, items: n, filter: r, ...a }) {
  var h;
  const {
    field: { ...s },
    fieldState: { error: l }
  } = md({
    name: t,
    control: e
  }), p = n.map((g) => ({ value: g.id.toString(), label: g.value }));
  let m = null;
  return r && s.value ? m = s.value.toString() : (h = s.value) != null && h.id && (m = s.value.id.toString()), /* @__PURE__ */ L.jsx(
    Dy,
    {
      data: p,
      error: l ? l.message : null,
      ...s,
      value: m,
      onChange: (g) => {
        if (r) {
          s.onChange(g);
          return;
        }
        const b = n.find((x) => x.id.toString() === g);
        s.onChange(b);
      },
      searchable: !0,
      ...a
    }
  );
}
function xMe({ control: e, name: t, items: n, ...r }) {
  const {
    field: { ref: a, ...s },
    fieldState: { error: l }
  } = md({
    name: t,
    control: e
  }), p = n.map((h) => ({ value: h.id, label: h.value })), m = s.value.map((h) => h.id);
  return /* @__PURE__ */ L.jsx(
    BT,
    {
      ref: a,
      data: p,
      error: l ? l.message : null,
      searchable: !0,
      ...s,
      value: m,
      onChange: (h) => {
        const g = [];
        h.forEach((b) => {
          g.push(n.find((x) => x.id === b));
        }), s.onChange(g);
      },
      ...r
    }
  );
}
function SMe({ control: e, name: t, items: n, ...r }) {
  const {
    field: { ref: a, ...s },
    fieldState: { error: l }
  } = md({
    name: t,
    control: e
  });
  return /* @__PURE__ */ L.jsx(Dy, { ref: a, data: n, error: l ? l.message : null, searchable: !0, ...s, ...r });
}
function tB({ control: e, name: t, ...n }) {
  const {
    field: { ref: r, ...a },
    fieldState: { error: s }
  } = md({
    name: t,
    control: e
  }), l = a.value || "";
  return /* @__PURE__ */ L.jsx(HT, { ref: r, ...a, error: s ? s.message : null, value: l, ...n });
}
function PN({ name: e, control: t, schema: n, filter: r, ...a }) {
  if (!n.type)
    return null;
  switch (n.type) {
    case "Boolean":
      return /* @__PURE__ */ L.jsx(
        SMe,
        {
          name: e,
          control: t,
          items: [
            { label: "True", value: !0 },
            { label: "False", value: !1 }
          ],
          ...a
        }
      );
    case "RelatedList":
      return /* @__PURE__ */ L.jsx(xMe, { name: e, control: t, items: n.values, ...a });
    case "Related":
      return /* @__PURE__ */ L.jsx(wMe, { name: e, control: t, items: n.values, filter: r, ...a });
    case "DateTime":
      return /* @__PURE__ */ L.jsx(
        bMe,
        {
          control: t,
          name: e,
          mask: "__.__.____ __:__",
          format: "dd.MM.yyyy HH:mm",
          schema: n,
          PopperProps: r && { placement: "bottom-end" },
          ...a
        }
      );
    case "Date":
      return /* @__PURE__ */ L.jsx(
        CDe,
        {
          control: t,
          name: e,
          mask: "__.__.____",
          format: "dd.MM.yyyy",
          schema: n,
          PopperProps: r && { placement: "bottom-end" },
          ...a
        }
      );
    case "Integer":
    case "Float":
      return /* @__PURE__ */ L.jsx(tB, { name: e, control: t, ...a });
    default:
      return /* @__PURE__ */ L.jsx(tB, { name: e, control: t, ...a });
  }
}
function EMe({ opened: e, onClose: t }) {
  const { info: n, addEntry: r } = sa(), { handleSubmit: a, reset: s, control: l } = HM({
    mode: "onChange",
    defaultValues: n.add.defaultValues,
    resolver: WM(n.add.schema)
  }), p = async (m) => {
    await r(m), s(), t();
  };
  return /* @__PURE__ */ L.jsx(
    ky,
    {
      opened: e,
      onClose: () => {
        s(), t();
      },
      title: n.add.title,
      size: "lg",
      centered: !0,
      children: /* @__PURE__ */ L.jsxs(mw, { spacing: "md", children: [
        n.add.columns.map((m) => /* @__PURE__ */ L.jsx(
          PN,
          {
            name: m.name,
            control: l,
            label: `${m.name}${m.required ? "*" : ""}`,
            description: m.description,
            schema: m
          },
          m.name
        )),
        /* @__PURE__ */ L.jsx(Gl, { position: "right", mt: "xl", children: /* @__PURE__ */ L.jsx(vy, { onClick: a(p), children: "Add" }) })
      ] })
    }
  );
}
function CMe() {
  const [e, t] = C.useState(!1);
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx($m, { label: "Add Item", children: /* @__PURE__ */ L.jsx(
      qs,
      {
        onClick: () => {
          t(!0);
        },
        children: /* @__PURE__ */ L.jsx(N8, {})
      }
    ) }),
    /* @__PURE__ */ L.jsx(
      EMe,
      {
        opened: e,
        onClose: () => {
          t(!1);
        }
      }
    )
  ] });
}
function TMe({ control: e, name: t, items: n, onChange: r, TextFieldProps: a, ...s }) {
  const {
    field: { ref: l, ...p },
    fieldState: { error: m }
  } = md({
    name: t,
    control: e
  });
  return /* @__PURE__ */ L.jsx(
    Dy,
    {
      ref: l,
      data: n,
      searchable: !0,
      onChange: (h, g) => {
        p.onChange(g), r && r(g.value ?? g);
      },
      ...p,
      ...s
    }
  );
}
function _Me({ control: e, name: t, items: n, onChange: r, TextFieldProps: a, ...s }) {
  const {
    field: { ref: l, ...p },
    fieldState: { error: m }
  } = md({
    name: t,
    control: e
  });
  return /* @__PURE__ */ L.jsx(
    Dy,
    {
      ref: l,
      data: n,
      searchable: !0,
      onChange: (h, g) => {
        p.onChange(g), r && r(g.value ?? g);
      },
      ...p,
      ...s
    }
  );
}
function OMe({ control: e, name: t, ...n }) {
  const [r, a] = C.useState([]), {
    field: { ref: s, ...l },
    fieldState: { error: p }
  } = md({
    name: t,
    control: e
  });
  return C.useEffect(() => {
    if (l.value) {
      const m = JSON.parse(l.value);
      a([...m]), l.onChange(m);
    } else
      l.onChange([]);
  }, []), /* @__PURE__ */ L.jsx(
    BT,
    {
      ref: s,
      data: r,
      placeholder: "Enter items",
      searchable: !0,
      creatable: !0,
      error: p ? p.message : null,
      ...l,
      value: l.value,
      getCreateLabel: (m) => `+ Add ${m}`,
      onCreate: (m) => (a((h) => [...h, m]), m),
      onChange: (m) => {
        l.onChange(m);
      }
    }
  );
}
const PMe = Y0({
  filters: AM().of(
    Y0({
      col: NC().required("Column is required"),
      opr: NC().required("Operation is required"),
      value: RM().required("Value is required")
    })
  )
});
function RMe({ onClose: e }) {
  const { info: t, queryParams: n, setQueryParams: r } = sa(), { handleSubmit: a, control: s, setValue: l, watch: p } = HM({
    mode: "onTouched",
    defaultValues: {
      filters: []
    },
    resolver: WM(PMe)
  }), { fields: m, append: h, remove: g, update: b } = v0e({ control: s, name: "filters" }), x = p("filters"), E = m.map((_, P) => ({
    ..._,
    ...x[P]
  }));
  C.useEffect(() => {
    n.filters.length && l("filters", JSON.parse(JSON.stringify(n.filters)));
  }, [n.filters, l]);
  const O = (_) => {
    const P = JSON.parse(JSON.stringify(_.filters));
    P.forEach((M) => {
      M.opr === "in" && Array.isArray(M.value) && (M.value = JSON.stringify(M.value));
    }), r({ filters: P }), e();
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    E.length ? E.map((_, P) => /* @__PURE__ */ L.jsxs(le.Fragment, { children: [
      /* @__PURE__ */ L.jsxs(Gl, { mt: "lg", spacing: "md", noWrap: !0, children: [
        /* @__PURE__ */ L.jsx(hn, { sx: { width: "192px" }, children: /* @__PURE__ */ L.jsx(
          TMe,
          {
            name: `filters.${P}.col`,
            control: s,
            items: Object.keys(t.filters),
            onChange: (M) => {
              b(P, { col: M, value: "", opr: "" });
            }
          }
        ) }),
        /* @__PURE__ */ L.jsx(hn, { sx: { width: "192px" }, children: _.col ? /* @__PURE__ */ L.jsx(
          _Me,
          {
            name: `filters.${P}.opr`,
            control: s,
            items: t.filters[_.col].filters.map((M) => ({
              label: M.name,
              value: M.operator
            }))
          }
        ) : null }),
        /* @__PURE__ */ L.jsx(hn, { sx: { width: "192px" }, children: _.col ? _.opr === "in" ? /* @__PURE__ */ L.jsx(OMe, { name: `filters.${P}.value`, control: s }) : /* @__PURE__ */ L.jsx(
          PN,
          {
            name: `filters.${P}.value`,
            control: s,
            schema: t.filters[_.col].schema,
            filter: !0
          }
        ) : null }),
        /* @__PURE__ */ L.jsx(
          qs,
          {
            size: "xs",
            onClick: () => {
              g(P);
            },
            children: /* @__PURE__ */ L.jsx(I8, {})
          }
        )
      ] }),
      E.length > 1 && P < E.length - 1 ? /* @__PURE__ */ L.jsx(
        H0,
        {
          sx: (M) => ({
            color: `${M.colors[M.primaryColor][M.fn.primaryShade()]} !important`
          }),
          my: "md",
          labelPosition: "center",
          label: "AND"
        }
      ) : null
    ] }, _.id)) : /* @__PURE__ */ L.jsx(hn, { sx: { width: "642px" }, children: /* @__PURE__ */ L.jsx(Gi, { sx: (_) => ({ fontStyle: "italic", padding: "7px" }), size: "sm", color: "dimmed", children: "No filters selected..." }) }),
    /* @__PURE__ */ L.jsx(H0, { my: "xl" }),
    /* @__PURE__ */ L.jsxs(hn, { sx: { display: "flex", justifyContent: "space-between" }, children: [
      /* @__PURE__ */ L.jsx(
        vy,
        {
          variant: "subtle",
          leftIcon: /* @__PURE__ */ L.jsx(N8, {}),
          onClick: () => {
            h({ col: "", opr: "", value: "" });
          },
          children: "Add Filter"
        }
      ),
      /* @__PURE__ */ L.jsx(Gl, { spacing: "md", children: /* @__PURE__ */ L.jsx(vy, { onClick: a(O), children: "Apply" }) })
    ] })
  ] });
}
function kMe() {
  const { queryParams: e } = sa(), [t, n] = C.useState(!1);
  return /* @__PURE__ */ L.jsxs(
    Zs,
    {
      opened: t,
      position: "bottom-end",
      onClose: () => n(!1),
      children: [
        /* @__PURE__ */ L.jsx(Zs.Target, { children: /* @__PURE__ */ L.jsx($m, { opened: t ? !1 : null, label: "Filter", children: /* @__PURE__ */ L.jsx(qs, { onClick: () => n(!0), children: e.filters.length ? /* @__PURE__ */ L.jsx(wM, { styles: (r) => ({ indicator: { paddingTop: "2px" } }), label: e.filters.length, children: /* @__PURE__ */ L.jsx(C5, {}) }) : /* @__PURE__ */ L.jsx(C5, {}) }) }) }),
        /* @__PURE__ */ L.jsxs(Zs.Dropdown, { children: [
          /* @__PURE__ */ L.jsx(hn, { sx: { position: "absolute", top: 4, right: 4 }, children: /* @__PURE__ */ L.jsx(IT, { title: "Filters", onClick: () => n(!1) }) }),
          /* @__PURE__ */ L.jsx(
            RMe,
            {
              onClose: () => {
                n(!1);
              }
            }
          )
        ] })
      ]
    }
  );
}
const aq = le.memo(({ settings: e, hideFilter: t, hideSettings: n, dense: r, dispatch: a }) => {
  const { info: s } = sa(), { classes: l } = zbe({ dense: r }, { name: "DataGrid" }), p = s.permissions.includes("can_post");
  return /* @__PURE__ */ L.jsxs(hn, { className: l.toolbarRoot, children: [
    /* @__PURE__ */ L.jsx(hn, { children: n ? null : /* @__PURE__ */ L.jsx(s0e, { onSettingsChange: (m) => a({ type: "setSettings", payload: m }), settings: e }) }),
    /* @__PURE__ */ L.jsxs(hn, { sx: { display: "flex" }, children: [
      p ? /* @__PURE__ */ L.jsx(CMe, {}) : null,
      t ? null : /* @__PURE__ */ L.jsx(kMe, {})
    ] })
  ] });
});
aq.displayName = "Toolbar";
/*!
 * OverlayScrollbars
 * Version: 2.2.0
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
function vr(e, t) {
  if (b_(e))
    for (let n = 0; n < e.length && t(e[n], n, e) !== !1; n++)
      ;
  else
    e && vr(Object.keys(e), (n) => t(e[n], n, e));
  return e;
}
function Ja(e, t) {
  const n = Kf(t);
  if (Xl(t) || n) {
    let a = n ? "" : {};
    if (e) {
      const s = window.getComputedStyle(e, null);
      a = n ? aB(e, s, t) : t.reduce((l, p) => (l[p] = aB(e, s, p), l), a);
    }
    return a;
  }
  e && vr(Es(t), (a) => YMe(e, a, t[a]));
}
const Vl = (e, t) => {
  const { o: n, u: r, _: a } = e;
  let s = n, l;
  const p = (g, b) => {
    const x = s, E = g, O = b || (r ? !r(x, E) : x !== E);
    return (O || a) && (s = E, l = x), [s, O, l];
  };
  return [t ? (g) => p(t(s, l), g) : p, (g) => [s, !!g, l]];
}, Ew = () => typeof window < "u", iq = Ew() && Node.ELEMENT_NODE, { toString: DMe, hasOwnProperty: rD } = Object.prototype, vd = (e) => e === void 0, g_ = (e) => e === null, $Me = (e) => vd(e) || g_(e) ? `${e}` : DMe.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase(), Af = (e) => typeof e == "number", Kf = (e) => typeof e == "string", RN = (e) => typeof e == "boolean", Kl = (e) => typeof e == "function", Xl = (e) => Array.isArray(e), tw = (e) => typeof e == "object" && !Xl(e) && !g_(e), b_ = (e) => {
  const t = !!e && e.length, n = Af(t) && t > -1 && t % 1 == 0;
  return Xl(e) || !Kl(e) && n ? t > 0 && tw(e) ? t - 1 in e : !0 : !1;
}, w$ = (e) => {
  if (!e || !tw(e) || $Me(e) !== "object")
    return !1;
  let t;
  const n = "constructor", r = e[n], a = r && r.prototype, s = rD.call(e, n), l = a && rD.call(a, "isPrototypeOf");
  if (r && !s && !l)
    return !1;
  for (t in e)
    ;
  return vd(t) || rD.call(e, t);
}, nT = (e) => {
  const t = HTMLElement;
  return e ? t ? e instanceof t : e.nodeType === iq : !1;
}, w_ = (e) => {
  const t = Element;
  return e ? t ? e instanceof t : e.nodeType === iq : !1;
}, kN = (e, t, n) => e.indexOf(t, n), Lr = (e, t, n) => (!n && !Kf(t) && b_(t) ? Array.prototype.push.apply(e, t) : e.push(t), e), Om = (e) => {
  const t = Array.from, n = [];
  return t && e ? t(e) : (e instanceof Set ? e.forEach((r) => {
    Lr(n, r);
  }) : vr(e, (r) => {
    Lr(n, r);
  }), n);
}, DN = (e) => !!e && e.length === 0, sc = (e, t, n) => {
  vr(e, (a) => a && a.apply(void 0, t || [])), !n && (e.length = 0);
}, x_ = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Es = (e) => e ? Object.keys(e) : [], ho = (e, t, n, r, a, s, l) => {
  const p = [t, n, r, a, s, l];
  return (typeof e != "object" || g_(e)) && !Kl(e) && (e = {}), vr(p, (m) => {
    vr(Es(m), (h) => {
      const g = m[h];
      if (e === g)
        return !0;
      const b = Xl(g);
      if (g && (w$(g) || b)) {
        const x = e[h];
        let E = x;
        b && !Xl(x) ? E = [] : !b && !w$(x) && (E = {}), e[h] = ho(E, g);
      } else
        e[h] = g;
    });
  }), e;
}, $N = (e) => {
  for (const t in e)
    return !1;
  return !0;
}, sq = (e, t, n, r) => {
  if (vd(r))
    return n ? n[e] : t;
  n && (Kf(r) || Af(r)) && (n[e] = r);
}, Za = (e, t, n) => {
  if (vd(n))
    return e ? e.getAttribute(t) : null;
  e && e.setAttribute(t, n);
}, Wi = (e, t) => {
  e && e.removeAttribute(t);
}, wm = (e, t, n, r) => {
  if (n) {
    const a = Za(e, t) || "", s = new Set(a.split(" "));
    s[r ? "add" : "delete"](n);
    const l = Om(s).join(" ").trim();
    Za(e, t, l);
  }
}, MMe = (e, t, n) => {
  const r = Za(e, t) || "";
  return new Set(r.split(" ")).has(n);
}, Yl = (e, t) => sq("scrollLeft", 0, e, t), td = (e, t) => sq("scrollTop", 0, e, t), x$ = Ew() && Element.prototype, lq = (e, t) => {
  const n = [], r = t ? w_(t) ? t : null : document;
  return r ? Lr(n, r.querySelectorAll(e)) : n;
}, NMe = (e, t) => {
  const n = t ? w_(t) ? t : null : document;
  return n ? n.querySelector(e) : null;
}, rT = (e, t) => w_(e) ? (x$.matches || x$.msMatchesSelector).call(e, t) : !1, MN = (e) => e ? Om(e.childNodes) : [], ud = (e) => e ? e.parentElement : null, Kv = (e, t) => {
  if (w_(e)) {
    const n = x$.closest;
    if (n)
      return n.call(e, t);
    do {
      if (rT(e, t))
        return e;
      e = ud(e);
    } while (e);
  }
  return null;
}, IMe = (e, t, n) => {
  const r = e && Kv(e, t), a = e && NMe(n, r), s = Kv(a, t) === r;
  return r && a ? r === e || a === e || s && Kv(Kv(e, n), t) !== r : !1;
}, NN = (e, t, n) => {
  if (n && e) {
    let r = t, a;
    b_(n) ? (a = document.createDocumentFragment(), vr(n, (s) => {
      s === r && (r = s.previousSibling), a.appendChild(s);
    })) : a = n, t && (r ? r !== t && (r = r.nextSibling) : r = e.firstChild), e.insertBefore(a, r || null);
  }
}, Gs = (e, t) => {
  NN(e, null, t);
}, AMe = (e, t) => {
  NN(ud(e), e, t);
}, nB = (e, t) => {
  NN(ud(e), e && e.nextSibling, t);
}, rc = (e) => {
  if (b_(e))
    vr(Om(e), (t) => rc(t));
  else if (e) {
    const t = ud(e);
    t && t.removeChild(e);
  }
}, xm = (e) => {
  const t = document.createElement("div");
  return e && Za(t, "class", e), t;
}, uq = (e) => {
  const t = xm();
  return t.innerHTML = e.trim(), vr(MN(t), (n) => rc(n));
}, S$ = (e) => e.charAt(0).toUpperCase() + e.slice(1), jMe = () => xm().style, LMe = ["-webkit-", "-moz-", "-o-", "-ms-"], FMe = ["WebKit", "Moz", "O", "MS", "webkit", "moz", "o", "ms"], oD = {}, aD = {}, zMe = (e) => {
  let t = aD[e];
  if (x_(aD, e))
    return t;
  const n = S$(e), r = jMe();
  return vr(LMe, (a) => {
    const s = a.replace(/-/g, "");
    return !(t = [e, a + e, s + n, S$(s) + n].find((p) => r[p] !== void 0));
  }), aD[e] = t || "";
}, Cw = (e) => {
  if (Ew()) {
    let t = oD[e] || window[e];
    return x_(oD, e) || (vr(FMe, (n) => (t = t || window[n + S$(e)], !t)), oD[e] = t), t;
  }
}, VMe = Cw("MutationObserver"), rB = Cw("IntersectionObserver"), Xv = Cw("ResizeObserver"), cq = Cw("cancelAnimationFrame"), dq = Cw("requestAnimationFrame"), oT = Ew() && window.setTimeout, E$ = Ew() && window.clearTimeout, UMe = /[^\x20\t\r\n\f]+/g, fq = (e, t, n) => {
  const r = e && e.classList;
  let a, s = 0, l = !1;
  if (r && t && Kf(t)) {
    const p = t.match(UMe) || [];
    for (l = p.length > 0; a = p[s++]; )
      l = !!n(r, a) && l;
  }
  return l;
}, IN = (e, t) => {
  fq(e, t, (n, r) => n.remove(r));
}, nd = (e, t) => (fq(e, t, (n, r) => n.add(r)), IN.bind(0, e, t)), S_ = (e, t, n, r) => {
  if (e && t) {
    let a = !0;
    return vr(n, (s) => {
      const l = r ? r(e[s]) : e[s], p = r ? r(t[s]) : t[s];
      l !== p && (a = !1);
    }), a;
  }
  return !1;
}, pq = (e, t) => S_(e, t, ["w", "h"]), mq = (e, t) => S_(e, t, ["x", "y"]), BMe = (e, t) => S_(e, t, ["t", "r", "b", "l"]), oB = (e, t, n) => S_(e, t, ["width", "height"], n && ((r) => Math.round(r))), Ys = () => {
}, Uv = (e) => {
  let t;
  const n = e ? oT : dq, r = e ? E$ : cq;
  return [(a) => {
    r(t), t = n(a, Kl(e) ? e() : e);
  }, () => r(t)];
}, AN = (e, t) => {
  let n, r, a, s = Ys;
  const { v: l, g: p, p: m } = t || {}, h = function(O) {
    s(), E$(n), n = r = void 0, s = Ys, e.apply(this, O);
  }, g = (E) => m && r ? m(r, E) : E, b = () => {
    s !== Ys && h(g(a) || a);
  }, x = function() {
    const O = Om(arguments), _ = Kl(l) ? l() : l;
    if (Af(_) && _ >= 0) {
      const M = Kl(p) ? p() : p, D = Af(M) && M >= 0, N = _ > 0 ? oT : dq, I = _ > 0 ? E$ : cq, j = g(O) || O, U = h.bind(0, j);
      s();
      const q = N(U, _);
      s = () => I(q), D && !n && (n = oT(b, M)), r = a = j;
    } else
      h(O);
  };
  return x.m = b, x;
}, HMe = {
  opacity: 1,
  zindex: 1
}, L1 = (e, t) => {
  const n = t ? parseFloat(e) : parseInt(e, 10);
  return n === n ? n : 0;
}, WMe = (e, t) => !HMe[e.toLowerCase()] && Af(t) ? `${t}px` : t, aB = (e, t, n) => t != null ? t[n] || t.getPropertyValue(n) : e.style[n], YMe = (e, t, n) => {
  try {
    const { style: r } = e;
    vd(r[t]) ? r.setProperty(t, n) : r[t] = WMe(t, n);
  } catch {
  }
}, nw = (e) => Ja(e, "direction") === "rtl", iB = (e, t, n) => {
  const r = t ? `${t}-` : "", a = n ? `-${n}` : "", s = `${r}top${a}`, l = `${r}right${a}`, p = `${r}bottom${a}`, m = `${r}left${a}`, h = Ja(e, [s, l, p, m]);
  return {
    t: L1(h[s], !0),
    r: L1(h[l], !0),
    b: L1(h[p], !0),
    l: L1(h[m], !0)
  };
}, { round: sB } = Math, jN = {
  w: 0,
  h: 0
}, Pm = (e) => e ? {
  w: e.offsetWidth,
  h: e.offsetHeight
} : jN, uE = (e) => e ? {
  w: e.clientWidth,
  h: e.clientHeight
} : jN, aT = (e) => e ? {
  w: e.scrollWidth,
  h: e.scrollHeight
} : jN, iT = (e) => {
  const t = parseFloat(Ja(e, "height")) || 0, n = parseFloat(Ja(e, "width")) || 0;
  return {
    w: n - sB(n),
    h: t - sB(t)
  };
}, Df = (e) => e.getBoundingClientRect();
let F1;
const qMe = () => {
  if (vd(F1)) {
    F1 = !1;
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get() {
          F1 = !0;
        }
      }));
    } catch {
    }
  }
  return F1;
}, hq = (e) => e.split(" "), GMe = (e, t, n, r) => {
  vr(hq(t), (a) => {
    e.removeEventListener(a, n, r);
  });
}, oa = (e, t, n, r) => {
  var a;
  const s = qMe(), l = (a = s && r && r.S) != null ? a : s, p = r && r.$ || !1, m = r && r.C || !1, h = [], g = s ? {
    passive: l,
    capture: p
  } : p;
  return vr(hq(t), (b) => {
    const x = m ? (E) => {
      e.removeEventListener(b, x, p), n && n(E);
    } : n;
    Lr(h, GMe.bind(null, e, b, x, p)), e.addEventListener(b, x, g);
  }), sc.bind(0, h);
}, vq = (e) => e.stopPropagation(), yq = (e) => e.preventDefault(), KMe = {
  x: 0,
  y: 0
}, iD = (e) => {
  const t = e ? Df(e) : 0;
  return t ? {
    x: t.left + window.pageYOffset,
    y: t.top + window.pageXOffset
  } : KMe;
}, lB = (e, t) => {
  vr(Xl(t) ? t : [t], e);
}, LN = (e) => {
  const t = /* @__PURE__ */ new Map(), n = (s, l) => {
    if (s) {
      const p = t.get(s);
      lB((m) => {
        p && p[m ? "delete" : "clear"](m);
      }, l);
    } else
      t.forEach((p) => {
        p.clear();
      }), t.clear();
  }, r = (s, l) => {
    if (Kf(s)) {
      const h = t.get(s) || /* @__PURE__ */ new Set();
      return t.set(s, h), lB((g) => {
        Kl(g) && h.add(g);
      }, l), n.bind(0, s, l);
    }
    RN(l) && l && n();
    const p = Es(s), m = [];
    return vr(p, (h) => {
      const g = s[h];
      g && Lr(m, r(h, g));
    }), sc.bind(0, m);
  }, a = (s, l) => {
    const p = t.get(s);
    vr(Om(p), (m) => {
      l && !DN(l) ? m.apply(0, l) : m();
    });
  };
  return r(e || {}), [r, n, a];
}, uB = (e) => JSON.stringify(e, (t, n) => {
  if (Kl(n))
    throw new Error();
  return n;
}), XMe = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, gq = (e, t) => {
  const n = {}, r = Es(t).concat(Es(e));
  return vr(r, (a) => {
    const s = e[a], l = t[a];
    if (tw(s) && tw(l))
      ho(n[a] = {}, gq(s, l)), $N(n[a]) && delete n[a];
    else if (x_(t, a) && l !== s) {
      let p = !0;
      if (Xl(s) || Xl(l))
        try {
          uB(s) === uB(l) && (p = !1);
        } catch {
        }
      p && (n[a] = l);
    }
  }), n;
}, bq = "os-environment", wq = `${bq}-flexbox-glue`, QMe = `${wq}-max`, xq = "os-scrollbar-hidden", sD = "data-overlayscrollbars-initialize", Ul = "data-overlayscrollbars", Sq = `${Ul}-overflow-x`, Eq = `${Ul}-overflow-y`, oy = "overflowVisible", ZMe = "scrollbarHidden", cB = "scrollbarPressed", sT = "updating", Of = "data-overlayscrollbars-viewport", lD = "arrange", Cq = "scrollbarHidden", ay = oy, C$ = "data-overlayscrollbars-padding", JMe = ay, dB = "data-overlayscrollbars-content", FN = "os-size-observer", eNe = `${FN}-appear`, tNe = `${FN}-listener`, nNe = "os-trinsic-observer", rNe = "os-no-css-vars", oNe = "os-theme-none", ts = "os-scrollbar", aNe = `${ts}-rtl`, iNe = `${ts}-horizontal`, sNe = `${ts}-vertical`, Tq = `${ts}-track`, zN = `${ts}-handle`, lNe = `${ts}-visible`, uNe = `${ts}-cornerless`, fB = `${ts}-transitionless`, pB = `${ts}-interaction`, mB = `${ts}-unusable`, hB = `${ts}-auto-hidden`, vB = `${ts}-wheel`, cNe = `${Tq}-interactive`, dNe = `${zN}-interactive`, _q = {}, Rm = () => _q, fNe = (e) => {
  const t = [];
  return vr(Xl(e) ? e : [e], (n) => {
    const r = Es(n);
    vr(r, (a) => {
      Lr(t, _q[a] = n[a]);
    });
  }), t;
}, pNe = "__osOptionsValidationPlugin", mNe = "__osSizeObserverPlugin", VN = "__osScrollbarsHidingPlugin", hNe = "__osClickScrollPlugin";
let uD;
const yB = (e, t, n, r) => {
  Gs(e, t);
  const a = uE(t), s = Pm(t), l = iT(n);
  return r && rc(t), {
    x: s.h - a.h + l.h,
    y: s.w - a.w + l.w
  };
}, vNe = (e) => {
  let t = !1;
  const n = nd(e, xq);
  try {
    t = Ja(e, zMe("scrollbar-width")) === "none" || window.getComputedStyle(e, "::-webkit-scrollbar").getPropertyValue("display") === "none";
  } catch {
  }
  return n(), t;
}, yNe = (e, t) => {
  const n = "hidden";
  Ja(e, {
    overflowX: n,
    overflowY: n,
    direction: "rtl"
  }), Yl(e, 0);
  const r = iD(e), a = iD(t);
  Yl(e, -999);
  const s = iD(t);
  return {
    i: r.x === a.x,
    n: a.x !== s.x
  };
}, gNe = (e, t) => {
  const n = nd(e, wq), r = Df(e), a = Df(t), s = oB(a, r, !0), l = nd(e, QMe), p = Df(e), m = Df(t), h = oB(m, p, !0);
  return n(), l(), s && h;
}, bNe = () => {
  const { body: e } = document, n = uq(`<div class="${bq}"><div></div></div>`)[0], r = n.firstChild, [a, , s] = LN(), [l, p] = Vl({
    o: yB(e, n, r),
    u: mq
  }, yB.bind(0, e, n, r, !0)), [m] = p(), h = vNe(n), g = {
    x: m.x === 0,
    y: m.y === 0
  }, b = {
    elements: {
      host: null,
      padding: !h,
      viewport: (D) => h && D === D.ownerDocument.body && D,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, x = ho({}, XMe), E = ho.bind(0, {}, x), O = ho.bind(0, {}, b), _ = {
    k: m,
    A: g,
    I: h,
    L: Ja(n, "zIndex") === "-1",
    B: yNe(n, r),
    V: gNe(n, r),
    Y: a.bind(0, "z"),
    j: a.bind(0, "r"),
    N: O,
    q: (D) => ho(b, D) && O(),
    F: E,
    G: (D) => ho(x, D) && E(),
    X: ho({}, b),
    U: ho({}, x)
  }, P = window.addEventListener, M = AN((D) => s(D ? "z" : "r"), {
    v: 33,
    g: 99
  });
  if (Wi(n, "style"), rc(n), P("resize", M.bind(0, !1)), !h && (!g.x || !g.y)) {
    let D;
    P("resize", () => {
      const N = Rm()[VN];
      D = D || N && N.R(), D && D(_, l, M.bind(0, !0));
    });
  }
  return _;
}, ns = () => (uD || (uD = bNe()), uD), UN = (e, t) => Kl(t) ? t.apply(0, e) : t, wNe = (e, t, n, r) => {
  const a = vd(r) ? n : r;
  return UN(e, a) || t.apply(0, e);
}, Oq = (e, t, n, r) => {
  const a = vd(r) ? n : r, s = UN(e, a);
  return !!s && (nT(s) ? s : t.apply(0, e));
}, xNe = (e, t, n) => {
  const { nativeScrollbarsOverlaid: r, body: a } = n || {}, { A: s, I: l } = ns(), { nativeScrollbarsOverlaid: p, body: m } = t, h = r ?? p, g = vd(a) ? m : a, b = (s.x || s.y) && h, x = e && (g_(g) ? !l : g);
  return !!b || !!x;
}, BN = /* @__PURE__ */ new WeakMap(), SNe = (e, t) => {
  BN.set(e, t);
}, ENe = (e) => {
  BN.delete(e);
}, Pq = (e) => BN.get(e), gB = (e, t) => e ? t.split(".").reduce((n, r) => n && x_(n, r) ? n[r] : void 0, e) : void 0, T$ = (e, t, n) => (r) => [gB(e, r), n || gB(t, r) !== void 0], Rq = (e) => {
  let t = e;
  return [() => t, (n) => {
    t = ho({}, t, n);
  }];
}, z1 = "tabindex", V1 = xm.bind(0, ""), cD = (e) => {
  Gs(ud(e), MN(e)), rc(e);
}, CNe = (e) => {
  const t = ns(), { N: n, I: r } = t, a = Rm()[VN], s = a && a.T, { elements: l } = n(), { host: p, padding: m, viewport: h, content: g } = l, b = nT(e), x = b ? {} : e, { elements: E } = x, { host: O, padding: _, viewport: P, content: M } = E || {}, D = b ? e : x.target, N = rT(D, "textarea"), I = D.ownerDocument, R = I.documentElement, j = D === I.body, U = I.defaultView, q = wNe.bind(0, [D]), J = Oq.bind(0, [D]), H = UN.bind(0, [D]), Z = q.bind(0, V1, h), re = J.bind(0, V1, g), Y = Z(P), K = Y === D, Q = K && j, te = !K && re(M), ne = !K && nT(Y) && Y === te, ae = ne && !!H(g), se = ae ? Z() : Y, V = ae ? te : re(), he = Q ? R : ne ? se : Y, ue = N ? q(V1, p, O) : D, fe = Q ? he : ue, Ce = ne ? V : te, Se = I.activeElement, Te = !K && U.top === U && Se === D, pe = {
    W: D,
    Z: fe,
    J: he,
    K: !K && J(V1, m, _),
    tt: Ce,
    nt: !K && !r && s && s(t),
    ot: Q ? R : he,
    st: Q ? I : he,
    et: U,
    ct: I,
    rt: N,
    it: j,
    lt: b,
    ut: K,
    dt: ne,
    ft: (qe, ot) => MMe(he, K ? Ul : Of, K ? ot : qe),
    _t: (qe, ot, et) => wm(he, K ? Ul : Of, K ? ot : qe, et)
  }, ye = Es(pe).reduce((qe, ot) => {
    const et = pe[ot];
    return Lr(qe, et && !ud(et) ? et : !1);
  }, []), Oe = (qe) => qe ? kN(ye, qe) > -1 : null, { W: Fe, Z: me, K: Pe, J: Ee, tt: Ke, nt: oe } = pe, de = [() => {
    Wi(me, Ul), Wi(me, sD), Wi(Fe, sD), j && (Wi(R, Ul), Wi(R, sD));
  }], we = N && Oe(me);
  let Me = N ? Fe : MN([Ke, Ee, Pe, me, Fe].find((qe) => Oe(qe) === !1));
  const Ae = Q ? Fe : Ke || Ee;
  return [pe, () => {
    Za(me, Ul, K ? "viewport" : "host"), Za(Pe, C$, ""), Za(Ke, dB, ""), K || Za(Ee, Of, "");
    const qe = j && !K ? nd(ud(D), xq) : Ys;
    if (we && (nB(Fe, me), Lr(de, () => {
      nB(me, Fe), rc(me);
    })), Gs(Ae, Me), Gs(me, Pe), Gs(Pe || me, !K && Ee), Gs(Ee, Ke), Lr(de, () => {
      qe(), Wi(Pe, C$), Wi(Ke, dB), Wi(Ee, Sq), Wi(Ee, Eq), Wi(Ee, Of), Oe(Ke) && cD(Ke), Oe(Ee) && cD(Ee), Oe(Pe) && cD(Pe);
    }), r && !K && (wm(Ee, Of, Cq, !0), Lr(de, Wi.bind(0, Ee, Of))), oe && (AMe(Ee, oe), Lr(de, rc.bind(0, oe))), Te) {
      const ot = Za(Ee, z1);
      Za(Ee, z1, "-1"), Ee.focus();
      const et = () => ot ? Za(Ee, z1, ot) : Wi(Ee, z1), ct = oa(I, "pointerdown keydown", () => {
        et(), ct();
      });
      Lr(de, [et, ct]);
    } else
      Se && Se.focus && Se.focus();
    Me = 0;
  }, sc.bind(0, de)];
}, TNe = (e, t) => {
  const { tt: n } = e, [r] = t;
  return (a) => {
    const { V: s } = ns(), { ht: l } = r(), { vt: p } = a, m = (n || !s) && p;
    return m && Ja(n, {
      height: l ? "" : "100%"
    }), {
      gt: m,
      wt: m
    };
  };
}, _Ne = (e, t) => {
  const [n, r] = t, { Z: a, K: s, J: l, ut: p } = e, [m, h] = Vl({
    u: BMe,
    o: iB()
  }, iB.bind(0, a, "padding", ""));
  return (g, b, x) => {
    let [E, O] = h(x);
    const { I: _, V: P } = ns(), { bt: M } = n(), { gt: D, wt: N, yt: I } = g, [R, j] = b("paddingAbsolute");
    (D || O || !P && N) && ([E, O] = m(x));
    const q = !p && (j || I || O);
    if (q) {
      const J = !R || !s && !_, H = E.r + E.l, Z = E.t + E.b, re = {
        marginRight: J && !M ? -H : 0,
        marginBottom: J ? -Z : 0,
        marginLeft: J && M ? -H : 0,
        top: J ? -E.t : 0,
        right: J ? M ? -E.r : "auto" : 0,
        left: J ? M ? "auto" : -E.l : 0,
        width: J ? `calc(100% + ${H}px)` : ""
      }, Y = {
        paddingTop: J ? E.t : 0,
        paddingRight: J ? E.r : 0,
        paddingBottom: J ? E.b : 0,
        paddingLeft: J ? E.l : 0
      };
      Ja(s || l, re), Ja(l, Y), r({
        K: E,
        St: !J,
        P: s ? Y : ho({}, re, Y)
      });
    }
    return {
      xt: q
    };
  };
}, { max: _$ } = Math, Pf = _$.bind(0, 0), kq = "visible", bB = "hidden", ONe = 42, U1 = {
  u: pq,
  o: {
    w: 0,
    h: 0
  }
}, PNe = {
  u: mq,
  o: {
    x: bB,
    y: bB
  }
}, RNe = (e, t) => {
  const n = window.devicePixelRatio % 1 !== 0 ? 1 : 0, r = {
    w: Pf(e.w - t.w),
    h: Pf(e.h - t.h)
  };
  return {
    w: r.w > n ? r.w : 0,
    h: r.h > n ? r.h : 0
  };
}, B1 = (e) => e.indexOf(kq) === 0, kNe = (e, t) => {
  const [n, r] = t, { Z: a, K: s, J: l, nt: p, ut: m, _t: h, it: g, et: b } = e, { k: x, V: E, I: O, A: _ } = ns(), P = Rm()[VN], M = !m && !O && (_.x || _.y), D = g && m, [N, I] = Vl(U1, iT.bind(0, l)), [R, j] = Vl(U1, aT.bind(0, l)), [U, q] = Vl(U1), [J, H] = Vl(U1), [Z] = Vl(PNe), re = (ae, se) => {
    if (Ja(l, {
      height: ""
    }), se) {
      const { St: V, K: ee } = n(), { $t: he, D: ue } = ae, fe = iT(a), Ce = uE(a), Se = Ja(l, "boxSizing") === "content-box", Te = V || Se ? ee.b + ee.t : 0, pe = !(_.x && Se);
      Ja(l, {
        height: Ce.h + fe.h + (he.x && pe ? ue.x : 0) - Te
      });
    }
  }, Y = (ae, se) => {
    const V = !O && !ae ? ONe : 0, ee = (Oe, Fe, me) => {
      const Pe = Ja(l, Oe), Ke = (se ? se[Oe] : Pe) === "scroll";
      return [Pe, Ke, Ke && !O ? Fe ? V : me : 0, Fe && !!V];
    }, [he, ue, fe, Ce] = ee("overflowX", _.x, x.x), [Se, Te, pe, ye] = ee("overflowY", _.y, x.y);
    return {
      Ct: {
        x: he,
        y: Se
      },
      $t: {
        x: ue,
        y: Te
      },
      D: {
        x: fe,
        y: pe
      },
      M: {
        x: Ce,
        y: ye
      }
    };
  }, K = (ae, se, V, ee) => {
    const he = (Te, pe) => {
      const ye = B1(Te), Oe = pe && ye && Te.replace(`${kq}-`, "") || "";
      return [pe && !ye ? Te : "", B1(Oe) ? "hidden" : Oe];
    }, [ue, fe] = he(V.x, se.x), [Ce, Se] = he(V.y, se.y);
    return ee.overflowX = fe && Ce ? fe : ue, ee.overflowY = Se && ue ? Se : Ce, Y(ae, ee);
  }, Q = (ae, se, V, ee) => {
    const { D: he, M: ue } = ae, { x: fe, y: Ce } = ue, { x: Se, y: Te } = he, { P: pe } = n(), ye = se ? "marginLeft" : "marginRight", Oe = se ? "paddingLeft" : "paddingRight", Fe = pe[ye], me = pe.marginBottom, Pe = pe[Oe], Ee = pe.paddingBottom;
    ee.width = `calc(100% + ${Te + -1 * Fe}px)`, ee[ye] = -Te + Fe, ee.marginBottom = -Se + me, V && (ee[Oe] = Pe + (Ce ? Te : 0), ee.paddingBottom = Ee + (fe ? Se : 0));
  }, [te, ne] = P ? P.H(M, E, l, p, n, Y, Q) : [() => M, () => [Ys]];
  return (ae, se, V) => {
    const { gt: ee, Ot: he, wt: ue, xt: fe, vt: Ce, yt: Se } = ae, { ht: Te, bt: pe } = n(), [ye, Oe] = se("showNativeOverlaidScrollbars"), [Fe, me] = se("overflow"), Pe = ye && _.x && _.y, Ee = !m && !E && (ee || ue || he || Oe || Ce), Ke = B1(Fe.x), oe = B1(Fe.y), de = Ke || oe;
    let we = I(V), Me = j(V), Ae = q(V), je = H(V), qe;
    if (Oe && O && h(Cq, ZMe, !Pe), Ee && (qe = Y(Pe), re(qe, Te)), ee || fe || ue || Se || Oe) {
      de && h(ay, oy, !1);
      const [ht, vt] = ne(Pe, pe, qe), [Nt, Tn] = we = N(V), [bt, Pn] = Me = R(V), wn = uE(l);
      let Cn = bt, ar = wn;
      ht(), (Pn || Tn || Oe) && vt && !Pe && te(vt, bt, Nt, pe) && (ar = uE(l), Cn = aT(l));
      const ir = {
        w: Pf(_$(bt.w, Cn.w) + Nt.w),
        h: Pf(_$(bt.h, Cn.h) + Nt.h)
      }, go = {
        w: Pf((D ? b.innerWidth : ar.w + Pf(wn.w - bt.w)) + Nt.w),
        h: Pf((D ? b.innerHeight + Nt.h : ar.h + Pf(wn.h - bt.h)) + Nt.h)
      };
      je = J(go), Ae = U(RNe(ir, go), V);
    }
    const [ot, et] = je, [ct, Qt] = Ae, [Ht, kt] = Me, [St, cn] = we, Ne = {
      x: ct.w > 0,
      y: ct.h > 0
    }, Ie = Ke && oe && (Ne.x || Ne.y) || Ke && Ne.x && !Ne.y || oe && Ne.y && !Ne.x;
    if (fe || Se || cn || kt || et || Qt || me || Oe || Ee) {
      const ht = {
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        width: "",
        overflowY: "",
        overflowX: ""
      }, vt = K(Pe, Ne, Fe, ht), Nt = te(vt, Ht, St, pe);
      m || Q(vt, pe, Nt, ht), Ee && re(vt, Te), m ? (Za(a, Sq, ht.overflowX), Za(a, Eq, ht.overflowY)) : Ja(l, ht);
    }
    wm(a, Ul, oy, Ie), wm(s, C$, JMe, Ie), m || wm(l, Of, ay, de);
    const [Je, pt] = Z(Y(Pe).Ct);
    return r({
      Ct: Je,
      zt: {
        x: ot.w,
        y: ot.h
      },
      Tt: {
        x: ct.w,
        y: ct.h
      },
      Et: Ne
    }), {
      It: pt,
      At: et,
      Lt: Qt
    };
  };
}, wB = (e, t, n) => {
  const r = {}, a = t || {}, s = Es(e).concat(Es(a));
  return vr(s, (l) => {
    const p = e[l], m = a[l];
    r[l] = !!(n || p || m);
  }), r;
}, DNe = (e, t) => {
  const { W: n, J: r, _t: a, ut: s } = e, { I: l, A: p, V: m } = ns(), h = !l && (p.x || p.y), g = [TNe(e, t), _Ne(e, t), kNe(e, t)];
  return (b, x, E) => {
    const O = wB(ho({
      gt: !1,
      xt: !1,
      yt: !1,
      vt: !1,
      At: !1,
      Lt: !1,
      It: !1,
      Ot: !1,
      wt: !1
    }, x), {}, E), _ = h || !m, P = _ && Yl(r), M = _ && td(r);
    a("", sT, !0);
    let D = O;
    return vr(g, (N) => {
      D = wB(D, N(D, b, !!E) || {}, E);
    }), Yl(r, P), td(r, M), a("", sT), s || (Yl(n, 0), td(n, 0)), D;
  };
}, $Ne = (e, t, n) => {
  let r, a = !1;
  const s = () => {
    a = !0;
  }, l = (p) => {
    if (n) {
      const m = n.reduce((h, g) => {
        if (g) {
          const [b, x] = g, E = x && b && (p ? p(b) : lq(b, e));
          E && E.length && x && Kf(x) && Lr(h, [E, x.trim()], !0);
        }
        return h;
      }, []);
      vr(m, (h) => vr(h[0], (g) => {
        const b = h[1], x = r.get(g) || [];
        if (e.contains(g)) {
          const O = oa(g, b, (_) => {
            a ? (O(), r.delete(g)) : t(_);
          });
          r.set(g, Lr(x, O));
        } else
          sc(x), r.delete(g);
      }));
    }
  };
  return n && (r = /* @__PURE__ */ new WeakMap(), l()), [s, l];
}, xB = (e, t, n, r) => {
  let a = !1;
  const { Ht: s, Pt: l, Dt: p, Mt: m, Rt: h, kt: g } = r || {}, b = AN(() => {
    a && n(!0);
  }, {
    v: 33,
    g: 99
  }), [x, E] = $Ne(e, b, p), O = s || [], _ = l || [], P = O.concat(_), M = (N, I) => {
    const R = h || Ys, j = g || Ys, U = /* @__PURE__ */ new Set(), q = /* @__PURE__ */ new Set();
    let J = !1, H = !1;
    if (vr(N, (Z) => {
      const { attributeName: re, target: Y, type: K, oldValue: Q, addedNodes: te, removedNodes: ne } = Z, ae = K === "attributes", se = K === "childList", V = e === Y, ee = ae && Kf(re) ? Za(Y, re) : 0, he = ee !== 0 && Q !== ee, ue = kN(_, re) > -1 && he;
      if (t && (se || !V)) {
        const fe = !ae, Ce = ae && he, Se = Ce && m && rT(Y, m), pe = (Se ? !R(Y, re, Q, ee) : fe || Ce) && !j(Z, !!Se, e, r);
        vr(te, (ye) => U.add(ye)), vr(ne, (ye) => U.add(ye)), H = H || pe;
      }
      !t && V && he && !R(Y, re, Q, ee) && (q.add(re), J = J || ue);
    }), U.size > 0 && E((Z) => Om(U).reduce((re, Y) => (Lr(re, lq(Z, Y)), rT(Y, Z) ? Lr(re, Y) : re), [])), t)
      return !I && H && n(!1), [!1];
    if (q.size > 0 || J) {
      const Z = [Om(q), J];
      return !I && n.apply(0, Z), Z;
    }
  }, D = new VMe((N) => M(N));
  return D.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: P,
    subtree: t,
    childList: t,
    characterData: t
  }), a = !0, [() => {
    a && (x(), D.disconnect(), a = !1);
  }, () => {
    if (a) {
      b.m();
      const N = D.takeRecords();
      return !DN(N) && M(N, !0);
    }
  }];
}, H1 = 3333333, W1 = (e) => e && (e.height || e.width), Dq = (e, t, n) => {
  const { Bt: r = !1, Vt: a = !1 } = n || {}, s = Rm()[mNe], { B: l } = ns(), m = uq(`<div class="${FN}"><div class="${tNe}"></div></div>`)[0], h = m.firstChild, g = nw.bind(0, e), [b] = Vl({
    o: void 0,
    _: !0,
    u: (_, P) => !(!_ || !W1(_) && W1(P))
  }), x = (_) => {
    const P = Xl(_) && _.length > 0 && tw(_[0]), M = !P && RN(_[0]);
    let D = !1, N = !1, I = !0;
    if (P) {
      const [R, , j] = b(_.pop().contentRect), U = W1(R), q = W1(j);
      D = !j || !U, N = !q && U, I = !D;
    } else
      M ? [, I] = _ : N = _ === !0;
    if (r && I) {
      const R = M ? _[0] : nw(m);
      Yl(m, R ? l.n ? -H1 : l.i ? 0 : H1 : H1), td(m, H1);
    }
    D || t({
      gt: !M,
      Yt: M ? _ : void 0,
      Vt: !!N
    });
  }, E = [];
  let O = a ? x : !1;
  return [() => {
    sc(E), rc(m);
  }, () => {
    if (Xv) {
      const _ = new Xv(x);
      _.observe(h), Lr(E, () => {
        _.disconnect();
      });
    } else if (s) {
      const [_, P] = s.O(h, x, a);
      O = _, Lr(E, P);
    }
    if (r) {
      const [_] = Vl({
        o: void 0
      }, g);
      Lr(E, oa(m, "scroll", (P) => {
        const M = _(), [D, N, I] = M;
        N && (IN(h, "ltr rtl"), D ? nd(h, "rtl") : nd(h, "ltr"), x([!!D, N, I])), vq(P);
      }));
    }
    O && (nd(m, eNe), Lr(E, oa(m, "animationstart", O, {
      C: !!Xv
    }))), (Xv || s) && Gs(e, m);
  }];
}, MNe = (e) => e.h === 0 || e.isIntersecting || e.intersectionRatio > 0, NNe = (e, t) => {
  let n;
  const r = xm(nNe), a = [], [s] = Vl({
    o: !1
  }), l = (m, h) => {
    if (m) {
      const g = s(MNe(m)), [, b] = g;
      if (b)
        return !h && t(g), [g];
    }
  }, p = (m, h) => {
    if (m && m.length > 0)
      return l(m.pop(), h);
  };
  return [() => {
    sc(a), rc(r);
  }, () => {
    if (rB)
      n = new rB((m) => p(m), {
        root: e
      }), n.observe(r), Lr(a, () => {
        n.disconnect();
      });
    else {
      const m = () => {
        const b = Pm(r);
        l(b);
      }, [h, g] = Dq(r, m);
      Lr(a, h), g(), m();
    }
    Gs(e, r);
  }, () => {
    if (n)
      return p(n.takeRecords(), !0);
  }];
}, SB = `[${Ul}]`, INe = `[${Of}]`, dD = ["tabindex"], EB = ["wrap", "cols", "rows"], fD = ["id", "class", "style", "open"], ANe = (e, t, n) => {
  let r, a, s;
  const { Z: l, J: p, tt: m, rt: h, ut: g, ft: b, _t: x } = e, { V: E } = ns(), [O] = Vl({
    u: pq,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const K = b(ay, oy), Q = b(lD, ""), te = Q && Yl(p), ne = Q && td(p);
    x(ay, oy), x(lD, ""), x("", sT, !0);
    const ae = aT(m), se = aT(p), V = iT(p);
    return x(ay, oy, K), x(lD, "", Q), x("", sT), Yl(p, te), td(p, ne), {
      w: se.w + ae.w + V.w,
      h: se.h + ae.h + V.h
    };
  }), _ = h ? EB : fD.concat(EB), P = AN(n, {
    v: () => r,
    g: () => a,
    p(K, Q) {
      const [te] = K, [ne] = Q;
      return [Es(te).concat(Es(ne)).reduce((ae, se) => (ae[se] = te[se] || ne[se], ae), {})];
    }
  }), M = (K) => {
    vr(K || dD, (Q) => {
      if (kN(dD, Q) > -1) {
        const te = Za(l, Q);
        Kf(te) ? Za(p, Q, te) : Wi(p, Q);
      }
    });
  }, D = (K, Q) => {
    const [te, ne] = K, ae = {
      vt: ne
    };
    return t({
      ht: te
    }), !Q && n(ae), ae;
  }, N = ({ gt: K, Yt: Q, Vt: te }) => {
    const ne = !K || te ? n : P;
    let ae = !1;
    if (Q) {
      const [se, V] = Q;
      ae = V, t({
        bt: se
      });
    }
    ne({
      gt: K,
      yt: ae
    });
  }, I = (K, Q) => {
    const [, te] = O(), ne = {
      wt: te
    };
    return te && !Q && (K ? n : P)(ne), ne;
  }, R = (K, Q, te) => {
    const ne = {
      Ot: Q
    };
    return Q ? !te && P(ne) : g || M(K), ne;
  }, [j, U, q] = m || !E ? NNe(l, D) : [Ys, Ys, Ys], [J, H] = g ? [Ys, Ys] : Dq(l, N, {
    Vt: !0,
    Bt: !0
  }), [Z, re] = xB(l, !1, R, {
    Pt: fD,
    Ht: fD.concat(dD)
  }), Y = g && Xv && new Xv(N.bind(0, {
    gt: !0
  }));
  return Y && Y.observe(l), M(), [() => {
    j(), J(), s && s[0](), Y && Y.disconnect(), Z();
  }, () => {
    H(), U();
  }, () => {
    const K = {}, Q = re(), te = q(), ne = s && s[1]();
    return Q && ho(K, R.apply(0, Lr(Q, !0))), te && ho(K, D.apply(0, Lr(te, !0))), ne && ho(K, I.apply(0, Lr(ne, !0))), K;
  }, (K) => {
    const [Q] = K("update.ignoreMutation"), [te, ne] = K("update.attributes"), [ae, se] = K("update.elementEvents"), [V, ee] = K("update.debounce"), he = se || ne, ue = (fe) => Kl(Q) && Q(fe);
    if (he && (s && (s[1](), s[0]()), s = xB(m || p, !0, I, {
      Ht: _.concat(te || []),
      Dt: ae,
      Mt: SB,
      kt: (fe, Ce) => {
        const { target: Se, attributeName: Te } = fe;
        return (!Ce && Te && !g ? IMe(Se, SB, INe) : !1) || !!Kv(Se, `.${ts}`) || !!ue(fe);
      }
    })), ee)
      if (P.m(), Xl(V)) {
        const fe = V[0], Ce = V[1];
        r = Af(fe) && fe, a = Af(Ce) && Ce;
      } else
        Af(V) ? (r = V, a = !1) : (r = !1, a = !1);
  }];
}, CB = {
  x: 0,
  y: 0
}, jNe = (e) => ({
  K: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  St: !1,
  P: {
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0
  },
  zt: CB,
  Tt: CB,
  Ct: {
    x: "hidden",
    y: "hidden"
  },
  Et: {
    x: !1,
    y: !1
  },
  ht: !1,
  bt: nw(e.Z)
}), LNe = (e, t) => {
  const n = T$(t, {}), [r, a, s] = LN(), [l, p, m] = CNe(e), h = Rq(jNe(l)), [g, b] = h, x = DNe(l, h), E = (N, I, R) => {
    const U = Es(N).some((q) => N[q]) || !$N(I) || R;
    return U && s("u", [N, I, R]), U;
  }, [O, _, P, M] = ANe(l, b, (N) => E(x(n, N), {}, !1)), D = g.bind(0);
  return D.jt = (N) => r("u", N), D.Nt = () => {
    const { W: N, J: I } = l, R = Yl(N), j = td(N);
    _(), p(), Yl(I, R), td(I, j);
  }, D.qt = l, [(N, I) => {
    const R = T$(t, N, I);
    return M(R), E(x(R, P(), I), N, !!I);
  }, D, () => {
    a(), O(), m();
  }];
}, { round: TB } = Math, FNe = (e) => {
  const { width: t, height: n } = Df(e), { w: r, h: a } = Pm(e);
  return {
    x: TB(t) / r || 1,
    y: TB(n) / a || 1
  };
}, zNe = (e, t, n) => {
  const r = t.scrollbars, { button: a, isPrimary: s, pointerType: l } = e, { pointers: p } = r;
  return a === 0 && s && r[n ? "dragScroll" : "clickScroll"] && (p || []).includes(l);
}, VNe = (e, t) => oa(e, "mousedown", oa.bind(0, t, "click", vq, {
  C: !0,
  $: !0
}), {
  $: !0
}), _B = "pointerup pointerleave pointercancel lostpointercapture", UNe = (e, t, n, r, a, s, l) => {
  const { B: p } = ns(), { Ft: m, Gt: h, Xt: g } = r, b = `scroll${l ? "Left" : "Top"}`, x = `client${l ? "X" : "Y"}`, E = l ? "width" : "height", O = l ? "left" : "top", _ = l ? "w" : "h", P = l ? "x" : "y", M = (D, N) => (I) => {
    const { Tt: R } = s(), j = Pm(h)[_] - Pm(m)[_], q = N * I / j * R[P], H = nw(g) && l ? p.n || p.i ? 1 : -1 : 1;
    a[b] = D + q * H;
  };
  return oa(h, "pointerdown", (D) => {
    const N = Kv(D.target, `.${zN}`) === m, I = N ? m : h;
    if (wm(t, Ul, cB, !0), zNe(D, e, N)) {
      const R = !N && D.shiftKey, j = () => Df(m), U = () => Df(h), q = (se, V) => (se || j())[O] - (V || U())[O], J = M(a[b] || 0, 1 / FNe(a)[P]), H = D[x], Z = j(), re = U(), Y = Z[E], K = q(Z, re) + Y / 2, Q = H - re[O], te = N ? 0 : Q - K, ne = (se) => {
        sc(ae), I.releasePointerCapture(se.pointerId);
      }, ae = [wm.bind(0, t, Ul, cB), oa(n, _B, ne), oa(n, "selectstart", (se) => yq(se), {
        S: !1
      }), oa(h, _B, ne), oa(h, "pointermove", (se) => {
        const V = se[x] - H;
        (N || R) && J(te + V);
      })];
      if (R)
        J(te);
      else if (!N) {
        const se = Rm()[hNe];
        se && Lr(ae, se.O(J, q, te, Y, Q));
      }
      I.setPointerCapture(D.pointerId);
    }
  });
}, BNe = (e, t) => (n, r, a, s, l, p) => {
  const { Xt: m } = n, [h, g] = Uv(333), b = !!l.scrollBy;
  let x = !0;
  return sc.bind(0, [oa(m, "pointerenter", () => {
    r(pB, !0);
  }), oa(m, "pointerleave pointercancel", () => {
    r(pB);
  }), oa(m, "wheel", (E) => {
    const { deltaX: O, deltaY: _, deltaMode: P } = E;
    b && x && P === 0 && ud(m) === s && l.scrollBy({
      left: O,
      top: _,
      behavior: "smooth"
    }), x = !1, r(vB, !0), h(() => {
      x = !0, r(vB);
    }), yq(E);
  }, {
    S: !1,
    $: !0
  }), VNe(m, a), UNe(e, s, a, n, l, t, p), g]);
}, { min: O$, max: OB, abs: HNe, round: WNe } = Math, $q = (e, t, n, r) => {
  if (r) {
    const p = n ? "x" : "y", { Tt: m, zt: h } = r, g = h[p], b = m[p];
    return OB(0, O$(1, g / (g + b)));
  }
  const a = n ? "w" : "h", s = Pm(e)[a], l = Pm(t)[a];
  return OB(0, O$(1, s / l));
}, YNe = (e, t, n, r, a, s) => {
  const { B: l } = ns(), p = s ? "x" : "y", m = s ? "Left" : "Top", { Tt: h } = r, g = WNe(h[p]), b = HNe(n[`scroll${m}`]), x = s && a, E = l.i ? b : g - b, _ = O$(1, (x ? E : b) / g), P = $q(e, t, s);
  return 1 / P * (1 - P) * _;
}, qNe = (e, t, n) => {
  const { N: r, L: a } = ns(), { scrollbars: s } = r(), { slot: l } = s, { ct: p, W: m, Z: h, J: g, lt: b, ot: x, it: E, ut: O } = t, { scrollbars: _ } = b ? {} : e, { slot: P } = _ || {}, M = Oq([m, h, g], () => O && E ? m : h, l, P), D = (te, ne, ae) => {
    const se = ae ? nd : IN;
    vr(te, (V) => {
      se(V.Xt, ne);
    });
  }, N = (te, ne) => {
    vr(te, (ae) => {
      const [se, V] = ne(ae);
      Ja(se, V);
    });
  }, I = (te, ne, ae) => {
    N(te, (se) => {
      const { Ft: V, Gt: ee } = se;
      return [V, {
        [ae ? "width" : "height"]: `${(100 * $q(V, ee, ae, ne)).toFixed(3)}%`
      }];
    });
  }, R = (te, ne, ae) => {
    const se = ae ? "X" : "Y";
    N(te, (V) => {
      const { Ft: ee, Gt: he, Xt: ue } = V, fe = YNe(ee, he, x, ne, nw(ue), ae);
      return [ee, {
        transform: fe === fe ? `translate${se}(${(100 * fe).toFixed(3)}%)` : ""
      }];
    });
  }, j = [], U = [], q = [], J = (te, ne, ae) => {
    const se = RN(ae), V = se ? ae : !0, ee = se ? !ae : !0;
    V && D(U, te, ne), ee && D(q, te, ne);
  }, H = (te) => {
    I(U, te, !0), I(q, te);
  }, Z = (te) => {
    R(U, te, !0), R(q, te);
  }, re = (te) => {
    const ne = te ? iNe : sNe, ae = te ? U : q, se = DN(ae) ? fB : "", V = xm(`${ts} ${ne} ${se}`), ee = xm(Tq), he = xm(zN), ue = {
      Xt: V,
      Gt: ee,
      Ft: he
    };
    return a || nd(V, rNe), Gs(V, ee), Gs(ee, he), Lr(ae, ue), Lr(j, [rc.bind(0, V), n(ue, J, p, h, x, te)]), ue;
  }, Y = re.bind(0, !0), K = re.bind(0, !1), Q = () => {
    Gs(M, U[0].Xt), Gs(M, q[0].Xt), oT(() => {
      J(fB);
    }, 300);
  };
  return Y(), K(), [{
    Ut: H,
    Wt: Z,
    Zt: J,
    Jt: {
      Kt: U,
      Qt: Y,
      tn: N.bind(0, U)
    },
    nn: {
      Kt: q,
      Qt: K,
      tn: N.bind(0, q)
    }
  }, Q, sc.bind(0, j)];
}, GNe = (e, t, n, r) => {
  let a, s, l, p, m, h = 0;
  const g = Rq({}), [b] = g, [x, E] = Uv(), [O, _] = Uv(), [P, M] = Uv(100), [D, N] = Uv(100), [I, R] = Uv(() => h), [j, U, q] = qNe(e, n.qt, BNe(t, n)), { Z: J, J: H, ot: Z, st: re, ut: Y, it: K } = n.qt, { Jt: Q, nn: te, Zt: ne, Ut: ae, Wt: se } = j, { tn: V } = Q, { tn: ee } = te, he = (Te) => {
    const { Xt: pe } = Te, ye = Y && !K && ud(pe) === H && pe;
    return [ye, {
      transform: ye ? `translate(${Yl(Z)}px, ${td(Z)}px)` : ""
    }];
  }, ue = (Te, pe) => {
    if (R(), Te)
      ne(hB);
    else {
      const ye = () => ne(hB, !0);
      h > 0 && !pe ? I(ye) : ye();
    }
  }, fe = () => {
    p = s, p && ue(!0);
  }, Ce = [M, R, N, _, E, q, oa(J, "pointerover", fe, {
    C: !0
  }), oa(J, "pointerenter", fe), oa(J, "pointerleave", () => {
    p = !1, s && ue(!1);
  }), oa(J, "pointermove", () => {
    a && x(() => {
      M(), ue(!0), D(() => {
        a && ue(!1);
      });
    });
  }), oa(re, "scroll", (Te) => {
    O(() => {
      se(n()), l && ue(!0), P(() => {
        l && !p && ue(!1);
      });
    }), r(Te), Y && V(he), Y && ee(he);
  })], Se = b.bind(0);
  return Se.qt = j, Se.Nt = U, [(Te, pe, ye) => {
    const { At: Oe, Lt: Fe, It: me, yt: Pe } = ye, { A: Ee } = ns(), Ke = T$(t, Te, pe), oe = n(), { Tt: de, Ct: we, bt: Me } = oe, [Ae, je] = Ke("showNativeOverlaidScrollbars"), [qe, ot] = Ke("scrollbars.theme"), [et, ct] = Ke("scrollbars.visibility"), [Qt, Ht] = Ke("scrollbars.autoHide"), [kt] = Ke("scrollbars.autoHideDelay"), [St, cn] = Ke("scrollbars.dragScroll"), [Ne, Ie] = Ke("scrollbars.clickScroll"), Je = Oe || Fe || Pe, pt = me || ct, ht = Ae && Ee.x && Ee.y, vt = (Nt, Tn) => {
      const bt = et === "visible" || et === "auto" && Nt === "scroll";
      return ne(lNe, bt, Tn), bt;
    };
    if (h = kt, je && ne(oNe, ht), ot && (ne(m), ne(qe, !0), m = qe), Ht && (a = Qt === "move", s = Qt === "leave", l = Qt !== "never", ue(!l, !0)), cn && ne(dNe, St), Ie && ne(cNe, Ne), pt) {
      const Nt = vt(we.x, !0), Tn = vt(we.y, !1);
      ne(uNe, !(Nt && Tn));
    }
    Je && (ae(oe), se(oe), ne(mB, !de.x, !0), ne(mB, !de.y, !1), ne(aNe, Me && !K));
  }, Se, sc.bind(0, Ce)];
}, Mq = (e, t, n) => {
  Kl(e) && e(t || void 0, n || void 0);
}, $f = (e, t, n) => {
  const { F: r, N: a, Y: s, j: l } = ns(), p = Rm(), m = nT(e), h = m ? e : e.target, g = Pq(h);
  if (t && !g) {
    let b = !1;
    const x = (Y) => {
      const K = Rm()[pNe], Q = K && K.O;
      return Q ? Q(Y, !0) : Y;
    }, E = ho({}, r(), x(t)), [O, _, P] = LN(n), [M, D, N] = LNe(e, E), [I, R, j] = GNe(e, E, D, (Y) => P("scroll", [re, Y])), U = (Y, K) => M(Y, !!K), q = U.bind(0, {}, !0), J = s(q), H = l(q), Z = (Y) => {
      ENe(h), J(), H(), j(), N(), b = !0, P("destroyed", [re, !!Y]), _();
    }, re = {
      options(Y, K) {
        if (Y) {
          const Q = K ? r() : {}, te = gq(E, ho(Q, x(Y)));
          $N(te) || (ho(E, te), U(te));
        }
        return ho({}, E);
      },
      on: O,
      off: (Y, K) => {
        Y && K && _(Y, K);
      },
      state() {
        const { zt: Y, Tt: K, Ct: Q, Et: te, K: ne, St: ae, bt: se } = D();
        return ho({}, {
          overflowEdge: Y,
          overflowAmount: K,
          overflowStyle: Q,
          hasOverflow: te,
          padding: ne,
          paddingAbsolute: ae,
          directionRTL: se,
          destroyed: b
        });
      },
      elements() {
        const { W: Y, Z: K, K: Q, J: te, tt: ne, ot: ae, st: se } = D.qt, { Jt: V, nn: ee } = R.qt, he = (fe) => {
          const { Ft: Ce, Gt: Se, Xt: Te } = fe;
          return {
            scrollbar: Te,
            track: Se,
            handle: Ce
          };
        }, ue = (fe) => {
          const { Kt: Ce, Qt: Se } = fe, Te = he(Ce[0]);
          return ho({}, Te, {
            clone: () => {
              const pe = he(Se());
              return I({}, !0, {}), pe;
            }
          });
        };
        return ho({}, {
          target: Y,
          host: K,
          padding: Q || te,
          viewport: te,
          content: ne || te,
          scrollOffsetElement: ae,
          scrollEventElement: se,
          scrollbarHorizontal: ue(V),
          scrollbarVertical: ue(ee)
        });
      },
      update: (Y) => U({}, Y),
      destroy: Z.bind(0)
    };
    return D.jt((Y, K, Q) => {
      I(K, Q, Y);
    }), SNe(h, re), vr(Es(p), (Y) => Mq(p[Y], 0, re)), xNe(D.qt.it, a().cancel, !m && e.cancel) ? (Z(!0), re) : (D.Nt(), R.Nt(), P("initialized", [re]), D.jt((Y, K, Q) => {
      const { gt: te, yt: ne, vt: ae, At: se, Lt: V, It: ee, wt: he, Ot: ue } = Y;
      P("updated", [re, {
        updateHints: {
          sizeChanged: te,
          directionChanged: ne,
          heightIntrinsicChanged: ae,
          overflowEdgeChanged: se,
          overflowAmountChanged: V,
          overflowStyleChanged: ee,
          contentMutation: he,
          hostMutation: ue
        },
        changedOptions: K,
        force: Q
      }]);
    }), re.update(!0), re);
  }
  return g;
};
$f.plugin = (e) => {
  vr(fNe(e), (t) => Mq(t, $f));
};
$f.valid = (e) => {
  const t = e && e.elements, n = Kl(t) && t();
  return w$(n) && !!Pq(n.target);
};
$f.env = () => {
  const { k: e, A: t, I: n, B: r, V: a, L: s, X: l, U: p, N: m, q: h, F: g, G: b } = ns();
  return ho({}, {
    scrollbarsSize: e,
    scrollbarsOverlaid: t,
    scrollbarsHiding: n,
    rtlScrollBehavior: r,
    flexboxGlue: a,
    cssCustomProperties: s,
    staticDefaultInitialization: l,
    staticDefaultOptions: p,
    getDefaultInitialization: m,
    setDefaultInitialization: h,
    getDefaultOptions: g,
    setDefaultOptions: b
  });
};
const KNe = () => {
  if (typeof window > "u") {
    const h = () => {
    };
    return [h, h];
  }
  let e, t;
  const n = window, r = typeof n.requestIdleCallback == "function", a = n.requestAnimationFrame, s = n.cancelAnimationFrame, l = r ? n.requestIdleCallback : a, p = r ? n.cancelIdleCallback : s, m = () => {
    p(e), s(t);
  };
  return [
    (h, g) => {
      m(), e = l(
        r ? () => {
          m(), t = a(h);
        } : h,
        typeof g == "object" ? g : { timeout: 2233 }
      );
    },
    m
  ];
}, XNe = (e) => {
  const { options: t, events: n, defer: r } = e || {}, [a, s] = C.useMemo(KNe, []), l = C.useRef(null), p = C.useRef(r), m = C.useRef(t), h = C.useRef(n);
  return C.useEffect(() => {
    p.current = r;
  }, [r]), C.useEffect(() => {
    const { current: g } = l;
    m.current = t, $f.valid(g) && g.options(t || {}, !0);
  }, [t]), C.useEffect(() => {
    const { current: g } = l;
    h.current = n, $f.valid(g) && g.on(n || {}, !0);
  }, [n]), C.useEffect(
    () => () => {
      var g;
      s(), (g = l.current) == null || g.destroy();
    },
    []
  ), C.useMemo(
    () => [
      (g) => {
        const b = l.current;
        if ($f.valid(b))
          return;
        const x = p.current, E = m.current || {}, O = h.current || {}, _ = () => l.current = $f(g, E, O);
        x ? a(_, x) : _();
      },
      () => l.current
    ],
    []
  );
}, QNe = (e, t) => {
  const { element: n = "div", options: r, events: a, defer: s, children: l, ...p } = e, m = n, h = C.useRef(null), g = C.useRef(null), [b, x] = XNe({ options: r, events: a, defer: s });
  return C.useEffect(() => {
    const { current: E } = h, { current: O } = g;
    return E && O && b({
      target: E,
      elements: {
        viewport: O,
        content: O
      }
    }), () => {
      var _;
      return (_ = x()) == null ? void 0 : _.destroy();
    };
  }, [b, n]), C.useImperativeHandle(
    t,
    () => ({
      osInstance: x,
      getElement: () => h.current
    }),
    []
  ), /* @__PURE__ */ le.createElement(m, {
    "data-overlayscrollbars-initialize": "",
    ref: h,
    ...p
  }, /* @__PURE__ */ le.createElement("div", {
    ref: g
  }, l));
}, ZNe = C.forwardRef(QNe), Nq = C.forwardRef(
  ({ children: e, options: t, ...n }, r) => /* @__PURE__ */ L.jsx(ZNe, { ref: r, options: t, ...n, children: e })
);
Nq.displayName = "ScrollArea";
const JNe = yn(
  (e, { selecDataGrid: t, selectedColumn: n, rtl: r }) => ({
    fieldTitleRoot: {
      position: "sticky",
      top: 0,
      padding: "0 !important",
      zIndex: 20,
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white
    },
    fieldTitleWrapper: {
      boxSizing: "border-box",
      display: "flex",
      flexDirection: r ? "row-reverse" : "row",
      paddingLeft: e.spacing.sm,
      paddingRight: e.spacing.sm,
      paddingTop: e.spacing.xs,
      paddingBottom: e.spacing.xs,
      borderBottom: `1px solid ${e.colors.gray[4]}`,
      ...e.fn.fontStyles(),
      fontSize: e.fontSizes.sm,
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      cursor: t ? "pointer" : "default",
      color: n ? e.colors[e.primaryColor][e.fn.primaryShade()] : null,
      "&:hover": {
        color: t ? n ? e.colors.dark[4] : e.colors.gray[6] : null
      }
    },
    fieldTitleName: {
      fontWeight: 700
    },
    fieldTitleIcon: {
      display: "flex",
      alignItems: "center",
      visibility: n ? "visible" : "hidden"
    }
  })
);
function PB({
  column: e,
  label: t,
  selecDataGrid: n,
  related: r,
  rtl: a,
  classNames: s,
  styles: l
}) {
  const { queryParams: p, setQueryParams: m } = sa(), h = p.order_column === e, { classes: g } = JNe({ selectedColumn: h, selecDataGrid: n, rtl: a }, { classNames: s, styles: l, name: "DataGrid" });
  return /* @__PURE__ */ L.jsx(
    "th",
    {
      className: g.fieldTitleRoot,
      onClick: n ? () => m({
        order_column: e,
        order_direction: p.order_direction === "asc" ? "desc" : "asc"
      }) : null,
      children: /* @__PURE__ */ L.jsxs(hn, { className: g.fieldTitleWrapper, children: [
        /* @__PURE__ */ L.jsx(hn, { className: g.fieldTitleName, children: t || e }),
        r ? /* @__PURE__ */ L.jsx($m, { label: "Related Field", children: /* @__PURE__ */ L.jsx(
          wM,
          {
            label: "rel",
            styles: (b) => ({ indicator: { top: "-1px !important", right: "-2px !important", padding: "4px" } }),
            children: /* @__PURE__ */ L.jsx(hn, { className: g.fieldTitleIcon, children: h ? p.order_direction === "asc" ? /* @__PURE__ */ L.jsx(ZD, { size: 14, strokeWidth: 1.5 }) : /* @__PURE__ */ L.jsx(E5, { size: 14, strokeWidth: 1.5 }) : null })
          }
        ) }) : /* @__PURE__ */ L.jsx(hn, { className: g.fieldTitleIcon, children: h ? p.order_direction === "asc" ? /* @__PURE__ */ L.jsx(ZD, { size: 14, strokeWidth: 1.5 }) : /* @__PURE__ */ L.jsx(E5, { size: 14, strokeWidth: 1.5 }) : null })
      ] })
    }
  );
}
const Iq = le.memo(({ settings: e, hideActions: t }) => {
  const { data: n, info: r } = sa();
  return /* @__PURE__ */ L.jsx("thead", { style: { padding: 0 }, children: /* @__PURE__ */ L.jsxs("tr", { children: [
    t ? null : /* @__PURE__ */ L.jsx(PB, { column: "Actions", rtl: e.rtl }),
    n.list_columns.map((a, s) => {
      var l;
      return /* @__PURE__ */ L.jsx(
        PB,
        {
          column: a,
          label: n.label_columns[a],
          selecDataGrid: n.order_columns.includes(a),
          related: ((l = r.filters[a]) == null ? void 0 : l.schema.type) === "Nested",
          rtl: e.rtl
        },
        a
      );
    })
  ] }) });
});
Iq.displayName = "Header";
const Aq = (e, t) => {
  const n = t.split(".").reduce((r, a) => r[a], e);
  return n ? typeof n == "boolean" ? n.toString() : Array.isArray(n) ? n.map((r) => r._name).join(", ") : typeof n == "object" ? n._name : n : null;
};
function jq(e, t) {
  return e === !0 || Array.isArray(e) ? t : Object.fromEntries(
    Object.keys(e).map((n) => [n, jq(e[n], t[n])])
  );
}
const eIe = yn((e, { selected: t, pointer: n, hover: r }) => {
  const a = e.fn.variant({
    color: e.colors[e.primaryColor][e.fn.primaryShade()],
    variant: "light"
  });
  return {
    row: {
      backgroundColor: t ? `${a.hover} !important` : void 0,
      ":hover": {
        cursor: n ? "pointer" : "default",
        backgroundColor: r ? t ? `${a.hover} !important` : `${a.background} !important` : void 0
      }
    }
  };
});
function tIe({ entry: e, selected: t, hover: n, onSelect: r, setSelectedItem: a, children: s }) {
  const { classes: l } = eIe({ selected: t, hover: r || n, pointer: !!r }, { name: "DataGrid" });
  return /* @__PURE__ */ L.jsx(
    "tr",
    {
      className: l.row,
      onClick: (p) => {
        r && (a(e), r(p, e));
      },
      children: s
    }
  );
}
const nIe = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "search",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
var rIe = nIe;
const oIe = /* @__PURE__ */ Uf(rIe), aIe = /\s?<!doctype html>|(<html\b[^>]*>|<body\b[^>]*>|<x-[^>]+>)+/i, iIe = new RegExp(oIe.map((e) => `<${e}\\b[^>]*>`).join("|"), "i");
function sIe(e) {
  return e = e.trim().slice(0, 1e3), aIe.test(e) || iIe.test(e);
}
var HN = {}, WN = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(WN);
var Hn = {}, Xf = Yu && Yu.__extends || function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, a) {
      r.__proto__ = a;
    } || function(r, a) {
      for (var s in a)
        Object.prototype.hasOwnProperty.call(a, s) && (r[s] = a[s]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), j0 = Yu && Yu.__assign || function() {
  return j0 = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var a in t)
        Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, j0.apply(this, arguments);
};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.cloneNode = Hn.hasChildren = Hn.isDocument = Hn.isDirective = Hn.isComment = Hn.isText = Hn.isCDATA = Hn.isTag = Hn.Element = Hn.Document = Hn.CDATA = Hn.NodeWithChildren = Hn.ProcessingInstruction = Hn.Comment = Hn.Text = Hn.DataNode = Hn.Node = void 0;
var Qi = WN, YN = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), qN(this, t);
    }, e;
  }()
);
Hn.Node = YN;
var E_ = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(YN)
);
Hn.DataNode = E_;
var Lq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E_)
);
Hn.Text = Lq;
var Fq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E_)
);
Hn.Comment = Fq;
var zq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t(n, r) {
      var a = e.call(this, r) || this;
      return a.name = n, a.type = Qi.ElementType.Directive, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E_)
);
Hn.ProcessingInstruction = zq;
var C_ = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(YN)
);
Hn.NodeWithChildren = C_;
var Vq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(C_)
);
Hn.CDATA = Vq;
var Uq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(C_)
);
Hn.Document = Uq;
var Bq = (
  /** @class */
  function(e) {
    Xf(t, e);
    function t(n, r, a, s) {
      a === void 0 && (a = []), s === void 0 && (s = n === "script" ? Qi.ElementType.Script : n === "style" ? Qi.ElementType.Style : Qi.ElementType.Tag);
      var l = e.call(this, a) || this;
      return l.name = n, l.attribs = r, l.type = s, l;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var a, s;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (a = n["x-attribsNamespace"]) === null || a === void 0 ? void 0 : a[r],
            prefix: (s = n["x-attribsPrefix"]) === null || s === void 0 ? void 0 : s[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(C_)
);
Hn.Element = Bq;
function Hq(e) {
  return (0, Qi.isTag)(e);
}
Hn.isTag = Hq;
function Wq(e) {
  return e.type === Qi.ElementType.CDATA;
}
Hn.isCDATA = Wq;
function Yq(e) {
  return e.type === Qi.ElementType.Text;
}
Hn.isText = Yq;
function qq(e) {
  return e.type === Qi.ElementType.Comment;
}
Hn.isComment = qq;
function Gq(e) {
  return e.type === Qi.ElementType.Directive;
}
Hn.isDirective = Gq;
function Kq(e) {
  return e.type === Qi.ElementType.Root;
}
Hn.isDocument = Kq;
function lIe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Hn.hasChildren = lIe;
function qN(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (Yq(e))
    n = new Lq(e.data);
  else if (qq(e))
    n = new Fq(e.data);
  else if (Hq(e)) {
    var r = t ? pD(e.children) : [], a = new Bq(e.name, j0({}, e.attribs), r);
    r.forEach(function(m) {
      return m.parent = a;
    }), e.namespace != null && (a.namespace = e.namespace), e["x-attribsNamespace"] && (a["x-attribsNamespace"] = j0({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (a["x-attribsPrefix"] = j0({}, e["x-attribsPrefix"])), n = a;
  } else if (Wq(e)) {
    var r = t ? pD(e.children) : [], s = new Vq(r);
    r.forEach(function(h) {
      return h.parent = s;
    }), n = s;
  } else if (Kq(e)) {
    var r = t ? pD(e.children) : [], l = new Uq(r);
    r.forEach(function(h) {
      return h.parent = l;
    }), e["x-mode"] && (l["x-mode"] = e["x-mode"]), n = l;
  } else if (Gq(e)) {
    var p = new zq(e.name, e.data);
    e["x-name"] != null && (p["x-name"] = e["x-name"], p["x-publicId"] = e["x-publicId"], p["x-systemId"] = e["x-systemId"]), n = p;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Hn.cloneNode = qN;
function pD(e) {
  for (var t = e.map(function(r) {
    return qN(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Yu && Yu.__createBinding || (Object.create ? function(p, m, h, g) {
    g === void 0 && (g = h);
    var b = Object.getOwnPropertyDescriptor(m, h);
    (!b || ("get" in b ? !m.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return m[h];
    } }), Object.defineProperty(p, g, b);
  } : function(p, m, h, g) {
    g === void 0 && (g = h), p[g] = m[h];
  }), n = Yu && Yu.__exportStar || function(p, m) {
    for (var h in p)
      h !== "default" && !Object.prototype.hasOwnProperty.call(m, h) && t(m, p, h);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = WN, a = Hn;
  n(Hn, e);
  var s = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, l = (
    /** @class */
    function() {
      function p(m, h, g) {
        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof h == "function" && (g = h, h = s), typeof m == "object" && (h = m, m = void 0), this.callback = m ?? null, this.options = h ?? s, this.elementCB = g ?? null;
      }
      return p.prototype.onparserinit = function(m) {
        this.parser = m;
      }, p.prototype.onreset = function() {
        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, p.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, p.prototype.onerror = function(m) {
        this.handleCallback(m);
      }, p.prototype.onclosetag = function() {
        this.lastNode = null;
        var m = this.tagStack.pop();
        this.options.withEndIndices && (m.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(m);
      }, p.prototype.onopentag = function(m, h) {
        var g = this.options.xmlMode ? r.ElementType.Tag : void 0, b = new a.Element(m, h, void 0, g);
        this.addNode(b), this.tagStack.push(b);
      }, p.prototype.ontext = function(m) {
        var h = this.lastNode;
        if (h && h.type === r.ElementType.Text)
          h.data += m, this.options.withEndIndices && (h.endIndex = this.parser.endIndex);
        else {
          var g = new a.Text(m);
          this.addNode(g), this.lastNode = g;
        }
      }, p.prototype.oncomment = function(m) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += m;
          return;
        }
        var h = new a.Comment(m);
        this.addNode(h), this.lastNode = h;
      }, p.prototype.oncommentend = function() {
        this.lastNode = null;
      }, p.prototype.oncdatastart = function() {
        var m = new a.Text(""), h = new a.CDATA([m]);
        this.addNode(h), m.parent = h, this.lastNode = m;
      }, p.prototype.oncdataend = function() {
        this.lastNode = null;
      }, p.prototype.onprocessinginstruction = function(m, h) {
        var g = new a.ProcessingInstruction(m, h);
        this.addNode(g);
      }, p.prototype.handleCallback = function(m) {
        if (typeof this.callback == "function")
          this.callback(m, this.dom);
        else if (m)
          throw m;
      }, p.prototype.addNode = function(m) {
        var h = this.tagStack[this.tagStack.length - 1], g = h.children[h.children.length - 1];
        this.options.withStartIndices && (m.startIndex = this.parser.startIndex), this.options.withEndIndices && (m.endIndex = this.parser.endIndex), h.children.push(m), g && (m.prev = g, g.next = m), m.parent = h, this.lastNode = null;
      }, p;
    }()
  );
  e.DomHandler = l, e.default = l;
})(HN);
var RB = "html", kB = "head", Y1 = "body", uIe = /<([a-zA-Z]+[0-9]?)/, DB = /<head[^]*>/i, $B = /<body[^]*>/i, lT = function() {
  throw new Error(
    "This browser does not support `document.implementation.createHTMLDocument`"
  );
}, P$ = function() {
  throw new Error(
    "This browser does not support `DOMParser.prototype.parseFromString`"
  );
}, MB = typeof window == "object" && window.DOMParser;
if (typeof MB == "function") {
  var cIe = new MB(), dIe = "text/html";
  P$ = function(e, t) {
    return t && (e = "<" + t + ">" + e + "</" + t + ">"), cIe.parseFromString(e, dIe);
  }, lT = P$;
}
if (typeof document == "object" && document.implementation) {
  var q1 = document.implementation.createHTMLDocument();
  lT = function(e, t) {
    if (t) {
      var n = q1.documentElement.querySelector(t);
      return n.innerHTML = e, q1;
    }
    return q1.documentElement.innerHTML = e, q1;
  };
}
var mD = typeof document == "object" ? document.createElement("template") : {}, R$;
mD.content && (R$ = function(e) {
  return mD.innerHTML = e, mD.content.childNodes;
});
function fIe(e) {
  var t, n = e.match(uIe);
  n && n[1] && (t = n[1].toLowerCase());
  var r, a, s;
  switch (t) {
    case RB:
      return r = P$(e), DB.test(e) || (a = r.querySelector(kB), a && a.parentNode.removeChild(a)), $B.test(e) || (a = r.querySelector(Y1), a && a.parentNode.removeChild(a)), r.querySelectorAll(RB);
    case kB:
    case Y1:
      return r = lT(e), s = r.querySelectorAll(t), $B.test(e) && DB.test(e) ? s[0].parentNode.childNodes : s;
    default:
      return R$ ? R$(e) : (a = lT(e, Y1).querySelector(Y1), a.childNodes);
  }
}
var pIe = fIe, GN = {}, Xq = {};
Xq.CASE_SENSITIVE_TAG_NAMES = [
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "linearGradient",
  "radialGradient",
  "textPath"
];
var T_ = HN, mIe = Xq, NB = mIe.CASE_SENSITIVE_TAG_NAMES, hIe = T_.Comment, vIe = T_.Element, yIe = T_.ProcessingInstruction, gIe = T_.Text, Qq = {}, hD;
for (var vD = 0, bIe = NB.length; vD < bIe; vD++)
  hD = NB[vD], Qq[hD.toLowerCase()] = hD;
function wIe(e) {
  return Qq[e];
}
function Zq(e) {
  for (var t = {}, n, r = 0, a = e.length; r < a; r++)
    n = e[r], t[n.name] = n.value;
  return t;
}
function xIe(e) {
  e = e.toLowerCase();
  var t = wIe(e);
  return t || e;
}
function Jq(e, t, n) {
  t = t || null;
  for (var r = [], a, s = 0, l = e.length; s < l; s++) {
    var p = e[s], m;
    switch (p.nodeType) {
      case 1:
        a = xIe(p.nodeName), m = new vIe(a, Zq(p.attributes)), m.children = Jq(
          // template children are on content
          a === "template" ? p.content.childNodes : p.childNodes,
          m
        );
        break;
      case 3:
        m = new gIe(p.nodeValue);
        break;
      case 8:
        m = new hIe(p.nodeValue);
        break;
      default:
        continue;
    }
    var h = r[s - 1] || null;
    h && (h.next = m), m.parent = t, m.prev = h, m.next = null, r.push(m);
  }
  return n && (m = new yIe(
    n.substring(0, n.indexOf(" ")).toLowerCase(),
    n
  ), m.next = r[0] || null, m.parent = t, r.unshift(m), r[1] && (r[1].prev = r[0])), r;
}
GN.formatAttributes = Zq;
GN.formatDOM = Jq;
var SIe = pIe, EIe = GN, CIe = EIe.formatDOM, TIe = /<(![a-zA-Z\s]+)>/;
function _Ie(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (e === "")
    return [];
  var t = e.match(TIe), n;
  return t && t[1] && (n = t[1]), CIe(SIe(e), null, n);
}
var OIe = _Ie, ll = {}, __ = {}, PIe = 0;
__.SAME = PIe;
var RIe = 1;
__.CAMELCASE = RIe;
__.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
Object.defineProperty(ll, "__esModule", { value: !0 });
function kIe(e, t) {
  return DIe(e) || $Ie(e, t) || MIe(e, t) || NIe();
}
function DIe(e) {
  if (Array.isArray(e))
    return e;
}
function $Ie(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], a = !0, s = !1, l, p;
    try {
      for (n = n.call(e); !(a = (l = n.next()).done) && (r.push(l.value), !(t && r.length === t)); a = !0)
        ;
    } catch (m) {
      s = !0, p = m;
    } finally {
      try {
        !a && n.return != null && n.return();
      } finally {
        if (s)
          throw p;
      }
    }
    return r;
  }
}
function MIe(e, t) {
  if (e) {
    if (typeof e == "string")
      return IB(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return IB(e, t);
  }
}
function IB(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function NIe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var eG = 0, Qf = 1, O_ = 2, P_ = 3, KN = 4, tG = 5, nG = 6;
function IIe(e) {
  return ka.hasOwnProperty(e) ? ka[e] : null;
}
function xi(e, t, n, r, a, s, l) {
  this.acceptsBooleans = t === O_ || t === P_ || t === KN, this.attributeName = r, this.attributeNamespace = a, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = l;
}
var ka = {}, AIe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
AIe.forEach(function(e) {
  ka[e] = new xi(
    e,
    eG,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = kIe(e, 2), n = t[0], r = t[1];
  ka[n] = new xi(
    n,
    Qf,
    !1,
    // mustUseProperty
    r,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  ka[e] = new xi(
    e,
    O_,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  ka[e] = new xi(
    e,
    O_,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach(function(e) {
  ka[e] = new xi(
    e,
    P_,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  ka[e] = new xi(
    e,
    P_,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  ka[e] = new xi(
    e,
    KN,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  ka[e] = new xi(
    e,
    nG,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["rowSpan", "start"].forEach(function(e) {
  ka[e] = new xi(
    e,
    tG,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
var XN = /[\-\:]([a-z])/g, QN = function(t) {
  return t[1].toUpperCase();
};
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(XN, QN);
  ka[t] = new xi(
    t,
    Qf,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(XN, QN);
  ka[t] = new xi(
    t,
    Qf,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(XN, QN);
  ka[t] = new xi(
    t,
    Qf,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
  );
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  ka[e] = new xi(
    e,
    Qf,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
var jIe = "xlinkHref";
ka[jIe] = new xi(
  "xlinkHref",
  Qf,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
);
["src", "href", "action", "formAction"].forEach(function(e) {
  ka[e] = new xi(
    e,
    Qf,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
  );
});
var ZN = __, LIe = ZN.CAMELCASE, FIe = ZN.SAME, AB = ZN.possibleStandardNames, zIe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", VIe = zIe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", UIe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + VIe + "]*$")
), BIe = Object.keys(AB).reduce(function(e, t) {
  var n = AB[t];
  return n === FIe ? e[t] = t : n === LIe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ll.BOOLEAN = P_;
ll.BOOLEANISH_STRING = O_;
ll.NUMERIC = tG;
ll.OVERLOADED_BOOLEAN = KN;
ll.POSITIVE_NUMERIC = nG;
ll.RESERVED = eG;
ll.STRING = Qf;
ll.getPropertyInfo = IIe;
ll.isCustomAttribute = UIe;
ll.possibleStandardNames = BIe;
var rG = {}, JN = { exports: {} }, jB = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, HIe = /\n/g, WIe = /^\s*/, YIe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, qIe = /^:\s*/, GIe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, KIe = /^[;\s]*/, XIe = /^\s+|\s+$/g, QIe = `
`, LB = "/", FB = "*", fm = "", ZIe = "comment", JIe = "declaration", eAe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function a(O) {
    var _ = O.match(HIe);
    _ && (n += _.length);
    var P = O.lastIndexOf(QIe);
    r = ~P ? O.length - P : r + O.length;
  }
  function s() {
    var O = { line: n, column: r };
    return function(_) {
      return _.position = new l(O), h(), _;
    };
  }
  function l(O) {
    this.start = O, this.end = { line: n, column: r }, this.source = t.source;
  }
  l.prototype.content = e;
  function p(O) {
    var _ = new Error(
      t.source + ":" + n + ":" + r + ": " + O
    );
    if (_.reason = O, _.filename = t.source, _.line = n, _.column = r, _.source = e, !t.silent)
      throw _;
  }
  function m(O) {
    var _ = O.exec(e);
    if (_) {
      var P = _[0];
      return a(P), e = e.slice(P.length), _;
    }
  }
  function h() {
    m(WIe);
  }
  function g(O) {
    var _;
    for (O = O || []; _ = b(); )
      _ !== !1 && O.push(_);
    return O;
  }
  function b() {
    var O = s();
    if (!(LB != e.charAt(0) || FB != e.charAt(1))) {
      for (var _ = 2; fm != e.charAt(_) && (FB != e.charAt(_) || LB != e.charAt(_ + 1)); )
        ++_;
      if (_ += 2, fm === e.charAt(_ - 1))
        return p("End of comment missing");
      var P = e.slice(2, _ - 2);
      return r += 2, a(P), e = e.slice(_), r += 2, O({
        type: ZIe,
        comment: P
      });
    }
  }
  function x() {
    var O = s(), _ = m(YIe);
    if (_) {
      if (b(), !m(qIe))
        return p("property missing ':'");
      var P = m(GIe), M = O({
        type: JIe,
        property: zB(_[0].replace(jB, fm)),
        value: P ? zB(P[0].replace(jB, fm)) : fm
      });
      return m(KIe), M;
    }
  }
  function E() {
    var O = [];
    g(O);
    for (var _; _ = x(); )
      _ !== !1 && (O.push(_), g(O));
    return O;
  }
  return h(), E();
};
function zB(e) {
  return e ? e.replace(XIe, fm) : fm;
}
var tAe = eAe;
function oG(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  for (var r, a = tAe(e), s = typeof t == "function", l, p, m = 0, h = a.length; m < h; m++)
    r = a[m], l = r.property, p = r.value, s ? t(l, p, r) : p && (n || (n = {}), n[l] = p);
  return n;
}
JN.exports = oG;
JN.exports.default = oG;
var nAe = JN.exports, R_ = {};
R_.__esModule = !0;
R_.camelCase = void 0;
var rAe = /^--[a-zA-Z0-9-]+$/, oAe = /-([a-z])/g, aAe = /^[^-]+$/, iAe = /^-(webkit|moz|ms|o|khtml)-/, sAe = /^-(ms)-/, lAe = function(e) {
  return !e || aAe.test(e) || rAe.test(e);
}, uAe = function(e, t) {
  return t.toUpperCase();
}, VB = function(e, t) {
  return "".concat(t, "-");
}, cAe = function(e, t) {
  return t === void 0 && (t = {}), lAe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(sAe, VB) : e = e.replace(iAe, VB), e.replace(oAe, uAe));
};
R_.camelCase = cAe;
(function(e) {
  var t = Yu && Yu.__importDefault || function(s) {
    return s && s.__esModule ? s : { default: s };
  };
  e.__esModule = !0;
  var n = t(nAe), r = R_;
  function a(s, l) {
    var p = {};
    return !s || typeof s != "string" || (0, n.default)(s, function(m, h) {
      m && h && (p[(0, r.camelCase)(m, l)] = h);
    }), p;
  }
  e.default = a;
})(rG);
var dAe = C, fAe = rG.default;
function pAe(e, t) {
  if (!e || typeof e != "object")
    throw new TypeError("First argument must be an object");
  var n, r, a = typeof t == "function", s = {}, l = {};
  for (n in e) {
    if (r = e[n], a && (s = t(n, r), s && s.length === 2)) {
      l[s[0]] = s[1];
      continue;
    }
    typeof r == "string" && (l[r] = n);
  }
  return l;
}
function mAe(e, t) {
  if (e.indexOf("-") === -1)
    return t && typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var hAe = { reactCompat: !0 };
function vAe(e, t) {
  if (e != null)
    try {
      t.style = fAe(e, hAe);
    } catch {
      t.style = {};
    }
}
var yAe = dAe.version.split(".")[0] >= 16, aG = /* @__PURE__ */ new Set([
  "tr",
  "tbody",
  "thead",
  "tfoot",
  "colgroup",
  "table",
  "head",
  "html",
  "frameset"
]);
function gAe(e) {
  return !aG.has(e.name);
}
var iG = {
  PRESERVE_CUSTOM_ATTRIBUTES: yAe,
  invertObject: pAe,
  isCustomComponent: mAe,
  setStyleProp: vAe,
  canTextBeChildOfNode: gAe,
  elementsWithNoTextChildren: aG
}, S0 = ll, UB = iG, bAe = ["checked", "value"], wAe = ["input", "select", "textarea"], xAe = {
  reset: !0,
  submit: !0
}, sG = function(t, n) {
  t = t || {};
  var r, a, s, l, p, m = {}, h = t.type && xAe[t.type];
  for (r in t) {
    if (s = t[r], S0.isCustomAttribute(r)) {
      m[r] = s;
      continue;
    }
    if (a = r.toLowerCase(), l = BB(a), l) {
      switch (p = S0.getPropertyInfo(l), bAe.indexOf(l) !== -1 && wAe.indexOf(n) !== -1 && !h && (l = BB("default" + a)), m[l] = s, p && p.type) {
        case S0.BOOLEAN:
          m[l] = !0;
          break;
        case S0.OVERLOADED_BOOLEAN:
          s === "" && (m[l] = !0);
          break;
      }
      continue;
    }
    UB.PRESERVE_CUSTOM_ATTRIBUTES && (m[r] = s);
  }
  return UB.setStyleProp(t.style, m), m;
};
function BB(e) {
  return S0.possibleStandardNames[e];
}
var SAe = C, EAe = sG, uT = iG, CAe = uT.setStyleProp, TAe = uT.canTextBeChildOfNode;
function lG(e, t) {
  t = t || {};
  for (var n = t.library || SAe, r = n.cloneElement, a = n.createElement, s = n.isValidElement, l = [], p, m, h = typeof t.replace == "function", g, b, x, E = t.trim, O = 0, _ = e.length; O < _; O++) {
    if (p = e[O], h && (g = t.replace(p), s(g))) {
      _ > 1 && (g = r(g, {
        key: g.key || O
      })), l.push(g);
      continue;
    }
    if (p.type === "text") {
      if (m = !p.data.trim().length, m && p.parent && !TAe(p.parent) || E && m)
        continue;
      l.push(p.data);
      continue;
    }
    switch (b = p.attribs, _Ae(p) ? CAe(b.style, b) : b && (b = EAe(b, p.name)), x = null, p.type) {
      case "script":
      case "style":
        p.children[0] && (b.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? b.defaultValue = p.children[0].data : p.children && p.children.length && (x = lG(p.children, t));
        break;
      default:
        continue;
    }
    _ > 1 && (b.key = O), l.push(a(p.name, b, x));
  }
  return l.length === 1 ? l[0] : l;
}
function _Ae(e) {
  return uT.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && uT.isCustomComponent(e.name, e.attribs);
}
var OAe = lG, k_ = HN, Qv = OIe, PAe = sG, uG = OAe;
Qv = /* istanbul ignore next */
typeof Qv.default == "function" ? Qv.default : Qv;
var RAe = { lowerCaseAttributeNames: !1 };
function oc(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  return e === "" ? [] : (t = t || {}, uG(
    Qv(e, t.htmlparser2 || RAe),
    t
  ));
}
oc.domToReact = uG;
oc.htmlToDOM = Qv;
oc.attributesToProps = PAe;
oc.Comment = k_.Comment;
oc.Element = k_.Element;
oc.ProcessingInstruction = k_.ProcessingInstruction;
oc.Text = k_.Text;
var kAe = oc;
oc.default = oc;
const Zf = /* @__PURE__ */ Uf(kAe);
Zf.domToReact;
Zf.htmlToDOM;
Zf.attributesToProps;
Zf.Comment;
Zf.Element;
Zf.ProcessingInstruction;
Zf.Text;
/*! @license DOMPurify 3.0.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.3/LICENSE */
const {
  entries: cG,
  setPrototypeOf: HB,
  isFrozen: DAe,
  getPrototypeOf: $Ae,
  getOwnPropertyDescriptor: MAe
} = Object;
let {
  freeze: wi,
  seal: Ql,
  create: NAe
} = Object, {
  apply: k$,
  construct: D$
} = typeof Reflect < "u" && Reflect;
k$ || (k$ = function(t, n, r) {
  return t.apply(n, r);
});
wi || (wi = function(t) {
  return t;
});
Ql || (Ql = function(t) {
  return t;
});
D$ || (D$ = function(t, n) {
  return new t(...n);
});
const IAe = al(Array.prototype.forEach), WB = al(Array.prototype.pop), h0 = al(Array.prototype.push), cE = al(String.prototype.toLowerCase), yD = al(String.prototype.toString), AAe = al(String.prototype.match), Ll = al(String.prototype.replace), jAe = al(String.prototype.indexOf), LAe = al(String.prototype.trim), hs = al(RegExp.prototype.test), v0 = FAe(TypeError);
function al(e) {
  return function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      r[a - 1] = arguments[a];
    return k$(e, t, r);
  };
}
function FAe(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return D$(e, n);
  };
}
function $n(e, t, n) {
  var r;
  n = (r = n) !== null && r !== void 0 ? r : cE, HB && HB(e, null);
  let a = t.length;
  for (; a--; ) {
    let s = t[a];
    if (typeof s == "string") {
      const l = n(s);
      l !== s && (DAe(t) || (t[a] = l), s = l);
    }
    e[s] = !0;
  }
  return e;
}
function Lv(e) {
  const t = NAe(null);
  for (const [n, r] of cG(e))
    t[n] = r;
  return t;
}
function G1(e, t) {
  for (; e !== null; ) {
    const r = MAe(e, t);
    if (r) {
      if (r.get)
        return al(r.get);
      if (typeof r.value == "function")
        return al(r.value);
    }
    e = $Ae(e);
  }
  function n(r) {
    return console.warn("fallback value for", r), null;
  }
  return n;
}
const YB = wi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), gD = wi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), bD = wi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), zAe = wi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), wD = wi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), VAe = wi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), qB = wi(["#text"]), GB = wi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), xD = wi(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), KB = wi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), K1 = wi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), UAe = Ql(/\{\{[\w\W]*|[\w\W]*\}\}/gm), BAe = Ql(/<%[\w\W]*|[\w\W]*%>/gm), HAe = Ql(/\${[\w\W]*}/gm), WAe = Ql(/^data-[\-\w.\u00B7-\uFFFF]/), YAe = Ql(/^aria-[\-\w]+$/), dG = Ql(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), qAe = Ql(/^(?:\w+script|data):/i), GAe = Ql(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), fG = Ql(/^html$/i);
var XB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: UAe,
  ERB_EXPR: BAe,
  TMPLIT_EXPR: HAe,
  DATA_ATTR: WAe,
  ARIA_ATTR: YAe,
  IS_ALLOWED_URI: dG,
  IS_SCRIPT_OR_DATA: qAe,
  ATTR_WHITESPACE: GAe,
  DOCTYPE_NAME: fG
});
const KAe = () => typeof window > "u" ? null : window, XAe = function(t, n) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let r = null;
  const a = "data-tt-policy-suffix";
  n && n.hasAttribute(a) && (r = n.getAttribute(a));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return t.createPolicy(s, {
      createHTML(l) {
        return l;
      },
      createScriptURL(l) {
        return l;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function pG() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : KAe();
  const t = (nt) => pG(nt);
  if (t.version = "3.0.3", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return t.isSupported = !1, t;
  const n = e.document, r = n.currentScript;
  let {
    document: a
  } = e;
  const {
    DocumentFragment: s,
    HTMLTemplateElement: l,
    Node: p,
    Element: m,
    NodeFilter: h,
    NamedNodeMap: g = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: b,
    DOMParser: x,
    trustedTypes: E
  } = e, O = m.prototype, _ = G1(O, "cloneNode"), P = G1(O, "nextSibling"), M = G1(O, "childNodes"), D = G1(O, "parentNode");
  if (typeof l == "function") {
    const nt = a.createElement("template");
    nt.content && nt.content.ownerDocument && (a = nt.content.ownerDocument);
  }
  let N, I = "";
  const {
    implementation: R,
    createNodeIterator: j,
    createDocumentFragment: U,
    getElementsByTagName: q
  } = a, {
    importNode: J
  } = n;
  let H = {};
  t.isSupported = typeof cG == "function" && typeof D == "function" && R && R.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: Z,
    ERB_EXPR: re,
    TMPLIT_EXPR: Y,
    DATA_ATTR: K,
    ARIA_ATTR: Q,
    IS_SCRIPT_OR_DATA: te,
    ATTR_WHITESPACE: ne
  } = XB;
  let {
    IS_ALLOWED_URI: ae
  } = XB, se = null;
  const V = $n({}, [...YB, ...gD, ...bD, ...wD, ...qB]);
  let ee = null;
  const he = $n({}, [...GB, ...xD, ...KB, ...K1]);
  let ue = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), fe = null, Ce = null, Se = !0, Te = !0, pe = !1, ye = !0, Oe = !1, Fe = !1, me = !1, Pe = !1, Ee = !1, Ke = !1, oe = !1, de = !0, we = !1;
  const Me = "user-content-";
  let Ae = !0, je = !1, qe = {}, ot = null;
  const et = $n({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ct = null;
  const Qt = $n({}, ["audio", "video", "img", "source", "image", "track"]);
  let Ht = null;
  const kt = $n({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), St = "http://www.w3.org/1998/Math/MathML", cn = "http://www.w3.org/2000/svg", Ne = "http://www.w3.org/1999/xhtml";
  let Ie = Ne, Je = !1, pt = null;
  const ht = $n({}, [St, cn, Ne], yD);
  let vt;
  const Nt = ["application/xhtml+xml", "text/html"], Tn = "text/html";
  let bt, Pn = null;
  const wn = a.createElement("form"), Cn = function(ge) {
    return ge instanceof RegExp || ge instanceof Function;
  }, ar = function(ge) {
    if (!(Pn && Pn === ge)) {
      if ((!ge || typeof ge != "object") && (ge = {}), ge = Lv(ge), vt = // eslint-disable-next-line unicorn/prefer-includes
      Nt.indexOf(ge.PARSER_MEDIA_TYPE) === -1 ? vt = Tn : vt = ge.PARSER_MEDIA_TYPE, bt = vt === "application/xhtml+xml" ? yD : cE, se = "ALLOWED_TAGS" in ge ? $n({}, ge.ALLOWED_TAGS, bt) : V, ee = "ALLOWED_ATTR" in ge ? $n({}, ge.ALLOWED_ATTR, bt) : he, pt = "ALLOWED_NAMESPACES" in ge ? $n({}, ge.ALLOWED_NAMESPACES, yD) : ht, Ht = "ADD_URI_SAFE_ATTR" in ge ? $n(
        Lv(kt),
        // eslint-disable-line indent
        ge.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        bt
        // eslint-disable-line indent
      ) : kt, ct = "ADD_DATA_URI_TAGS" in ge ? $n(
        Lv(Qt),
        // eslint-disable-line indent
        ge.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        bt
        // eslint-disable-line indent
      ) : Qt, ot = "FORBID_CONTENTS" in ge ? $n({}, ge.FORBID_CONTENTS, bt) : et, fe = "FORBID_TAGS" in ge ? $n({}, ge.FORBID_TAGS, bt) : {}, Ce = "FORBID_ATTR" in ge ? $n({}, ge.FORBID_ATTR, bt) : {}, qe = "USE_PROFILES" in ge ? ge.USE_PROFILES : !1, Se = ge.ALLOW_ARIA_ATTR !== !1, Te = ge.ALLOW_DATA_ATTR !== !1, pe = ge.ALLOW_UNKNOWN_PROTOCOLS || !1, ye = ge.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Oe = ge.SAFE_FOR_TEMPLATES || !1, Fe = ge.WHOLE_DOCUMENT || !1, Ee = ge.RETURN_DOM || !1, Ke = ge.RETURN_DOM_FRAGMENT || !1, oe = ge.RETURN_TRUSTED_TYPE || !1, Pe = ge.FORCE_BODY || !1, de = ge.SANITIZE_DOM !== !1, we = ge.SANITIZE_NAMED_PROPS || !1, Ae = ge.KEEP_CONTENT !== !1, je = ge.IN_PLACE || !1, ae = ge.ALLOWED_URI_REGEXP || dG, Ie = ge.NAMESPACE || Ne, ue = ge.CUSTOM_ELEMENT_HANDLING || {}, ge.CUSTOM_ELEMENT_HANDLING && Cn(ge.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ue.tagNameCheck = ge.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ge.CUSTOM_ELEMENT_HANDLING && Cn(ge.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ue.attributeNameCheck = ge.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ge.CUSTOM_ELEMENT_HANDLING && typeof ge.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ue.allowCustomizedBuiltInElements = ge.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Oe && (Te = !1), Ke && (Ee = !0), qe && (se = $n({}, [...qB]), ee = [], qe.html === !0 && ($n(se, YB), $n(ee, GB)), qe.svg === !0 && ($n(se, gD), $n(ee, xD), $n(ee, K1)), qe.svgFilters === !0 && ($n(se, bD), $n(ee, xD), $n(ee, K1)), qe.mathMl === !0 && ($n(se, wD), $n(ee, KB), $n(ee, K1))), ge.ADD_TAGS && (se === V && (se = Lv(se)), $n(se, ge.ADD_TAGS, bt)), ge.ADD_ATTR && (ee === he && (ee = Lv(ee)), $n(ee, ge.ADD_ATTR, bt)), ge.ADD_URI_SAFE_ATTR && $n(Ht, ge.ADD_URI_SAFE_ATTR, bt), ge.FORBID_CONTENTS && (ot === et && (ot = Lv(ot)), $n(ot, ge.FORBID_CONTENTS, bt)), Ae && (se["#text"] = !0), Fe && $n(se, ["html", "head", "body"]), se.table && ($n(se, ["tbody"]), delete fe.tbody), ge.TRUSTED_TYPES_POLICY) {
        if (typeof ge.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw v0('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof ge.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw v0('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        N = ge.TRUSTED_TYPES_POLICY, I = N.createHTML("");
      } else
        N === void 0 && (N = XAe(E, r)), N !== null && typeof I == "string" && (I = N.createHTML(""));
      wi && wi(ge), Pn = ge;
    }
  }, ir = $n({}, ["mi", "mo", "mn", "ms", "mtext"]), go = $n({}, ["foreignobject", "desc", "title", "annotation-xml"]), Kr = $n({}, ["title", "style", "font", "a", "script"]), xr = $n({}, gD);
  $n(xr, bD), $n(xr, zAe);
  const Ln = $n({}, wD);
  $n(Ln, VAe);
  const Dn = function(ge) {
    let $e = D(ge);
    (!$e || !$e.tagName) && ($e = {
      namespaceURI: Ie,
      tagName: "template"
    });
    const dt = cE(ge.tagName), Ft = cE($e.tagName);
    return pt[ge.namespaceURI] ? ge.namespaceURI === cn ? $e.namespaceURI === Ne ? dt === "svg" : $e.namespaceURI === St ? dt === "svg" && (Ft === "annotation-xml" || ir[Ft]) : !!xr[dt] : ge.namespaceURI === St ? $e.namespaceURI === Ne ? dt === "math" : $e.namespaceURI === cn ? dt === "math" && go[Ft] : !!Ln[dt] : ge.namespaceURI === Ne ? $e.namespaceURI === cn && !go[Ft] || $e.namespaceURI === St && !ir[Ft] ? !1 : !Ln[dt] && (Kr[dt] || !xr[dt]) : !!(vt === "application/xhtml+xml" && pt[ge.namespaceURI]) : !1;
  }, Yn = function(ge) {
    h0(t.removed, {
      element: ge
    });
    try {
      ge.parentNode.removeChild(ge);
    } catch {
      ge.remove();
    }
  }, Jr = function(ge, $e) {
    try {
      h0(t.removed, {
        attribute: $e.getAttributeNode(ge),
        from: $e
      });
    } catch {
      h0(t.removed, {
        attribute: null,
        from: $e
      });
    }
    if ($e.removeAttribute(ge), ge === "is" && !ee[ge])
      if (Ee || Ke)
        try {
          Yn($e);
        } catch {
        }
      else
        try {
          $e.setAttribute(ge, "");
        } catch {
        }
  }, dr = function(ge) {
    let $e, dt;
    if (Pe)
      ge = "<remove></remove>" + ge;
    else {
      const er = AAe(ge, /^[\r\n\t ]+/);
      dt = er && er[0];
    }
    vt === "application/xhtml+xml" && Ie === Ne && (ge = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ge + "</body></html>");
    const Ft = N ? N.createHTML(ge) : ge;
    if (Ie === Ne)
      try {
        $e = new x().parseFromString(Ft, vt);
      } catch {
      }
    if (!$e || !$e.documentElement) {
      $e = R.createDocument(Ie, "template", null);
      try {
        $e.documentElement.innerHTML = Je ? I : Ft;
      } catch {
      }
    }
    const fn = $e.body || $e.documentElement;
    return ge && dt && fn.insertBefore(a.createTextNode(dt), fn.childNodes[0] || null), Ie === Ne ? q.call($e, Fe ? "html" : "body")[0] : Fe ? $e.documentElement : fn;
  }, Dr = function(ge) {
    return j.call(
      ge.ownerDocument || ge,
      ge,
      // eslint-disable-next-line no-bitwise
      h.SHOW_ELEMENT | h.SHOW_COMMENT | h.SHOW_TEXT,
      null,
      !1
    );
  }, Fr = function(ge) {
    return ge instanceof b && (typeof ge.nodeName != "string" || typeof ge.textContent != "string" || typeof ge.removeChild != "function" || !(ge.attributes instanceof g) || typeof ge.removeAttribute != "function" || typeof ge.setAttribute != "function" || typeof ge.namespaceURI != "string" || typeof ge.insertBefore != "function" || typeof ge.hasChildNodes != "function");
  }, zr = function(ge) {
    return typeof p == "object" ? ge instanceof p : ge && typeof ge == "object" && typeof ge.nodeType == "number" && typeof ge.nodeName == "string";
  }, Vr = function(ge, $e, dt) {
    H[ge] && IAe(H[ge], (Ft) => {
      Ft.call(t, $e, dt, Pn);
    });
  }, be = function(ge) {
    let $e;
    if (Vr("beforeSanitizeElements", ge, null), Fr(ge))
      return Yn(ge), !0;
    const dt = bt(ge.nodeName);
    if (Vr("uponSanitizeElement", ge, {
      tagName: dt,
      allowedTags: se
    }), ge.hasChildNodes() && !zr(ge.firstElementChild) && (!zr(ge.content) || !zr(ge.content.firstElementChild)) && hs(/<[/\w]/g, ge.innerHTML) && hs(/<[/\w]/g, ge.textContent))
      return Yn(ge), !0;
    if (!se[dt] || fe[dt]) {
      if (!fe[dt] && wt(dt) && (ue.tagNameCheck instanceof RegExp && hs(ue.tagNameCheck, dt) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(dt)))
        return !1;
      if (Ae && !ot[dt]) {
        const Ft = D(ge) || ge.parentNode, fn = M(ge) || ge.childNodes;
        if (fn && Ft) {
          const er = fn.length;
          for (let In = er - 1; In >= 0; --In)
            Ft.insertBefore(_(fn[In], !0), P(ge));
        }
      }
      return Yn(ge), !0;
    }
    return ge instanceof m && !Dn(ge) || (dt === "noscript" || dt === "noembed") && hs(/<\/no(script|embed)/i, ge.innerHTML) ? (Yn(ge), !0) : (Oe && ge.nodeType === 3 && ($e = ge.textContent, $e = Ll($e, Z, " "), $e = Ll($e, re, " "), $e = Ll($e, Y, " "), ge.textContent !== $e && (h0(t.removed, {
      element: ge.cloneNode()
    }), ge.textContent = $e)), Vr("afterSanitizeElements", ge, null), !1);
  }, at = function(ge, $e, dt) {
    if (de && ($e === "id" || $e === "name") && (dt in a || dt in wn))
      return !1;
    if (!(Te && !Ce[$e] && hs(K, $e))) {
      if (!(Se && hs(Q, $e))) {
        if (!ee[$e] || Ce[$e]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(wt(ge) && (ue.tagNameCheck instanceof RegExp && hs(ue.tagNameCheck, ge) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(ge)) && (ue.attributeNameCheck instanceof RegExp && hs(ue.attributeNameCheck, $e) || ue.attributeNameCheck instanceof Function && ue.attributeNameCheck($e)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            $e === "is" && ue.allowCustomizedBuiltInElements && (ue.tagNameCheck instanceof RegExp && hs(ue.tagNameCheck, dt) || ue.tagNameCheck instanceof Function && ue.tagNameCheck(dt)))
          )
            return !1;
        } else if (!Ht[$e]) {
          if (!hs(ae, Ll(dt, ne, ""))) {
            if (!(($e === "src" || $e === "xlink:href" || $e === "href") && ge !== "script" && jAe(dt, "data:") === 0 && ct[ge])) {
              if (!(pe && !hs(te, Ll(dt, ne, "")))) {
                if (dt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, wt = function(ge) {
    return ge.indexOf("-") > 0;
  }, Tt = function(ge) {
    let $e, dt, Ft, fn;
    Vr("beforeSanitizeAttributes", ge, null);
    const {
      attributes: er
    } = ge;
    if (!er)
      return;
    const In = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: ee
    };
    for (fn = er.length; fn--; ) {
      $e = er[fn];
      const {
        name: An,
        namespaceURI: _n
      } = $e;
      if (dt = An === "value" ? $e.value : LAe($e.value), Ft = bt(An), In.attrName = Ft, In.attrValue = dt, In.keepAttr = !0, In.forceKeepAttr = void 0, Vr("uponSanitizeAttribute", ge, In), dt = In.attrValue, In.forceKeepAttr || (Jr(An, ge), !In.keepAttr))
        continue;
      if (!ye && hs(/\/>/i, dt)) {
        Jr(An, ge);
        continue;
      }
      Oe && (dt = Ll(dt, Z, " "), dt = Ll(dt, re, " "), dt = Ll(dt, Y, " "));
      const rs = bt(ge.nodeName);
      if (at(rs, Ft, dt)) {
        if (we && (Ft === "id" || Ft === "name") && (Jr(An, ge), dt = Me + dt), N && typeof E == "object" && typeof E.getAttributeType == "function" && !_n)
          switch (E.getAttributeType(rs, Ft)) {
            case "TrustedHTML": {
              dt = N.createHTML(dt);
              break;
            }
            case "TrustedScriptURL": {
              dt = N.createScriptURL(dt);
              break;
            }
          }
        try {
          _n ? ge.setAttributeNS(_n, An, dt) : ge.setAttribute(An, dt), WB(t.removed);
        } catch {
        }
      }
    }
    Vr("afterSanitizeAttributes", ge, null);
  }, it = function nt(ge) {
    let $e;
    const dt = Dr(ge);
    for (Vr("beforeSanitizeShadowDOM", ge, null); $e = dt.nextNode(); )
      Vr("uponSanitizeShadowNode", $e, null), !be($e) && ($e.content instanceof s && nt($e.content), Tt($e));
    Vr("afterSanitizeShadowDOM", ge, null);
  };
  return t.sanitize = function(nt) {
    let ge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $e, dt, Ft, fn;
    if (Je = !nt, Je && (nt = "<!-->"), typeof nt != "string" && !zr(nt))
      if (typeof nt.toString == "function") {
        if (nt = nt.toString(), typeof nt != "string")
          throw v0("dirty is not a string, aborting");
      } else
        throw v0("toString is not a function");
    if (!t.isSupported)
      return nt;
    if (me || ar(ge), t.removed = [], typeof nt == "string" && (je = !1), je) {
      if (nt.nodeName) {
        const An = bt(nt.nodeName);
        if (!se[An] || fe[An])
          throw v0("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (nt instanceof p)
      $e = dr("<!---->"), dt = $e.ownerDocument.importNode(nt, !0), dt.nodeType === 1 && dt.nodeName === "BODY" || dt.nodeName === "HTML" ? $e = dt : $e.appendChild(dt);
    else {
      if (!Ee && !Oe && !Fe && // eslint-disable-next-line unicorn/prefer-includes
      nt.indexOf("<") === -1)
        return N && oe ? N.createHTML(nt) : nt;
      if ($e = dr(nt), !$e)
        return Ee ? null : oe ? I : "";
    }
    $e && Pe && Yn($e.firstChild);
    const er = Dr(je ? nt : $e);
    for (; Ft = er.nextNode(); )
      be(Ft) || (Ft.content instanceof s && it(Ft.content), Tt(Ft));
    if (je)
      return nt;
    if (Ee) {
      if (Ke)
        for (fn = U.call($e.ownerDocument); $e.firstChild; )
          fn.appendChild($e.firstChild);
      else
        fn = $e;
      return (ee.shadowroot || ee.shadowrootmod) && (fn = J.call(n, fn, !0)), fn;
    }
    let In = Fe ? $e.outerHTML : $e.innerHTML;
    return Fe && se["!doctype"] && $e.ownerDocument && $e.ownerDocument.doctype && $e.ownerDocument.doctype.name && hs(fG, $e.ownerDocument.doctype.name) && (In = "<!DOCTYPE " + $e.ownerDocument.doctype.name + `>
` + In), Oe && (In = Ll(In, Z, " "), In = Ll(In, re, " "), In = Ll(In, Y, " ")), N && oe ? N.createHTML(In) : In;
  }, t.setConfig = function(nt) {
    ar(nt), me = !0;
  }, t.clearConfig = function() {
    Pn = null, me = !1;
  }, t.isValidAttribute = function(nt, ge, $e) {
    Pn || ar({});
    const dt = bt(nt), Ft = bt(ge);
    return at(dt, Ft, $e);
  }, t.addHook = function(nt, ge) {
    typeof ge == "function" && (H[nt] = H[nt] || [], h0(H[nt], ge));
  }, t.removeHook = function(nt) {
    if (H[nt])
      return WB(H[nt]);
  }, t.removeHooks = function(nt) {
    H[nt] && (H[nt] = []);
  }, t.removeAllHooks = function() {
    H = {};
  }, t;
}
var QAe = pG();
const ZAe = yn((e, { rightBorder: t, rtl: n }) => ({
  field: {
    ...e.fn.fontStyles(),
    fontSize: e.fontSizes.sm,
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    textAlign: n ? "right" : "left",
    borderBottom: `1px solid ${e.colors.gray[4]}`
  },
  borderRight: {
    borderRight: t && `1px solid ${e.colors.gray[4]}`,
    "&:last-of-type": {
      borderRight: "none"
    }
  }
})), $$ = le.memo(({ loading: e, rightBorder: t, rtl: n, children: r, ...a }) => {
  const { classes: s, cx: l } = ZAe({ rightBorder: t, rtl: n });
  let p;
  return typeof r == "string" && sIe(r) && (p = Zf(QAe.sanitize(r))), /* @__PURE__ */ L.jsx("td", { className: l(s.field, t ? s.borderRight : null), ...a, children: /* @__PURE__ */ L.jsx(ZW, { visible: e, children: p || r }) });
});
$$.displayName = "Field";
function JAe({ relatedPath: e, ...t }) {
  const { path: n } = sa(), r = qi(
    n ? n.substring(0, n.lastIndexOf("/")) : "",
    e.substring(0, e.lastIndexOf("/"))
  );
  return /* @__PURE__ */ L.jsx(Fbe, { path: r, relation: t, children: /* @__PURE__ */ L.jsx(xG, { hideToolbar: !0 }) });
}
const e2e = le.memo(JAe);
function t2e({ item: e, info: t, loading: n, opened: r, onClose: a }) {
  return /* @__PURE__ */ L.jsxs(
    ky,
    {
      opened: r,
      onClose: a,
      title: `${e == null ? void 0 : e.show_title} (#${e == null ? void 0 : e.id})`,
      size: "lg",
      centered: !0,
      children: [
        /* @__PURE__ */ L.jsx(xM, { visible: n }),
        !n && e ? /* @__PURE__ */ L.jsxs(Vu, { defaultValue: "details", children: [
          /* @__PURE__ */ L.jsxs(Vu.List, { children: [
            /* @__PURE__ */ L.jsx(Vu.Tab, { value: "details", children: "Details" }),
            t.relations.map((s, l) => /* @__PURE__ */ L.jsx(Vu.Tab, { value: s.name, children: s.name }, l))
          ] }),
          /* @__PURE__ */ L.jsx(Vu.Panel, { pt: "xs", value: "details", children: /* @__PURE__ */ L.jsx(XE, { p: "xs", withBorder: !0, children: /* @__PURE__ */ L.jsx(mw, { spacing: "md", children: e.show_columns.map((s, l) => /* @__PURE__ */ L.jsxs(Bv, { children: [
            /* @__PURE__ */ L.jsx(Bv.Col, { span: 4, children: /* @__PURE__ */ L.jsx(Gi, { size: "md", sx: {}, children: e.label_columns[s] }) }),
            /* @__PURE__ */ L.jsx(Bv.Col, { span: 1, children: /* @__PURE__ */ L.jsx(Gi, { size: "xs", color: "dimmed", children: ":" }) }),
            /* @__PURE__ */ L.jsx(Bv.Col, { span: 4, children: /* @__PURE__ */ L.jsx(Gi, { size: "md", color: "dimmed", sx: {}, children: Aq(e.result, s) }) })
          ] }, l)) }) }) }),
          t.relations.map((s, l) => /* @__PURE__ */ L.jsx(Vu.Panel, { pt: "xs", value: s.name, children: /* @__PURE__ */ L.jsx(XE, { withBorder: !0, children: /* @__PURE__ */ L.jsx(
            e2e,
            {
              relatedPath: s.path,
              id: e.id,
              foreign_key: s.foreign_key,
              type: s.type
            }
          ) }) }, l))
        ] }) : null
      ]
    }
  );
}
function n2e({ id: e }) {
  const { info: t, getEntry: n } = sa(), [r, a] = C.useState(null), [s, l] = C.useState(!1), [p, m] = C.useState(!1);
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx($m, { label: "Details", children: /* @__PURE__ */ L.jsx(
      qs,
      {
        size: "sm",
        onClick: async () => {
          l(!0);
          const h = await n(e);
          h && (a(h), l(!1), m(!0));
        },
        children: /* @__PURE__ */ L.jsx(e0e, {})
      }
    ) }),
    /* @__PURE__ */ L.jsx(t2e, { item: r, info: t, loading: s, opened: p, onClose: () => m(!1) })
  ] });
}
function r2e({ item: e, info: t, opened: n, onClose: r }) {
  const { updateEntry: a } = sa(), { handleSubmit: s, reset: l, setValue: p, formState: m, control: h } = HM({
    mode: "onTouched",
    defaultValues: t.edit.defaultValues,
    resolver: WM(t.edit.schema)
  });
  C.useEffect(() => {
    if (e)
      for (const b of t.edit.columns)
        p(b.name, e.result[b.name]);
  }, [e, t.edit.columns, p]), m.dirtyFields;
  const g = async (b) => {
    b = jq(m.dirtyFields, b), await a(e.id, b), l(), r();
  };
  return e ? /* @__PURE__ */ L.jsx(
    ky,
    {
      opened: n,
      onClose: () => {
        r(), l();
      },
      title: `${t.edit.title}  (#${e == null ? void 0 : e.id})`,
      size: "lg",
      centered: !0,
      children: /* @__PURE__ */ L.jsxs(mw, { spacing: "md", children: [
        t.edit.columns.map((b) => /* @__PURE__ */ L.jsx(
          PN,
          {
            name: b.name,
            control: h,
            label: `${b.label}${b.required ? "*" : ""}`,
            description: b.description,
            schema: b
          },
          b.name
        )),
        /* @__PURE__ */ L.jsx(Gl, { position: "right", mt: "xl", children: /* @__PURE__ */ L.jsx(vy, { onClick: s(g), children: "Save" }) })
      ] })
    }
  ) : null;
}
function o2e({ id: e }) {
  const { info: t, getEntry: n } = sa(), [r, a] = C.useState(null), [s, l] = C.useState(!1), [p, m] = C.useState(!1);
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx($m, { label: "Edit", children: /* @__PURE__ */ L.jsx(
      qs,
      {
        size: "sm",
        onClick: async () => {
          l(!0);
          const h = await n(e);
          h && (a(h), l(!1), m(!0));
        },
        children: /* @__PURE__ */ L.jsx(r0e, {})
      }
    ) }),
    /* @__PURE__ */ L.jsx(r2e, { item: r, info: t, opened: p, onClose: () => m(!1) })
  ] });
}
function a2e({ opened: e, onClose: t, handleAccept: n, handleReject: r }) {
  return /* @__PURE__ */ L.jsxs(
    ky,
    {
      opened: e,
      onClose: t,
      "aria-labelledby": "alert-dialog-title",
      "aria-describedby": "alert-dialog-description",
      title: "Item löschen?",
      centered: !0,
      children: [
        "Sind Sie Sicher, dass Sie das Item löschen wollen?",
        /* @__PURE__ */ L.jsxs(Gl, { position: "right", mt: "xl", children: [
          /* @__PURE__ */ L.jsx(vy, { onClick: r, variant: "default", children: "Abbrechen" }),
          /* @__PURE__ */ L.jsx(vy, { onClick: n, color: "red", children: "Löschen" })
        ] })
      ]
    }
  );
}
function i2e({ id: e }) {
  const { deleteEntry: t } = sa(), [n, r] = C.useState(!1), a = () => {
    r(!1);
  }, s = async () => {
    t(e), r(!1);
  };
  return /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
    /* @__PURE__ */ L.jsx($m, { label: "Delete", children: /* @__PURE__ */ L.jsx(
      qs,
      {
        size: "sm",
        onClick: () => {
          r(!0);
        },
        children: /* @__PURE__ */ L.jsx(I8, {})
      }
    ) }),
    /* @__PURE__ */ L.jsx(a2e, { opened: n, onClose: a, handleAccept: s, handleReject: a })
  ] });
}
function s2e({ id: e, selected: t, rtl: n }) {
  const { info: r } = sa();
  return /* @__PURE__ */ L.jsxs(Gl, { sx: { gap: 4, justifyContent: n ? "flex-end" : void 0 }, spacing: 0, noWrap: !0, children: [
    r.permissions.includes("can_get") ? /* @__PURE__ */ L.jsx(n2e, { id: e }) : null,
    r.permissions.includes("can_put") ? /* @__PURE__ */ L.jsx(o2e, { id: e }) : null,
    r.permissions.includes("can_delete") ? /* @__PURE__ */ L.jsx(i2e, { id: e }) : null
  ] });
}
function l2e({
  settings: e,
  loading: t,
  onSelect: n,
  hideActions: r
}) {
  const { data: a } = sa(), [s, l] = C.useState(null);
  return /* @__PURE__ */ L.jsx("tbody", { children: a.result.length ? a.result.map((p, m) => {
    const h = a.ids[m];
    return /* @__PURE__ */ L.jsxs(
      tIe,
      {
        entry: { ...p, id: h },
        selected: (s == null ? void 0 : s.id) === h,
        hover: e.hover,
        setSelectedItem: l,
        onSelect: n,
        children: [
          r ? null : /* @__PURE__ */ L.jsx($$, { rtl: e.rtl, rightBorder: e.rightBorder, loading: t, children: /* @__PURE__ */ L.jsx(s2e, { id: a.ids[m], selected: (s == null ? void 0 : s.id) === h, rtl: e.rtl }) }),
          a.list_columns.map((g, b) => /* @__PURE__ */ L.jsx($$, { rtl: e.rtl, rightBorder: e.rightBorder, loading: t, children: Aq(p, g) }, b))
        ]
      },
      m
    );
  }) : /* @__PURE__ */ L.jsx("tr", { children: /* @__PURE__ */ L.jsx(
    "td",
    {
      style: { padding: "8px" },
      colSpan: r ? a.list_columns.length : a.list_columns.length + 1,
      children: /* @__PURE__ */ L.jsx(Gi, { sx: { fontStyle: "italic" }, size: "sm", color: "dimmed", children: "No data available..." })
    }
  ) }) });
}
function u2e({
  settings: e,
  hideActions: t,
  loading: n,
  onSelect: r
}) {
  const a = Da();
  return /* @__PURE__ */ L.jsx(
    Nq,
    {
      options: { className: a.colorScheme === "dark" ? "os-theme-light" : void 0 },
      style: { flex: 1, flexDirection: "column" },
      children: /* @__PURE__ */ L.jsxs(
        s8,
        {
          verticalSpacing: e.dense ? "xs" : "md",
          horizontalSpacing: e.dense ? "xs" : "md",
          fontSize: e.dense ? "sm" : "md",
          striped: e.striped,
          highlightOnHover: !!r,
          children: [
            /* @__PURE__ */ L.jsx(Iq, { settings: e, hideActions: t }),
            /* @__PURE__ */ L.jsx(l2e, { settings: e, loading: n, onSelect: r, hideActions: t })
          ]
        }
      )
    }
  );
}
const QB = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage"), ZB = Cs(/* @__PURE__ */ L.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage"), mG = /* @__PURE__ */ C.createContext();
process.env.NODE_ENV !== "production" && (mG.displayName = "TableContext");
const c2e = mG, hG = /* @__PURE__ */ C.createContext();
process.env.NODE_ENV !== "production" && (hG.displayName = "Tablelvl2Context");
const d2e = hG;
function f2e(e) {
  return Xt("MuiTableCell", e);
}
const p2e = Bt("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), m2e = p2e, h2e = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"], v2e = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: a,
    size: s,
    stickyHeader: l
  } = e, p = {
    root: ["root", n, l && "stickyHeader", r !== "inherit" && `align${xt(r)}`, a !== "normal" && `padding${xt(a)}`, `size${xt(s)}`]
  };
  return Kt(p, f2e, t);
}, y2e = Ge("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${xt(n.size)}`], n.padding !== "normal" && t[`padding${xt(n.padding)}`], n.align !== "inherit" && t[`align${xt(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(({
  theme: e,
  ownerState: t
}) => B({}, e.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? Y3(Wn(e.palette.divider, 1), 0.88) : W3(Wn(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, t.variant === "head" && {
  color: (e.vars || e).palette.text.primary,
  lineHeight: e.typography.pxToRem(24),
  fontWeight: e.typography.fontWeightMedium
}, t.variant === "body" && {
  color: (e.vars || e).palette.text.primary
}, t.variant === "footer" && {
  color: (e.vars || e).palette.text.secondary,
  lineHeight: e.typography.pxToRem(21),
  fontSize: e.typography.pxToRem(12)
}, t.size === "small" && {
  padding: "6px 16px",
  [`&.${m2e.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, t.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, t.padding === "none" && {
  padding: 0
}, t.align === "left" && {
  textAlign: "left"
}, t.align === "center" && {
  textAlign: "center"
}, t.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, t.align === "justify" && {
  textAlign: "justify"
}, t.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (e.vars || e).palette.background.default
})), vG = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTableCell"
  }), {
    align: a = "inherit",
    className: s,
    component: l,
    padding: p,
    scope: m,
    size: h,
    sortDirection: g,
    variant: b
  } = r, x = st(r, h2e), E = C.useContext(c2e), O = C.useContext(d2e), _ = O && O.variant === "head";
  let P;
  l ? P = l : P = _ ? "th" : "td";
  let M = m;
  P === "td" ? M = void 0 : !M && _ && (M = "col");
  const D = b || O && O.variant, N = B({}, r, {
    align: a,
    component: P,
    padding: p || (E && E.padding ? E.padding : "normal"),
    size: h || (E && E.size ? E.size : "medium"),
    sortDirection: g,
    stickyHeader: D === "head" && E && E.stickyHeader,
    variant: D
  }), I = v2e(N);
  let R = null;
  return g && (R = g === "asc" ? "ascending" : "descending"), /* @__PURE__ */ L.jsx(y2e, B({
    as: P,
    ref: n,
    className: Wt(I.root, s),
    "aria-sort": R,
    scope: M,
    ownerState: N
  }, x));
});
process.env.NODE_ENV !== "production" && (vG.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the table cell content.
   *
   * Monetary or generally number fields **should be right aligned** as that allows
   * you to add them up quickly in your head without having to worry about decimals.
   * @default 'inherit'
   */
  align: c.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * Sets the padding applied to the cell.
   * The prop defaults to the value (`'default'`) inherited from the parent Table component.
   */
  padding: c.oneOf(["checkbox", "none", "normal"]),
  /**
   * Set scope attribute.
   */
  scope: c.string,
  /**
   * Specify the size of the cell.
   * The prop defaults to the value (`'medium'`) inherited from the parent Table component.
   */
  size: c.oneOfType([c.oneOf(["medium", "small"]), c.string]),
  /**
   * Set aria-sort direction.
   */
  sortDirection: c.oneOf(["asc", "desc", !1]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * Specify the cell type.
   * The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components.
   */
  variant: c.oneOfType([c.oneOf(["body", "footer", "head"]), c.string])
});
const M$ = vG;
function g2e(e) {
  return Xt("MuiToolbar", e);
}
Bt("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const b2e = ["className", "component", "disableGutters", "variant"], w2e = (e) => {
  const {
    classes: t,
    disableGutters: n,
    variant: r
  } = e;
  return Kt({
    root: ["root", !n && "gutters", r]
  }, g2e, t);
}, x2e = Ge("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disableGutters && t.gutters, t[n.variant]];
  }
})(({
  theme: e,
  ownerState: t
}) => B({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !t.disableGutters && {
  paddingLeft: e.spacing(2),
  paddingRight: e.spacing(2),
  [e.breakpoints.up("sm")]: {
    paddingLeft: e.spacing(3),
    paddingRight: e.spacing(3)
  }
}, t.variant === "dense" && {
  minHeight: 48
}), ({
  theme: e,
  ownerState: t
}) => t.variant === "regular" && e.mixins.toolbar), yG = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiToolbar"
  }), {
    className: a,
    component: s = "div",
    disableGutters: l = !1,
    variant: p = "regular"
  } = r, m = st(r, b2e), h = B({}, r, {
    component: s,
    disableGutters: l,
    variant: p
  }), g = w2e(h);
  return /* @__PURE__ */ L.jsx(x2e, B({
    as: s,
    className: Wt(g.root, a),
    ref: n,
    ownerState: h
  }, m));
});
process.env.NODE_ENV !== "production" && (yG.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The Toolbar children, usually a mixture of `IconButton`, `Button` and `Typography`.
   * The Toolbar is a flex container, allowing flex item properties to be used to lay out the children.
   */
  children: c.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * If `true`, disables gutter padding.
   * @default false
   */
  disableGutters: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object]),
  /**
   * The variant to use.
   * @default 'regular'
   */
  variant: c.oneOfType([c.oneOf(["dense", "regular"]), c.string])
});
const S2e = yG;
var JB, e3, t3, n3, r3, o3, a3, i3;
const E2e = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"], gG = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const {
    backIconButtonProps: r,
    count: a,
    getItemAriaLabel: s,
    nextIconButtonProps: l,
    onPageChange: p,
    page: m,
    rowsPerPage: h,
    showFirstButton: g,
    showLastButton: b
  } = t, x = st(t, E2e), E = Ji(), O = (D) => {
    p(D, 0);
  }, _ = (D) => {
    p(D, m - 1);
  }, P = (D) => {
    p(D, m + 1);
  }, M = (D) => {
    p(D, Math.max(0, Math.ceil(a / h) - 1));
  };
  return /* @__PURE__ */ L.jsxs("div", B({
    ref: n
  }, x, {
    children: [g && /* @__PURE__ */ L.jsx(Jc, {
      onClick: O,
      disabled: m === 0,
      "aria-label": s("first", m),
      title: s("first", m),
      children: E.direction === "rtl" ? JB || (JB = /* @__PURE__ */ L.jsx(ZB, {})) : e3 || (e3 = /* @__PURE__ */ L.jsx(QB, {}))
    }), /* @__PURE__ */ L.jsx(Jc, B({
      onClick: _,
      disabled: m === 0,
      color: "inherit",
      "aria-label": s("previous", m),
      title: s("previous", m)
    }, r, {
      children: E.direction === "rtl" ? t3 || (t3 = /* @__PURE__ */ L.jsx(b$, {})) : n3 || (n3 = /* @__PURE__ */ L.jsx(g$, {}))
    })), /* @__PURE__ */ L.jsx(Jc, B({
      onClick: P,
      disabled: a !== -1 ? m >= Math.ceil(a / h) - 1 : !1,
      color: "inherit",
      "aria-label": s("next", m),
      title: s("next", m)
    }, l, {
      children: E.direction === "rtl" ? r3 || (r3 = /* @__PURE__ */ L.jsx(g$, {})) : o3 || (o3 = /* @__PURE__ */ L.jsx(b$, {}))
    })), b && /* @__PURE__ */ L.jsx(Jc, {
      onClick: M,
      disabled: m >= Math.ceil(a / h) - 1,
      "aria-label": s("last", m),
      title: s("last", m),
      children: E.direction === "rtl" ? a3 || (a3 = /* @__PURE__ */ L.jsx(QB, {})) : i3 || (i3 = /* @__PURE__ */ L.jsx(ZB, {}))
    })]
  }));
});
process.env.NODE_ENV !== "production" && (gG.propTypes = {
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  backIconButtonProps: c.object,
  /**
   * The total number of rows.
   */
  count: c.number.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   *
   * @param {string} type The link or button type to format ('page' | 'first' | 'last' | 'next' | 'previous'). Defaults to 'page'.
   * @param {number} page The page number to format.
   * @returns {string}
   */
  getItemAriaLabel: c.func.isRequired,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: c.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {object} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: c.func.isRequired,
  /**
   * The zero-based index of the current page.
   */
  page: c.number.isRequired,
  /**
   * The number of rows per page.
   */
  rowsPerPage: c.number.isRequired,
  /**
   * If `true`, show the first-page button.
   */
  showFirstButton: c.bool.isRequired,
  /**
   * If `true`, show the last-page button.
   */
  showLastButton: c.bool.isRequired
});
const C2e = gG;
function T2e(e) {
  return Xt("MuiTablePagination", e);
}
const _2e = Bt("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]), L0 = _2e;
var s3;
const O2e = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"], P2e = Ge(M$, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  overflow: "auto",
  color: (e.vars || e).palette.text.primary,
  fontSize: e.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
})), R2e = Ge(S2e, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (e, t) => B({
    [`& .${L0.actions}`]: t.actions
  }, t.toolbar)
})(({
  theme: e
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${e.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [e.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${L0.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
})), k2e = Ge("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (e, t) => t.spacer
})({
  flex: "1 1 100%"
}), D2e = Ge("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (e, t) => t.selectLabel
})(({
  theme: e
}) => B({}, e.typography.body2, {
  flexShrink: 0
})), $2e = Ge(RY, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (e, t) => B({
    [`& .${L0.selectIcon}`]: t.selectIcon,
    [`& .${L0.select}`]: t.select
  }, t.input, t.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${L0.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
}), M2e = Ge(KY, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (e, t) => t.menuItem
})({}), N2e = Ge("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (e, t) => t.displayedRows
})(({
  theme: e
}) => B({}, e.typography.body2, {
  flexShrink: 0
}));
function I2e({
  from: e,
  to: t,
  count: n
}) {
  return `${e}–${t} of ${n !== -1 ? n : `more than ${t}`}`;
}
function A2e(e) {
  return `Go to ${e} page`;
}
const j2e = (e) => {
  const {
    classes: t
  } = e;
  return Kt({
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  }, T2e, t);
}, bG = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = Lt({
    props: t,
    name: "MuiTablePagination"
  }), {
    ActionsComponent: a = C2e,
    backIconButtonProps: s,
    className: l,
    colSpan: p,
    component: m = M$,
    count: h,
    getItemAriaLabel: g = A2e,
    labelDisplayedRows: b = I2e,
    labelRowsPerPage: x = "Rows per page:",
    nextIconButtonProps: E,
    onPageChange: O,
    onRowsPerPageChange: _,
    page: P,
    rowsPerPage: M,
    rowsPerPageOptions: D = [10, 25, 50, 100],
    SelectProps: N = {},
    showFirstButton: I = !1,
    showLastButton: R = !1
  } = r, j = st(r, O2e), U = r, q = j2e(U), J = N.native ? "option" : M2e;
  let H;
  (m === M$ || m === "td") && (H = p || 1e3);
  const Z = uy(N.id), re = uy(N.labelId), Y = () => h === -1 ? (P + 1) * M : M === -1 ? h : Math.min(h, (P + 1) * M);
  return /* @__PURE__ */ L.jsx(P2e, B({
    colSpan: H,
    ref: n,
    as: m,
    ownerState: U,
    className: Wt(q.root, l)
  }, j, {
    children: /* @__PURE__ */ L.jsxs(R2e, {
      className: q.toolbar,
      children: [/* @__PURE__ */ L.jsx(k2e, {
        className: q.spacer
      }), D.length > 1 && /* @__PURE__ */ L.jsx(D2e, {
        className: q.selectLabel,
        id: re,
        children: x
      }), D.length > 1 && /* @__PURE__ */ L.jsx($2e, B({
        variant: "standard"
      }, !N.variant && {
        input: s3 || (s3 = /* @__PURE__ */ L.jsx(y_, {}))
      }, {
        value: M,
        onChange: _,
        id: Z,
        labelId: re
      }, N, {
        classes: B({}, N.classes, {
          // TODO v5 remove `classes.input`
          root: Wt(q.input, q.selectRoot, (N.classes || {}).root),
          select: Wt(q.select, (N.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: Wt(q.selectIcon, (N.classes || {}).icon)
        }),
        children: D.map((K) => /* @__PURE__ */ C.createElement(J, B({}, !zf(J) && {
          ownerState: U
        }, {
          className: q.menuItem,
          key: K.label ? K.label : K,
          value: K.value ? K.value : K
        }), K.label ? K.label : K))
      })), /* @__PURE__ */ L.jsx(N2e, {
        className: q.displayedRows,
        children: b({
          from: h === 0 ? 0 : P * M + 1,
          to: Y(),
          count: h === -1 ? -1 : h,
          page: P
        })
      }), /* @__PURE__ */ L.jsx(a, {
        className: q.actions,
        backIconButtonProps: s,
        count: h,
        nextIconButtonProps: E,
        onPageChange: O,
        page: P,
        rowsPerPage: M,
        showFirstButton: I,
        showLastButton: R,
        getItemAriaLabel: g
      })]
    })
  }));
});
process.env.NODE_ENV !== "production" && (bG.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The component used for displaying the actions.
   * Either a string to use a HTML element or a component.
   * @default TablePaginationActions
   */
  ActionsComponent: c.elementType,
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) component.
   */
  backIconButtonProps: c.object,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: c.object,
  /**
   * @ignore
   */
  className: c.string,
  /**
   * @ignore
   */
  colSpan: c.number,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: c.elementType,
  /**
   * The total number of rows.
   *
   * To enable server side pagination for an unknown number of items, provide -1.
   */
  count: C0.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   * This is important for screen reader users.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @param {string} type The link or button type to format ('first' | 'last' | 'next' | 'previous').
   * @returns {string}
   * @default function defaultGetAriaLabel(type) {
   *   return `Go to ${type} page`;
   * }
   */
  getItemAriaLabel: c.func,
  /**
   * Customize the displayed rows label. Invoked with a `{ from, to, count, page }`
   * object.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default function defaultLabelDisplayedRows({ from, to, count }) {
   *   return `${from}–${to} of ${count !== -1 ? count : `more than ${to}`}`;
   * }
   */
  labelDisplayedRows: c.func,
  /**
   * Customize the rows per page label.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default 'Rows per page:'
   */
  labelRowsPerPage: c.node,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: c.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {React.MouseEvent<HTMLButtonElement> | null} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: c.func.isRequired,
  /**
   * Callback fired when the number of rows per page is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   */
  onRowsPerPageChange: c.func,
  /**
   * The zero-based index of the current page.
   */
  page: cd(C0.isRequired, (e) => {
    const {
      count: t,
      page: n,
      rowsPerPage: r
    } = e;
    if (t === -1)
      return null;
    const a = Math.max(0, Math.ceil(t / r) - 1);
    return n < 0 || n > a ? new Error(`MUI: The page prop of a TablePagination is out of range (0 to ${a}, but page is ${n}).`) : null;
  }),
  /**
   * The number of rows per page.
   *
   * Set -1 to display all the rows.
   */
  rowsPerPage: C0.isRequired,
  /**
   * Customizes the options of the rows per page select field. If less than two options are
   * available, no select field will be displayed.
   * Use -1 for the value with a custom label to show all the rows.
   * @default [10, 25, 50, 100]
   */
  rowsPerPageOptions: c.arrayOf(c.oneOfType([c.number, c.shape({
    label: c.string.isRequired,
    value: c.number.isRequired
  })]).isRequired),
  /**
   * Props applied to the rows per page [`Select`](/material-ui/api/select/) element.
   * @default {}
   */
  SelectProps: c.object,
  /**
   * If `true`, show the first-page button.
   * @default false
   */
  showFirstButton: c.bool,
  /**
   * If `true`, show the last-page button.
   * @default false
   */
  showLastButton: c.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: c.oneOfType([c.arrayOf(c.oneOfType([c.func, c.object, c.bool])), c.func, c.object])
});
const L2e = bG;
function F2e(e) {
  const { count: t, page: n, rowsPerPage: r, onPageChange: a } = e, s = (h) => {
    a(h, 0);
  }, l = (h) => {
    a(h, n - 1);
  }, p = (h) => {
    a(h, n + 1);
  }, m = (h) => {
    a(h, Math.max(0, Math.ceil(t / r) - 1));
  };
  return /* @__PURE__ */ L.jsxs(Gl, { ml: "sm", noWrap: !0, children: [
    /* @__PURE__ */ L.jsx(qs, { onClick: s, disabled: n === 0, "aria-label": "first page", children: /* @__PURE__ */ L.jsx(Kbe, {}) }),
    /* @__PURE__ */ L.jsx(qs, { onClick: l, disabled: n === 0, "aria-label": "previous page", children: /* @__PURE__ */ L.jsx(Qbe, {}) }),
    /* @__PURE__ */ L.jsx(
      qs,
      {
        onClick: p,
        disabled: n >= Math.ceil(t / r) - 1,
        "aria-label": "next page",
        children: /* @__PURE__ */ L.jsx(Zbe, {})
      }
    ),
    /* @__PURE__ */ L.jsx(
      qs,
      {
        onClick: m,
        disabled: n >= Math.ceil(t / r) - 1,
        "aria-label": "last page",
        children: /* @__PURE__ */ L.jsx(Xbe, {})
      }
    )
  ] });
}
const wG = le.memo(({ ...e }) => {
  const { data: t, queryParams: n, setQueryParams: r } = sa(), a = [10, 25, 50], s = n.page_size, [l, p] = C.useState(n.page), m = C.useMemo(
    () => ly((b) => {
      r({ page: b });
    }, 550),
    [r]
  );
  C.useEffect(() => {
    p(n.page);
  }, [n.page]);
  const h = (b, x) => {
    p(x), m(x);
  }, g = (b) => {
    r({ page_size: parseInt(b.target.value, 10) });
  };
  return /* @__PURE__ */ L.jsx(
    hn,
    {
      sx: (b) => ({
        flex: "0 1 0",
        height: 54,
        border: "none",
        borderTopWidth: "1px",
        borderTopStyle: "solid",
        borderColor: b.colors.gray[4]
      }),
      children: /* @__PURE__ */ L.jsx(
        L2e,
        {
          sx: {
            color: "inherit",
            "& .MuiSvgIcon-root": {
              color: "inherit"
            }
          },
          rowsPerPageOptions: a,
          component: "div",
          count: t.count,
          rowsPerPage: s,
          page: l,
          onPageChange: h,
          onRowsPerPageChange: g,
          ActionsComponent: F2e,
          ...e
        }
      )
    }
  );
});
wG.displayName = "Pagination";
function z2e() {
  const { error: e } = sa(), [t, n] = C.useState(!1);
  return C.useEffect(() => {
    e && n(!0);
  }, [e]), /* @__PURE__ */ L.jsx(
    ky,
    {
      opened: t,
      onClose: () => n(!1),
      title: /* @__PURE__ */ L.jsxs(Gl, { children: [
        /* @__PURE__ */ L.jsx(qbe, { size: 16, color: "red" }),
        /* @__PURE__ */ L.jsx(Gi, { children: e ? e.originalError.message : "Error" })
      ] }),
      centered: !0,
      children: e ? /* @__PURE__ */ L.jsx(Gi, { children: e.message }) : null
    }
  );
}
const hje = {
  root: "Root element",
  toolbar: "Main control",
  body: "Track element, contains all other elements",
  pagination: "Filled part of the track",
  header: "DataGrid header, contains titles"
}, V2e = yn(() => ({
  root: {},
  toolbar: {
    display: "flex",
    boxSizing: "border-box"
  },
  body: {
    flex: 1,
    width: "100vw",
    boxSizing: "border-box"
  },
  pagination: {
    flex: 1,
    width: "100vw",
    boxSizing: "border-box"
  }
})), U2e = {
  settings: {
    rtl: !1,
    dense: !1,
    striped: !1,
    rightBorder: !1,
    hover: !1
  }
};
function B2e(e, t) {
  switch (t.type) {
    case "setSettings":
      return { ...e, settings: t.payload };
    default:
      throw new Error();
  }
}
const xG = C.forwardRef((e, t) => {
  const { path: n, data: r, loading: a, info: s, setQueryParams: l } = sa(), {
    hideToolbar: p = !1,
    hideFilter: m = !1,
    hideSettings: h = !1,
    hideActions: g = !1,
    settings: b = null,
    sx: x = null,
    onSelectEntry: E = null,
    fetchOnMount: O = !0,
    styles: _
  } = e, P = `${n}-datagrid`, { classes: M, cx: D, theme: N } = V2e(), [I, R] = C.useReducer(B2e, {
    ...U2e,
    settings: JSON.parse(localStorage.getItem(P)) || {
      rtl: (b == null ? void 0 : b.rtl) ?? !1,
      dense: (b == null ? void 0 : b.dense) ?? !1,
      striped: (b == null ? void 0 : b.striped) ?? !1,
      rightBorder: (b == null ? void 0 : b.rightBorder) ?? !1,
      hover: (b == null ? void 0 : b.hover) ?? !1
    }
  });
  return C.useEffect(() => {
    !r && O && l({});
  }, [r]), C.useEffect(() => {
    I.settings && localStorage.setItem(P, JSON.stringify(I.settings));
  }, [I.settings]), /* @__PURE__ */ L.jsxs(
    XE,
    {
      ref: t,
      className: M.root,
      sx: { position: "relative", height: "100%", display: "flex", flexDirection: "column", ...x },
      children: [
        /* @__PURE__ */ L.jsx(
          xM,
          {
            loaderProps: { size: "sm", variant: "dots" },
            overlayOpacity: 0.1,
            overlayColor: "#c5c5c5",
            visible: a
          }
        ),
        s && r && !a && /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
          p ? null : /* @__PURE__ */ L.jsx(
            aq,
            {
              settings: I.settings,
              dispatch: R,
              hideFilter: m,
              hideSettings: h,
              dense: I.settings.dense
            }
          ),
          /* @__PURE__ */ L.jsx(u2e, { settings: I.settings, hideActions: g, loading: a, onSelect: E }),
          /* @__PURE__ */ L.jsx(wG, {})
        ] }),
        /* @__PURE__ */ L.jsx(z2e, {})
      ]
    }
  );
});
xG.displayName = "DataGrid";
function vje({ name: e, ...t }) {
  const { info: n, queryParams: r, setQueryParams: a } = sa(), [s, l] = C.useState(), [p, m] = C.useState();
  return C.useEffect(() => {
    if (n) {
      const h = n.quickfilters.find((g) => g.name === e);
      l(h);
    }
  }, [n]), C.useEffect(() => {
    var h;
    if (r) {
      const g = (h = r == null ? void 0 : r.filters) == null ? void 0 : h.find(
        (b) => b.col === s.column && b.opr === "in"
      );
      m(g);
    }
  }, [r]), s ? /* @__PURE__ */ L.jsx(
    rC.Group,
    {
      value: p && typeof p.value == "string" ? JSON.parse(p.value) : [],
      label: s.label,
      onChange: (h) => {
        var b;
        const g = (b = r.filters) == null ? void 0 : b.filter((x) => x !== p);
        a({
          ...r,
          filters: [...g, { col: s.column, opr: "in", value: JSON.stringify(h) }]
        });
      },
      ...t,
      children: s.options.map((h) => /* @__PURE__ */ L.jsx(rC, { value: h.value, label: h.label }, h.value))
    }
  ) : null;
}
function yje({ name: e, ...t }) {
  const { info: n, queryParams: r, setQueryParams: a } = sa(), [s, l] = C.useState(), [p, m] = C.useState();
  return C.useEffect(() => {
    if (n) {
      const h = n.quickfilters.find((g) => g.name === e);
      l(h);
    }
  }, [n]), C.useEffect(() => {
    var h;
    if (r) {
      const g = (h = r == null ? void 0 : r.filters) == null ? void 0 : h.find(
        (b) => b.col === s.column && b.opr === "in"
      );
      m(g);
    }
  }, [r]), s ? /* @__PURE__ */ L.jsx(
    BT,
    {
      value: p && typeof p.value == "string" ? JSON.parse(p.value) : [],
      label: s.label,
      onChange: (h) => {
        var b;
        const g = (b = r.filters) == null ? void 0 : b.filter((x) => x !== p);
        a({
          ...r,
          filters: [...g, { col: s.column, opr: "in", value: JSON.stringify(h) }]
        });
      },
      ...t,
      data: s.options
    }
  ) : null;
}
function gje({ name: e, ...t }) {
  const { info: n, queryParams: r, setQueryParams: a } = sa(), [s, l] = C.useState(), [p, m] = C.useState();
  return C.useEffect(() => {
    if (n) {
      const h = n.quickfilters.find((g) => g.name === e);
      l(h);
    }
  }, [n]), C.useEffect(() => {
    var h;
    if (r) {
      const g = (h = r == null ? void 0 : r.filters) == null ? void 0 : h.find(
        (b) => b.col === s.column && b.opr === "eq"
      );
      m(g);
    }
  }, [r]), s ? /* @__PURE__ */ L.jsx(
    Dy,
    {
      value: p && typeof p.value == "string" ? p.value : [],
      label: s.label,
      onChange: (h) => {
        var b;
        const g = (b = r.filters) == null ? void 0 : b.filter((x) => x !== p);
        a({
          ...r,
          filters: [...g, { col: s.column, opr: "eq", value: h }]
        });
      },
      ...t,
      data: s.options
    }
  ) : null;
}
/**
 * @remix-run/router v1.6.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function N$() {
  return N$ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, N$.apply(this, arguments);
}
var l3;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})(l3 || (l3 = {}));
function xs(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function SG(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function EG(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e);
  }
  return t;
}
var u3;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(u3 || (u3 = {}));
function H2e(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: a = ""
  } = typeof e == "string" ? EG(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : W2e(n, t) : t,
    search: K2e(r),
    hash: X2e(a)
  };
}
function W2e(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((a) => {
    a === ".." ? n.length > 1 && n.pop() : a !== "." && n.push(a);
  }), n.length > 1 ? n.join("/") : "/";
}
function SD(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function Y2e(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0);
}
function q2e(e, t, n, r) {
  r === void 0 && (r = !1);
  let a;
  typeof e == "string" ? a = EG(e) : (a = N$({}, e), xs(!a.pathname || !a.pathname.includes("?"), SD("?", "pathname", "search", a)), xs(!a.pathname || !a.pathname.includes("#"), SD("#", "pathname", "hash", a)), xs(!a.search || !a.search.includes("#"), SD("#", "search", "hash", a)));
  let s = e === "" || a.pathname === "", l = s ? "/" : a.pathname, p;
  if (r || l == null)
    p = n;
  else {
    let b = t.length - 1;
    if (l.startsWith("..")) {
      let x = l.split("/");
      for (; x[0] === ".."; )
        x.shift(), b -= 1;
      a.pathname = x.join("/");
    }
    p = b >= 0 ? t[b] : "/";
  }
  let m = H2e(a, p), h = l && l !== "/" && l.endsWith("/"), g = (s || l === ".") && n.endsWith("/");
  return !m.pathname.endsWith("/") && (h || g) && (m.pathname += "/"), m;
}
const G2e = (e) => e.join("/").replace(/\/\/+/g, "/"), K2e = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, X2e = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, CG = ["post", "put", "patch", "delete"];
new Set(CG);
const Q2e = ["get", ...CG];
new Set(Q2e);
/**
 * React Router v6.12.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function I$() {
  return I$ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, I$.apply(this, arguments);
}
const eI = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (eI.displayName = "DataRouter");
const Z2e = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (Z2e.displayName = "DataRouterState");
const J2e = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (J2e.displayName = "Await");
const tI = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (tI.displayName = "Navigation");
const nI = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (nI.displayName = "Location");
const D_ = /* @__PURE__ */ C.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (D_.displayName = "Route");
const eje = /* @__PURE__ */ C.createContext(null);
process.env.NODE_ENV !== "production" && (eje.displayName = "RouteError");
function TG() {
  return C.useContext(nI) != null;
}
function tje() {
  return TG() || (process.env.NODE_ENV !== "production" ? xs(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : xs(!1)), C.useContext(nI).location;
}
const _G = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function OG(e) {
  C.useContext(tI).static || C.useLayoutEffect(e);
}
function nje() {
  let {
    isDataRoute: e
  } = C.useContext(D_);
  return e ? sje() : rje();
}
function rje() {
  TG() || (process.env.NODE_ENV !== "production" ? xs(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : xs(!1));
  let e = C.useContext(eI), {
    basename: t,
    navigator: n
  } = C.useContext(tI), {
    matches: r
  } = C.useContext(D_), {
    pathname: a
  } = tje(), s = JSON.stringify(Y2e(r).map((m) => m.pathnameBase)), l = C.useRef(!1);
  return OG(() => {
    l.current = !0;
  }), C.useCallback(function(m, h) {
    if (h === void 0 && (h = {}), process.env.NODE_ENV !== "production" && SG(l.current, _G), !l.current)
      return;
    if (typeof m == "number") {
      n.go(m);
      return;
    }
    let g = q2e(m, JSON.parse(s), a, h.relative === "path");
    e == null && t !== "/" && (g.pathname = g.pathname === "/" ? t : G2e([t, g.pathname])), (h.replace ? n.replace : n.push)(g, h.state, h);
  }, [t, n, s, a, e]);
}
var A$;
(function(e) {
  e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate";
})(A$ || (A$ = {}));
var j$;
(function(e) {
  e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId";
})(j$ || (j$ = {}));
function PG(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function oje(e) {
  let t = C.useContext(eI);
  return t || (process.env.NODE_ENV !== "production" ? xs(!1, PG(e)) : xs(!1)), t;
}
function aje(e) {
  let t = C.useContext(D_);
  return t || (process.env.NODE_ENV !== "production" ? xs(!1, PG(e)) : xs(!1)), t;
}
function ije(e) {
  let t = aje(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (process.env.NODE_ENV !== "production" ? xs(!1, e + ' can only be used on routes that contain a unique "id"') : xs(!1)), n.route.id;
}
function sje() {
  let {
    router: e
  } = oje(A$.UseNavigateStable), t = ije(j$.UseNavigateStable), n = C.useRef(!1);
  return OG(() => {
    n.current = !0;
  }), C.useCallback(function(a, s) {
    s === void 0 && (s = {}), process.env.NODE_ENV !== "production" && SG(n.current, _G), n.current && (typeof a == "number" ? e.navigate(a) : e.navigate(a, I$({
      fromRouteId: t
    }, s)));
  }, [e, t]);
}
var c3;
(function(e) {
  e[e.pending = 0] = "pending", e[e.success = 1] = "success", e[e.error = 2] = "error";
})(c3 || (c3 = {}));
new Promise(() => {
});
const lje = yn((e) => ({
  user: {
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    padding: `${e.spacing.xs}px ${e.spacing.sm}px`,
    borderRadius: e.radius.sm,
    transition: "background-color 100ms ease",
    "&:hover": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[1]
    }
  },
  userActive: {
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[1]
  }
}));
function bje({ basePath: e = "/security", Target: t, children: n }) {
  const r = nje(), { user: a, signout: s } = Age(), { classes: l, cx: p } = lje(), [m, h] = C.useState(!1), b = [
    { path: e + "/users", label: "Users", name: "UsersApi", Icon: i0e },
    { path: e + "/roles", label: "Roles", name: "RolesApi", Icon: t0e },
    { path: e + "/permissions", label: "Base Permissions", name: "PermissionsApi", Icon: T5 },
    { path: e + "/permissionviews", label: "Permission on Views", name: "PermissionViewApi", Icon: T5 },
    { path: e + "/viewsmenus", label: "Views/Menus", name: "ViewsMenusApi", Icon: Gbe }
  ].filter((x) => a.permissions.includes(x.name));
  return /* @__PURE__ */ L.jsxs(
    To,
    {
      width: 260,
      position: "bottom-end",
      transition: "pop-top-right",
      opened: m,
      onClose: () => h(!1),
      onOpen: () => h(!0),
      children: [
        /* @__PURE__ */ L.jsx(To.Target, { children: t || /* @__PURE__ */ L.jsx(MT, { className: p(l.user, { [l.userActive]: m }), children: /* @__PURE__ */ L.jsxs(Gl, { sx: { flexWrap: "nowrap" }, spacing: 7, children: [
          /* @__PURE__ */ L.jsx(Gi, { weight: 500, size: "sm", sx: { lineHeight: 1, whiteSpace: "nowrap" }, mr: 3, children: `${a.first_name} ${a.last_name}` }),
          /* @__PURE__ */ L.jsx(ZD, { size: 12 })
        ] }) }) }),
        /* @__PURE__ */ L.jsxs(To.Dropdown, { children: [
          b.length ? /* @__PURE__ */ L.jsxs(L.Fragment, { children: [
            /* @__PURE__ */ L.jsx(To.Label, { children: "Security" }),
            b.map((x, E) => /* @__PURE__ */ L.jsx(To.Item, { icon: /* @__PURE__ */ L.jsx(x.Icon, { size: 16 }), onClick: () => r(x.path), children: x.label }, E)),
            /* @__PURE__ */ L.jsx(To.Divider, {})
          ] }) : null,
          n,
          /* @__PURE__ */ L.jsx(To.Item, { icon: /* @__PURE__ */ L.jsx(n0e, { size: 14 }), onClick: s, children: "Logout" })
        ] })
      ]
    }
  );
}
export {
  vje as CheckboxGroup,
  xG as DataGrid,
  hje as DataGridStyles,
  yje as MultiSelect,
  Fbe as SeidrApiProvider,
  mje as SeidrProvider,
  gje as Select,
  bje as UserMenu,
  sa as useApi,
  Age as useSeidrAuth,
  jge as useSeidrInfo,
  pje as useSeidrTheme
};
