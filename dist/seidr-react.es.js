import * as P from "react";
import F, { createContext as Br, useContext as ar, createElement as et, forwardRef as Ne, Fragment as Yi, useRef as qe, useState as Me, useEffect as Ue, useLayoutEffect as Zf, useCallback as qn, Children as Bo, isValidElement as Wo, cloneElement as on, useReducer as hl, useMemo as fn, memo as Jf, useImperativeHandle as z2 } from "react";
import * as rg from "react-dom";
import zl, { createPortal as B2, flushSync as W2 } from "react-dom";
import { useNavigate as U2 } from "react-router-dom";
var Bn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var jh = { exports: {} }, ss = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O0;
function H2() {
  if (O0)
    return ss;
  O0 = 1;
  var e = F, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(l, c, u) {
    var d, f = {}, p = null, m = null;
    u !== void 0 && (p = "" + u), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (m = c.ref);
    for (d in c)
      n.call(c, d) && !a.hasOwnProperty(d) && (f[d] = c[d]);
    if (l && l.defaultProps)
      for (d in c = l.defaultProps, c)
        f[d] === void 0 && (f[d] = c[d]);
    return { $$typeof: t, type: l, key: p, ref: m, props: f, _owner: o.current };
  }
  return ss.Fragment = r, ss.jsx = i, ss.jsxs = i, ss;
}
var ls = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P0;
function Y2() {
  return P0 || (P0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = F, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), y = Symbol.iterator, h = "@@iterator";
    function v(Y) {
      if (Y === null || typeof Y != "object")
        return null;
      var ve = y && Y[y] || Y[h];
      return typeof ve == "function" ? ve : null;
    }
    var g = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(Y) {
      {
        for (var ve = arguments.length, Ee = new Array(ve > 1 ? ve - 1 : 0), He = 1; He < ve; He++)
          Ee[He - 1] = arguments[He];
        x("error", Y, Ee);
      }
    }
    function x(Y, ve, Ee) {
      {
        var He = g.ReactDebugCurrentFrame, be = He.getStackAddendum();
        be !== "" && (ve += "%s", Ee = Ee.concat([be]));
        var We = Ee.map(function(Ye) {
          return String(Ye);
        });
        We.unshift("Warning: " + ve), Function.prototype.apply.call(console[Y], console, We);
      }
    }
    var O = !1, w = !1, S = !1, E = !1, C = !1, N;
    N = Symbol.for("react.module.reference");
    function $(Y) {
      return !!(typeof Y == "string" || typeof Y == "function" || Y === n || Y === a || C || Y === o || Y === u || Y === d || E || Y === m || O || w || S || typeof Y == "object" && Y !== null && (Y.$$typeof === p || Y.$$typeof === f || Y.$$typeof === i || Y.$$typeof === l || Y.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Y.$$typeof === N || Y.getModuleId !== void 0));
    }
    function j(Y, ve, Ee) {
      var He = Y.displayName;
      if (He)
        return He;
      var be = ve.displayName || ve.name || "";
      return be !== "" ? Ee + "(" + be + ")" : Ee;
    }
    function A(Y) {
      return Y.displayName || "Context";
    }
    function k(Y) {
      if (Y == null)
        return null;
      if (typeof Y.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Y == "function")
        return Y.displayName || Y.name || null;
      if (typeof Y == "string")
        return Y;
      switch (Y) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case a:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof Y == "object")
        switch (Y.$$typeof) {
          case l:
            var ve = Y;
            return A(ve) + ".Consumer";
          case i:
            var Ee = Y;
            return A(Ee._context) + ".Provider";
          case c:
            return j(Y, Y.render, "ForwardRef");
          case f:
            var He = Y.displayName || null;
            return He !== null ? He : k(Y.type) || "Memo";
          case p: {
            var be = Y, We = be._payload, Ye = be._init;
            try {
              return k(Ye(We));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, D = 0, L, B, H, U, I, V, G;
    function q() {
    }
    q.__reactDisabledLog = !0;
    function J() {
      {
        if (D === 0) {
          L = console.log, B = console.info, H = console.warn, U = console.error, I = console.group, V = console.groupCollapsed, G = console.groupEnd;
          var Y = {
            configurable: !0,
            enumerable: !0,
            value: q,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Y,
            log: Y,
            warn: Y,
            error: Y,
            group: Y,
            groupCollapsed: Y,
            groupEnd: Y
          });
        }
        D++;
      }
    }
    function ne() {
      {
        if (D--, D === 0) {
          var Y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, Y, {
              value: L
            }),
            info: R({}, Y, {
              value: B
            }),
            warn: R({}, Y, {
              value: H
            }),
            error: R({}, Y, {
              value: U
            }),
            group: R({}, Y, {
              value: I
            }),
            groupCollapsed: R({}, Y, {
              value: V
            }),
            groupEnd: R({}, Y, {
              value: G
            })
          });
        }
        D < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var te = g.ReactCurrentDispatcher, ee;
    function K(Y, ve, Ee) {
      {
        if (ee === void 0)
          try {
            throw Error();
          } catch (be) {
            var He = be.stack.trim().match(/\n( *(at )?)/);
            ee = He && He[1] || "";
          }
        return `
` + ee + Y;
      }
    }
    var Q = !1, ae;
    {
      var ie = typeof WeakMap == "function" ? WeakMap : Map;
      ae = new ie();
    }
    function oe(Y, ve) {
      if (!Y || Q)
        return "";
      {
        var Ee = ae.get(Y);
        if (Ee !== void 0)
          return Ee;
      }
      var He;
      Q = !0;
      var be = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var We;
      We = te.current, te.current = null, J();
      try {
        if (ve) {
          var Ye = function() {
            throw Error();
          };
          if (Object.defineProperty(Ye.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ye, []);
            } catch (Tt) {
              He = Tt;
            }
            Reflect.construct(Y, [], Ye);
          } else {
            try {
              Ye.call();
            } catch (Tt) {
              He = Tt;
            }
            Y.call(Ye.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Tt) {
            He = Tt;
          }
          Y();
        }
      } catch (Tt) {
        if (Tt && He && typeof Tt.stack == "string") {
          for (var fe = Tt.stack.split(`
`), X = He.stack.split(`
`), pe = fe.length - 1, xe = X.length - 1; pe >= 1 && xe >= 0 && fe[pe] !== X[xe]; )
            xe--;
          for (; pe >= 1 && xe >= 0; pe--, xe--)
            if (fe[pe] !== X[xe]) {
              if (pe !== 1 || xe !== 1)
                do
                  if (pe--, xe--, xe < 0 || fe[pe] !== X[xe]) {
                    var tt = `
` + fe[pe].replace(" at new ", " at ");
                    return Y.displayName && tt.includes("<anonymous>") && (tt = tt.replace("<anonymous>", Y.displayName)), typeof Y == "function" && ae.set(Y, tt), tt;
                  }
                while (pe >= 1 && xe >= 0);
              break;
            }
        }
      } finally {
        Q = !1, te.current = We, ne(), Error.prepareStackTrace = be;
      }
      var Dt = Y ? Y.displayName || Y.name : "", ut = Dt ? K(Dt) : "";
      return typeof Y == "function" && ae.set(Y, ut), ut;
    }
    function se(Y, ve, Ee) {
      return oe(Y, !1);
    }
    function re(Y) {
      var ve = Y.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function le(Y, ve, Ee) {
      if (Y == null)
        return "";
      if (typeof Y == "function")
        return oe(Y, re(Y));
      if (typeof Y == "string")
        return K(Y);
      switch (Y) {
        case u:
          return K("Suspense");
        case d:
          return K("SuspenseList");
      }
      if (typeof Y == "object")
        switch (Y.$$typeof) {
          case c:
            return se(Y.render);
          case f:
            return le(Y.type, ve, Ee);
          case p: {
            var He = Y, be = He._payload, We = He._init;
            try {
              return le(We(be), ve, Ee);
            } catch {
            }
          }
        }
      return "";
    }
    var M = Object.prototype.hasOwnProperty, W = {}, Z = g.ReactDebugCurrentFrame;
    function he(Y) {
      if (Y) {
        var ve = Y._owner, Ee = le(Y.type, Y._source, ve ? ve.type : null);
        Z.setExtraStackFrame(Ee);
      } else
        Z.setExtraStackFrame(null);
    }
    function me(Y, ve, Ee, He, be) {
      {
        var We = Function.call.bind(M);
        for (var Ye in Y)
          if (We(Y, Ye)) {
            var fe = void 0;
            try {
              if (typeof Y[Ye] != "function") {
                var X = Error((He || "React class") + ": " + Ee + " type `" + Ye + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Y[Ye] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw X.name = "Invariant Violation", X;
              }
              fe = Y[Ye](ve, Ye, He, Ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (pe) {
              fe = pe;
            }
            fe && !(fe instanceof Error) && (he(be), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", He || "React class", Ee, Ye, typeof fe), he(null)), fe instanceof Error && !(fe.message in W) && (W[fe.message] = !0, he(be), b("Failed %s type: %s", Ee, fe.message), he(null));
          }
      }
    }
    var de = Array.isArray;
    function ue(Y) {
      return de(Y);
    }
    function Oe(Y) {
      {
        var ve = typeof Symbol == "function" && Symbol.toStringTag, Ee = ve && Y[Symbol.toStringTag] || Y.constructor.name || "Object";
        return Ee;
      }
    }
    function Se(Y) {
      try {
        return De(Y), !1;
      } catch {
        return !0;
      }
    }
    function De(Y) {
      return "" + Y;
    }
    function nt(Y) {
      if (Se(Y))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Oe(Y)), De(Y);
    }
    var rt = g.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, it, we;
    we = {};
    function ye(Y) {
      if (M.call(Y, "ref")) {
        var ve = Object.getOwnPropertyDescriptor(Y, "ref").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return Y.ref !== void 0;
    }
    function _e(Y) {
      if (M.call(Y, "key")) {
        var ve = Object.getOwnPropertyDescriptor(Y, "key").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return Y.key !== void 0;
    }
    function Re(Y, ve) {
      if (typeof Y.ref == "string" && rt.current && ve && rt.current.stateNode !== ve) {
        var Ee = k(rt.current.type);
        we[Ee] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', k(rt.current.type), Y.ref), we[Ee] = !0);
      }
    }
    function je(Y, ve) {
      {
        var Ee = function() {
          Ie || (Ie = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Ee.isReactWarning = !0, Object.defineProperty(Y, "key", {
          get: Ee,
          configurable: !0
        });
      }
    }
    function Fe(Y, ve) {
      {
        var Ee = function() {
          it || (it = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        Ee.isReactWarning = !0, Object.defineProperty(Y, "ref", {
          get: Ee,
          configurable: !0
        });
      }
    }
    var Ze = function(Y, ve, Ee, He, be, We, Ye) {
      var fe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: Y,
        key: ve,
        ref: Ee,
        props: Ye,
        // Record the component responsible for creating this element.
        _owner: We
      };
      return fe._store = {}, Object.defineProperty(fe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(fe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: He
      }), Object.defineProperty(fe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: be
      }), Object.freeze && (Object.freeze(fe.props), Object.freeze(fe)), fe;
    };
    function ft(Y, ve, Ee, He, be) {
      {
        var We, Ye = {}, fe = null, X = null;
        Ee !== void 0 && (nt(Ee), fe = "" + Ee), _e(ve) && (nt(ve.key), fe = "" + ve.key), ye(ve) && (X = ve.ref, Re(ve, be));
        for (We in ve)
          M.call(ve, We) && !Be.hasOwnProperty(We) && (Ye[We] = ve[We]);
        if (Y && Y.defaultProps) {
          var pe = Y.defaultProps;
          for (We in pe)
            Ye[We] === void 0 && (Ye[We] = pe[We]);
        }
        if (fe || X) {
          var xe = typeof Y == "function" ? Y.displayName || Y.name || "Unknown" : Y;
          fe && je(Ye, xe), X && Fe(Ye, xe);
        }
        return Ze(Y, fe, X, be, He, rt.current, Ye);
      }
    }
    var Je = g.ReactCurrentOwner, Ht = g.ReactDebugCurrentFrame;
    function at(Y) {
      if (Y) {
        var ve = Y._owner, Ee = le(Y.type, Y._source, ve ? ve.type : null);
        Ht.setExtraStackFrame(Ee);
      } else
        Ht.setExtraStackFrame(null);
    }
    var Jt;
    Jt = !1;
    function Yt(Y) {
      return typeof Y == "object" && Y !== null && Y.$$typeof === t;
    }
    function qt() {
      {
        if (Je.current) {
          var Y = k(Je.current.type);
          if (Y)
            return `

Check the render method of \`` + Y + "`.";
        }
        return "";
      }
    }
    function Or(Y) {
      {
        if (Y !== void 0) {
          var ve = Y.fileName.replace(/^.*[\\\/]/, ""), Ee = Y.lineNumber;
          return `

Check your code at ` + ve + ":" + Ee + ".";
        }
        return "";
      }
    }
    var Qt = {};
    function Gt(Y) {
      {
        var ve = qt();
        if (!ve) {
          var Ee = typeof Y == "string" ? Y : Y.displayName || Y.name;
          Ee && (ve = `

Check the top-level render call using <` + Ee + ">.");
        }
        return ve;
      }
    }
    function Rt(Y, ve) {
      {
        if (!Y._store || Y._store.validated || Y.key != null)
          return;
        Y._store.validated = !0;
        var Ee = Gt(ve);
        if (Qt[Ee])
          return;
        Qt[Ee] = !0;
        var He = "";
        Y && Y._owner && Y._owner !== Je.current && (He = " It was passed a child from " + k(Y._owner.type) + "."), at(Y), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ee, He), at(null);
      }
    }
    function ct(Y, ve) {
      {
        if (typeof Y != "object")
          return;
        if (ue(Y))
          for (var Ee = 0; Ee < Y.length; Ee++) {
            var He = Y[Ee];
            Yt(He) && Rt(He, ve);
          }
        else if (Yt(Y))
          Y._store && (Y._store.validated = !0);
        else if (Y) {
          var be = v(Y);
          if (typeof be == "function" && be !== Y.entries)
            for (var We = be.call(Y), Ye; !(Ye = We.next()).done; )
              Yt(Ye.value) && Rt(Ye.value, ve);
        }
      }
    }
    function sr(Y) {
      {
        var ve = Y.type;
        if (ve == null || typeof ve == "string")
          return;
        var Ee;
        if (typeof ve == "function")
          Ee = ve.propTypes;
        else if (typeof ve == "object" && (ve.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ve.$$typeof === f))
          Ee = ve.propTypes;
        else
          return;
        if (Ee) {
          var He = k(ve);
          me(Ee, Y.props, "prop", He, Y);
        } else if (ve.PropTypes !== void 0 && !Jt) {
          Jt = !0;
          var be = k(ve);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", be || "Unknown");
        }
        typeof ve.getDefaultProps == "function" && !ve.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Gr(Y) {
      {
        for (var ve = Object.keys(Y.props), Ee = 0; Ee < ve.length; Ee++) {
          var He = ve[Ee];
          if (He !== "children" && He !== "key") {
            at(Y), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", He), at(null);
            break;
          }
        }
        Y.ref !== null && (at(Y), b("Invalid attribute `ref` supplied to `React.Fragment`."), at(null));
      }
    }
    function Mt(Y, ve, Ee, He, be, We) {
      {
        var Ye = $(Y);
        if (!Ye) {
          var fe = "";
          (Y === void 0 || typeof Y == "object" && Y !== null && Object.keys(Y).length === 0) && (fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var X = Or(be);
          X ? fe += X : fe += qt();
          var pe;
          Y === null ? pe = "null" : ue(Y) ? pe = "array" : Y !== void 0 && Y.$$typeof === t ? (pe = "<" + (k(Y.type) || "Unknown") + " />", fe = " Did you accidentally export a JSX literal instead of a component?") : pe = typeof Y, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", pe, fe);
        }
        var xe = ft(Y, ve, Ee, be, We);
        if (xe == null)
          return xe;
        if (Ye) {
          var tt = ve.children;
          if (tt !== void 0)
            if (He)
              if (ue(tt)) {
                for (var Dt = 0; Dt < tt.length; Dt++)
                  ct(tt[Dt], Y);
                Object.freeze && Object.freeze(tt);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ct(tt, Y);
        }
        return Y === n ? Gr(xe) : sr(xe), xe;
      }
    }
    function er(Y, ve, Ee) {
      return Mt(Y, ve, Ee, !0);
    }
    function Kr(Y, ve, Ee) {
      return Mt(Y, ve, Ee, !1);
    }
    var wn = Kr, $o = er;
    ls.Fragment = n, ls.jsx = wn, ls.jsxs = $o;
  }()), ls;
}
process.env.NODE_ENV === "production" ? jh.exports = H2() : jh.exports = Y2();
var _ = jh.exports;
function xo(e, t) {
  return process.env.NODE_ENV === "production" ? () => null : function(...n) {
    return e(...n) || t(...n);
  };
}
function ya(e) {
  return e !== null && typeof e == "object" && e.constructor === Object;
}
function LT(e) {
  if (!ya(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r] = LT(e[r]);
  }), t;
}
function an(e, t, r = {
  clone: !0
}) {
  const n = r.clone ? {
    ...e
  } : e;
  return ya(e) && ya(t) && Object.keys(t).forEach((o) => {
    o !== "__proto__" && (ya(t[o]) && o in e && ya(e[o]) ? n[o] = an(e[o], t[o], r) : r.clone ? n[o] = ya(t[o]) ? LT(t[o]) : t[o] : n[o] = t[o]);
  }), n;
}
var Fh = { exports: {} }, Lh = { exports: {} }, xt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var S0;
function q2() {
  if (S0)
    return xt;
  S0 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, l = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, g = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var S = w.$$typeof;
      switch (S) {
        case t:
          switch (w = w.type, w) {
            case c:
            case u:
            case n:
            case a:
            case o:
            case f:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case l:
                case d:
                case y:
                case m:
                case i:
                  return w;
                default:
                  return S;
              }
          }
        case r:
          return S;
      }
    }
  }
  function O(w) {
    return x(w) === u;
  }
  return xt.AsyncMode = c, xt.ConcurrentMode = u, xt.ContextConsumer = l, xt.ContextProvider = i, xt.Element = t, xt.ForwardRef = d, xt.Fragment = n, xt.Lazy = y, xt.Memo = m, xt.Portal = r, xt.Profiler = a, xt.StrictMode = o, xt.Suspense = f, xt.isAsyncMode = function(w) {
    return O(w) || x(w) === c;
  }, xt.isConcurrentMode = O, xt.isContextConsumer = function(w) {
    return x(w) === l;
  }, xt.isContextProvider = function(w) {
    return x(w) === i;
  }, xt.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, xt.isForwardRef = function(w) {
    return x(w) === d;
  }, xt.isFragment = function(w) {
    return x(w) === n;
  }, xt.isLazy = function(w) {
    return x(w) === y;
  }, xt.isMemo = function(w) {
    return x(w) === m;
  }, xt.isPortal = function(w) {
    return x(w) === r;
  }, xt.isProfiler = function(w) {
    return x(w) === a;
  }, xt.isStrictMode = function(w) {
    return x(w) === o;
  }, xt.isSuspense = function(w) {
    return x(w) === f;
  }, xt.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === n || w === u || w === a || w === o || w === f || w === p || typeof w == "object" && w !== null && (w.$$typeof === y || w.$$typeof === m || w.$$typeof === i || w.$$typeof === l || w.$$typeof === d || w.$$typeof === v || w.$$typeof === g || w.$$typeof === b || w.$$typeof === h);
  }, xt.typeOf = x, xt;
}
var _t = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var T0;
function G2() {
  return T0 || (T0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, l = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, g = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
    function x(oe) {
      return typeof oe == "string" || typeof oe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      oe === n || oe === u || oe === a || oe === o || oe === f || oe === p || typeof oe == "object" && oe !== null && (oe.$$typeof === y || oe.$$typeof === m || oe.$$typeof === i || oe.$$typeof === l || oe.$$typeof === d || oe.$$typeof === v || oe.$$typeof === g || oe.$$typeof === b || oe.$$typeof === h);
    }
    function O(oe) {
      if (typeof oe == "object" && oe !== null) {
        var se = oe.$$typeof;
        switch (se) {
          case t:
            var re = oe.type;
            switch (re) {
              case c:
              case u:
              case n:
              case a:
              case o:
              case f:
                return re;
              default:
                var le = re && re.$$typeof;
                switch (le) {
                  case l:
                  case d:
                  case y:
                  case m:
                  case i:
                    return le;
                  default:
                    return se;
                }
            }
          case r:
            return se;
        }
      }
    }
    var w = c, S = u, E = l, C = i, N = t, $ = d, j = n, A = y, k = m, R = r, D = a, L = o, B = f, H = !1;
    function U(oe) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), I(oe) || O(oe) === c;
    }
    function I(oe) {
      return O(oe) === u;
    }
    function V(oe) {
      return O(oe) === l;
    }
    function G(oe) {
      return O(oe) === i;
    }
    function q(oe) {
      return typeof oe == "object" && oe !== null && oe.$$typeof === t;
    }
    function J(oe) {
      return O(oe) === d;
    }
    function ne(oe) {
      return O(oe) === n;
    }
    function te(oe) {
      return O(oe) === y;
    }
    function ee(oe) {
      return O(oe) === m;
    }
    function K(oe) {
      return O(oe) === r;
    }
    function Q(oe) {
      return O(oe) === a;
    }
    function ae(oe) {
      return O(oe) === o;
    }
    function ie(oe) {
      return O(oe) === f;
    }
    _t.AsyncMode = w, _t.ConcurrentMode = S, _t.ContextConsumer = E, _t.ContextProvider = C, _t.Element = N, _t.ForwardRef = $, _t.Fragment = j, _t.Lazy = A, _t.Memo = k, _t.Portal = R, _t.Profiler = D, _t.StrictMode = L, _t.Suspense = B, _t.isAsyncMode = U, _t.isConcurrentMode = I, _t.isContextConsumer = V, _t.isContextProvider = G, _t.isElement = q, _t.isForwardRef = J, _t.isFragment = ne, _t.isLazy = te, _t.isMemo = ee, _t.isPortal = K, _t.isProfiler = Q, _t.isStrictMode = ae, _t.isSuspense = ie, _t.isValidElementType = x, _t.typeOf = O;
  }()), _t;
}
process.env.NODE_ENV === "production" ? Lh.exports = q2() : Lh.exports = G2();
var ng = Lh.exports;
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var gm, E0;
function K2() {
  if (E0)
    return gm;
  E0 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var i = {}, l = 0; l < 10; l++)
        i["_" + String.fromCharCode(l)] = l;
      var c = Object.getOwnPropertyNames(i).map(function(d) {
        return i[d];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        u[d] = d;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return gm = o() ? Object.assign : function(a, i) {
    for (var l, c = n(a), u, d = 1; d < arguments.length; d++) {
      l = Object(arguments[d]);
      for (var f in l)
        t.call(l, f) && (c[f] = l[f]);
      if (e) {
        u = e(l);
        for (var p = 0; p < u.length; p++)
          r.call(l, u[p]) && (c[u[p]] = l[u[p]]);
      }
    }
    return c;
  }, gm;
}
var bm, $0;
function og() {
  if ($0)
    return bm;
  $0 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return bm = e, bm;
}
var wm, C0;
function VT() {
  return C0 || (C0 = 1, wm = Function.call.bind(Object.prototype.hasOwnProperty)), wm;
}
var xm, k0;
function X2() {
  if (k0)
    return xm;
  k0 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = og(), r = {}, n = VT();
    e = function(a) {
      var i = "Warning: " + a;
      typeof console < "u" && console.error(i);
      try {
        throw new Error(i);
      } catch {
      }
    };
  }
  function o(a, i, l, c, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var d in a)
        if (n(a, d)) {
          var f;
          try {
            if (typeof a[d] != "function") {
              var p = Error(
                (c || "React class") + ": " + l + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            f = a[d](i, d, c, l, null, t);
          } catch (y) {
            f = y;
          }
          if (f && !(f instanceof Error) && e(
            (c || "React class") + ": type specification of " + l + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in r)) {
            r[f.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + l + " type: " + f.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, xm = o, xm;
}
var _m, R0;
function Q2() {
  if (R0)
    return _m;
  R0 = 1;
  var e = ng, t = K2(), r = og(), n = VT(), o = X2(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(l) {
    var c = "Warning: " + l;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function i() {
    return null;
  }
  return _m = function(l, c) {
    var u = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function f(I) {
      var V = I && (u && I[u] || I[d]);
      if (typeof V == "function")
        return V;
    }
    var p = "<<anonymous>>", m = {
      array: g("array"),
      bigint: g("bigint"),
      bool: g("boolean"),
      func: g("function"),
      number: g("number"),
      object: g("object"),
      string: g("string"),
      symbol: g("symbol"),
      any: b(),
      arrayOf: x,
      element: O(),
      elementType: w(),
      instanceOf: S,
      node: $(),
      objectOf: C,
      oneOf: E,
      oneOfType: N,
      shape: A,
      exact: k
    };
    function y(I, V) {
      return I === V ? I !== 0 || 1 / I === 1 / V : I !== I && V !== V;
    }
    function h(I, V) {
      this.message = I, this.data = V && typeof V == "object" ? V : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function v(I) {
      if (process.env.NODE_ENV !== "production")
        var V = {}, G = 0;
      function q(ne, te, ee, K, Q, ae, ie) {
        if (K = K || p, ae = ae || ee, ie !== r) {
          if (c) {
            var oe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw oe.name = "Invariant Violation", oe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = K + ":" + ee;
            !V[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + ae + "` prop on `" + K + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), V[se] = !0, G++);
          }
        }
        return te[ee] == null ? ne ? te[ee] === null ? new h("The " + Q + " `" + ae + "` is marked as required " + ("in `" + K + "`, but its value is `null`.")) : new h("The " + Q + " `" + ae + "` is marked as required in " + ("`" + K + "`, but its value is `undefined`.")) : null : I(te, ee, K, Q, ae);
      }
      var J = q.bind(null, !1);
      return J.isRequired = q.bind(null, !0), J;
    }
    function g(I) {
      function V(G, q, J, ne, te, ee) {
        var K = G[q], Q = L(K);
        if (Q !== I) {
          var ae = B(K);
          return new h(
            "Invalid " + ne + " `" + te + "` of type " + ("`" + ae + "` supplied to `" + J + "`, expected ") + ("`" + I + "`."),
            { expectedType: I }
          );
        }
        return null;
      }
      return v(V);
    }
    function b() {
      return v(i);
    }
    function x(I) {
      function V(G, q, J, ne, te) {
        if (typeof I != "function")
          return new h("Property `" + te + "` of component `" + J + "` has invalid PropType notation inside arrayOf.");
        var ee = G[q];
        if (!Array.isArray(ee)) {
          var K = L(ee);
          return new h("Invalid " + ne + " `" + te + "` of type " + ("`" + K + "` supplied to `" + J + "`, expected an array."));
        }
        for (var Q = 0; Q < ee.length; Q++) {
          var ae = I(ee, Q, J, ne, te + "[" + Q + "]", r);
          if (ae instanceof Error)
            return ae;
        }
        return null;
      }
      return v(V);
    }
    function O() {
      function I(V, G, q, J, ne) {
        var te = V[G];
        if (!l(te)) {
          var ee = L(te);
          return new h("Invalid " + J + " `" + ne + "` of type " + ("`" + ee + "` supplied to `" + q + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(I);
    }
    function w() {
      function I(V, G, q, J, ne) {
        var te = V[G];
        if (!e.isValidElementType(te)) {
          var ee = L(te);
          return new h("Invalid " + J + " `" + ne + "` of type " + ("`" + ee + "` supplied to `" + q + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(I);
    }
    function S(I) {
      function V(G, q, J, ne, te) {
        if (!(G[q] instanceof I)) {
          var ee = I.name || p, K = U(G[q]);
          return new h("Invalid " + ne + " `" + te + "` of type " + ("`" + K + "` supplied to `" + J + "`, expected ") + ("instance of `" + ee + "`."));
        }
        return null;
      }
      return v(V);
    }
    function E(I) {
      if (!Array.isArray(I))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), i;
      function V(G, q, J, ne, te) {
        for (var ee = G[q], K = 0; K < I.length; K++)
          if (y(ee, I[K]))
            return null;
        var Q = JSON.stringify(I, function(ie, oe) {
          var se = B(oe);
          return se === "symbol" ? String(oe) : oe;
        });
        return new h("Invalid " + ne + " `" + te + "` of value `" + String(ee) + "` " + ("supplied to `" + J + "`, expected one of " + Q + "."));
      }
      return v(V);
    }
    function C(I) {
      function V(G, q, J, ne, te) {
        if (typeof I != "function")
          return new h("Property `" + te + "` of component `" + J + "` has invalid PropType notation inside objectOf.");
        var ee = G[q], K = L(ee);
        if (K !== "object")
          return new h("Invalid " + ne + " `" + te + "` of type " + ("`" + K + "` supplied to `" + J + "`, expected an object."));
        for (var Q in ee)
          if (n(ee, Q)) {
            var ae = I(ee, Q, J, ne, te + "." + Q, r);
            if (ae instanceof Error)
              return ae;
          }
        return null;
      }
      return v(V);
    }
    function N(I) {
      if (!Array.isArray(I))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), i;
      for (var V = 0; V < I.length; V++) {
        var G = I[V];
        if (typeof G != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(G) + " at index " + V + "."
          ), i;
      }
      function q(J, ne, te, ee, K) {
        for (var Q = [], ae = 0; ae < I.length; ae++) {
          var ie = I[ae], oe = ie(J, ne, te, ee, K, r);
          if (oe == null)
            return null;
          oe.data && n(oe.data, "expectedType") && Q.push(oe.data.expectedType);
        }
        var se = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new h("Invalid " + ee + " `" + K + "` supplied to " + ("`" + te + "`" + se + "."));
      }
      return v(q);
    }
    function $() {
      function I(V, G, q, J, ne) {
        return R(V[G]) ? null : new h("Invalid " + J + " `" + ne + "` supplied to " + ("`" + q + "`, expected a ReactNode."));
      }
      return v(I);
    }
    function j(I, V, G, q, J) {
      return new h(
        (I || "React class") + ": " + V + " type `" + G + "." + q + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + J + "`."
      );
    }
    function A(I) {
      function V(G, q, J, ne, te) {
        var ee = G[q], K = L(ee);
        if (K !== "object")
          return new h("Invalid " + ne + " `" + te + "` of type `" + K + "` " + ("supplied to `" + J + "`, expected `object`."));
        for (var Q in I) {
          var ae = I[Q];
          if (typeof ae != "function")
            return j(J, ne, te, Q, B(ae));
          var ie = ae(ee, Q, J, ne, te + "." + Q, r);
          if (ie)
            return ie;
        }
        return null;
      }
      return v(V);
    }
    function k(I) {
      function V(G, q, J, ne, te) {
        var ee = G[q], K = L(ee);
        if (K !== "object")
          return new h("Invalid " + ne + " `" + te + "` of type `" + K + "` " + ("supplied to `" + J + "`, expected `object`."));
        var Q = t({}, G[q], I);
        for (var ae in Q) {
          var ie = I[ae];
          if (n(I, ae) && typeof ie != "function")
            return j(J, ne, te, ae, B(ie));
          if (!ie)
            return new h(
              "Invalid " + ne + " `" + te + "` key `" + ae + "` supplied to `" + J + "`.\nBad object: " + JSON.stringify(G[q], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(I), null, "  ")
            );
          var oe = ie(ee, ae, J, ne, te + "." + ae, r);
          if (oe)
            return oe;
        }
        return null;
      }
      return v(V);
    }
    function R(I) {
      switch (typeof I) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !I;
        case "object":
          if (Array.isArray(I))
            return I.every(R);
          if (I === null || l(I))
            return !0;
          var V = f(I);
          if (V) {
            var G = V.call(I), q;
            if (V !== I.entries) {
              for (; !(q = G.next()).done; )
                if (!R(q.value))
                  return !1;
            } else
              for (; !(q = G.next()).done; ) {
                var J = q.value;
                if (J && !R(J[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function D(I, V) {
      return I === "symbol" ? !0 : V ? V["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && V instanceof Symbol : !1;
    }
    function L(I) {
      var V = typeof I;
      return Array.isArray(I) ? "array" : I instanceof RegExp ? "object" : D(V, I) ? "symbol" : V;
    }
    function B(I) {
      if (typeof I > "u" || I === null)
        return "" + I;
      var V = L(I);
      if (V === "object") {
        if (I instanceof Date)
          return "date";
        if (I instanceof RegExp)
          return "regexp";
      }
      return V;
    }
    function H(I) {
      var V = B(I);
      switch (V) {
        case "array":
        case "object":
          return "an " + V;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + V;
        default:
          return V;
      }
    }
    function U(I) {
      return !I.constructor || !I.constructor.name ? p : I.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, _m;
}
var Om, D0;
function Z2() {
  if (D0)
    return Om;
  D0 = 1;
  var e = og();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, Om = function() {
    function n(i, l, c, u, d, f) {
      if (f !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    n.isRequired = n;
    function o() {
      return n;
    }
    var a = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: o,
      element: n,
      elementType: n,
      instanceOf: o,
      node: n,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, Om;
}
if (process.env.NODE_ENV !== "production") {
  var J2 = ng, eA = !0;
  Fh.exports = Q2()(J2.isElement, eA);
} else
  Fh.exports = Z2()();
var tA = Fh.exports;
const s = /* @__PURE__ */ qi(tA);
function rA(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function zT(e, t, r, n, o) {
  const a = e[t], i = o || t;
  if (a == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let l;
  const c = a.type;
  return typeof c == "function" && !rA(c) && (l = "Did you accidentally use a plain function component for an element instead?"), l !== void 0 ? new Error(`Invalid ${n} \`${i}\` supplied to \`${r}\`. Expected an element that can hold a ref. ${l} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const BT = xo(s.element, zT);
BT.isRequired = xo(s.element.isRequired, zT);
const yl = BT;
function nA(e) {
  const {
    prototype: t = {}
  } = e;
  return !!t.isReactComponent;
}
function oA(e, t, r, n, o) {
  const a = e[t], i = o || t;
  if (a == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let l;
  return typeof a == "function" && !nA(a) && (l = "Did you accidentally provide a plain function component instead?"), l !== void 0 ? new Error(`Invalid ${n} \`${i}\` supplied to \`${r}\`. Expected an element type that can hold a ref. ${l} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const ep = xo(s.elementType, oA), aA = "exact-prop: â€‹";
function tp(e) {
  return process.env.NODE_ENV === "production" ? e : {
    ...e,
    [aA]: (t) => {
      const r = Object.keys(t).filter((n) => !e.hasOwnProperty(n));
      return r.length > 0 ? new Error(`The following props are not supported: ${r.map((n) => `\`${n}\``).join(", ")}. Please remove them.`) : null;
    }
  };
}
function Go(e) {
  let t = "https://mui.com/production-error/?code=" + e;
  for (let r = 1; r < arguments.length; r += 1)
    t += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified MUI error #" + e + "; visit " + t + " for the full message.";
}
var Vh = { exports: {} }, Ot = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N0;
function iA() {
  if (N0)
    return Ot;
  N0 = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), l = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), y;
  y = Symbol.for("react.module.reference");
  function h(v) {
    if (typeof v == "object" && v !== null) {
      var g = v.$$typeof;
      switch (g) {
        case e:
          switch (v = v.type, v) {
            case r:
            case o:
            case n:
            case u:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case l:
                case i:
                case c:
                case p:
                case f:
                case a:
                  return v;
                default:
                  return g;
              }
          }
        case t:
          return g;
      }
    }
  }
  return Ot.ContextConsumer = i, Ot.ContextProvider = a, Ot.Element = e, Ot.ForwardRef = c, Ot.Fragment = r, Ot.Lazy = p, Ot.Memo = f, Ot.Portal = t, Ot.Profiler = o, Ot.StrictMode = n, Ot.Suspense = u, Ot.SuspenseList = d, Ot.isAsyncMode = function() {
    return !1;
  }, Ot.isConcurrentMode = function() {
    return !1;
  }, Ot.isContextConsumer = function(v) {
    return h(v) === i;
  }, Ot.isContextProvider = function(v) {
    return h(v) === a;
  }, Ot.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Ot.isForwardRef = function(v) {
    return h(v) === c;
  }, Ot.isFragment = function(v) {
    return h(v) === r;
  }, Ot.isLazy = function(v) {
    return h(v) === p;
  }, Ot.isMemo = function(v) {
    return h(v) === f;
  }, Ot.isPortal = function(v) {
    return h(v) === t;
  }, Ot.isProfiler = function(v) {
    return h(v) === o;
  }, Ot.isStrictMode = function(v) {
    return h(v) === n;
  }, Ot.isSuspense = function(v) {
    return h(v) === u;
  }, Ot.isSuspenseList = function(v) {
    return h(v) === d;
  }, Ot.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === o || v === n || v === u || v === d || v === m || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === f || v.$$typeof === a || v.$$typeof === i || v.$$typeof === c || v.$$typeof === y || v.getModuleId !== void 0);
  }, Ot.typeOf = h, Ot;
}
var Pt = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var I0;
function sA() {
  return I0 || (I0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), i = Symbol.for("react.context"), l = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), y = !1, h = !1, v = !1, g = !1, b = !1, x;
    x = Symbol.for("react.module.reference");
    function O(re) {
      return !!(typeof re == "string" || typeof re == "function" || re === r || re === o || b || re === n || re === u || re === d || g || re === m || y || h || v || typeof re == "object" && re !== null && (re.$$typeof === p || re.$$typeof === f || re.$$typeof === a || re.$$typeof === i || re.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      re.$$typeof === x || re.getModuleId !== void 0));
    }
    function w(re) {
      if (typeof re == "object" && re !== null) {
        var le = re.$$typeof;
        switch (le) {
          case e:
            var M = re.type;
            switch (M) {
              case r:
              case o:
              case n:
              case u:
              case d:
                return M;
              default:
                var W = M && M.$$typeof;
                switch (W) {
                  case l:
                  case i:
                  case c:
                  case p:
                  case f:
                  case a:
                    return W;
                  default:
                    return le;
                }
            }
          case t:
            return le;
        }
      }
    }
    var S = i, E = a, C = e, N = c, $ = r, j = p, A = f, k = t, R = o, D = n, L = u, B = d, H = !1, U = !1;
    function I(re) {
      return H || (H = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function V(re) {
      return U || (U = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function G(re) {
      return w(re) === i;
    }
    function q(re) {
      return w(re) === a;
    }
    function J(re) {
      return typeof re == "object" && re !== null && re.$$typeof === e;
    }
    function ne(re) {
      return w(re) === c;
    }
    function te(re) {
      return w(re) === r;
    }
    function ee(re) {
      return w(re) === p;
    }
    function K(re) {
      return w(re) === f;
    }
    function Q(re) {
      return w(re) === t;
    }
    function ae(re) {
      return w(re) === o;
    }
    function ie(re) {
      return w(re) === n;
    }
    function oe(re) {
      return w(re) === u;
    }
    function se(re) {
      return w(re) === d;
    }
    Pt.ContextConsumer = S, Pt.ContextProvider = E, Pt.Element = C, Pt.ForwardRef = N, Pt.Fragment = $, Pt.Lazy = j, Pt.Memo = A, Pt.Portal = k, Pt.Profiler = R, Pt.StrictMode = D, Pt.Suspense = L, Pt.SuspenseList = B, Pt.isAsyncMode = I, Pt.isConcurrentMode = V, Pt.isContextConsumer = G, Pt.isContextProvider = q, Pt.isElement = J, Pt.isForwardRef = ne, Pt.isFragment = te, Pt.isLazy = ee, Pt.isMemo = K, Pt.isPortal = Q, Pt.isProfiler = ae, Pt.isStrictMode = ie, Pt.isSuspense = oe, Pt.isSuspenseList = se, Pt.isValidElementType = O, Pt.typeOf = w;
  }()), Pt;
}
process.env.NODE_ENV === "production" ? Vh.exports = iA() : Vh.exports = sA();
var Ci = Vh.exports;
const lA = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function cA(e) {
  const t = `${e}`.match(lA);
  return t && t[1] || "";
}
function WT(e, t = "") {
  return e.displayName || e.name || cA(e) || t;
}
function M0(e, t, r) {
  const n = WT(t);
  return e.displayName || (n !== "" ? `${r}(${n})` : r);
}
function uA(e) {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (typeof e == "function")
      return WT(e, "Component");
    if (typeof e == "object")
      switch (e.$$typeof) {
        case Ci.ForwardRef:
          return M0(e, e.render, "ForwardRef");
        case Ci.Memo:
          return M0(e, e.type, "memo");
        default:
          return;
      }
  }
}
function Gn(e, t, r, n, o) {
  if (process.env.NODE_ENV === "production")
    return null;
  const a = e[t], i = o || t;
  return a == null ? null : a && a.nodeType !== 1 ? new Error(`Invalid ${n} \`${i}\` supplied to \`${r}\`. Expected an HTMLElement.`) : null;
}
const dA = s.oneOfType([s.func, s.object]), vn = dA;
function Te(e) {
  if (typeof e != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : Go(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function A0(...e) {
  return e.reduce((t, r) => r == null ? t : function(...o) {
    t.apply(this, o), r.apply(this, o);
  }, () => {
  });
}
function ki(e, t = 166) {
  let r;
  function n(...o) {
    const a = () => {
      e.apply(this, o);
    };
    clearTimeout(r), r = setTimeout(a, t);
  }
  return n.clear = () => {
    clearTimeout(r);
  }, n;
}
function As(e, t) {
  return /* @__PURE__ */ P.isValidElement(e) && t.indexOf(e.type.muiName) !== -1;
}
function nr(e) {
  return e && e.ownerDocument || document;
}
function ho(e) {
  return nr(e).defaultView || window;
}
function fA(e, t) {
  if (process.env.NODE_ENV === "production")
    return () => null;
  const r = t ? {
    ...t.propTypes
  } : null;
  return (o) => (a, i, l, c, u, ...d) => {
    const f = u || i, p = r == null ? void 0 : r[f];
    if (p) {
      const m = p(a, i, l, c, u, ...d);
      if (m)
        return m;
    }
    return typeof a[i] < "u" && !a[o] ? new Error(`The prop \`${f}\` of \`${e}\` can only be used together with the \`${o}\` prop.`) : null;
  };
}
function zh(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
const pA = typeof window < "u" ? P.useLayoutEffect : P.useEffect, wr = pA;
let j0 = 0;
function mA(e) {
  const [t, r] = P.useState(e), n = e || t;
  return P.useEffect(() => {
    t == null && (j0 += 1, r(`mui-${j0}`));
  }, [t]), n;
}
const F0 = P["useId".toString()];
function Ri(e) {
  if (F0 !== void 0) {
    const t = F0();
    return e ?? t;
  }
  return mA(e);
}
function UT(e, t, r, n, o) {
  if (process.env.NODE_ENV === "production")
    return null;
  const a = o || t;
  return typeof e[t] < "u" ? new Error(`The prop \`${a}\` is not supported. Please remove it.`) : null;
}
function Wr({
  controlled: e,
  default: t,
  name: r,
  state: n = "value"
}) {
  const {
    current: o
  } = P.useRef(e !== void 0), [a, i] = P.useState(t), l = o ? e : a;
  if (process.env.NODE_ENV !== "production") {
    P.useEffect(() => {
      o !== (e !== void 0) && console.error([`MUI: A component is changing the ${o ? "" : "un"}controlled ${n} state of ${r} to be ${o ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [n, r, e]);
    const {
      current: u
    } = P.useRef(t);
    P.useEffect(() => {
      !o && u !== t && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const c = P.useCallback((u) => {
    o || i(u);
  }, []);
  return [l, c];
}
function $t(e) {
  const t = P.useRef(e);
  return wr(() => {
    t.current = e;
  }), P.useCallback((...r) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...r)
  ), []);
}
function Lt(...e) {
  return P.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((r) => {
      zh(r, t);
    });
  }, e);
}
let rp = !0, Bh = !1, L0;
const hA = {
  text: !0,
  search: !0,
  url: !0,
  tel: !0,
  email: !0,
  password: !0,
  number: !0,
  date: !0,
  month: !0,
  week: !0,
  time: !0,
  datetime: !0,
  "datetime-local": !0
};
function yA(e) {
  const {
    type: t,
    tagName: r
  } = e;
  return !!(r === "INPUT" && hA[t] && !e.readOnly || r === "TEXTAREA" && !e.readOnly || e.isContentEditable);
}
function vA(e) {
  e.metaKey || e.altKey || e.ctrlKey || (rp = !0);
}
function Pm() {
  rp = !1;
}
function gA() {
  this.visibilityState === "hidden" && Bh && (rp = !0);
}
function bA(e) {
  e.addEventListener("keydown", vA, !0), e.addEventListener("mousedown", Pm, !0), e.addEventListener("pointerdown", Pm, !0), e.addEventListener("touchstart", Pm, !0), e.addEventListener("visibilitychange", gA, !0);
}
function wA(e) {
  const {
    target: t
  } = e;
  try {
    return t.matches(":focus-visible");
  } catch {
  }
  return rp || yA(t);
}
function xA() {
  const e = P.useCallback((o) => {
    o != null && bA(o.ownerDocument);
  }, []), t = P.useRef(!1);
  function r() {
    return t.current ? (Bh = !0, window.clearTimeout(L0), L0 = window.setTimeout(() => {
      Bh = !1;
    }, 100), t.current = !1, !0) : !1;
  }
  function n(o) {
    return wA(o) ? (t.current = !0, !0) : !1;
  }
  return {
    isFocusVisibleRef: t,
    onFocus: n,
    onBlur: r,
    ref: e
  };
}
function HT(e) {
  const t = e.documentElement.clientWidth;
  return Math.abs(window.innerWidth - t);
}
let Ga;
function YT() {
  if (Ga)
    return Ga;
  const e = document.createElement("div"), t = document.createElement("div");
  return t.style.width = "10px", t.style.height = "1px", e.appendChild(t), e.dir = "rtl", e.style.fontSize = "14px", e.style.width = "4px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.overflow = "scroll", document.body.appendChild(e), Ga = "reverse", e.scrollLeft > 0 ? Ga = "default" : (e.scrollLeft = 1, e.scrollLeft === 0 && (Ga = "negative")), document.body.removeChild(e), Ga;
}
function V0(e, t) {
  const r = e.scrollLeft;
  if (t !== "rtl")
    return r;
  switch (YT()) {
    case "negative":
      return e.scrollWidth - e.clientWidth + r;
    case "reverse":
      return e.scrollWidth - e.clientWidth - r;
    default:
      return r;
  }
}
function _A(e) {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : Number.isFinite(e) ? e !== Math.floor(e) ? "float" : "number" : "Infinity";
    case "object":
      return e === null ? "null" : e.constructor.name;
    default:
      return t;
  }
}
function OA(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
const PA = Number.isInteger || OA;
function qT(e, t, r, n) {
  const o = e[t];
  if (o == null || !PA(o)) {
    const a = _A(o);
    return new RangeError(`Invalid ${n} \`${t}\` of type \`${a}\` supplied to \`${r}\`, expected \`integer\`.`);
  }
  return null;
}
function GT(e, t, ...r) {
  return e[t] === void 0 ? null : qT(e, t, ...r);
}
function Wh() {
  return null;
}
GT.isRequired = qT;
Wh.isRequired = Wh;
const js = process.env.NODE_ENV === "production" ? Wh : GT;
function ag(e, t) {
  const r = {
    ...t
  };
  return Object.keys(e).forEach((n) => {
    if (n.toString().match(/^(components|slots)$/))
      r[n] = {
        ...e[n],
        ...r[n]
      };
    else if (n.toString().match(/^(componentsProps|slotProps)$/)) {
      const o = e[n] || {}, a = t[n];
      r[n] = {}, !a || !Object.keys(a) ? r[n] = o : !o || !Object.keys(o) ? r[n] = a : (r[n] = {
        ...a
      }, Object.keys(o).forEach((i) => {
        r[n][i] = ag(o[i], a[i]);
      }));
    } else
      r[n] === void 0 && (r[n] = e[n]);
  }), r;
}
function Ve(e, t, r = void 0) {
  const n = {};
  return Object.keys(e).forEach(
    // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (o) => {
      n[o] = e[o].reduce((a, i) => {
        if (i) {
          const l = t(i);
          l !== "" && a.push(l), r && r[i] && a.push(r[i]);
        }
        return a;
      }, []).join(" ");
    }
  ), n;
}
const z0 = (e) => e, SA = () => {
  let e = z0;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = z0;
    }
  };
}, TA = SA(), EA = TA, $A = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  readOnly: "readOnly",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function ze(e, t, r = "Mui") {
  const n = $A[t];
  return n ? `${r}-${n}` : `${EA.generate(e)}-${t}`;
}
function Le(e, t, r = "Mui") {
  const n = {};
  return t.forEach((o) => {
    n[o] = ze(e, o, r);
  }), n;
}
function T() {
  return T = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, T.apply(this, arguments);
}
function ge(e, t) {
  if (e == null)
    return {};
  var r = {}, n = Object.keys(e), o, a;
  for (a = 0; a < n.length; a++)
    o = n[a], !(t.indexOf(o) >= 0) && (r[o] = e[o]);
  return r;
}
function KT(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(r) {
    return t[r] === void 0 && (t[r] = e(r)), t[r];
  };
}
var CA = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, kA = /* @__PURE__ */ KT(
  function(e) {
    return CA.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function RA(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function DA(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var NA = /* @__PURE__ */ function() {
  function e(r) {
    var n = this;
    this._insertTag = function(o) {
      var a;
      n.tags.length === 0 ? n.insertionPoint ? a = n.insertionPoint.nextSibling : n.prepend ? a = n.container.firstChild : a = n.before : a = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(o, a), n.tags.push(o);
    }, this.isSpeedy = r.speedy === void 0 ? process.env.NODE_ENV === "production" : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(n) {
    n.forEach(this._insertTag);
  }, t.insert = function(n) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(DA(this));
    var o = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var a = n.charCodeAt(0) === 64 && n.charCodeAt(1) === 105;
      a && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + n + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !a;
    }
    if (this.isSpeedy) {
      var i = RA(o);
      try {
        i.insertRule(n, i.cssRules.length);
      } catch (l) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(n) && console.error('There was a problem inserting the following rule: "' + n + '"', l);
      }
    } else
      o.appendChild(document.createTextNode(n));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(n) {
      return n.parentNode && n.parentNode.removeChild(n);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, e;
}(), pr = "-ms-", Su = "-moz-", yt = "-webkit-", ig = "comm", sg = "rule", lg = "decl", IA = "@import", XT = "@keyframes", MA = "@layer", AA = Math.abs, np = String.fromCharCode, jA = Object.assign;
function FA(e, t) {
  return ur(e, 0) ^ 45 ? (((t << 2 ^ ur(e, 0)) << 2 ^ ur(e, 1)) << 2 ^ ur(e, 2)) << 2 ^ ur(e, 3) : 0;
}
function QT(e) {
  return e.trim();
}
function LA(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function vt(e, t, r) {
  return e.replace(t, r);
}
function Uh(e, t) {
  return e.indexOf(t);
}
function ur(e, t) {
  return e.charCodeAt(t) | 0;
}
function Js(e, t, r) {
  return e.slice(t, r);
}
function An(e) {
  return e.length;
}
function cg(e) {
  return e.length;
}
function Bl(e, t) {
  return t.push(e), e;
}
function VA(e, t) {
  return e.map(t).join("");
}
var op = 1, Di = 1, ZT = 0, Dr = 0, Zt = 0, Gi = "";
function ap(e, t, r, n, o, a, i) {
  return { value: e, root: t, parent: r, type: n, props: o, children: a, line: op, column: Di, length: i, return: "" };
}
function cs(e, t) {
  return jA(ap("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function zA() {
  return Zt;
}
function BA() {
  return Zt = Dr > 0 ? ur(Gi, --Dr) : 0, Di--, Zt === 10 && (Di = 1, op--), Zt;
}
function zr() {
  return Zt = Dr < ZT ? ur(Gi, Dr++) : 0, Di++, Zt === 10 && (Di = 1, op++), Zt;
}
function Hn() {
  return ur(Gi, Dr);
}
function Tc() {
  return Dr;
}
function vl(e, t) {
  return Js(Gi, e, t);
}
function el(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function JT(e) {
  return op = Di = 1, ZT = An(Gi = e), Dr = 0, [];
}
function eE(e) {
  return Gi = "", e;
}
function Ec(e) {
  return QT(vl(Dr - 1, Hh(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function WA(e) {
  for (; (Zt = Hn()) && Zt < 33; )
    zr();
  return el(e) > 2 || el(Zt) > 3 ? "" : " ";
}
function UA(e, t) {
  for (; --t && zr() && !(Zt < 48 || Zt > 102 || Zt > 57 && Zt < 65 || Zt > 70 && Zt < 97); )
    ;
  return vl(e, Tc() + (t < 6 && Hn() == 32 && zr() == 32));
}
function Hh(e) {
  for (; zr(); )
    switch (Zt) {
      case e:
        return Dr;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Hh(Zt);
        break;
      case 40:
        e === 41 && Hh(e);
        break;
      case 92:
        zr();
        break;
    }
  return Dr;
}
function HA(e, t) {
  for (; zr() && e + Zt !== 47 + 10; )
    if (e + Zt === 42 + 42 && Hn() === 47)
      break;
  return "/*" + vl(t, Dr - 1) + "*" + np(e === 47 ? e : zr());
}
function YA(e) {
  for (; !el(Hn()); )
    zr();
  return vl(e, Dr);
}
function qA(e) {
  return eE($c("", null, null, null, [""], e = JT(e), 0, [0], e));
}
function $c(e, t, r, n, o, a, i, l, c) {
  for (var u = 0, d = 0, f = i, p = 0, m = 0, y = 0, h = 1, v = 1, g = 1, b = 0, x = "", O = o, w = a, S = n, E = x; v; )
    switch (y = b, b = zr()) {
      case 40:
        if (y != 108 && ur(E, f - 1) == 58) {
          Uh(E += vt(Ec(b), "&", "&\f"), "&\f") != -1 && (g = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        E += Ec(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        E += WA(y);
        break;
      case 92:
        E += UA(Tc() - 1, 7);
        continue;
      case 47:
        switch (Hn()) {
          case 42:
          case 47:
            Bl(GA(HA(zr(), Tc()), t, r), c);
            break;
          default:
            E += "/";
        }
        break;
      case 123 * h:
        l[u++] = An(E) * g;
      case 125 * h:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            v = 0;
          case 59 + d:
            g == -1 && (E = vt(E, /\f/g, "")), m > 0 && An(E) - f && Bl(m > 32 ? W0(E + ";", n, r, f - 1) : W0(vt(E, " ", "") + ";", n, r, f - 2), c);
            break;
          case 59:
            E += ";";
          default:
            if (Bl(S = B0(E, t, r, u, d, o, l, x, O = [], w = [], f), a), b === 123)
              if (d === 0)
                $c(E, t, S, S, O, a, f, l, w);
              else
                switch (p === 99 && ur(E, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    $c(e, S, S, n && Bl(B0(e, S, S, 0, 0, o, l, x, o, O = [], f), w), o, w, f, l, n ? O : w);
                    break;
                  default:
                    $c(E, S, S, S, [""], w, 0, l, w);
                }
        }
        u = d = m = 0, h = g = 1, x = E = "", f = i;
        break;
      case 58:
        f = 1 + An(E), m = y;
      default:
        if (h < 1) {
          if (b == 123)
            --h;
          else if (b == 125 && h++ == 0 && BA() == 125)
            continue;
        }
        switch (E += np(b), b * h) {
          case 38:
            g = d > 0 ? 1 : (E += "\f", -1);
            break;
          case 44:
            l[u++] = (An(E) - 1) * g, g = 1;
            break;
          case 64:
            Hn() === 45 && (E += Ec(zr())), p = Hn(), d = f = An(x = E += YA(Tc())), b++;
            break;
          case 45:
            y === 45 && An(E) == 2 && (h = 0);
        }
    }
  return a;
}
function B0(e, t, r, n, o, a, i, l, c, u, d) {
  for (var f = o - 1, p = o === 0 ? a : [""], m = cg(p), y = 0, h = 0, v = 0; y < n; ++y)
    for (var g = 0, b = Js(e, f + 1, f = AA(h = i[y])), x = e; g < m; ++g)
      (x = QT(h > 0 ? p[g] + " " + b : vt(b, /&\f/g, p[g]))) && (c[v++] = x);
  return ap(e, t, r, o === 0 ? sg : l, c, u, d);
}
function GA(e, t, r) {
  return ap(e, t, r, ig, np(zA()), Js(e, 2, -2), 0);
}
function W0(e, t, r, n) {
  return ap(e, t, r, lg, Js(e, 0, n), Js(e, n + 1, -1), n);
}
function _i(e, t) {
  for (var r = "", n = cg(e), o = 0; o < n; o++)
    r += t(e[o], o, e, t) || "";
  return r;
}
function KA(e, t, r, n) {
  switch (e.type) {
    case MA:
      if (e.children.length)
        break;
    case IA:
    case lg:
      return e.return = e.return || e.value;
    case ig:
      return "";
    case XT:
      return e.return = e.value + "{" + _i(e.children, n) + "}";
    case sg:
      e.value = e.props.join(",");
  }
  return An(r = _i(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function XA(e) {
  var t = cg(e);
  return function(r, n, o, a) {
    for (var i = "", l = 0; l < t; l++)
      i += e[l](r, n, o, a) || "";
    return i;
  };
}
function QA(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
var U0 = function(t) {
  var r = /* @__PURE__ */ new WeakMap();
  return function(n) {
    if (r.has(n))
      return r.get(n);
    var o = t(n);
    return r.set(n, o), o;
  };
}, ZA = function(t, r, n) {
  for (var o = 0, a = 0; o = a, a = Hn(), o === 38 && a === 12 && (r[n] = 1), !el(a); )
    zr();
  return vl(t, Dr);
}, JA = function(t, r) {
  var n = -1, o = 44;
  do
    switch (el(o)) {
      case 0:
        o === 38 && Hn() === 12 && (r[n] = 1), t[n] += ZA(Dr - 1, r, n);
        break;
      case 2:
        t[n] += Ec(o);
        break;
      case 4:
        if (o === 44) {
          t[++n] = Hn() === 58 ? "&\f" : "", r[n] = t[n].length;
          break;
        }
      default:
        t[n] += np(o);
    }
  while (o = zr());
  return t;
}, ej = function(t, r) {
  return eE(JA(JT(t), r));
}, H0 = /* @__PURE__ */ new WeakMap(), tj = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var r = t.value, n = t.parent, o = t.column === n.column && t.line === n.line; n.type !== "rule"; )
      if (n = n.parent, !n)
        return;
    if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !H0.get(n)) && !o) {
      H0.set(t, !0);
      for (var a = [], i = ej(r, a), l = n.props, c = 0, u = 0; c < i.length; c++)
        for (var d = 0; d < l.length; d++, u++)
          t.props[u] = a[c] ? i[c].replace(/&\f/g, l[d]) : l[d] + " " + i[c];
    }
  }
}, rj = function(t) {
  if (t.type === "decl") {
    var r = t.value;
    // charcode for l
    r.charCodeAt(0) === 108 && // charcode for b
    r.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
}, nj = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", oj = function(t) {
  return t.type === "comm" && t.children.indexOf(nj) > -1;
}, aj = function(t) {
  return function(r, n, o) {
    if (!(r.type !== "rule" || t.compat)) {
      var a = r.value.match(/(:first|:nth|:nth-last)-child/g);
      if (a) {
        for (var i = !!r.parent, l = i ? r.parent.children : (
          // global rule at the root level
          o
        ), c = l.length - 1; c >= 0; c--) {
          var u = l[c];
          if (u.line < r.line)
            break;
          if (u.column < r.column) {
            if (oj(u))
              return;
            break;
          }
        }
        a.forEach(function(d) {
          console.error('The pseudo class "' + d + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + d.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, tE = function(t) {
  return t.type.charCodeAt(1) === 105 && t.type.charCodeAt(0) === 64;
}, ij = function(t, r) {
  for (var n = t - 1; n >= 0; n--)
    if (!tE(r[n]))
      return !0;
  return !1;
}, Y0 = function(t) {
  t.type = "", t.value = "", t.return = "", t.children = "", t.props = "";
}, sj = function(t, r, n) {
  tE(t) && (t.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), Y0(t)) : ij(r, n) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), Y0(t)));
};
function rE(e, t) {
  switch (FA(e, t)) {
    case 5103:
      return yt + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return yt + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return yt + e + Su + e + pr + e + e;
    case 6828:
    case 4268:
      return yt + e + pr + e + e;
    case 6165:
      return yt + e + pr + "flex-" + e + e;
    case 5187:
      return yt + e + vt(e, /(\w+).+(:[^]+)/, yt + "box-$1$2" + pr + "flex-$1$2") + e;
    case 5443:
      return yt + e + pr + "flex-item-" + vt(e, /flex-|-self/, "") + e;
    case 4675:
      return yt + e + pr + "flex-line-pack" + vt(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return yt + e + pr + vt(e, "shrink", "negative") + e;
    case 5292:
      return yt + e + pr + vt(e, "basis", "preferred-size") + e;
    case 6060:
      return yt + "box-" + vt(e, "-grow", "") + yt + e + pr + vt(e, "grow", "positive") + e;
    case 4554:
      return yt + vt(e, /([^-])(transform)/g, "$1" + yt + "$2") + e;
    case 6187:
      return vt(vt(vt(e, /(zoom-|grab)/, yt + "$1"), /(image-set)/, yt + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return vt(e, /(image-set\([^]*)/, yt + "$1$`$1");
    case 4968:
      return vt(vt(e, /(.+:)(flex-)?(.*)/, yt + "box-pack:$3" + pr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + yt + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return vt(e, /(.+)-inline(.+)/, yt + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (An(e) - 1 - t > 6)
        switch (ur(e, t + 1)) {
          case 109:
            if (ur(e, t + 4) !== 45)
              break;
          case 102:
            return vt(e, /(.+:)(.+)-([^]+)/, "$1" + yt + "$2-$3$1" + Su + (ur(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          case 115:
            return ~Uh(e, "stretch") ? rE(vt(e, "stretch", "fill-available"), t) + e : e;
        }
      break;
    case 4949:
      if (ur(e, t + 1) !== 115)
        break;
    case 6444:
      switch (ur(e, An(e) - 3 - (~Uh(e, "!important") && 10))) {
        case 107:
          return vt(e, ":", ":" + yt) + e;
        case 101:
          return vt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + yt + (ur(e, 14) === 45 ? "inline-" : "") + "box$3$1" + yt + "$2$3$1" + pr + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (ur(e, t + 11)) {
        case 114:
          return yt + e + pr + vt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return yt + e + pr + vt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return yt + e + pr + vt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return yt + e + pr + e + e;
  }
  return e;
}
var lj = function(t, r, n, o) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case lg:
        t.return = rE(t.value, t.length);
        break;
      case XT:
        return _i([cs(t, {
          value: vt(t.value, "@", "@" + yt)
        })], o);
      case sg:
        if (t.length)
          return VA(t.props, function(a) {
            switch (LA(a, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return _i([cs(t, {
                  props: [vt(a, /:(read-\w+)/, ":" + Su + "$1")]
                })], o);
              case "::placeholder":
                return _i([cs(t, {
                  props: [vt(a, /:(plac\w+)/, ":" + yt + "input-$1")]
                }), cs(t, {
                  props: [vt(a, /:(plac\w+)/, ":" + Su + "$1")]
                }), cs(t, {
                  props: [vt(a, /:(plac\w+)/, pr + "input-$1")]
                })], o);
            }
            return "";
          });
    }
}, cj = [lj], nE = function(t) {
  var r = t.key;
  if (process.env.NODE_ENV !== "production" && !r)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (r === "css") {
    var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(n, function(h) {
      var v = h.getAttribute("data-emotion");
      v.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var o = t.stylisPlugins || cj;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(r))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + r + '" was passed');
  var a = {}, i, l = [];
  i = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
    function(h) {
      for (var v = h.getAttribute("data-emotion").split(" "), g = 1; g < v.length; g++)
        a[v[g]] = !0;
      l.push(h);
    }
  );
  var c, u = [tj, rj];
  process.env.NODE_ENV !== "production" && u.push(aj({
    get compat() {
      return y.compat;
    }
  }), sj);
  {
    var d, f = [KA, process.env.NODE_ENV !== "production" ? function(h) {
      h.root || (h.return ? d.insert(h.return) : h.value && h.type !== ig && d.insert(h.value + "{}"));
    } : QA(function(h) {
      d.insert(h);
    })], p = XA(u.concat(o, f)), m = function(v) {
      return _i(qA(v), p);
    };
    c = function(v, g, b, x) {
      d = b, process.env.NODE_ENV !== "production" && g.map !== void 0 && (d = {
        insert: function(w) {
          b.insert(w + g.map);
        }
      }), m(v ? v + "{" + g.styles + "}" : g.styles), x && (y.inserted[g.name] = !0);
    };
  }
  var y = {
    key: r,
    sheet: new NA({
      key: r,
      container: i,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return y.sheet.hydrate(l), y;
}, oE = ng, uj = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, dj = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, aE = {};
aE[oE.ForwardRef] = uj;
aE[oE.Memo] = dj;
var fj = !0;
function ip(e, t, r) {
  var n = "";
  return r.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : n += o + " ";
  }), n;
}
var sp = function(t, r, n) {
  var o = t.key + "-" + r.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (n === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  fj === !1) && t.registered[o] === void 0 && (t.registered[o] = r.styles);
}, gl = function(t, r, n) {
  sp(t, r, n);
  var o = t.key + "-" + r.name;
  if (t.inserted[r.name] === void 0) {
    var a = r;
    do
      t.insert(r === a ? "." + o : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function pj(e) {
  for (var t = 0, r, n = 0, o = e.length; o >= 4; ++n, o -= 4)
    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(n + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(n + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var mj = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, q0 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, hj = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", yj = /[A-Z]|^ms/g, iE = /_EMO_([^_]+?)_([^]*?)_EMO_/g, ug = function(t) {
  return t.charCodeAt(1) === 45;
}, G0 = function(t) {
  return t != null && typeof t != "boolean";
}, Sm = /* @__PURE__ */ KT(function(e) {
  return ug(e) ? e : e.replace(yj, "-$&").toLowerCase();
}), Tu = function(t, r) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof r == "string")
        return r.replace(iE, function(n, o, a) {
          return Pn = {
            name: o,
            styles: a,
            next: Pn
          }, o;
        });
  }
  return mj[t] !== 1 && !ug(t) && typeof r == "number" && r !== 0 ? r + "px" : r;
};
if (process.env.NODE_ENV !== "production") {
  var vj = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, gj = ["normal", "none", "initial", "inherit", "unset"], bj = Tu, wj = /^-ms-/, xj = /-(.)/g, K0 = {};
  Tu = function(t, r) {
    if (t === "content" && (typeof r != "string" || gj.indexOf(r) === -1 && !vj.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + r + "\"'`");
    var n = bj(t, r);
    return n !== "" && !ug(t) && t.indexOf("-") !== -1 && K0[t] === void 0 && (K0[t] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + t.replace(wj, "ms-").replace(xj, function(o, a) {
      return a.toUpperCase();
    }) + "?")), n;
  };
}
var sE = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function tl(e, t, r) {
  if (r == null)
    return "";
  if (r.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && r.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(sE);
    return r;
  }
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      if (r.anim === 1)
        return Pn = {
          name: r.name,
          styles: r.styles,
          next: Pn
        }, r.name;
      if (r.styles !== void 0) {
        var n = r.next;
        if (n !== void 0)
          for (; n !== void 0; )
            Pn = {
              name: n.name,
              styles: n.styles,
              next: Pn
            }, n = n.next;
        var o = r.styles + ";";
        return process.env.NODE_ENV !== "production" && r.map !== void 0 && (o += r.map), o;
      }
      return _j(e, t, r);
    }
    case "function": {
      if (e !== void 0) {
        var a = Pn, i = r(e);
        return Pn = a, tl(e, t, i);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var l = [], c = r.replace(iE, function(d, f, p) {
          var m = "animation" + l.length;
          return l.push("const " + m + " = keyframes`" + p.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + m + "}";
        });
        l.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(l, ["`" + c + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + c + "`"));
      }
      break;
  }
  if (t == null)
    return r;
  var u = t[r];
  return u !== void 0 ? u : r;
}
function _j(e, t, r) {
  var n = "";
  if (Array.isArray(r))
    for (var o = 0; o < r.length; o++)
      n += tl(e, t, r[o]) + ";";
  else
    for (var a in r) {
      var i = r[a];
      if (typeof i != "object")
        t != null && t[i] !== void 0 ? n += a + "{" + t[i] + "}" : G0(i) && (n += Sm(a) + ":" + Tu(a, i) + ";");
      else {
        if (a === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(sE);
        if (Array.isArray(i) && typeof i[0] == "string" && (t == null || t[i[0]] === void 0))
          for (var l = 0; l < i.length; l++)
            G0(i[l]) && (n += Sm(a) + ":" + Tu(a, i[l]) + ";");
        else {
          var c = tl(e, t, i);
          switch (a) {
            case "animation":
            case "animationName": {
              n += Sm(a) + ":" + c + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && a === "undefined" && console.error(hj), n += a + "{" + c + "}";
          }
        }
      }
    }
  return n;
}
var X0 = /label:\s*([^\s;\n{]+)\s*(;|$)/g, lE;
process.env.NODE_ENV !== "production" && (lE = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var Pn, ka = function(t, r, n) {
  if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
    return t[0];
  var o = !0, a = "";
  Pn = void 0;
  var i = t[0];
  i == null || i.raw === void 0 ? (o = !1, a += tl(n, r, i)) : (process.env.NODE_ENV !== "production" && i[0] === void 0 && console.error(q0), a += i[0]);
  for (var l = 1; l < t.length; l++)
    a += tl(n, r, t[l]), o && (process.env.NODE_ENV !== "production" && i[l] === void 0 && console.error(q0), a += i[l]);
  var c;
  process.env.NODE_ENV !== "production" && (a = a.replace(lE, function(p) {
    return c = p, "";
  })), X0.lastIndex = 0;
  for (var u = "", d; (d = X0.exec(a)) !== null; )
    u += "-" + // $FlowFixMe we know it's not null
    d[1];
  var f = pj(a) + u;
  return process.env.NODE_ENV !== "production" ? {
    name: f,
    styles: a,
    map: c,
    next: Pn,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: f,
    styles: a,
    next: Pn
  };
}, Oj = function(t) {
  return t();
}, cE = P["useInsertionEffect"] ? P["useInsertionEffect"] : !1, dg = cE || Oj, Q0 = cE || P.useLayoutEffect, Pj = {}.hasOwnProperty, fg = /* @__PURE__ */ Br(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ nE({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (fg.displayName = "EmotionCacheContext");
fg.Provider;
var lp = function(t) {
  return /* @__PURE__ */ Ne(function(r, n) {
    var o = ar(fg);
    return t(r, o, n);
  });
}, yo = /* @__PURE__ */ Br({});
process.env.NODE_ENV !== "production" && (yo.displayName = "EmotionThemeContext");
var Sj = function(t, r) {
  if (typeof r == "function") {
    var n = r(t);
    if (process.env.NODE_ENV !== "production" && (n == null || typeof n != "object" || Array.isArray(n)))
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    return n;
  }
  if (process.env.NODE_ENV !== "production" && (r == null || typeof r != "object" || Array.isArray(r)))
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  return T({}, t, r);
}, Tj = /* @__PURE__ */ U0(function(e) {
  return U0(function(t) {
    return Sj(e, t);
  });
}), Ej = function(t) {
  var r = ar(yo);
  return t.theme !== r && (r = Tj(r)(t.theme)), /* @__PURE__ */ et(yo.Provider, {
    value: r
  }, t.children);
}, Z0 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", J0 = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", $j = function(t) {
  var r = t.cache, n = t.serialized, o = t.isStringTag;
  return sp(r, n, o), dg(function() {
    return gl(r, n, o);
  }), null;
}, Cj = /* @__PURE__ */ lp(function(e, t, r) {
  var n = e.css;
  typeof n == "string" && t.registered[n] !== void 0 && (n = t.registered[n]);
  var o = e[Z0], a = [n], i = "";
  typeof e.className == "string" ? i = ip(t.registered, a, e.className) : e.className != null && (i = e.className + " ");
  var l = ka(a, void 0, ar(yo));
  if (process.env.NODE_ENV !== "production" && l.name.indexOf("-") === -1) {
    var c = e[J0];
    c && (l = ka([l, "label:" + c + ";"]));
  }
  i += t.key + "-" + l.name;
  var u = {};
  for (var d in e)
    Pj.call(e, d) && d !== "css" && d !== Z0 && (process.env.NODE_ENV === "production" || d !== J0) && (u[d] = e[d]);
  return u.ref = r, u.className = i, /* @__PURE__ */ et(Yi, null, /* @__PURE__ */ et($j, {
    cache: t,
    serialized: l,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ et(o, u));
});
process.env.NODE_ENV !== "production" && (Cj.displayName = "EmotionCssPropInternal");
var kj = {
  name: "@emotion/react",
  version: "11.10.6",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": "./macro.js"
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.js",
    "macro.d.ts",
    "macro.js.flow"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.10.6",
    "@emotion/cache": "^11.10.5",
    "@emotion/serialize": "^1.1.1",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
    "@emotion/utils": "^1.2.0",
    "@emotion/weak-memoize": "^0.3.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.10.6",
    "@emotion/css-prettifier": "1.1.1",
    "@emotion/server": "11.10.0",
    "@emotion/styled": "11.10.6",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      }
    }
  }
}, ew = !1, Ki = /* @__PURE__ */ lp(function(e, t) {
  process.env.NODE_ENV !== "production" && !ew && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (e.className || e.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), ew = !0);
  var r = e.styles, n = ka([r], void 0, ar(yo)), o = qe();
  return Q0(function() {
    var a = t.key + "-global", i = new t.sheet.constructor({
      key: a,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), l = !1, c = document.querySelector('style[data-emotion="' + a + " " + n.name + '"]');
    return t.sheet.tags.length && (i.before = t.sheet.tags[0]), c !== null && (l = !0, c.setAttribute("data-emotion", a), i.hydrate([c])), o.current = [i, l], function() {
      i.flush();
    };
  }, [t]), Q0(function() {
    var a = o.current, i = a[0], l = a[1];
    if (l) {
      a[1] = !1;
      return;
    }
    if (n.next !== void 0 && gl(t, n.next, !0), i.tags.length) {
      var c = i.tags[i.tags.length - 1].nextElementSibling;
      i.before = c, i.flush();
    }
    t.insert("", n, i, !1);
  }, [t, n.name]), null;
});
process.env.NODE_ENV !== "production" && (Ki.displayName = "EmotionGlobal");
function Rj() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return ka(t);
}
var _o = function() {
  var t = Rj.apply(void 0, arguments), r = "animation-" + t.name;
  return {
    name: r,
    styles: "@keyframes " + r + "{" + t.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, Dj = function e(t) {
  for (var r = t.length, n = 0, o = ""; n < r; n++) {
    var a = t[n];
    if (a != null) {
      var i = void 0;
      switch (typeof a) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(a))
            i = e(a);
          else {
            process.env.NODE_ENV !== "production" && a.styles !== void 0 && a.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), i = "";
            for (var l in a)
              a[l] && l && (i && (i += " "), i += l);
          }
          break;
        }
        default:
          i = a;
      }
      i && (o && (o += " "), o += i);
    }
  }
  return o;
};
function Nj(e, t, r) {
  var n = [], o = ip(e, n, r);
  return n.length < 2 ? r : o + t(n);
}
var Ij = function(t) {
  var r = t.cache, n = t.serializedArr;
  return dg(function() {
    for (var o = 0; o < n.length; o++)
      gl(r, n[o], !1);
  }), null;
}, Mj = /* @__PURE__ */ lp(function(e, t) {
  var r = !1, n = [], o = function() {
    if (r && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var u = arguments.length, d = new Array(u), f = 0; f < u; f++)
      d[f] = arguments[f];
    var p = ka(d, t.registered);
    return n.push(p), sp(t, p, !1), t.key + "-" + p.name;
  }, a = function() {
    if (r && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var u = arguments.length, d = new Array(u), f = 0; f < u; f++)
      d[f] = arguments[f];
    return Nj(t.registered, o, Dj(d));
  }, i = {
    css: o,
    cx: a,
    theme: ar(yo)
  }, l = e.children(i);
  return r = !0, /* @__PURE__ */ et(Yi, null, /* @__PURE__ */ et(Ij, {
    cache: t,
    serializedArr: n
  }), l);
});
process.env.NODE_ENV !== "production" && (Mj.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var tw = !0, Aj = typeof jest < "u" || typeof vi < "u";
  if (tw && !Aj) {
    var rw = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : tw ? window : global
    ), nw = "__EMOTION_REACT_" + kj.version.split(".")[0] + "__";
    rw[nw] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), rw[nw] = !0;
  }
}
var jj = kA, Fj = function(t) {
  return t !== "theme";
}, ow = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? jj : Fj;
}, aw = function(t, r, n) {
  var o;
  if (r) {
    var a = r.shouldForwardProp;
    o = t.__emotion_forwardProp && a ? function(i) {
      return t.__emotion_forwardProp(i) && a(i);
    } : a;
  }
  return typeof o != "function" && n && (o = t.__emotion_forwardProp), o;
}, iw = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, Lj = function(t) {
  var r = t.cache, n = t.serialized, o = t.isStringTag;
  return sp(r, n, o), dg(function() {
    return gl(r, n, o);
  }), null;
}, Vj = function e(t, r) {
  if (process.env.NODE_ENV !== "production" && t === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var n = t.__emotion_real === t, o = n && t.__emotion_base || t, a, i;
  r !== void 0 && (a = r.label, i = r.target);
  var l = aw(t, r, n), c = l || ow(o), u = !c("as");
  return function() {
    var d = arguments, f = n && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (a !== void 0 && f.push("label:" + a + ";"), d[0] == null || d[0].raw === void 0)
      f.push.apply(f, d);
    else {
      process.env.NODE_ENV !== "production" && d[0][0] === void 0 && console.error(iw), f.push(d[0][0]);
      for (var p = d.length, m = 1; m < p; m++)
        process.env.NODE_ENV !== "production" && d[0][m] === void 0 && console.error(iw), f.push(d[m], d[0][m]);
    }
    var y = lp(function(h, v, g) {
      var b = u && h.as || o, x = "", O = [], w = h;
      if (h.theme == null) {
        w = {};
        for (var S in h)
          w[S] = h[S];
        w.theme = ar(yo);
      }
      typeof h.className == "string" ? x = ip(v.registered, O, h.className) : h.className != null && (x = h.className + " ");
      var E = ka(f.concat(O), v.registered, w);
      x += v.key + "-" + E.name, i !== void 0 && (x += " " + i);
      var C = u && l === void 0 ? ow(b) : c, N = {};
      for (var $ in h)
        u && $ === "as" || // $FlowFixMe
        C($) && (N[$] = h[$]);
      return N.className = x, N.ref = g, /* @__PURE__ */ et(Yi, null, /* @__PURE__ */ et(Lj, {
        cache: v,
        serialized: E,
        isStringTag: typeof b == "string"
      }), /* @__PURE__ */ et(b, N));
    });
    return y.displayName = a !== void 0 ? a : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", y.defaultProps = t.defaultProps, y.__emotion_real = y, y.__emotion_base = o, y.__emotion_styles = f, y.__emotion_forwardProp = l, Object.defineProperty(y, "toString", {
      value: function() {
        return i === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + i;
      }
    }), y.withComponent = function(h, v) {
      return e(h, T({}, r, v, {
        shouldForwardProp: aw(y, v, !0)
      })).apply(void 0, f);
    }, y;
  };
};
const zj = Vj;
var Bj = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Yh = zj.bind();
Bj.forEach(function(e) {
  Yh[e] = Yh(e);
});
const Wj = Yh;
function Uj(e) {
  return e == null || Object.keys(e).length === 0;
}
function uE(e) {
  const {
    styles: t,
    defaultTheme: r = {}
  } = e, n = typeof t == "function" ? (o) => t(Uj(o) ? r : o) : t;
  return /* @__PURE__ */ _.jsx(Ki, {
    styles: n
  });
}
process.env.NODE_ENV !== "production" && (uE.propTypes = {
  defaultTheme: s.object,
  styles: s.oneOfType([s.array, s.string, s.object, s.func])
});
/**
 * @mui/styled-engine v5.13.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function Hj(e, t) {
  const r = Wj(e, t);
  return process.env.NODE_ENV !== "production" ? (...n) => {
    const o = typeof e == "string" ? `"${e}"` : "component";
    return n.length === 0 ? console.error([`MUI: Seems like you called \`styled(${o})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : n.some((a) => a === void 0) && console.error(`MUI: the styled(${o})(...args) API requires all its args to be defined.`), r(...n);
  } : r;
}
const Yj = (e, t) => {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}, qj = ["values", "unit", "step"], Gj = (e) => {
  const t = Object.keys(e).map((r) => ({
    key: r,
    val: e[r]
  })) || [];
  return t.sort((r, n) => r.val - n.val), t.reduce((r, n) => T({}, r, {
    [n.key]: n.val
  }), {});
};
function Kj(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: r = "px",
    step: n = 5
  } = e, o = ge(e, qj), a = Gj(t), i = Object.keys(a);
  function l(p) {
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${r})`;
  }
  function c(p) {
    return `@media (max-width:${(typeof t[p] == "number" ? t[p] : p) - n / 100}${r})`;
  }
  function u(p, m) {
    const y = i.indexOf(m);
    return `@media (min-width:${typeof t[p] == "number" ? t[p] : p}${r}) and (max-width:${(y !== -1 && typeof t[i[y]] == "number" ? t[i[y]] : m) - n / 100}${r})`;
  }
  function d(p) {
    return i.indexOf(p) + 1 < i.length ? u(p, i[i.indexOf(p) + 1]) : l(p);
  }
  function f(p) {
    const m = i.indexOf(p);
    return m === 0 ? l(i[1]) : m === i.length - 1 ? c(i[m]) : u(p, i[i.indexOf(p) + 1]).replace("@media", "@media not all and");
  }
  return T({
    keys: i,
    values: a,
    up: l,
    down: c,
    between: u,
    only: d,
    not: f,
    unit: r
  }, o);
}
const Xj = {
  borderRadius: 4
}, Qj = Xj, Zj = process.env.NODE_ENV !== "production" ? s.oneOfType([s.number, s.string, s.object, s.array]) : {}, Qo = Zj;
function Fs(e, t) {
  return t ? an(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const pg = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, sw = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${pg[e]}px)`
};
function pn(e, t, r) {
  const n = e.theme || {};
  if (Array.isArray(t)) {
    const a = n.breakpoints || sw;
    return t.reduce((i, l, c) => (i[a.up(a.keys[c])] = r(t[c]), i), {});
  }
  if (typeof t == "object") {
    const a = n.breakpoints || sw;
    return Object.keys(t).reduce((i, l) => {
      if (Object.keys(a.values || pg).indexOf(l) !== -1) {
        const c = a.up(l);
        i[c] = r(t[l], l);
      } else {
        const c = l;
        i[c] = t[c];
      }
      return i;
    }, {});
  }
  return r(t);
}
function Jj(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((n, o) => {
    const a = e.up(o);
    return n[a] = {}, n;
  }, {})) || {};
}
function eF(e, t) {
  return e.reduce((r, n) => {
    const o = r[n];
    return (!o || Object.keys(o).length === 0) && delete r[n], r;
  }, t);
}
function tF(e, t) {
  if (typeof e != "object")
    return {};
  const r = {}, n = Object.keys(t);
  return Array.isArray(e) ? n.forEach((o, a) => {
    a < e.length && (r[o] = !0);
  }) : n.forEach((o) => {
    e[o] != null && (r[o] = !0);
  }), r;
}
function cp({
  values: e,
  breakpoints: t,
  base: r
}) {
  const n = r || tF(e, t), o = Object.keys(n);
  if (o.length === 0)
    return e;
  let a;
  return o.reduce((i, l, c) => (Array.isArray(e) ? (i[l] = e[c] != null ? e[c] : e[a], a = c) : typeof e == "object" ? (i[l] = e[l] != null ? e[l] : e[a], a = l) : i[l] = e, i), {});
}
function up(e, t, r = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && r) {
    const n = `vars.${t}`.split(".").reduce((o, a) => o && o[a] ? o[a] : null, e);
    if (n != null)
      return n;
  }
  return t.split(".").reduce((n, o) => n && n[o] != null ? n[o] : null, e);
}
function Eu(e, t, r, n = r) {
  let o;
  return typeof e == "function" ? o = e(r) : Array.isArray(e) ? o = e[r] || n : o = up(e, r) || n, t && (o = t(o, n, e)), o;
}
function St(e) {
  const {
    prop: t,
    cssProperty: r = e.prop,
    themeKey: n,
    transform: o
  } = e, a = (i) => {
    if (i[t] == null)
      return null;
    const l = i[t], c = i.theme, u = up(c, n) || {};
    return pn(i, l, (f) => {
      let p = Eu(u, o, f);
      return f === p && typeof f == "string" && (p = Eu(u, o, `${t}${f === "default" ? "" : Te(f)}`, f)), r === !1 ? p : {
        [r]: p
      };
    });
  };
  return a.propTypes = process.env.NODE_ENV !== "production" ? {
    [t]: Qo
  } : {}, a.filterProps = [t], a;
}
function rF(e) {
  const t = {};
  return (r) => (t[r] === void 0 && (t[r] = e(r)), t[r]);
}
const nF = {
  m: "margin",
  p: "padding"
}, oF = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, lw = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, aF = rF((e) => {
  if (e.length > 2)
    if (lw[e])
      e = lw[e];
    else
      return [e];
  const [t, r] = e.split(""), n = nF[t], o = oF[r] || "";
  return Array.isArray(o) ? o.map((a) => n + a) : [n + o];
}), dp = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], fp = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], iF = [...dp, ...fp];
function bl(e, t, r, n) {
  var o;
  const a = (o = up(e, t, !1)) != null ? o : r;
  return typeof a == "number" ? (i) => typeof i == "string" ? i : (process.env.NODE_ENV !== "production" && typeof i != "number" && console.error(`MUI: Expected ${n} argument to be a number or a string, got ${i}.`), a * i) : Array.isArray(a) ? (i) => typeof i == "string" ? i : (process.env.NODE_ENV !== "production" && (Number.isInteger(i) ? i > a.length - 1 && console.error([`MUI: The value provided (${i}) overflows.`, `The supported values are: ${JSON.stringify(a)}.`, `${i} > ${a.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${t}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${t}\` as a number.`].join(`
`))), a[i]) : typeof a == "function" ? a : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${t}\` value (${a}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function dE(e) {
  return bl(e, "spacing", 8, "spacing");
}
function wl(e, t) {
  if (typeof t == "string" || t == null)
    return t;
  const r = Math.abs(t), n = e(r);
  return t >= 0 ? n : typeof n == "number" ? -n : `-${n}`;
}
function sF(e, t) {
  return (r) => e.reduce((n, o) => (n[o] = wl(t, r), n), {});
}
function lF(e, t, r, n) {
  if (t.indexOf(r) === -1)
    return null;
  const o = aF(r), a = sF(o, n), i = e[r];
  return pn(e, i, a);
}
function fE(e, t) {
  const r = dE(e.theme);
  return Object.keys(e).map((n) => lF(e, t, n, r)).reduce(Fs, {});
}
function Vt(e) {
  return fE(e, dp);
}
Vt.propTypes = process.env.NODE_ENV !== "production" ? dp.reduce((e, t) => (e[t] = Qo, e), {}) : {};
Vt.filterProps = dp;
function zt(e) {
  return fE(e, fp);
}
zt.propTypes = process.env.NODE_ENV !== "production" ? fp.reduce((e, t) => (e[t] = Qo, e), {}) : {};
zt.filterProps = fp;
process.env.NODE_ENV !== "production" && iF.reduce((e, t) => (e[t] = Qo, e), {});
function cF(e = 8) {
  if (e.mui)
    return e;
  const t = dE({
    spacing: e
  }), r = (...n) => (process.env.NODE_ENV !== "production" && (n.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${n.length}`)), (n.length === 0 ? [1] : n).map((a) => {
    const i = t(a);
    return typeof i == "number" ? `${i}px` : i;
  }).join(" "));
  return r.mui = !0, r;
}
function pp(...e) {
  const t = e.reduce((n, o) => (o.filterProps.forEach((a) => {
    n[a] = o;
  }), n), {}), r = (n) => Object.keys(n).reduce((o, a) => t[a] ? Fs(o, t[a](n)) : o, {});
  return r.propTypes = process.env.NODE_ENV !== "production" ? e.reduce((n, o) => Object.assign(n, o.propTypes), {}) : {}, r.filterProps = e.reduce((n, o) => n.concat(o.filterProps), []), r;
}
function Ln(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
const uF = St({
  prop: "border",
  themeKey: "borders",
  transform: Ln
}), dF = St({
  prop: "borderTop",
  themeKey: "borders",
  transform: Ln
}), fF = St({
  prop: "borderRight",
  themeKey: "borders",
  transform: Ln
}), pF = St({
  prop: "borderBottom",
  themeKey: "borders",
  transform: Ln
}), mF = St({
  prop: "borderLeft",
  themeKey: "borders",
  transform: Ln
}), hF = St({
  prop: "borderColor",
  themeKey: "palette"
}), yF = St({
  prop: "borderTopColor",
  themeKey: "palette"
}), vF = St({
  prop: "borderRightColor",
  themeKey: "palette"
}), gF = St({
  prop: "borderBottomColor",
  themeKey: "palette"
}), bF = St({
  prop: "borderLeftColor",
  themeKey: "palette"
}), mp = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = bl(e.theme, "shape.borderRadius", 4, "borderRadius"), r = (n) => ({
      borderRadius: wl(t, n)
    });
    return pn(e, e.borderRadius, r);
  }
  return null;
};
mp.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: Qo
} : {};
mp.filterProps = ["borderRadius"];
pp(uF, dF, fF, pF, mF, hF, yF, vF, gF, bF, mp);
const hp = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = bl(e.theme, "spacing", 8, "gap"), r = (n) => ({
      gap: wl(t, n)
    });
    return pn(e, e.gap, r);
  }
  return null;
};
hp.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: Qo
} : {};
hp.filterProps = ["gap"];
const yp = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = bl(e.theme, "spacing", 8, "columnGap"), r = (n) => ({
      columnGap: wl(t, n)
    });
    return pn(e, e.columnGap, r);
  }
  return null;
};
yp.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: Qo
} : {};
yp.filterProps = ["columnGap"];
const vp = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = bl(e.theme, "spacing", 8, "rowGap"), r = (n) => ({
      rowGap: wl(t, n)
    });
    return pn(e, e.rowGap, r);
  }
  return null;
};
vp.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: Qo
} : {};
vp.filterProps = ["rowGap"];
const wF = St({
  prop: "gridColumn"
}), xF = St({
  prop: "gridRow"
}), _F = St({
  prop: "gridAutoFlow"
}), OF = St({
  prop: "gridAutoColumns"
}), PF = St({
  prop: "gridAutoRows"
}), SF = St({
  prop: "gridTemplateColumns"
}), TF = St({
  prop: "gridTemplateRows"
}), EF = St({
  prop: "gridTemplateAreas"
}), $F = St({
  prop: "gridArea"
});
pp(hp, yp, vp, wF, xF, _F, OF, PF, SF, TF, EF, $F);
function Oi(e, t) {
  return t === "grey" ? t : e;
}
const CF = St({
  prop: "color",
  themeKey: "palette",
  transform: Oi
}), kF = St({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Oi
}), RF = St({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Oi
});
pp(CF, kF, RF);
function Fr(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const DF = St({
  prop: "width",
  transform: Fr
}), mg = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (r) => {
      var n, o, a;
      return {
        maxWidth: ((n = e.theme) == null || (o = n.breakpoints) == null || (a = o.values) == null ? void 0 : a[r]) || pg[r] || Fr(r)
      };
    };
    return pn(e, e.maxWidth, t);
  }
  return null;
};
mg.filterProps = ["maxWidth"];
const NF = St({
  prop: "minWidth",
  transform: Fr
}), IF = St({
  prop: "height",
  transform: Fr
}), MF = St({
  prop: "maxHeight",
  transform: Fr
}), AF = St({
  prop: "minHeight",
  transform: Fr
});
St({
  prop: "size",
  cssProperty: "width",
  transform: Fr
});
St({
  prop: "size",
  cssProperty: "height",
  transform: Fr
});
const jF = St({
  prop: "boxSizing"
});
pp(DF, mg, NF, IF, MF, AF, jF);
const FF = {
  // borders
  border: {
    themeKey: "borders",
    transform: Ln
  },
  borderTop: {
    themeKey: "borders",
    transform: Ln
  },
  borderRight: {
    themeKey: "borders",
    transform: Ln
  },
  borderBottom: {
    themeKey: "borders",
    transform: Ln
  },
  borderLeft: {
    themeKey: "borders",
    transform: Ln
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: mp
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Oi
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Oi
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Oi
  },
  // spacing
  p: {
    style: zt
  },
  pt: {
    style: zt
  },
  pr: {
    style: zt
  },
  pb: {
    style: zt
  },
  pl: {
    style: zt
  },
  px: {
    style: zt
  },
  py: {
    style: zt
  },
  padding: {
    style: zt
  },
  paddingTop: {
    style: zt
  },
  paddingRight: {
    style: zt
  },
  paddingBottom: {
    style: zt
  },
  paddingLeft: {
    style: zt
  },
  paddingX: {
    style: zt
  },
  paddingY: {
    style: zt
  },
  paddingInline: {
    style: zt
  },
  paddingInlineStart: {
    style: zt
  },
  paddingInlineEnd: {
    style: zt
  },
  paddingBlock: {
    style: zt
  },
  paddingBlockStart: {
    style: zt
  },
  paddingBlockEnd: {
    style: zt
  },
  m: {
    style: Vt
  },
  mt: {
    style: Vt
  },
  mr: {
    style: Vt
  },
  mb: {
    style: Vt
  },
  ml: {
    style: Vt
  },
  mx: {
    style: Vt
  },
  my: {
    style: Vt
  },
  margin: {
    style: Vt
  },
  marginTop: {
    style: Vt
  },
  marginRight: {
    style: Vt
  },
  marginBottom: {
    style: Vt
  },
  marginLeft: {
    style: Vt
  },
  marginX: {
    style: Vt
  },
  marginY: {
    style: Vt
  },
  marginInline: {
    style: Vt
  },
  marginInlineStart: {
    style: Vt
  },
  marginInlineEnd: {
    style: Vt
  },
  marginBlock: {
    style: Vt
  },
  marginBlockStart: {
    style: Vt
  },
  marginBlockEnd: {
    style: Vt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: hp
  },
  rowGap: {
    style: vp
  },
  columnGap: {
    style: yp
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Fr
  },
  maxWidth: {
    style: mg
  },
  minWidth: {
    transform: Fr
  },
  height: {
    transform: Fr
  },
  maxHeight: {
    transform: Fr
  },
  minHeight: {
    transform: Fr
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
}, gp = FF;
function LF(...e) {
  const t = e.reduce((n, o) => n.concat(Object.keys(o)), []), r = new Set(t);
  return e.every((n) => r.size === Object.keys(n).length);
}
function VF(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function zF() {
  function e(r, n, o, a) {
    const i = {
      [r]: n,
      theme: o
    }, l = a[r];
    if (!l)
      return {
        [r]: n
      };
    const {
      cssProperty: c = r,
      themeKey: u,
      transform: d,
      style: f
    } = l;
    if (n == null)
      return null;
    if (u === "typography" && n === "inherit")
      return {
        [r]: n
      };
    const p = up(o, u) || {};
    return f ? f(i) : pn(i, n, (y) => {
      let h = Eu(p, d, y);
      return y === h && typeof y == "string" && (h = Eu(p, d, `${r}${y === "default" ? "" : Te(y)}`, y)), c === !1 ? h : {
        [c]: h
      };
    });
  }
  function t(r) {
    var n;
    const {
      sx: o,
      theme: a = {}
    } = r || {};
    if (!o)
      return null;
    const i = (n = a.unstable_sxConfig) != null ? n : gp;
    function l(c) {
      let u = c;
      if (typeof c == "function")
        u = c(a);
      else if (typeof c != "object")
        return c;
      if (!u)
        return null;
      const d = Jj(a.breakpoints), f = Object.keys(d);
      let p = d;
      return Object.keys(u).forEach((m) => {
        const y = VF(u[m], a);
        if (y != null)
          if (typeof y == "object")
            if (i[m])
              p = Fs(p, e(m, y, a, i));
            else {
              const h = pn({
                theme: a
              }, y, (v) => ({
                [m]: v
              }));
              LF(h, y) ? p[m] = t({
                sx: y,
                theme: a
              }) : p = Fs(p, h);
            }
          else
            p = Fs(p, e(m, y, a, i));
      }), eF(f, p);
    }
    return Array.isArray(o) ? o.map(l) : l(o);
  }
  return t;
}
const pE = zF();
pE.filterProps = ["sx"];
const hg = pE, BF = ["breakpoints", "palette", "spacing", "shape"];
function yg(e = {}, ...t) {
  const {
    breakpoints: r = {},
    palette: n = {},
    spacing: o,
    shape: a = {}
  } = e, i = ge(e, BF), l = Kj(r), c = cF(o);
  let u = an({
    breakpoints: l,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: T({
      mode: "light"
    }, n),
    spacing: c,
    shape: T({}, Qj, a)
  }, i);
  return u = t.reduce((d, f) => an(d, f), u), u.unstable_sxConfig = T({}, gp, i == null ? void 0 : i.unstable_sxConfig), u.unstable_sx = function(f) {
    return hg({
      sx: f,
      theme: this
    });
  }, u;
}
function WF(e) {
  return Object.keys(e).length === 0;
}
function bp(e = null) {
  const t = P.useContext(yo);
  return !t || WF(t) ? e : t;
}
const UF = yg();
function xl(e = UF) {
  return bp(e);
}
function mE({
  styles: e,
  themeId: t,
  defaultTheme: r = {}
}) {
  const n = xl(r), o = typeof e == "function" ? e(t && n[t] || n) : e;
  return /* @__PURE__ */ _.jsx(uE, {
    styles: o
  });
}
process.env.NODE_ENV !== "production" && (mE.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  defaultTheme: s.object,
  /**
   * @ignore
   */
  styles: s.oneOfType([s.array, s.func, s.number, s.object, s.string, s.bool]),
  /**
   * @ignore
   */
  themeId: s.string
});
const HF = ["sx"], YF = (e) => {
  var t, r;
  const n = {
    systemProps: {},
    otherProps: {}
  }, o = (t = e == null || (r = e.theme) == null ? void 0 : r.unstable_sxConfig) != null ? t : gp;
  return Object.keys(e).forEach((a) => {
    o[a] ? n.systemProps[a] = e[a] : n.otherProps[a] = e[a];
  }), n;
};
function hE(e) {
  const {
    sx: t
  } = e, r = ge(e, HF), {
    systemProps: n,
    otherProps: o
  } = YF(r);
  let a;
  return Array.isArray(t) ? a = [n, ...t] : typeof t == "function" ? a = (...i) => {
    const l = t(...i);
    return ya(l) ? T({}, n, l) : n;
  } : a = T({}, n, t), T({}, o, {
    sx: a
  });
}
function yE(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (r = yE(e[t])) && (n && (n += " "), n += r);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function Pe() {
  for (var e, t, r = 0, n = ""; r < arguments.length; )
    (e = arguments[r++]) && (t = yE(e)) && (n && (n += " "), n += t);
  return n;
}
const qF = ["variant"];
function cw(e) {
  return e.length === 0;
}
function vE(e) {
  const {
    variant: t
  } = e, r = ge(e, qF);
  let n = t || "";
  return Object.keys(r).sort().forEach((o) => {
    o === "color" ? n += cw(n) ? e[o] : Te(e[o]) : n += `${cw(n) ? o : Te(o)}${Te(e[o].toString())}`;
  }), n;
}
const GF = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function KF(e) {
  return Object.keys(e).length === 0;
}
function XF(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
const QF = (e, t) => t.components && t.components[e] && t.components[e].styleOverrides ? t.components[e].styleOverrides : null, ZF = (e, t) => {
  let r = [];
  t && t.components && t.components[e] && t.components[e].variants && (r = t.components[e].variants);
  const n = {};
  return r.forEach((o) => {
    const a = vE(o.props);
    n[a] = o.style;
  }), n;
}, JF = (e, t, r, n) => {
  var o, a;
  const {
    ownerState: i = {}
  } = e, l = [], c = r == null || (o = r.components) == null || (a = o[n]) == null ? void 0 : a.variants;
  return c && c.forEach((u) => {
    let d = !0;
    Object.keys(u.props).forEach((f) => {
      i[f] !== u.props[f] && e[f] !== u.props[f] && (d = !1);
    }), d && l.push(t[vE(u.props)]);
  }), l;
};
function Ls(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const eL = yg(), tL = (e) => e.charAt(0).toLowerCase() + e.slice(1);
function us({
  defaultTheme: e,
  theme: t,
  themeId: r
}) {
  return KF(t) ? e : t[r] || t;
}
function rL(e = {}) {
  const {
    themeId: t,
    defaultTheme: r = eL,
    rootShouldForwardProp: n = Ls,
    slotShouldForwardProp: o = Ls
  } = e, a = (i) => hg(T({}, i, {
    theme: us(T({}, i, {
      defaultTheme: r,
      themeId: t
    }))
  }));
  return a.__mui_systemSx = !0, (i, l = {}) => {
    Yj(i, (O) => O.filter((w) => !(w != null && w.__mui_systemSx)));
    const {
      name: c,
      slot: u,
      skipVariantsResolver: d,
      skipSx: f,
      overridesResolver: p
    } = l, m = ge(l, GF), y = d !== void 0 ? d : u && u !== "Root" || !1, h = f || !1;
    let v;
    process.env.NODE_ENV !== "production" && c && (v = `${c}-${tL(u || "Root")}`);
    let g = Ls;
    u === "Root" ? g = n : u ? g = o : XF(i) && (g = void 0);
    const b = Hj(i, T({
      shouldForwardProp: g,
      label: v
    }, m)), x = (O, ...w) => {
      const S = w ? w.map(($) => typeof $ == "function" && $.__emotion_real !== $ ? (j) => $(T({}, j, {
        theme: us(T({}, j, {
          defaultTheme: r,
          themeId: t
        }))
      })) : $) : [];
      let E = O;
      c && p && S.push(($) => {
        const j = us(T({}, $, {
          defaultTheme: r,
          themeId: t
        })), A = QF(c, j);
        if (A) {
          const k = {};
          return Object.entries(A).forEach(([R, D]) => {
            k[R] = typeof D == "function" ? D(T({}, $, {
              theme: j
            })) : D;
          }), p($, k);
        }
        return null;
      }), c && !y && S.push(($) => {
        const j = us(T({}, $, {
          defaultTheme: r,
          themeId: t
        }));
        return JF($, ZF(c, j), j, c);
      }), h || S.push(a);
      const C = S.length - w.length;
      if (Array.isArray(O) && C > 0) {
        const $ = new Array(C).fill("");
        E = [...O, ...$], E.raw = [...O.raw, ...$];
      } else
        typeof O == "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        O.__emotion_real !== O && (E = ($) => O(T({}, $, {
          theme: us(T({}, $, {
            defaultTheme: r,
            themeId: t
          }))
        })));
      const N = b(E, ...S);
      if (process.env.NODE_ENV !== "production") {
        let $;
        c && ($ = `${c}${u || ""}`), $ === void 0 && ($ = `Styled(${uA(i)})`), N.displayName = $;
      }
      return i.muiName && (N.muiName = i.muiName), N;
    };
    return b.withConfig && (x.withConfig = b.withConfig), x;
  };
}
function gE(e) {
  const {
    theme: t,
    name: r,
    props: n
  } = e;
  return !t || !t.components || !t.components[r] || !t.components[r].defaultProps ? n : ag(t.components[r].defaultProps, n);
}
function nL({
  props: e,
  name: t,
  defaultTheme: r,
  themeId: n
}) {
  let o = xl(r);
  return n && (o = o[n] || o), gE({
    theme: o,
    name: t,
    props: e
  });
}
function vg(e, t = 0, r = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > r) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${r}].`), Math.min(Math.max(t, e), r);
}
function oL(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let r = e.match(t);
  return r && r[0].length === 1 && (r = r.map((n) => n + n)), r ? `rgb${r.length === 4 ? "a" : ""}(${r.map((n, o) => o < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Ra(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Ra(oL(e));
  const t = e.indexOf("("), r = e.substring(0, t);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(r) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${e}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : Go(9, e));
  let n = e.substring(t + 1, e.length - 1), o;
  if (r === "color") {
    if (n = n.split(" "), o = n.shift(), n.length === 4 && n[3].charAt(0) === "/" && (n[3] = n[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(o) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${o}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : Go(10, o));
  } else
    n = n.split(",");
  return n = n.map((a) => parseFloat(a)), {
    type: r,
    values: n,
    colorSpace: o
  };
}
function wp(e) {
  const {
    type: t,
    colorSpace: r
  } = e;
  let {
    values: n
  } = e;
  return t.indexOf("rgb") !== -1 ? n = n.map((o, a) => a < 3 ? parseInt(o, 10) : o) : t.indexOf("hsl") !== -1 && (n[1] = `${n[1]}%`, n[2] = `${n[2]}%`), t.indexOf("color") !== -1 ? n = `${r} ${n.join(" ")}` : n = `${n.join(", ")}`, `${t}(${n})`;
}
function aL(e) {
  e = Ra(e);
  const {
    values: t
  } = e, r = t[0], n = t[1] / 100, o = t[2] / 100, a = n * Math.min(o, 1 - o), i = (u, d = (u + r / 30) % 12) => o - a * Math.max(Math.min(d - 3, 9 - d, 1), -1);
  let l = "rgb";
  const c = [Math.round(i(0) * 255), Math.round(i(8) * 255), Math.round(i(4) * 255)];
  return e.type === "hsla" && (l += "a", c.push(t[3])), wp({
    type: l,
    values: c
  });
}
function uw(e) {
  e = Ra(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Ra(aL(e)).values : e.values;
  return t = t.map((r) => (e.type !== "color" && (r /= 255), r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function dw(e, t) {
  const r = uw(e), n = uw(t);
  return (Math.max(r, n) + 0.05) / (Math.min(r, n) + 0.05);
}
function dt(e, t) {
  return e = Ra(e), t = vg(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, wp(e);
}
function bE(e, t) {
  if (e = Ra(e), t = vg(t), e.type.indexOf("hsl") !== -1)
    e.values[2] *= 1 - t;
  else if (e.type.indexOf("rgb") !== -1 || e.type.indexOf("color") !== -1)
    for (let r = 0; r < 3; r += 1)
      e.values[r] *= 1 - t;
  return wp(e);
}
function wE(e, t) {
  if (e = Ra(e), t = vg(t), e.type.indexOf("hsl") !== -1)
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.indexOf("rgb") !== -1)
    for (let r = 0; r < 3; r += 1)
      e.values[r] += (255 - e.values[r]) * t;
  else if (e.type.indexOf("color") !== -1)
    for (let r = 0; r < 3; r += 1)
      e.values[r] += (1 - e.values[r]) * t;
  return wp(e);
}
const xE = /* @__PURE__ */ P.createContext(null);
process.env.NODE_ENV !== "production" && (xE.displayName = "ThemeContext");
const _E = xE;
function OE() {
  const e = P.useContext(_E);
  return process.env.NODE_ENV !== "production" && P.useDebugValue(e), e;
}
const iL = typeof Symbol == "function" && Symbol.for, sL = iL ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function lL(e, t) {
  if (typeof t == "function") {
    const r = t(e);
    return process.env.NODE_ENV !== "production" && (r || console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join(`
`))), r;
  }
  return {
    ...e,
    ...t
  };
}
function $u(e) {
  const {
    children: t,
    theme: r
  } = e, n = OE();
  process.env.NODE_ENV !== "production" && n === null && typeof r == "function" && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const o = P.useMemo(() => {
    const a = n === null ? r : lL(n, r);
    return a != null && (a[sL] = n !== null), a;
  }, [r, n]);
  return /* @__PURE__ */ _.jsx(_E.Provider, {
    value: o,
    children: t
  });
}
process.env.NODE_ENV !== "production" && ($u.propTypes = {
  /**
   * Your component tree.
   */
  children: s.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: s.oneOfType([s.object, s.func]).isRequired
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && ($u.propTypes = tp($u.propTypes));
const fw = {};
function pw(e, t, r, n = !1) {
  return P.useMemo(() => {
    const o = e && t[e] || t;
    if (typeof r == "function") {
      const a = r(o), i = e ? T({}, t, {
        [e]: a
      }) : a;
      return n ? () => i : i;
    }
    return e ? T({}, t, {
      [e]: r
    }) : T({}, t, r);
  }, [e, t, r, n]);
}
function Cu(e) {
  const {
    children: t,
    theme: r,
    themeId: n
  } = e, o = bp(fw), a = OE() || fw;
  process.env.NODE_ENV !== "production" && (o === null && typeof r == "function" || n && o && !o[n] && typeof r == "function") && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const i = pw(n, o, r), l = pw(n, a, r, !0);
  return /* @__PURE__ */ _.jsx($u, {
    theme: l,
    children: /* @__PURE__ */ _.jsx(yo.Provider, {
      value: i,
      children: t
    })
  });
}
process.env.NODE_ENV !== "production" && (Cu.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Your component tree.
   */
  children: s.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: s.oneOfType([s.func, s.object]).isRequired,
  /**
   * The design system's unique id for getting the corresponded theme when there are multiple design systems.
   */
  themeId: s.string
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (Cu.propTypes = tp(Cu.propTypes));
function cL(e, t) {
  return T({
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    }
  }, t);
}
const uL = {
  black: "#000",
  white: "#fff"
}, rl = uL, dL = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, fL = dL, pL = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, Ka = pL, mL = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, Xa = mL, hL = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, ds = hL, yL = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, Qa = yL, vL = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, Za = vL, gL = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, Ja = gL, bL = ["mode", "contrastThreshold", "tonalOffset"], mw = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: rl.white,
    default: rl.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, Tm = {
  text: {
    primary: rl.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: rl.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function hw(e, t, r, n) {
  const o = n.light || n, a = n.dark || n * 1.5;
  e[t] || (e.hasOwnProperty(r) ? e[t] = e[r] : t === "light" ? e.light = wE(e.main, o) : t === "dark" && (e.dark = bE(e.main, a)));
}
function wL(e = "light") {
  return e === "dark" ? {
    main: Qa[200],
    light: Qa[50],
    dark: Qa[400]
  } : {
    main: Qa[700],
    light: Qa[400],
    dark: Qa[800]
  };
}
function xL(e = "light") {
  return e === "dark" ? {
    main: Ka[200],
    light: Ka[50],
    dark: Ka[400]
  } : {
    main: Ka[500],
    light: Ka[300],
    dark: Ka[700]
  };
}
function _L(e = "light") {
  return e === "dark" ? {
    main: Xa[500],
    light: Xa[300],
    dark: Xa[700]
  } : {
    main: Xa[700],
    light: Xa[400],
    dark: Xa[800]
  };
}
function OL(e = "light") {
  return e === "dark" ? {
    main: Za[400],
    light: Za[300],
    dark: Za[700]
  } : {
    main: Za[700],
    light: Za[500],
    dark: Za[900]
  };
}
function PL(e = "light") {
  return e === "dark" ? {
    main: Ja[400],
    light: Ja[300],
    dark: Ja[700]
  } : {
    main: Ja[800],
    light: Ja[500],
    dark: Ja[900]
  };
}
function SL(e = "light") {
  return e === "dark" ? {
    main: ds[400],
    light: ds[300],
    dark: ds[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: ds[500],
    dark: ds[900]
  };
}
function TL(e) {
  const {
    mode: t = "light",
    contrastThreshold: r = 3,
    tonalOffset: n = 0.2
  } = e, o = ge(e, bL), a = e.primary || wL(t), i = e.secondary || xL(t), l = e.error || _L(t), c = e.info || OL(t), u = e.success || PL(t), d = e.warning || SL(t);
  function f(h) {
    const v = dw(h, Tm.text.primary) >= r ? Tm.text.primary : mw.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const g = dw(h, v);
      g < 3 && console.error([`MUI: The contrast ratio of ${g}:1 for ${v} on ${h}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return v;
  }
  const p = ({
    color: h,
    name: v,
    mainShade: g = 500,
    lightShade: b = 300,
    darkShade: x = 700
  }) => {
    if (h = T({}, h), !h.main && h[g] && (h.main = h[g]), !h.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${v ? ` (${v})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${g}\` property.` : Go(11, v ? ` (${v})` : "", g));
    if (typeof h.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${v ? ` (${v})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(h.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : Go(12, v ? ` (${v})` : "", JSON.stringify(h.main)));
    return hw(h, "light", b, n), hw(h, "dark", x, n), h.contrastText || (h.contrastText = f(h.main)), h;
  }, m = {
    dark: Tm,
    light: mw
  };
  return process.env.NODE_ENV !== "production" && (m[t] || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), an(T({
    // A collection of common colors.
    common: T({}, rl),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: p({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: p({
      color: i,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: p({
      color: l,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: p({
      color: d,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: p({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: p({
      color: u,
      name: "success"
    }),
    // The grey colors.
    grey: fL,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: r,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: f,
    // Generate a rich color object.
    augmentColor: p,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: n
  }, m[t]), o);
}
const EL = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function $L(e) {
  return Math.round(e * 1e5) / 1e5;
}
const yw = {
  textTransform: "uppercase"
}, vw = '"Roboto", "Helvetica", "Arial", sans-serif';
function CL(e, t) {
  const r = typeof t == "function" ? t(e) : t, {
    fontFamily: n = vw,
    // The default font size of the Material Specification.
    fontSize: o = 14,
    // px
    fontWeightLight: a = 300,
    fontWeightRegular: i = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: c = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: u = 16,
    // Apply the CSS properties to all the variants.
    allVariants: d,
    pxToRem: f
  } = r, p = ge(r, EL);
  process.env.NODE_ENV !== "production" && (typeof o != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof u != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const m = o / 14, y = f || ((g) => `${g / u * m}rem`), h = (g, b, x, O, w) => T({
    fontFamily: n,
    fontWeight: g,
    fontSize: y(b),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: x
  }, n === vw ? {
    letterSpacing: `${$L(O / b)}em`
  } : {}, w, d), v = {
    h1: h(a, 96, 1.167, -1.5),
    h2: h(a, 60, 1.2, -0.5),
    h3: h(i, 48, 1.167, 0),
    h4: h(i, 34, 1.235, 0.25),
    h5: h(i, 24, 1.334, 0),
    h6: h(l, 20, 1.6, 0.15),
    subtitle1: h(i, 16, 1.75, 0.15),
    subtitle2: h(l, 14, 1.57, 0.1),
    body1: h(i, 16, 1.5, 0.15),
    body2: h(i, 14, 1.43, 0.15),
    button: h(l, 14, 1.75, 0.4, yw),
    caption: h(i, 12, 1.66, 0.4),
    overline: h(i, 12, 2.66, 1, yw),
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return an(T({
    htmlFontSize: u,
    pxToRem: y,
    fontFamily: n,
    fontSize: o,
    fontWeightLight: a,
    fontWeightRegular: i,
    fontWeightMedium: l,
    fontWeightBold: c
  }, v), p, {
    clone: !1
    // No need to clone deep
  });
}
const kL = 0.2, RL = 0.14, DL = 0.12;
function At(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${kL})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${RL})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${DL})`].join(",");
}
const NL = ["none", At(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), At(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), At(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), At(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), At(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), At(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), At(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), At(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), At(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), At(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), At(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), At(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), At(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), At(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), At(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), At(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), At(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), At(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), At(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), At(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), At(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), At(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), At(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), At(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], IL = NL, ML = ["duration", "easing", "delay"], AL = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, jL = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function gw(e) {
  return `${Math.round(e)}ms`;
}
function FL(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.round((4 + 15 * t ** 0.25 + t / 5) * 10);
}
function LL(e) {
  const t = T({}, AL, e.easing), r = T({}, jL, e.duration);
  return T({
    getAutoHeightDuration: FL,
    create: (o = ["all"], a = {}) => {
      const {
        duration: i = r.standard,
        easing: l = t.easeInOut,
        delay: c = 0
      } = a, u = ge(a, ML);
      if (process.env.NODE_ENV !== "production") {
        const d = (p) => typeof p == "string", f = (p) => !isNaN(parseFloat(p));
        !d(o) && !Array.isArray(o) && console.error('MUI: Argument "props" must be a string or Array.'), !f(i) && !d(i) && console.error(`MUI: Argument "duration" must be a number or a string but found ${i}.`), d(l) || console.error('MUI: Argument "easing" must be a string.'), !f(c) && !d(c) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(u).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(u).join(",")}].`);
      }
      return (Array.isArray(o) ? o : [o]).map((d) => `${d} ${typeof i == "string" ? i : gw(i)} ${l} ${typeof c == "string" ? c : gw(c)}`).join(",");
    }
  }, e, {
    easing: t,
    duration: r
  });
}
const VL = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, zL = VL, BL = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function PE(e = {}, ...t) {
  const {
    mixins: r = {},
    palette: n = {},
    transitions: o = {},
    typography: a = {}
  } = e, i = ge(e, BL);
  if (e.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : Go(18));
  const l = TL(n), c = yg(e);
  let u = an(c, {
    mixins: cL(c.breakpoints, r),
    palette: l,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: IL.slice(),
    typography: CL(l, a),
    transitions: LL(o),
    zIndex: T({}, zL)
  });
  if (u = an(u, i), u = t.reduce((d, f) => an(d, f), u), process.env.NODE_ENV !== "production") {
    const d = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], f = (p, m) => {
      let y;
      for (y in p) {
        const h = p[y];
        if (d.indexOf(y) !== -1 && Object.keys(h).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const v = ze("", y);
            console.error([`MUI: The \`${m}\` component increases the CSS specificity of the \`${y}\` internal state.`, "You can not override it like this: ", JSON.stringify(p, null, 2), "", `Instead, you need to use the '&.${v}' syntax:`, JSON.stringify({
              root: {
                [`&.${v}`]: h
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          p[y] = {};
        }
      }
    };
    Object.keys(u.components).forEach((p) => {
      const m = u.components[p].styleOverrides;
      m && p.indexOf("Mui") === 0 && f(m, p);
    });
  }
  return u.unstable_sxConfig = T({}, gp, i == null ? void 0 : i.unstable_sxConfig), u.unstable_sx = function(f) {
    return hg({
      sx: f,
      theme: this
    });
  }, u;
}
const WL = PE(), xp = WL;
function Nr() {
  const e = xl(xp);
  return process.env.NODE_ENV !== "production" && P.useDebugValue(e), e;
}
function Ae({
  props: e,
  name: t
}) {
  return nL({
    props: e,
    name: t,
    defaultTheme: xp
  });
}
const to = (e) => Ls(e) && e !== "classes", UL = Ls, HL = rL({
  defaultTheme: xp,
  rootShouldForwardProp: to
}), ce = HL, YL = (e) => {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, (t / 100).toFixed(2);
}, bw = YL, qL = {
  primaryColor: "blue",
  components: {
    Tooltip: {
      styles: (e) => ({
        body: {
          padding: 0.5 * e.spacing.xs,
          paddingTop: 0.25 * e.spacing.xs,
          paddingBottom: 0.25 * e.spacing.xs,
          fontSize: e.fontSizes.xs,
          backgroundColor: e.colors.gray[6]
        }
      }),
      defaultProps: { position: "bottom", transition: "fade", openDelay: 400 }
    },
    Modal: {
      styles: {
        title: {
          fontWeight: 700
        }
      }
    },
    ActionIcon: {
      styles: (e) => ({
        hover: {
          color: e.colors.gray[6]
        }
      })
    }
  }
}, GL = PE({});
function ku(e, t) {
  let r = e;
  for (; (r = r.parentElement) && !r.matches(t); )
    ;
  return r;
}
function KL(e, t, r) {
  for (let n = e - 1; n >= 0; n -= 1)
    if (!t[n].disabled)
      return n;
  if (r) {
    for (let n = t.length - 1; n > -1; n -= 1)
      if (!t[n].disabled)
        return n;
  }
  return e;
}
function XL(e, t, r) {
  for (let n = e + 1; n < t.length; n += 1)
    if (!t[n].disabled)
      return n;
  if (r) {
    for (let n = 0; n < t.length; n += 1)
      if (!t[n].disabled)
        return n;
  }
  return e;
}
function QL(e, t, r) {
  return ku(e, r) === ku(t, r);
}
function SE({
  parentSelector: e,
  siblingSelector: t,
  onKeyDown: r,
  loop: n = !0,
  activateOnFocus: o = !1,
  dir: a = "rtl",
  orientation: i
}) {
  return (l) => {
    var c;
    r == null || r(l);
    const u = Array.from(((c = ku(l.currentTarget, e)) == null ? void 0 : c.querySelectorAll(t)) || []).filter((h) => QL(l.currentTarget, h, e)), d = u.findIndex((h) => l.currentTarget === h), f = XL(d, u, n), p = KL(d, u, n), m = a === "rtl" ? p : f, y = a === "rtl" ? f : p;
    switch (l.key) {
      case "ArrowRight": {
        i === "horizontal" && (l.stopPropagation(), l.preventDefault(), u[m].focus(), o && u[m].click());
        break;
      }
      case "ArrowLeft": {
        i === "horizontal" && (l.stopPropagation(), l.preventDefault(), u[y].focus(), o && u[y].click());
        break;
      }
      case "ArrowUp": {
        i === "vertical" && (l.stopPropagation(), l.preventDefault(), u[p].focus(), o && u[p].click());
        break;
      }
      case "ArrowDown": {
        i === "vertical" && (l.stopPropagation(), l.preventDefault(), u[f].focus(), o && u[f].click());
        break;
      }
      case "Home": {
        l.stopPropagation(), l.preventDefault(), !u[0].disabled && u[0].focus();
        break;
      }
      case "End": {
        l.stopPropagation(), l.preventDefault();
        const h = u.length - 1;
        !u[h].disabled && u[h].focus();
        break;
      }
    }
  };
}
function ZL(e, t, r) {
  var n;
  return r ? Array.from(((n = ku(r, t)) == null ? void 0 : n.querySelectorAll(e)) || []).findIndex((o) => o === r) : null;
}
function _p(e) {
  const t = Br(null);
  return [({ children: o, value: a }) => /* @__PURE__ */ F.createElement(t.Provider, {
    value: a
  }, o), () => {
    const o = ar(t);
    if (o === null)
      throw new Error(e);
    return o;
  }];
}
function nl(e) {
  return Array.isArray(e) ? e : [e];
}
function ww(e, t) {
  return (r) => {
    if (typeof r != "string" || r.trim().length === 0)
      throw new Error(t);
    return `${e}-${r}`;
  };
}
const JL = () => {
};
function eV(e, t = { active: !0 }) {
  return typeof e != "function" || !t.active ? t.onKeyDown || JL : (r) => {
    var n;
    r.key === "Escape" && (e(r), (n = t.onTrigger) == null || n.call(t));
  };
}
function lo(e, t) {
  return (r) => {
    e == null || e(r), t == null || t(r);
  };
}
function tV() {
  const [e, t] = Me(-1);
  return [e, { setHovered: t, resetHovered: () => t(-1) }];
}
function TE({ data: e }) {
  const t = [], r = [], n = e.reduce((o, a, i) => (a.group ? o[a.group] ? o[a.group].push(i) : o[a.group] = [i] : r.push(i), o), {});
  return Object.keys(n).forEach((o) => {
    t.push(...n[o].map((a) => e[a]));
  }), t.push(...r.map((o) => e[o])), t;
}
function _l(e) {
  return Array.isArray(e) || e === null ? !1 : typeof e == "object" ? e.type !== F.Fragment : !1;
}
function EE(e) {
  var t, r, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (r = EE(e[t])) && (n && (n += " "), n += r);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function $E() {
  for (var e = 0, t, r, n = ""; e < arguments.length; )
    (t = arguments[e++]) && (r = EE(t)) && (n && (n += " "), n += r);
  return n;
}
const rV = {
  dark: [
    "#C1C2C5",
    "#A6A7AB",
    "#909296",
    "#5c5f66",
    "#373A40",
    "#2C2E33",
    "#25262b",
    "#1A1B1E",
    "#141517",
    "#101113"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
};
function nV(e) {
  return () => ({ fontFamily: e.fontFamily || "sans-serif" });
}
var oV = Object.defineProperty, xw = Object.getOwnPropertySymbols, aV = Object.prototype.hasOwnProperty, iV = Object.prototype.propertyIsEnumerable, _w = (e, t, r) => t in e ? oV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ow = (e, t) => {
  for (var r in t || (t = {}))
    aV.call(t, r) && _w(e, r, t[r]);
  if (xw)
    for (var r of xw(t))
      iV.call(t, r) && _w(e, r, t[r]);
  return e;
};
function sV(e) {
  return (t) => ({
    WebkitTapHighlightColor: "transparent",
    [t || "&:focus"]: Ow({}, e.focusRing === "always" || e.focusRing === "auto" ? e.focusRingStyles.styles(e) : e.focusRingStyles.resetStyles(e)),
    [t ? t.replace(":focus", ":focus:not(:focus-visible)") : "&:focus:not(:focus-visible)"]: Ow({}, e.focusRing === "auto" || e.focusRing === "never" ? e.focusRingStyles.resetStyles(e) : null)
  });
}
function Ol(e) {
  return (t) => typeof e.primaryShade == "number" ? e.primaryShade : e.primaryShade[t || e.colorScheme];
}
function gg(e) {
  const t = Ol(e);
  return (r, n, o = !0, a = !0) => {
    if (typeof r == "string" && r.includes(".")) {
      const [l, c] = r.split("."), u = parseInt(c, 10);
      if (l in e.colors && u >= 0 && u < 10)
        return e.colors[l][typeof n == "number" && !a ? n : u];
    }
    const i = typeof n == "number" ? n : t();
    return r in e.colors ? e.colors[r][i] : o ? e.colors[e.primaryColor][i] : r;
  };
}
function CE(e) {
  let t = "";
  for (let r = 1; r < e.length - 1; r += 1)
    t += `${e[r]} ${r / (e.length - 1) * 100}%, `;
  return `${e[0]} 0%, ${t}${e[e.length - 1]} 100%`;
}
function lV(e, ...t) {
  return `linear-gradient(${e}deg, ${CE(t)})`;
}
function cV(...e) {
  return `radial-gradient(circle, ${CE(e)})`;
}
function kE(e) {
  const t = gg(e), r = Ol(e);
  return (n) => {
    const o = {
      from: (n == null ? void 0 : n.from) || e.defaultGradient.from,
      to: (n == null ? void 0 : n.to) || e.defaultGradient.to,
      deg: (n == null ? void 0 : n.deg) || e.defaultGradient.deg
    };
    return `linear-gradient(${o.deg}deg, ${t(o.from, r(), !1)} 0%, ${t(o.to, r(), !1)} 100%)`;
  };
}
function bg(e) {
  if (typeof e.size == "number")
    return e.size;
  const t = e.sizes[e.size];
  return t !== void 0 ? t : e.size || e.sizes.md;
}
function uV(e) {
  return (t) => `@media (min-width: ${bg({ size: t, sizes: e.breakpoints })}px)`;
}
function dV(e) {
  return (t) => `@media (max-width: ${bg({ size: t, sizes: e.breakpoints }) - 1}px)`;
}
function fV(e) {
  return /^#?([0-9A-F]{3}){1,2}$/i.test(e);
}
function pV(e) {
  let t = e.replace("#", "");
  if (t.length === 3) {
    const i = t.split("");
    t = [
      i[0],
      i[0],
      i[1],
      i[1],
      i[2],
      i[2]
    ].join("");
  }
  const r = parseInt(t, 16), n = r >> 16 & 255, o = r >> 8 & 255, a = r & 255;
  return {
    r: n,
    g: o,
    b: a,
    a: 1
  };
}
function mV(e) {
  const [t, r, n, o] = e.replace(/[^0-9,.]/g, "").split(",").map(Number);
  return { r: t, g: r, b: n, a: o || 1 };
}
function wg(e) {
  return fV(e) ? pV(e) : e.startsWith("rgb") ? mV(e) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function ci(e, t) {
  if (typeof e != "string" || t > 1 || t < 0)
    return "rgba(0, 0, 0, 1)";
  const { r, g: n, b: o } = wg(e);
  return `rgba(${r}, ${n}, ${o}, ${t})`;
}
function hV(e = 0) {
  return {
    position: "absolute",
    top: e,
    right: e,
    left: e,
    bottom: e
  };
}
function yV(e, t) {
  const { r, g: n, b: o, a } = wg(e), i = 1 - t, l = (c) => Math.round(c * i);
  return `rgba(${l(r)}, ${l(n)}, ${l(o)}, ${a})`;
}
function vV(e, t) {
  const { r, g: n, b: o, a } = wg(e), i = (l) => Math.round(l + (255 - l) * t);
  return `rgba(${i(r)}, ${i(n)}, ${i(o)}, ${a})`;
}
function gV(e) {
  return (t) => {
    if (typeof t == "number")
      return t;
    const r = typeof e.defaultRadius == "number" ? e.defaultRadius : e.radius[e.defaultRadius] || e.defaultRadius;
    return e.radius[t] || t || r;
  };
}
function bV(e, t) {
  if (typeof e == "string" && e.includes(".")) {
    const [r, n] = e.split("."), o = parseInt(n, 10);
    if (r in t.colors && o >= 0 && o < 10)
      return { isSplittedColor: !0, key: r, shade: o };
  }
  return { isSplittedColor: !1 };
}
function wV(e) {
  const t = gg(e), r = Ol(e), n = kE(e);
  return ({ variant: o, color: a, gradient: i, primaryFallback: l }) => {
    const c = bV(a, e);
    switch (o) {
      case "light":
        return {
          border: "transparent",
          background: ci(t(a, e.colorScheme === "dark" ? 8 : 0, l, !1), e.colorScheme === "dark" ? 0.2 : 1),
          color: a === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(a, e.colorScheme === "dark" ? 2 : r("light")),
          hover: ci(t(a, e.colorScheme === "dark" ? 7 : 1, l, !1), e.colorScheme === "dark" ? 0.25 : 0.65)
        };
      case "subtle":
        return {
          border: "transparent",
          background: "transparent",
          color: a === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(a, e.colorScheme === "dark" ? 2 : r("light")),
          hover: ci(t(a, e.colorScheme === "dark" ? 8 : 0, l, !1), e.colorScheme === "dark" ? 0.2 : 1)
        };
      case "outline":
        return {
          border: t(a, e.colorScheme === "dark" ? 5 : r("light")),
          background: "transparent",
          color: t(a, e.colorScheme === "dark" ? 5 : r("light")),
          hover: e.colorScheme === "dark" ? ci(t(a, 5, l, !1), 0.05) : ci(t(a, 0, l, !1), 0.35)
        };
      case "default":
        return {
          border: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4],
          background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
          color: e.colorScheme === "dark" ? e.white : e.black,
          hover: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[0]
        };
      case "white":
        return {
          border: "transparent",
          background: e.white,
          color: t(a, r()),
          hover: null
        };
      case "transparent":
        return {
          border: "transparent",
          color: a === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(a, e.colorScheme === "dark" ? 2 : r("light")),
          background: "transparent",
          hover: null
        };
      case "gradient":
        return {
          background: n(i),
          color: e.white,
          border: "transparent",
          hover: null
        };
      default: {
        const u = r(), d = c.isSplittedColor ? c.shade : u, f = c.isSplittedColor ? c.key : a;
        return {
          border: "transparent",
          background: t(f, d, l),
          color: e.white,
          hover: t(f, d === 9 ? 8 : d + 1)
        };
      }
    }
  };
}
function xV(e) {
  return (t) => {
    const r = Ol(e)(t);
    return e.colors[e.primaryColor][r];
  };
}
function _V(e) {
  return {
    "@media (hover: hover)": {
      "&:hover": e
    },
    "@media (hover: none)": {
      "&:active": e
    }
  };
}
function OV(e) {
  return () => ({
    userSelect: "none",
    color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
  });
}
const tr = {
  fontStyles: nV,
  themeColor: gg,
  focusStyles: sV,
  linearGradient: lV,
  radialGradient: cV,
  smallerThan: dV,
  largerThan: uV,
  rgba: ci,
  size: bg,
  cover: hV,
  darken: yV,
  lighten: vV,
  radius: gV,
  variant: wV,
  primaryShade: Ol,
  hover: _V,
  gradient: kE,
  primaryColor: xV,
  placeholderStyles: OV
};
var PV = Object.defineProperty, SV = Object.defineProperties, TV = Object.getOwnPropertyDescriptors, Pw = Object.getOwnPropertySymbols, EV = Object.prototype.hasOwnProperty, $V = Object.prototype.propertyIsEnumerable, Sw = (e, t, r) => t in e ? PV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, CV = (e, t) => {
  for (var r in t || (t = {}))
    EV.call(t, r) && Sw(e, r, t[r]);
  if (Pw)
    for (var r of Pw(t))
      $V.call(t, r) && Sw(e, r, t[r]);
  return e;
}, kV = (e, t) => SV(e, TV(t));
function RE(e) {
  return kV(CV({}, e), {
    fn: {
      fontStyles: tr.fontStyles(e),
      themeColor: tr.themeColor(e),
      focusStyles: tr.focusStyles(e),
      largerThan: tr.largerThan(e),
      smallerThan: tr.smallerThan(e),
      radialGradient: tr.radialGradient,
      linearGradient: tr.linearGradient,
      gradient: tr.gradient(e),
      rgba: tr.rgba,
      size: tr.size,
      cover: tr.cover,
      lighten: tr.lighten,
      darken: tr.darken,
      primaryShade: tr.primaryShade(e),
      radius: tr.radius(e),
      variant: tr.variant(e),
      hover: tr.hover,
      primaryColor: tr.primaryColor(e),
      placeholderStyles: tr.placeholderStyles(e)
    }
  });
}
const DE = ["xs", "sm", "md", "lg", "xl"], RV = {
  dir: "ltr",
  primaryShade: {
    light: 6,
    dark: 8
  },
  focusRing: "auto",
  loader: "oval",
  dateFormat: "MMMM D, YYYY",
  colorScheme: "light",
  white: "#fff",
  black: "#000",
  defaultRadius: "sm",
  transitionTimingFunction: "ease",
  colors: rV,
  lineHeight: 1.55,
  fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  primaryColor: "blue",
  respectReducedMotion: !0,
  cursorType: "default",
  defaultGradient: {
    from: "indigo",
    to: "cyan",
    deg: 45
  },
  shadows: {
    xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
    sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
    md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
    lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
    xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px"
  },
  fontSizes: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 18,
    xl: 20
  },
  radius: {
    xs: 2,
    sm: 4,
    md: 8,
    lg: 16,
    xl: 32
  },
  spacing: {
    xs: 10,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24
  },
  breakpoints: {
    xs: 576,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1400
  },
  headings: {
    fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
    fontWeight: 700,
    sizes: {
      h1: { fontSize: 34, lineHeight: 1.3, fontWeight: void 0 },
      h2: { fontSize: 26, lineHeight: 1.35, fontWeight: void 0 },
      h3: { fontSize: 22, lineHeight: 1.4, fontWeight: void 0 },
      h4: { fontSize: 18, lineHeight: 1.45, fontWeight: void 0 },
      h5: { fontSize: 16, lineHeight: 1.5, fontWeight: void 0 },
      h6: { fontSize: 14, lineHeight: 1.5, fontWeight: void 0 }
    }
  },
  other: {},
  components: {},
  activeStyles: { transform: "translateY(1px)" },
  datesLocale: "en",
  globalStyles: void 0,
  focusRingStyles: {
    styles: (e) => ({
      outlineOffset: 2,
      outline: `2px solid ${e.colors[e.primaryColor][e.colorScheme === "dark" ? 7 : 5]}`
    }),
    resetStyles: () => ({ outline: "none" }),
    inputStyles: (e) => ({
      outline: "none",
      borderColor: e.colors[e.primaryColor][typeof e.primaryShade == "object" ? e.primaryShade[e.colorScheme] : e.primaryShade]
    })
  }
}, xg = RE(RV);
var DV = Object.defineProperty, NV = Object.defineProperties, IV = Object.getOwnPropertyDescriptors, Tw = Object.getOwnPropertySymbols, MV = Object.prototype.hasOwnProperty, AV = Object.prototype.propertyIsEnumerable, Ew = (e, t, r) => t in e ? DV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, jV = (e, t) => {
  for (var r in t || (t = {}))
    MV.call(t, r) && Ew(e, r, t[r]);
  if (Tw)
    for (var r of Tw(t))
      AV.call(t, r) && Ew(e, r, t[r]);
  return e;
}, FV = (e, t) => NV(e, IV(t));
function LV({ theme: e }) {
  return /* @__PURE__ */ F.createElement(Ki, {
    styles: {
      "*, *::before, *::after": {
        boxSizing: "border-box"
      },
      html: {
        colorScheme: e.colorScheme === "dark" ? "dark" : "light"
      },
      body: FV(jV({}, e.fn.fontStyles()), {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        lineHeight: e.lineHeight,
        fontSize: e.fontSizes.md,
        WebkitFontSmoothing: "antialiased",
        MozOsxFontSmoothing: "grayscale"
      })
    }
  });
}
function Wl(e, t, r) {
  Object.keys(t).forEach((n) => {
    e[`--mantine-${r}-${n}`] = typeof t[n] == "number" ? `${t[n]}px` : t[n];
  });
}
function VV({ theme: e }) {
  const t = {
    "--mantine-color-white": e.white,
    "--mantine-color-black": e.black,
    "--mantine-transition-timing-function": e.transitionTimingFunction,
    "--mantine-line-height": `${e.lineHeight}`,
    "--mantine-font-family": e.fontFamily,
    "--mantine-font-family-monospace": e.fontFamilyMonospace,
    "--mantine-font-family-headings": e.headings.fontFamily,
    "--mantine-heading-font-weight": `${e.headings.fontWeight}`
  };
  Wl(t, e.shadows, "shadow"), Wl(t, e.fontSizes, "font-size"), Wl(t, e.radius, "radius"), Wl(t, e.spacing, "spacing"), Object.keys(e.colors).forEach((n) => {
    e.colors[n].forEach((o, a) => {
      t[`--mantine-color-${n}-${a}`] = o;
    });
  });
  const r = e.headings.sizes;
  return Object.keys(r).forEach((n) => {
    t[`--mantine-${n}-font-size`] = `${r[n].fontSize}px`, t[`--mantine-${n}-line-height`] = `${r[n].lineHeight}`;
  }), /* @__PURE__ */ F.createElement(Ki, {
    styles: {
      ":root": t
    }
  });
}
var zV = Object.defineProperty, BV = Object.defineProperties, WV = Object.getOwnPropertyDescriptors, $w = Object.getOwnPropertySymbols, UV = Object.prototype.hasOwnProperty, HV = Object.prototype.propertyIsEnumerable, Cw = (e, t, r) => t in e ? zV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ca = (e, t) => {
  for (var r in t || (t = {}))
    UV.call(t, r) && Cw(e, r, t[r]);
  if ($w)
    for (var r of $w(t))
      HV.call(t, r) && Cw(e, r, t[r]);
  return e;
}, kw = (e, t) => BV(e, WV(t));
function YV(e, t) {
  if (!t)
    return e;
  const r = Object.keys(e).reduce((n, o) => {
    if (o === "headings" && t.headings) {
      const a = t.headings.sizes ? Object.keys(e.headings.sizes).reduce((i, l) => (i[l] = ca(ca({}, e.headings.sizes[l]), t.headings.sizes[l]), i), {}) : e.headings.sizes;
      return kw(ca({}, n), {
        headings: kw(ca(ca({}, e.headings), t.headings), {
          sizes: a
        })
      });
    }
    return n[o] = typeof t[o] == "object" ? ca(ca({}, e[o]), t[o]) : typeof t[o] == "number" || typeof t[o] == "boolean" || typeof t[o] == "function" ? t[o] : t[o] || e[o], n;
  }, {});
  if (!(r.primaryColor in r.colors))
    throw new Error("MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more â€“ https://mantine.dev/theming/colors/#primary-color");
  return r;
}
function qV(e, t) {
  return RE(YV(e, t));
}
function NE(e) {
  return Object.keys(e).reduce((t, r) => (e[r] !== void 0 && (t[r] = e[r]), t), {});
}
const GV = {
  html: {
    fontFamily: "sans-serif",
    lineHeight: "1.15",
    textSizeAdjust: "100%"
  },
  body: {
    margin: 0
  },
  "article, aside, footer, header, nav, section, figcaption, figure, main": {
    display: "block"
  },
  h1: {
    fontSize: "2em"
  },
  hr: {
    boxSizing: "content-box",
    height: 0,
    overflow: "visible"
  },
  pre: {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  a: {
    background: "transparent",
    textDecorationSkip: "objects"
  },
  "a:active, a:hover": {
    outlineWidth: 0
  },
  "abbr[title]": {
    borderBottom: "none",
    textDecoration: "underline"
  },
  "b, strong": {
    fontWeight: "bolder"
  },
  "code, kbp, samp": {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  dfn: {
    fontStyle: "italic"
  },
  mark: {
    backgroundColor: "#ff0",
    color: "#000"
  },
  small: {
    fontSize: "80%"
  },
  "sub, sup": {
    fontSize: "75%",
    lineHeight: 0,
    position: "relative",
    verticalAlign: "baseline"
  },
  sup: {
    top: "-0.5em"
  },
  sub: {
    bottom: "-0.25em"
  },
  "audio, video": {
    display: "inline-block"
  },
  "audio:not([controls])": {
    display: "none",
    height: 0
  },
  img: {
    borderStyle: "none",
    verticalAlign: "middle"
  },
  "svg:not(:root)": {
    overflow: "hidden"
  },
  "button, input, optgroup, select, textarea": {
    fontFamily: "sans-serif",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: 0
  },
  "button, input": {
    overflow: "visible"
  },
  "button, select": {
    textTransform: "none"
  },
  "button, [type=reset], [type=submit]": {
    WebkitAppearance: "button"
  },
  "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner": {
    borderStyle: "none",
    padding: 0
  },
  "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring": {
    outline: "1px dotted ButtonText"
  },
  legend: {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: 0,
    whiteSpace: "normal"
  },
  progress: {
    display: "inline-block",
    verticalAlign: "baseline"
  },
  textarea: {
    overflow: "auto"
  },
  "[type=checkbox], [type=radio]": {
    boxSizing: "border-box",
    padding: 0
  },
  "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button": {
    height: "auto"
  },
  "[type=search]": {
    appearance: "none"
  },
  "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration": {
    appearance: "none"
  },
  "::-webkit-file-upload-button": {
    appearance: "button",
    font: "inherit"
  },
  "details, menu": {
    display: "block"
  },
  summary: {
    display: "list-item"
  },
  canvas: {
    display: "inline-block"
  },
  template: {
    display: "none"
  },
  "[hidden]": {
    display: "none"
  }
};
function KV() {
  return /* @__PURE__ */ F.createElement(Ki, {
    styles: GV
  });
}
var XV = Object.defineProperty, Rw = Object.getOwnPropertySymbols, QV = Object.prototype.hasOwnProperty, ZV = Object.prototype.propertyIsEnumerable, Dw = (e, t, r) => t in e ? XV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Vs = (e, t) => {
  for (var r in t || (t = {}))
    QV.call(t, r) && Dw(e, r, t[r]);
  if (Rw)
    for (var r of Rw(t))
      ZV.call(t, r) && Dw(e, r, t[r]);
  return e;
};
const Ru = Br({
  theme: xg
});
function fr() {
  var e;
  return ((e = ar(Ru)) == null ? void 0 : e.theme) || xg;
}
function JV(e) {
  const t = fr(), r = (n) => {
    var o, a;
    return {
      styles: ((o = t.components[n]) == null ? void 0 : o.styles) || {},
      classNames: ((a = t.components[n]) == null ? void 0 : a.classNames) || {}
    };
  };
  return Array.isArray(e) ? e.map(r) : [r(e)];
}
function IE() {
  var e;
  return (e = ar(Ru)) == null ? void 0 : e.emotionCache;
}
function Xe(e, t, r) {
  var n;
  const o = fr(), a = (n = o.components[e]) == null ? void 0 : n.defaultProps, i = typeof a == "function" ? a(o) : a;
  return Vs(Vs(Vs({}, t), i), NE(r));
}
function ME({
  theme: e,
  emotionCache: t,
  withNormalizeCSS: r = !1,
  withGlobalStyles: n = !1,
  withCSSVariables: o = !1,
  inherit: a = !1,
  children: i
}) {
  const l = ar(Ru), c = qV(xg, a ? Vs(Vs({}, l.theme), e) : e);
  return /* @__PURE__ */ F.createElement(Ej, {
    theme: c
  }, /* @__PURE__ */ F.createElement(Ru.Provider, {
    value: { theme: c, emotionCache: t }
  }, r && /* @__PURE__ */ F.createElement(KV, null), n && /* @__PURE__ */ F.createElement(LV, {
    theme: c
  }), o && /* @__PURE__ */ F.createElement(VV, {
    theme: c
  }), typeof c.globalStyles == "function" && /* @__PURE__ */ F.createElement(Ki, {
    styles: c.globalStyles(c)
  }), i));
}
ME.displayName = "@mantine/core/MantineProvider";
const ez = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function Oo(e) {
  return ez[e];
}
function tz(e, t) {
  const r = qe();
  return (!r.current || t.length !== r.current.prevDeps.length || r.current.prevDeps.map((n, o) => n === t[o]).indexOf(!1) >= 0) && (r.current = {
    v: e(),
    prevDeps: [...t]
  }), r.current.v;
}
const rz = nE({ key: "mantine", prepend: !0 });
function nz() {
  return IE() || rz;
}
var oz = Object.defineProperty, Nw = Object.getOwnPropertySymbols, az = Object.prototype.hasOwnProperty, iz = Object.prototype.propertyIsEnumerable, Iw = (e, t, r) => t in e ? oz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, sz = (e, t) => {
  for (var r in t || (t = {}))
    az.call(t, r) && Iw(e, r, t[r]);
  if (Nw)
    for (var r of Nw(t))
      iz.call(t, r) && Iw(e, r, t[r]);
  return e;
};
const Em = "ref";
function lz(e) {
  let t;
  if (e.length !== 1)
    return { args: e, ref: t };
  const [r] = e;
  if (!(r instanceof Object))
    return { args: e, ref: t };
  if (!(Em in r))
    return { args: e, ref: t };
  t = r[Em];
  const n = sz({}, r);
  return delete n[Em], { args: [n], ref: t };
}
const { cssFactory: cz } = (() => {
  function e(r, n, o) {
    const a = [], i = ip(r, a, o);
    return a.length < 2 ? o : i + n(a);
  }
  function t(r) {
    const { cache: n } = r, o = (...i) => {
      const { ref: l, args: c } = lz(i), u = ka(c, n.registered);
      return gl(n, u, !1), `${n.key}-${u.name}${l === void 0 ? "" : ` ${l}`}`;
    };
    return { css: o, cx: (...i) => e(n.registered, o, $E(i)) };
  }
  return { cssFactory: t };
})();
function AE() {
  const e = nz();
  return tz(() => cz({ cache: e }), [e]);
}
function uz({
  cx: e,
  classes: t,
  context: r,
  classNames: n,
  name: o,
  cache: a
}) {
  const i = r.reduce((l, c) => (Object.keys(c.classNames).forEach((u) => {
    typeof l[u] != "string" ? l[u] = `${c.classNames[u]}` : l[u] = `${l[u]} ${c.classNames[u]}`;
  }), l), {});
  return Object.keys(t).reduce((l, c) => (l[c] = e(t[c], i[c], n != null && n[c], Array.isArray(o) ? o.filter(Boolean).map((u) => `${(a == null ? void 0 : a.key) || "mantine"}-${u}-${c}`).join(" ") : o ? `${(a == null ? void 0 : a.key) || "mantine"}-${o}-${c}` : null), l), {});
}
var dz = Object.defineProperty, Mw = Object.getOwnPropertySymbols, fz = Object.prototype.hasOwnProperty, pz = Object.prototype.propertyIsEnumerable, Aw = (e, t, r) => t in e ? dz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, $m = (e, t) => {
  for (var r in t || (t = {}))
    fz.call(t, r) && Aw(e, r, t[r]);
  if (Mw)
    for (var r of Mw(t))
      pz.call(t, r) && Aw(e, r, t[r]);
  return e;
};
function mz(e) {
  return `__mantine-ref-${e || ""}`;
}
function jw(e, t, r) {
  const n = (o) => typeof o == "function" ? o(t, r || {}) : o || {};
  return Array.isArray(e) ? e.map((o) => n(o.styles)).reduce((o, a) => (Object.keys(a).forEach((i) => {
    o[i] ? o[i] = $m($m({}, o[i]), a[i]) : o[i] = $m({}, a[i]);
  }), o), {}) : n(e);
}
function Qe(e) {
  const t = typeof e == "function" ? e : () => e;
  function r(n, o) {
    const a = fr(), i = JV(o == null ? void 0 : o.name), l = IE(), { css: c, cx: u } = AE(), d = t(a, n, mz), f = jw(o == null ? void 0 : o.styles, a, n), p = jw(i, a, n), m = Object.fromEntries(Object.keys(d).map((y) => {
      const h = u({ [c(d[y])]: !(o != null && o.unstyled) }, c(p[y]), c(f[y]));
      return [y, h];
    }));
    return {
      classes: uz({
        cx: u,
        classes: m,
        context: i,
        classNames: o == null ? void 0 : o.classNames,
        name: o == null ? void 0 : o.name,
        cache: l
      }),
      cx: u,
      theme: a
    };
  }
  return r;
}
var hz = Object.defineProperty, yz = Object.defineProperties, vz = Object.getOwnPropertyDescriptors, Fw = Object.getOwnPropertySymbols, gz = Object.prototype.hasOwnProperty, bz = Object.prototype.propertyIsEnumerable, Lw = (e, t, r) => t in e ? hz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, fs = (e, t) => {
  for (var r in t || (t = {}))
    gz.call(t, r) && Lw(e, r, t[r]);
  if (Fw)
    for (var r of Fw(t))
      bz.call(t, r) && Lw(e, r, t[r]);
  return e;
}, ps = (e, t) => yz(e, vz(t));
const ms = {
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: "scale(.9) translateY(10px)" },
  transitionProperty: "transform, opacity"
}, Ul = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: ps(fs({}, ms), {
    common: { transformOrigin: "center center" }
  }),
  "pop-bottom-left": ps(fs({}, ms), {
    common: { transformOrigin: "bottom left" }
  }),
  "pop-bottom-right": ps(fs({}, ms), {
    common: { transformOrigin: "bottom right" }
  }),
  "pop-top-left": ps(fs({}, ms), {
    common: { transformOrigin: "top left" }
  }),
  "pop-top-right": ps(fs({}, ms), {
    common: { transformOrigin: "top right" }
  })
}, Vw = ["mousedown", "touchstart"];
function wz(e, t, r) {
  const n = qe();
  return Ue(() => {
    const o = (a) => {
      const { target: i } = a ?? {};
      if (Array.isArray(r)) {
        const l = (i == null ? void 0 : i.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(i) && i.tagName !== "HTML";
        r.every((u) => !!u && !a.composedPath().includes(u)) && !l && e();
      } else
        n.current && !n.current.contains(i) && e();
    };
    return (t || Vw).forEach((a) => document.addEventListener(a, o)), () => {
      (t || Vw).forEach((a) => document.removeEventListener(a, o));
    };
  }, [n, e, r]), n;
}
function xz(e, t) {
  try {
    return e.addEventListener("change", t), () => e.removeEventListener("change", t);
  } catch {
    return e.addListener(t), () => e.removeListener(t);
  }
}
function _z(e, t) {
  return typeof t == "boolean" ? t : typeof window < "u" && "matchMedia" in window ? window.matchMedia(e).matches : !1;
}
function Oz(e, t, { getInitialValueInEffect: r } = {
  getInitialValueInEffect: !0
}) {
  const [n, o] = Me(r ? t : _z(e, t)), a = qe();
  return Ue(() => {
    if ("matchMedia" in window)
      return a.current = window.matchMedia(e), o(a.current.matches), xz(a.current, (i) => o(i.matches));
  }, [e]), n;
}
const jE = typeof document < "u" ? Zf : Ue;
function sn(e, t) {
  const r = qe(!1);
  Ue(() => () => {
    r.current = !1;
  }, []), Ue(() => {
    if (r.current)
      return e();
    r.current = !0;
  }, t);
}
function FE({ opened: e, shouldReturnFocus: t = !0 }) {
  const r = qe(), n = () => {
    var o;
    r.current && "focus" in r.current && typeof r.current.focus == "function" && ((o = r.current) == null || o.focus({ preventScroll: !0 }));
  };
  return sn(() => {
    let o = -1;
    const a = (i) => {
      i.key === "Tab" && window.clearTimeout(o);
    };
    return document.addEventListener("keydown", a), e ? r.current = document.activeElement : t && (o = window.setTimeout(n, 10)), () => {
      window.clearTimeout(o), document.removeEventListener("keydown", a);
    };
  }, [e, t]), n;
}
const Pz = /input|select|textarea|button|object/, LE = "a, input, select, textarea, button, object, [tabindex]";
function Sz(e) {
  return process.env.NODE_ENV === "test" ? !1 : e.style.display === "none";
}
function Tz(e) {
  if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || e.getAttribute("type") === "hidden")
    return !1;
  let r = e;
  for (; r && !(r === document.body || r.nodeType === 11); ) {
    if (Sz(r))
      return !1;
    r = r.parentNode;
  }
  return !0;
}
function VE(e) {
  let t = e.getAttribute("tabindex");
  return t === null && (t = void 0), parseInt(t, 10);
}
function qh(e) {
  const t = e.nodeName.toLowerCase(), r = !Number.isNaN(VE(e));
  return (Pz.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || r) && Tz(e);
}
function zE(e) {
  const t = VE(e);
  return (Number.isNaN(t) || t >= 0) && qh(e);
}
function Ez(e) {
  return Array.from(e.querySelectorAll(LE)).filter(zE);
}
function $z(e, t) {
  const r = Ez(e);
  if (!r.length) {
    t.preventDefault();
    return;
  }
  const n = r[t.shiftKey ? 0 : r.length - 1], o = e.getRootNode();
  if (!(n === o.activeElement || e === o.activeElement))
    return;
  t.preventDefault();
  const i = r[t.shiftKey ? r.length - 1 : 0];
  i && i.focus();
}
function Cz(e, t = "body > :not(script)") {
  const r = Array.from(document.querySelectorAll(t)).map((n) => {
    var o;
    if ((o = n == null ? void 0 : n.shadowRoot) != null && o.contains(e) || n.contains(e))
      return;
    const a = n.getAttribute("aria-hidden");
    return (a === null || a === "false") && n.setAttribute("aria-hidden", "true"), { node: n, ariaHidden: a };
  });
  return () => {
    r.forEach((n) => {
      n && (n.ariaHidden === null ? n.node.removeAttribute("aria-hidden") : n.node.setAttribute("aria-hidden", n.ariaHidden));
    });
  };
}
function BE(e = !0) {
  const t = qe(), r = qe(null), n = qn((o) => {
    if (e) {
      if (o === null) {
        r.current && (r.current(), r.current = null);
        return;
      }
      if (r.current = Cz(o), t.current !== o)
        if (o) {
          const a = () => {
            let i = o.querySelector("[data-autofocus]");
            if (!i) {
              const l = Array.from(o.querySelectorAll(LE));
              i = l.find(zE) || l.find(qh) || null, !i && qh(o) && (i = o);
            }
            i ? i.focus({ preventScroll: !0 }) : process.env.NODE_ENV === "development" && console.warn("[@mantine/hooks/use-focus-trap] Failed to find focusable element within provided node", o);
          };
          setTimeout(() => {
            o.getRootNode() ? a() : process.env.NODE_ENV === "development" && console.warn("[@mantine/hooks/use-focus-trap] Ref node is not part of the dom", o);
          }), t.current = o;
        } else
          t.current = null;
    }
  }, [e]);
  return Ue(() => {
    if (!e)
      return;
    const o = (a) => {
      a.key === "Tab" && t.current && $z(t.current, a);
    };
    return document.addEventListener("keydown", o), () => {
      document.removeEventListener("keydown", o), r.current && r.current();
    };
  }, [e]), n;
}
const kz = () => `mantine-${Math.random().toString(36).slice(2, 11)}`, Rz = F["useId".toString()] || (() => {
});
function Dz() {
  const [e, t] = Me("");
  return jE(() => {
    t(kz());
  }, []), e;
}
function Nz() {
  const e = Rz();
  return e ? `mantine-${e.replace(/:/g, "")}` : "";
}
function Zo(e) {
  return typeof e == "string" ? e : Nz() || Dz();
}
function Gh(e, t, r) {
  Ue(() => (window.addEventListener(e, t, r), () => window.removeEventListener(e, t, r)), [e, t]);
}
function Iz(e, t) {
  typeof e == "function" ? e(t) : typeof e == "object" && e !== null && "current" in e && (e.current = t);
}
function Mz(...e) {
  return (t) => {
    e.forEach((r) => Iz(r, t));
  };
}
function Jo(...e) {
  return qn(Mz(...e), e);
}
function Kn({
  value: e,
  defaultValue: t,
  finalValue: r,
  onChange: n = () => {
  }
}) {
  const [o, a] = Me(t !== void 0 ? t : r), i = (l) => {
    a(l), n == null || n(l);
  };
  return e !== void 0 ? [e, n, !0] : [o, i, !1];
}
function WE(e, t) {
  return Oz("(prefers-reduced-motion: reduce)", e, t);
}
const Az = (e) => e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e, jz = ({
  axis: e,
  target: t,
  parent: r,
  alignment: n,
  offset: o,
  isList: a
}) => {
  if (!t || !r && typeof document > "u")
    return 0;
  const i = !!r, c = (r || document.body).getBoundingClientRect(), u = t.getBoundingClientRect(), d = (f) => u[f] - c[f];
  if (e === "y") {
    const f = d("top");
    if (f === 0)
      return 0;
    if (n === "start") {
      const m = f - o;
      return m <= u.height * (a ? 0 : 1) || !a ? m : 0;
    }
    const p = i ? c.height : window.innerHeight;
    if (n === "end") {
      const m = f + o - p + u.height;
      return m >= -u.height * (a ? 0 : 1) || !a ? m : 0;
    }
    return n === "center" ? f - p / 2 + u.height / 2 : 0;
  }
  if (e === "x") {
    const f = d("left");
    if (f === 0)
      return 0;
    if (n === "start") {
      const m = f - o;
      return m <= u.width || !a ? m : 0;
    }
    const p = i ? c.width : window.innerWidth;
    if (n === "end") {
      const m = f + o - p + u.width;
      return m >= -u.width || !a ? m : 0;
    }
    return n === "center" ? f - p / 2 + u.width / 2 : 0;
  }
  return 0;
}, Fz = ({ axis: e, parent: t }) => {
  if (!t && typeof document > "u")
    return 0;
  const r = e === "y" ? "scrollTop" : "scrollLeft";
  if (t)
    return t[r];
  const { body: n, documentElement: o } = document;
  return n[r] + o[r];
}, Lz = ({ axis: e, parent: t, distance: r }) => {
  if (!t && typeof document > "u")
    return;
  const n = e === "y" ? "scrollTop" : "scrollLeft";
  if (t)
    t[n] = r;
  else {
    const { body: o, documentElement: a } = document;
    o[n] = r, a[n] = r;
  }
};
function UE({
  duration: e = 1250,
  axis: t = "y",
  onScrollFinish: r,
  easing: n = Az,
  offset: o = 0,
  cancelable: a = !0,
  isList: i = !1
} = {}) {
  const l = qe(0), c = qe(0), u = qe(!1), d = qe(null), f = qe(null), p = WE(), m = () => {
    l.current && cancelAnimationFrame(l.current);
  }, y = qn(({ alignment: v = "start" } = {}) => {
    var g;
    u.current = !1, l.current && m();
    const b = (g = Fz({ parent: d.current, axis: t })) != null ? g : 0, x = jz({
      parent: d.current,
      target: f.current,
      axis: t,
      alignment: v,
      offset: o,
      isList: i
    }) - (d.current ? 0 : b);
    function O() {
      c.current === 0 && (c.current = performance.now());
      const S = performance.now() - c.current, E = p || e === 0 ? 1 : S / e, C = b + x * n(E);
      Lz({
        parent: d.current,
        axis: t,
        distance: C
      }), !u.current && E < 1 ? l.current = requestAnimationFrame(O) : (typeof r == "function" && r(), c.current = 0, l.current = 0, m());
    }
    O();
  }, [t, e, n, i, o, r, p]), h = () => {
    a && (u.current = !0);
  };
  return Gh("wheel", h, {
    passive: !0
  }), Gh("touchmove", h, {
    passive: !0
  }), Ue(() => m, []), {
    scrollableRef: d,
    targetRef: f,
    scrollIntoView: y,
    cancel: m
  };
}
function Vz() {
  if (typeof window > "u" || typeof document > "u")
    return 0;
  const e = parseInt(window.getComputedStyle(document.body).paddingRight, 10), t = window.innerWidth - document.documentElement.clientWidth;
  return e + t;
}
const zz = ({ disableBodyPadding: e }) => {
  const t = e ? null : Vz();
  return `body {
        --removed-scroll-width: ${t}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${t ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
};
function Bz(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Wz(e) {
  (document.head || document.getElementsByTagName("head")[0]).appendChild(e);
}
function Uz() {
  const e = document.createElement("style");
  return e.type = "text/css", e.setAttribute("mantine-scroll-lock", ""), e;
}
function Hz(e, t = {
  disableBodyPadding: !1
}) {
  const [r, n] = Me(e || !1), o = qe(0), { disableBodyPadding: a } = t, i = qe(null), l = () => {
    o.current = window.scrollY;
    const u = zz({ disableBodyPadding: a }), d = Uz();
    Bz(d, u), Wz(d), i.current = d;
  }, c = () => {
    i != null && i.current && (i.current.parentNode.removeChild(i.current), i.current = null);
  };
  return Ue(() => (r ? l() : c(), c), [r]), Ue(() => {
    e !== void 0 && n(e);
  }, [e]), Ue(() => {
    e === void 0 && typeof window < "u" && window.document.body.style.overflow === "hidden" && n(!0);
  }, [n]), [r, n];
}
function HE(e) {
  const t = qe();
  return Ue(() => {
    t.current = e;
  }, [e]), t.current;
}
function Yz() {
  return `mantine-${Math.random().toString(36).slice(2, 11)}`;
}
var zw = Object.getOwnPropertySymbols, qz = Object.prototype.hasOwnProperty, Gz = Object.prototype.propertyIsEnumerable, Kz = (e, t) => {
  var r = {};
  for (var n in e)
    qz.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && zw)
    for (var n of zw(e))
      t.indexOf(n) < 0 && Gz.call(e, n) && (r[n] = e[n]);
  return r;
};
function Xi(e) {
  const t = e, {
    m: r,
    mx: n,
    my: o,
    mt: a,
    mb: i,
    ml: l,
    mr: c,
    p: u,
    px: d,
    py: f,
    pt: p,
    pb: m,
    pl: y,
    pr: h,
    bg: v,
    c: g,
    opacity: b,
    ff: x,
    fz: O,
    fw: w,
    lts: S,
    ta: E,
    lh: C,
    fs: N,
    tt: $,
    td: j,
    w: A,
    miw: k,
    maw: R,
    h: D,
    mih: L,
    mah: B,
    bgsz: H,
    bgp: U,
    bgr: I,
    bga: V,
    pos: G,
    top: q,
    left: J,
    bottom: ne,
    right: te,
    inset: ee,
    display: K
  } = t, Q = Kz(t, [
    "m",
    "mx",
    "my",
    "mt",
    "mb",
    "ml",
    "mr",
    "p",
    "px",
    "py",
    "pt",
    "pb",
    "pl",
    "pr",
    "bg",
    "c",
    "opacity",
    "ff",
    "fz",
    "fw",
    "lts",
    "ta",
    "lh",
    "fs",
    "tt",
    "td",
    "w",
    "miw",
    "maw",
    "h",
    "mih",
    "mah",
    "bgsz",
    "bgp",
    "bgr",
    "bga",
    "pos",
    "top",
    "left",
    "bottom",
    "right",
    "inset",
    "display"
  ]);
  return { systemStyles: NE({
    m: r,
    mx: n,
    my: o,
    mt: a,
    mb: i,
    ml: l,
    mr: c,
    p: u,
    px: d,
    py: f,
    pt: p,
    pb: m,
    pl: y,
    pr: h,
    bg: v,
    c: g,
    opacity: b,
    ff: x,
    fz: O,
    fw: w,
    lts: S,
    ta: E,
    lh: C,
    fs: N,
    tt: $,
    td: j,
    w: A,
    miw: k,
    maw: R,
    h: D,
    mih: L,
    mah: B,
    bgsz: H,
    bgp: U,
    bgr: I,
    bga: V,
    pos: G,
    top: q,
    left: J,
    bottom: ne,
    right: te,
    inset: ee,
    display: K
  }), rest: Q };
}
function Xz(e, t) {
  const r = Object.keys(e).filter((n) => n !== "base").sort((n, o) => t.fn.size({ size: n, sizes: t.breakpoints }) - t.fn.size({ size: o, sizes: t.breakpoints }));
  return "base" in e ? ["base", ...r] : r;
}
function Qz({ value: e, theme: t, getValue: r, property: n }) {
  if (e == null)
    return;
  if (typeof e == "object")
    return Xz(e, t).reduce((i, l) => {
      if (l === "base" && e.base !== void 0) {
        const u = r(e.base, t);
        return Array.isArray(n) ? (n.forEach((d) => {
          i[d] = u;
        }), i) : (i[n] = u, i);
      }
      const c = r(e[l], t);
      return Array.isArray(n) ? (i[t.fn.largerThan(l)] = {}, n.forEach((u) => {
        i[t.fn.largerThan(l)][u] = c;
      }), i) : (i[t.fn.largerThan(l)] = {
        [n]: c
      }, i);
    }, {});
  const o = r(e, t);
  return Array.isArray(n) ? n.reduce((a, i) => (a[i] = o, a), {}) : { [n]: o };
}
function Zz(e, t) {
  return e === "dimmed" ? t.colorScheme === "dark" ? t.colors.dark[2] : t.colors.gray[6] : t.fn.variant({ variant: "filled", color: e, primaryFallback: !1 }).background;
}
function Jz(e) {
  return e;
}
function e5(e, t) {
  return t.fn.size({ size: e, sizes: t.fontSizes });
}
const t5 = ["-xs", "-sm", "-md", "-lg", "-xl"];
function r5(e, t) {
  return t5.includes(e) ? t.fn.size({ size: e.replace("-", ""), sizes: t.spacing }) * -1 : t.fn.size({ size: e, sizes: t.spacing });
}
const n5 = {
  color: Zz,
  default: Jz,
  fontSize: e5,
  spacing: r5
}, o5 = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  mx: { type: "spacing", property: ["marginRight", "marginLeft"] },
  my: { type: "spacing", property: ["marginTop", "marginBottom"] },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  px: { type: "spacing", property: ["paddingRight", "paddingLeft"] },
  py: { type: "spacing", property: ["paddingTop", "paddingBottom"] },
  bg: { type: "color", property: "background" },
  c: { type: "color", property: "color" },
  opacity: { type: "default", property: "opacity" },
  ff: { type: "default", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "default", property: "fontWeight" },
  lts: { type: "default", property: "letterSpacing" },
  ta: { type: "default", property: "textAlign" },
  lh: { type: "default", property: "lineHeight" },
  fs: { type: "default", property: "fontStyle" },
  tt: { type: "default", property: "textTransform" },
  td: { type: "default", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "default", property: "background-size" },
  bgp: { type: "default", property: "background-position" },
  bgr: { type: "default", property: "background-repeat" },
  bga: { type: "default", property: "background-attachment" },
  pos: { type: "default", property: "position" },
  top: { type: "default", property: "top" },
  left: { type: "default", property: "left" },
  bottom: { type: "default", property: "bottom" },
  right: { type: "default", property: "right" },
  inset: { type: "default", property: "inset" },
  display: { type: "default", property: "display" }
};
var a5 = Object.defineProperty, Bw = Object.getOwnPropertySymbols, i5 = Object.prototype.hasOwnProperty, s5 = Object.prototype.propertyIsEnumerable, Ww = (e, t, r) => t in e ? a5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Uw = (e, t) => {
  for (var r in t || (t = {}))
    i5.call(t, r) && Ww(e, r, t[r]);
  if (Bw)
    for (var r of Bw(t))
      s5.call(t, r) && Ww(e, r, t[r]);
  return e;
};
function Hw(e, t, r = o5) {
  return Object.keys(r).reduce((o, a) => (a in e && e[a] !== void 0 && o.push(Qz({
    value: e[a],
    getValue: n5[r[a].type],
    property: r[a].property,
    theme: t
  })), o), []).reduce((o, a) => (Object.keys(a).forEach((i) => {
    typeof a[i] == "object" && a[i] !== null && i in o ? o[i] = Uw(Uw({}, o[i]), a[i]) : o[i] = a[i];
  }), o), {});
}
function Yw(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function l5(e, t, r) {
  const n = fr(), { css: o, cx: a } = AE();
  return Array.isArray(e) ? a(r, o(Hw(t, n)), e.map((i) => o(Yw(i, n)))) : a(r, o(Yw(e, n)), o(Hw(t, n)));
}
var c5 = Object.defineProperty, Du = Object.getOwnPropertySymbols, YE = Object.prototype.hasOwnProperty, qE = Object.prototype.propertyIsEnumerable, qw = (e, t, r) => t in e ? c5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, u5 = (e, t) => {
  for (var r in t || (t = {}))
    YE.call(t, r) && qw(e, r, t[r]);
  if (Du)
    for (var r of Du(t))
      qE.call(t, r) && qw(e, r, t[r]);
  return e;
}, d5 = (e, t) => {
  var r = {};
  for (var n in e)
    YE.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Du)
    for (var n of Du(e))
      t.indexOf(n) < 0 && qE.call(e, n) && (r[n] = e[n]);
  return r;
};
const GE = Ne((e, t) => {
  var r = e, { className: n, component: o, style: a, sx: i } = r, l = d5(r, ["className", "component", "style", "sx"]);
  const { systemStyles: c, rest: u } = Xi(l), d = o || "div";
  return /* @__PURE__ */ F.createElement(d, u5({
    ref: t,
    className: l5(i, c, n),
    style: a
  }, u));
});
GE.displayName = "@mantine/core/Box";
const Ke = GE;
var f5 = Object.defineProperty, p5 = Object.defineProperties, m5 = Object.getOwnPropertyDescriptors, Gw = Object.getOwnPropertySymbols, h5 = Object.prototype.hasOwnProperty, y5 = Object.prototype.propertyIsEnumerable, Kw = (e, t, r) => t in e ? f5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Xw = (e, t) => {
  for (var r in t || (t = {}))
    h5.call(t, r) && Kw(e, r, t[r]);
  if (Gw)
    for (var r of Gw(t))
      y5.call(t, r) && Kw(e, r, t[r]);
  return e;
}, v5 = (e, t) => p5(e, m5(t)), g5 = Qe((e) => ({
  root: v5(Xw(Xw({}, e.fn.focusStyles()), e.fn.fontStyles()), {
    cursor: "pointer",
    border: 0,
    padding: 0,
    appearance: "none",
    fontSize: e.fontSizes.md,
    backgroundColor: "transparent",
    textAlign: "left",
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    textDecoration: "none",
    boxSizing: "border-box"
  })
}));
const b5 = g5;
var w5 = Object.defineProperty, Nu = Object.getOwnPropertySymbols, KE = Object.prototype.hasOwnProperty, XE = Object.prototype.propertyIsEnumerable, Qw = (e, t, r) => t in e ? w5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, x5 = (e, t) => {
  for (var r in t || (t = {}))
    KE.call(t, r) && Qw(e, r, t[r]);
  if (Nu)
    for (var r of Nu(t))
      XE.call(t, r) && Qw(e, r, t[r]);
  return e;
}, _5 = (e, t) => {
  var r = {};
  for (var n in e)
    KE.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Nu)
    for (var n of Nu(e))
      t.indexOf(n) < 0 && XE.call(e, n) && (r[n] = e[n]);
  return r;
};
const QE = Ne((e, t) => {
  const r = Xe("UnstyledButton", {}, e), {
    className: n,
    component: o = "button",
    unstyled: a
  } = r, i = _5(r, [
    "className",
    "component",
    "unstyled"
  ]), { classes: l, cx: c } = b5(null, { name: "UnstyledButton", unstyled: a });
  return /* @__PURE__ */ F.createElement(Ke, x5({
    component: o,
    ref: t,
    className: c(l.root, n),
    type: o === "button" ? "button" : void 0
  }, i));
});
QE.displayName = "@mantine/core/UnstyledButton";
const Op = QE;
var O5 = Object.defineProperty, P5 = Object.defineProperties, S5 = Object.getOwnPropertyDescriptors, Zw = Object.getOwnPropertySymbols, T5 = Object.prototype.hasOwnProperty, E5 = Object.prototype.propertyIsEnumerable, Jw = (e, t, r) => t in e ? O5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ZE = (e, t) => {
  for (var r in t || (t = {}))
    T5.call(t, r) && Jw(e, r, t[r]);
  if (Zw)
    for (var r of Zw(t))
      E5.call(t, r) && Jw(e, r, t[r]);
  return e;
}, $5 = (e, t) => P5(e, S5(t));
const Ds = {
  xs: 18,
  sm: 22,
  md: 28,
  lg: 34,
  xl: 44
};
function C5({ variant: e, theme: t, color: r, gradient: n }) {
  const o = t.fn.variant({ color: r, variant: e, gradient: n });
  return e === "gradient" ? {
    border: 0,
    backgroundImage: o.background,
    color: o.color,
    "&:hover": t.fn.hover({
      backgroundSize: "200%"
    })
  } : ZE({
    border: `1px solid ${o.border}`,
    backgroundColor: o.background,
    color: o.color
  }, t.fn.hover({
    backgroundColor: o.hover
  }));
}
var k5 = Qe((e, { color: t, size: r, radius: n, variant: o, gradient: a }) => ({
  root: $5(ZE({}, C5({ variant: o, theme: e, color: t, gradient: a })), {
    position: "relative",
    height: e.fn.size({ size: r, sizes: Ds }),
    minHeight: e.fn.size({ size: r, sizes: Ds }),
    width: e.fn.size({ size: r, sizes: Ds }),
    minWidth: e.fn.size({ size: r, sizes: Ds }),
    borderRadius: e.fn.radius(n),
    padding: 0,
    lineHeight: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    "&:active": e.activeStyles,
    "&:disabled, &[data-disabled]": {
      color: e.colors.gray[e.colorScheme === "dark" ? 6 : 4],
      cursor: "not-allowed",
      backgroundColor: o === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
      borderColor: o === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
      backgroundImage: "none",
      pointerEvents: "none",
      "&:active": {
        transform: "none"
      }
    },
    "&[data-loading]": {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        top: -1,
        left: -1,
        right: -1,
        bottom: -1,
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], 0.5) : "rgba(255, 255, 255, .5)",
        borderRadius: e.fn.radius(n),
        cursor: "not-allowed"
      }
    }
  })
}));
const R5 = k5;
var D5 = Object.defineProperty, Iu = Object.getOwnPropertySymbols, JE = Object.prototype.hasOwnProperty, e$ = Object.prototype.propertyIsEnumerable, ex = (e, t, r) => t in e ? D5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, N5 = (e, t) => {
  for (var r in t || (t = {}))
    JE.call(t, r) && ex(e, r, t[r]);
  if (Iu)
    for (var r of Iu(t))
      e$.call(t, r) && ex(e, r, t[r]);
  return e;
}, I5 = (e, t) => {
  var r = {};
  for (var n in e)
    JE.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Iu)
    for (var n of Iu(e))
      t.indexOf(n) < 0 && e$.call(e, n) && (r[n] = e[n]);
  return r;
};
function M5(e) {
  var t = e, { size: r, color: n } = t, o = I5(t, ["size", "color"]);
  return /* @__PURE__ */ F.createElement("svg", N5({
    viewBox: "0 0 135 140",
    xmlns: "http://www.w3.org/2000/svg",
    fill: n,
    width: `${r}px`
  }, o), /* @__PURE__ */ F.createElement("rect", {
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "height",
    begin: "0.5s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "y",
    begin: "0.5s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("rect", {
    x: "30",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "height",
    begin: "0.25s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "y",
    begin: "0.25s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("rect", {
    x: "60",
    width: "15",
    height: "140",
    rx: "6"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "height",
    begin: "0s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "y",
    begin: "0s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("rect", {
    x: "90",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "height",
    begin: "0.25s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "y",
    begin: "0.25s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("rect", {
    x: "120",
    y: "10",
    width: "15",
    height: "120",
    rx: "6"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "height",
    begin: "0.5s",
    dur: "1s",
    values: "120;110;100;90;80;70;60;50;40;140;120",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "y",
    begin: "0.5s",
    dur: "1s",
    values: "10;15;20;25;30;35;40;45;50;0;10",
    calcMode: "linear",
    repeatCount: "indefinite"
  })));
}
var A5 = Object.defineProperty, Mu = Object.getOwnPropertySymbols, t$ = Object.prototype.hasOwnProperty, r$ = Object.prototype.propertyIsEnumerable, tx = (e, t, r) => t in e ? A5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, j5 = (e, t) => {
  for (var r in t || (t = {}))
    t$.call(t, r) && tx(e, r, t[r]);
  if (Mu)
    for (var r of Mu(t))
      r$.call(t, r) && tx(e, r, t[r]);
  return e;
}, F5 = (e, t) => {
  var r = {};
  for (var n in e)
    t$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Mu)
    for (var n of Mu(e))
      t.indexOf(n) < 0 && r$.call(e, n) && (r[n] = e[n]);
  return r;
};
function L5(e) {
  var t = e, { size: r, color: n } = t, o = F5(t, ["size", "color"]);
  return /* @__PURE__ */ F.createElement("svg", j5({
    width: `${r}px`,
    height: `${r}px`,
    viewBox: "0 0 38 38",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: n
  }, o), /* @__PURE__ */ F.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ F.createElement("g", {
    transform: "translate(2.5 2.5)",
    strokeWidth: "5"
  }, /* @__PURE__ */ F.createElement("circle", {
    strokeOpacity: ".5",
    cx: "16",
    cy: "16",
    r: "16"
  }), /* @__PURE__ */ F.createElement("path", {
    d: "M32 16c0-9.94-8.06-16-16-16"
  }, /* @__PURE__ */ F.createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    from: "0 16 16",
    to: "360 16 16",
    dur: "1s",
    repeatCount: "indefinite"
  })))));
}
var V5 = Object.defineProperty, Au = Object.getOwnPropertySymbols, n$ = Object.prototype.hasOwnProperty, o$ = Object.prototype.propertyIsEnumerable, rx = (e, t, r) => t in e ? V5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, z5 = (e, t) => {
  for (var r in t || (t = {}))
    n$.call(t, r) && rx(e, r, t[r]);
  if (Au)
    for (var r of Au(t))
      o$.call(t, r) && rx(e, r, t[r]);
  return e;
}, B5 = (e, t) => {
  var r = {};
  for (var n in e)
    n$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Au)
    for (var n of Au(e))
      t.indexOf(n) < 0 && o$.call(e, n) && (r[n] = e[n]);
  return r;
};
function W5(e) {
  var t = e, { size: r, color: n } = t, o = B5(t, ["size", "color"]);
  return /* @__PURE__ */ F.createElement("svg", z5({
    width: `${r}px`,
    height: `${r / 4}px`,
    viewBox: "0 0 120 30",
    xmlns: "http://www.w3.org/2000/svg",
    fill: n
  }, o), /* @__PURE__ */ F.createElement("circle", {
    cx: "15",
    cy: "15",
    r: "15"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "r",
    from: "15",
    to: "15",
    begin: "0s",
    dur: "0.8s",
    values: "15;9;15",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "fill-opacity",
    from: "1",
    to: "1",
    begin: "0s",
    dur: "0.8s",
    values: "1;.5;1",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("circle", {
    cx: "60",
    cy: "15",
    r: "9",
    fillOpacity: "0.3"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "r",
    from: "9",
    to: "9",
    begin: "0s",
    dur: "0.8s",
    values: "9;15;9",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "fill-opacity",
    from: "0.5",
    to: "0.5",
    begin: "0s",
    dur: "0.8s",
    values: ".5;1;.5",
    calcMode: "linear",
    repeatCount: "indefinite"
  })), /* @__PURE__ */ F.createElement("circle", {
    cx: "105",
    cy: "15",
    r: "15"
  }, /* @__PURE__ */ F.createElement("animate", {
    attributeName: "r",
    from: "15",
    to: "15",
    begin: "0s",
    dur: "0.8s",
    values: "15;9;15",
    calcMode: "linear",
    repeatCount: "indefinite"
  }), /* @__PURE__ */ F.createElement("animate", {
    attributeName: "fill-opacity",
    from: "1",
    to: "1",
    begin: "0s",
    dur: "0.8s",
    values: "1;.5;1",
    calcMode: "linear",
    repeatCount: "indefinite"
  })));
}
var U5 = Object.defineProperty, ju = Object.getOwnPropertySymbols, a$ = Object.prototype.hasOwnProperty, i$ = Object.prototype.propertyIsEnumerable, nx = (e, t, r) => t in e ? U5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, H5 = (e, t) => {
  for (var r in t || (t = {}))
    a$.call(t, r) && nx(e, r, t[r]);
  if (ju)
    for (var r of ju(t))
      i$.call(t, r) && nx(e, r, t[r]);
  return e;
}, Y5 = (e, t) => {
  var r = {};
  for (var n in e)
    a$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && ju)
    for (var n of ju(e))
      t.indexOf(n) < 0 && i$.call(e, n) && (r[n] = e[n]);
  return r;
};
const Cm = {
  bars: M5,
  oval: L5,
  dots: W5
}, q5 = {
  xs: 18,
  sm: 22,
  md: 36,
  lg: 44,
  xl: 58
}, G5 = {
  size: "md"
};
function Pp(e) {
  const t = Xe("Loader", G5, e), { size: r, color: n, variant: o } = t, a = Y5(t, ["size", "color", "variant"]), i = fr(), l = o in Cm ? o : i.loader;
  return /* @__PURE__ */ F.createElement(Ke, H5({
    role: "presentation",
    component: Cm[l] || Cm.bars,
    size: i.fn.size({ size: r, sizes: q5 }),
    color: i.fn.variant({
      variant: "filled",
      primaryFallback: !1,
      color: n || i.primaryColor
    }).background
  }, a));
}
Pp.displayName = "@mantine/core/Loader";
var K5 = Object.defineProperty, Fu = Object.getOwnPropertySymbols, s$ = Object.prototype.hasOwnProperty, l$ = Object.prototype.propertyIsEnumerable, ox = (e, t, r) => t in e ? K5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ax = (e, t) => {
  for (var r in t || (t = {}))
    s$.call(t, r) && ox(e, r, t[r]);
  if (Fu)
    for (var r of Fu(t))
      l$.call(t, r) && ox(e, r, t[r]);
  return e;
}, X5 = (e, t) => {
  var r = {};
  for (var n in e)
    s$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Fu)
    for (var n of Fu(e))
      t.indexOf(n) < 0 && l$.call(e, n) && (r[n] = e[n]);
  return r;
};
const Q5 = {
  color: "gray",
  size: "md",
  variant: "subtle",
  loading: !1
}, c$ = Ne((e, t) => {
  const r = Xe("ActionIcon", Q5, e), {
    className: n,
    color: o,
    children: a,
    radius: i,
    size: l,
    variant: c,
    gradient: u,
    disabled: d,
    loaderProps: f,
    loading: p,
    unstyled: m
  } = r, y = X5(r, [
    "className",
    "color",
    "children",
    "radius",
    "size",
    "variant",
    "gradient",
    "disabled",
    "loaderProps",
    "loading",
    "unstyled"
  ]), { classes: h, cx: v, theme: g } = R5({ size: l, radius: i, color: o, variant: c, gradient: u }, { name: "ActionIcon", unstyled: m }), b = g.fn.variant({ color: o, variant: c }), x = /* @__PURE__ */ F.createElement(Pp, ax({
    color: b.color,
    size: g.fn.size({ size: l, sizes: Ds }) - 12
  }, f));
  return /* @__PURE__ */ F.createElement(Op, ax({
    className: v(h.root, n),
    ref: t,
    disabled: d,
    "data-disabled": d || void 0,
    "data-loading": p || void 0,
    unstyled: m
  }, y), p ? x : a);
});
c$.displayName = "@mantine/core/ActionIcon";
const tn = c$;
function u$(e) {
  const { children: t, target: r, className: n } = Xe("Portal", {}, e), o = fr(), [a, i] = Me(!1), l = qe();
  return jE(() => (i(!0), l.current = r ? typeof r == "string" ? document.querySelector(r) : r : document.createElement("div"), r || document.body.appendChild(l.current), () => {
    !r && document.body.removeChild(l.current);
  }), [r]), a ? B2(/* @__PURE__ */ F.createElement("div", {
    className: n,
    dir: o.dir
  }, t), l.current) : null;
}
u$.displayName = "@mantine/core/Portal";
var Z5 = Object.defineProperty, Lu = Object.getOwnPropertySymbols, d$ = Object.prototype.hasOwnProperty, f$ = Object.prototype.propertyIsEnumerable, ix = (e, t, r) => t in e ? Z5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, J5 = (e, t) => {
  for (var r in t || (t = {}))
    d$.call(t, r) && ix(e, r, t[r]);
  if (Lu)
    for (var r of Lu(t))
      f$.call(t, r) && ix(e, r, t[r]);
  return e;
}, eB = (e, t) => {
  var r = {};
  for (var n in e)
    d$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Lu)
    for (var n of Lu(e))
      t.indexOf(n) < 0 && f$.call(e, n) && (r[n] = e[n]);
  return r;
};
function Pl(e) {
  var t = e, { withinPortal: r = !0, children: n } = t, o = eB(t, ["withinPortal", "children"]);
  return r ? /* @__PURE__ */ F.createElement(u$, J5({}, o), n) : /* @__PURE__ */ F.createElement(F.Fragment, null, n);
}
Pl.displayName = "@mantine/core/OptionalPortal";
var tB = Object.defineProperty, sx = Object.getOwnPropertySymbols, rB = Object.prototype.hasOwnProperty, nB = Object.prototype.propertyIsEnumerable, lx = (e, t, r) => t in e ? tB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, oB = (e, t) => {
  for (var r in t || (t = {}))
    rB.call(t, r) && lx(e, r, t[r]);
  if (sx)
    for (var r of sx(t))
      nB.call(t, r) && lx(e, r, t[r]);
  return e;
};
function p$(e) {
  return /* @__PURE__ */ F.createElement("svg", oB({
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e), /* @__PURE__ */ F.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
p$.displayName = "@mantine/core/CloseIcon";
var aB = Object.defineProperty, Vu = Object.getOwnPropertySymbols, m$ = Object.prototype.hasOwnProperty, h$ = Object.prototype.propertyIsEnumerable, cx = (e, t, r) => t in e ? aB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, iB = (e, t) => {
  for (var r in t || (t = {}))
    m$.call(t, r) && cx(e, r, t[r]);
  if (Vu)
    for (var r of Vu(t))
      h$.call(t, r) && cx(e, r, t[r]);
  return e;
}, sB = (e, t) => {
  var r = {};
  for (var n in e)
    m$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Vu)
    for (var n of Vu(e))
      t.indexOf(n) < 0 && h$.call(e, n) && (r[n] = e[n]);
  return r;
};
const lB = {
  xs: 12,
  sm: 14,
  md: 16,
  lg: 20,
  xl: 24
}, cB = {
  size: "md"
}, y$ = Ne((e, t) => {
  const r = Xe("CloseButton", cB, e), {
    iconSize: n,
    size: o = "md"
  } = r, a = sB(r, [
    "iconSize",
    "size"
  ]), i = fr(), l = n || i.fn.size({ size: o, sizes: lB });
  return /* @__PURE__ */ F.createElement(tn, iB({
    size: o,
    ref: t
  }, a), /* @__PURE__ */ F.createElement(p$, {
    width: l,
    height: l
  }));
});
y$.displayName = "@mantine/core/CloseButton";
const Sp = y$;
var uB = Object.defineProperty, dB = Object.defineProperties, fB = Object.getOwnPropertyDescriptors, ux = Object.getOwnPropertySymbols, pB = Object.prototype.hasOwnProperty, mB = Object.prototype.propertyIsEnumerable, dx = (e, t, r) => t in e ? uB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, hs = (e, t) => {
  for (var r in t || (t = {}))
    pB.call(t, r) && dx(e, r, t[r]);
  if (ux)
    for (var r of ux(t))
      mB.call(t, r) && dx(e, r, t[r]);
  return e;
}, hB = (e, t) => dB(e, fB(t));
function yB({
  underline: e,
  strikethrough: t
}) {
  const r = [];
  return e && r.push("underline"), t && r.push("line-through"), r.length > 0 ? r.join(" ") : "none";
}
function vB({ theme: e, color: t, variant: r }) {
  return t === "dimmed" ? e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6] : typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? e.fn.variant({ variant: "filled", color: t }).background : r === "link" ? e.colors[e.primaryColor][e.colorScheme === "dark" ? 4 : 7] : t || "inherit";
}
function gB(e) {
  return typeof e == "number" ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    display: "-webkit-box",
    WebkitLineClamp: e,
    WebkitBoxOrient: "vertical"
  } : null;
}
function bB({ theme: e, truncate: t }) {
  return t === "start" ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    direction: e.dir === "ltr" ? "rtl" : "ltr",
    textAlign: e.dir === "ltr" ? "right" : "left"
  } : t ? {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  } : null;
}
var wB = Qe((e, {
  color: t,
  variant: r,
  size: n,
  lineClamp: o,
  truncate: a,
  inline: i,
  inherit: l,
  underline: c,
  gradient: u,
  weight: d,
  transform: f,
  align: p,
  strikethrough: m,
  italic: y
}) => {
  const h = e.fn.variant({ variant: "gradient", gradient: u });
  return {
    root: hs(hB(hs(hs(hs(hs({}, e.fn.fontStyles()), e.fn.focusStyles()), gB(o)), bB({ theme: e, truncate: a })), {
      color: vB({ color: t, theme: e, variant: r }),
      fontFamily: l ? "inherit" : e.fontFamily,
      fontSize: l || n === void 0 ? "inherit" : e.fn.size({ size: n, sizes: e.fontSizes }),
      lineHeight: l ? "inherit" : i ? 1 : e.lineHeight,
      textDecoration: yB({ underline: c, strikethrough: m }),
      WebkitTapHighlightColor: "transparent",
      fontWeight: l ? "inherit" : d,
      textTransform: f,
      textAlign: p,
      fontStyle: y ? "italic" : void 0
    }), e.fn.hover(r === "link" && c === void 0 ? {
      textDecoration: "underline"
    } : void 0)),
    gradient: {
      backgroundImage: h.background,
      WebkitBackgroundClip: "text",
      WebkitTextFillColor: "transparent"
    }
  };
});
const xB = wB;
var _B = Object.defineProperty, zu = Object.getOwnPropertySymbols, v$ = Object.prototype.hasOwnProperty, g$ = Object.prototype.propertyIsEnumerable, fx = (e, t, r) => t in e ? _B(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, OB = (e, t) => {
  for (var r in t || (t = {}))
    v$.call(t, r) && fx(e, r, t[r]);
  if (zu)
    for (var r of zu(t))
      g$.call(t, r) && fx(e, r, t[r]);
  return e;
}, PB = (e, t) => {
  var r = {};
  for (var n in e)
    v$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && zu)
    for (var n of zu(e))
      t.indexOf(n) < 0 && g$.call(e, n) && (r[n] = e[n]);
  return r;
};
const SB = {
  variant: "text"
}, b$ = Ne((e, t) => {
  const r = Xe("Text", SB, e), {
    className: n,
    size: o,
    weight: a,
    transform: i,
    color: l,
    align: c,
    variant: u,
    lineClamp: d,
    truncate: f,
    gradient: p,
    inline: m,
    inherit: y,
    underline: h,
    strikethrough: v,
    italic: g,
    classNames: b,
    styles: x,
    unstyled: O,
    span: w
  } = r, S = PB(r, [
    "className",
    "size",
    "weight",
    "transform",
    "color",
    "align",
    "variant",
    "lineClamp",
    "truncate",
    "gradient",
    "inline",
    "inherit",
    "underline",
    "strikethrough",
    "italic",
    "classNames",
    "styles",
    "unstyled",
    "span"
  ]), { classes: E, cx: C } = xB({
    variant: u,
    color: l,
    size: o,
    lineClamp: d,
    truncate: f,
    inline: m,
    inherit: y,
    underline: h,
    strikethrough: v,
    italic: g,
    weight: a,
    transform: i,
    align: c,
    gradient: p
  }, { unstyled: O, name: "Text" });
  return /* @__PURE__ */ F.createElement(Ke, OB({
    ref: t,
    className: C(E.root, { [E.gradient]: u === "gradient" }, n),
    component: w ? "span" : "div"
  }, S));
});
b$.displayName = "@mantine/core/Text";
const $r = b$, Hl = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};
function Yl(e, t) {
  const r = e.fn.variant({ variant: "outline", color: t }).border;
  return typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? r : t === void 0 ? e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4] : t;
}
var TB = Qe((e, { size: t, variant: r, color: n }) => ({
  root: {},
  withLabel: {
    borderTop: "0 !important"
  },
  left: {
    "&::before": {
      display: "none"
    }
  },
  right: {
    "&::after": {
      display: "none"
    }
  },
  label: {
    display: "flex",
    alignItems: "center",
    "&::before": {
      content: '""',
      flex: 1,
      height: 1,
      borderTop: `${e.fn.size({ size: t, sizes: Hl })}px ${r} ${Yl(e, n)}`,
      marginRight: e.spacing.xs
    },
    "&::after": {
      content: '""',
      flex: 1,
      borderTop: `${e.fn.size({ size: t, sizes: Hl })}px ${r} ${Yl(e, n)}`,
      marginLeft: e.spacing.xs
    }
  },
  labelDefaultStyles: {
    color: n === "dark" ? e.colors.dark[1] : e.fn.themeColor(n, e.colorScheme === "dark" ? 5 : e.fn.primaryShade(), !1)
  },
  horizontal: {
    border: 0,
    borderTopWidth: e.fn.size({ size: t, sizes: Hl }),
    borderTopColor: Yl(e, n),
    borderTopStyle: r,
    margin: 0
  },
  vertical: {
    border: 0,
    alignSelf: "stretch",
    height: "auto",
    borderLeftWidth: e.fn.size({ size: t, sizes: Hl }),
    borderLeftColor: Yl(e, n),
    borderLeftStyle: r
  }
}));
const EB = TB;
var $B = Object.defineProperty, CB = Object.defineProperties, kB = Object.getOwnPropertyDescriptors, Bu = Object.getOwnPropertySymbols, w$ = Object.prototype.hasOwnProperty, x$ = Object.prototype.propertyIsEnumerable, px = (e, t, r) => t in e ? $B(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, mx = (e, t) => {
  for (var r in t || (t = {}))
    w$.call(t, r) && px(e, r, t[r]);
  if (Bu)
    for (var r of Bu(t))
      x$.call(t, r) && px(e, r, t[r]);
  return e;
}, RB = (e, t) => CB(e, kB(t)), DB = (e, t) => {
  var r = {};
  for (var n in e)
    w$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Bu)
    for (var n of Bu(e))
      t.indexOf(n) < 0 && x$.call(e, n) && (r[n] = e[n]);
  return r;
};
const NB = {
  orientation: "horizontal",
  size: "xs",
  labelPosition: "left",
  variant: "solid"
}, ol = Ne((e, t) => {
  const r = Xe("Divider", NB, e), {
    className: n,
    color: o,
    orientation: a,
    size: i,
    label: l,
    labelPosition: c,
    labelProps: u,
    variant: d,
    styles: f,
    classNames: p,
    unstyled: m
  } = r, y = DB(r, [
    "className",
    "color",
    "orientation",
    "size",
    "label",
    "labelPosition",
    "labelProps",
    "variant",
    "styles",
    "classNames",
    "unstyled"
  ]), { classes: h, cx: v } = EB({ color: o, size: i, variant: d }, { classNames: p, styles: f, unstyled: m, name: "Divider" }), g = a === "vertical", b = a === "horizontal", x = !!l && b, O = !(u != null && u.color);
  return /* @__PURE__ */ F.createElement(Ke, mx({
    ref: t,
    className: v(h.root, {
      [h.vertical]: g,
      [h.horizontal]: b,
      [h.withLabel]: x
    }, n),
    role: "separator"
  }, y), x && /* @__PURE__ */ F.createElement($r, RB(mx({}, u), {
    size: (u == null ? void 0 : u.size) || "xs",
    sx: { marginTop: 2 },
    className: v(h.label, h[c], {
      [h.labelDefaultStyles]: O
    })
  }), l));
});
ol.displayName = "@mantine/core/Divider";
var IB = Object.defineProperty, MB = Object.defineProperties, AB = Object.getOwnPropertyDescriptors, hx = Object.getOwnPropertySymbols, jB = Object.prototype.hasOwnProperty, FB = Object.prototype.propertyIsEnumerable, yx = (e, t, r) => t in e ? IB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, vx = (e, t) => {
  for (var r in t || (t = {}))
    jB.call(t, r) && yx(e, r, t[r]);
  if (hx)
    for (var r of hx(t))
      FB.call(t, r) && yx(e, r, t[r]);
  return e;
}, LB = (e, t) => MB(e, AB(t)), VB = Qe((e, { size: t }) => ({
  item: LB(vx({}, e.fn.fontStyles()), {
    boxSizing: "border-box",
    textAlign: "left",
    width: "100%",
    padding: `${e.fn.size({ size: t, sizes: e.spacing }) / 1.5}px ${e.fn.size({
      size: t,
      sizes: e.spacing
    })}px`,
    cursor: "pointer",
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    borderRadius: e.fn.radius(),
    "&[data-hovered]": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[1]
    },
    "&[data-selected]": vx({
      backgroundColor: e.fn.variant({ variant: "filled" }).background,
      color: e.fn.variant({ variant: "filled" }).color
    }, e.fn.hover({ backgroundColor: e.fn.variant({ variant: "filled" }).hover })),
    "&[data-disabled]": {
      cursor: "default",
      color: e.colors.dark[2]
    }
  }),
  nothingFound: {
    boxSizing: "border-box",
    color: e.colors.gray[6],
    paddingTop: e.fn.size({ size: t, sizes: e.spacing }) / 2,
    paddingBottom: e.fn.size({ size: t, sizes: e.spacing }) / 2,
    textAlign: "center"
  },
  separator: {
    boxSizing: "border-box",
    textAlign: "left",
    width: "100%",
    padding: `${e.fn.size({ size: t, sizes: e.spacing }) / 1.5}px ${e.fn.size({
      size: t,
      sizes: e.spacing
    })}px`
  },
  separatorLabel: {
    color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
  }
}));
const zB = VB;
var BB = Object.defineProperty, gx = Object.getOwnPropertySymbols, WB = Object.prototype.hasOwnProperty, UB = Object.prototype.propertyIsEnumerable, bx = (e, t, r) => t in e ? BB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, HB = (e, t) => {
  for (var r in t || (t = {}))
    WB.call(t, r) && bx(e, r, t[r]);
  if (gx)
    for (var r of gx(t))
      UB.call(t, r) && bx(e, r, t[r]);
  return e;
};
function _g({
  data: e,
  hovered: t,
  classNames: r,
  styles: n,
  isItemSelected: o,
  uuid: a,
  __staticSelector: i,
  onItemHover: l,
  onItemSelect: c,
  itemsRefs: u,
  itemComponent: d,
  size: f,
  nothingFound: p,
  creatable: m,
  createLabel: y,
  unstyled: h
}) {
  const { classes: v } = zB({ size: f }, { classNames: r, styles: n, unstyled: h, name: i }), g = [], b = [];
  let x = null;
  const O = (S, E) => {
    const C = typeof o == "function" ? o(S.value) : !1;
    return /* @__PURE__ */ F.createElement(d, HB({
      key: S.value,
      className: v.item,
      "data-disabled": S.disabled || void 0,
      "data-hovered": !S.disabled && t === E || void 0,
      "data-selected": !S.disabled && C || void 0,
      selected: C,
      onMouseEnter: () => l(E),
      id: `${a}-${E}`,
      role: "option",
      tabIndex: -1,
      "aria-selected": t === E,
      ref: (N) => {
        u && u.current && (u.current[S.value] = N);
      },
      onMouseDown: S.disabled ? null : (N) => {
        N.preventDefault(), c(S);
      },
      disabled: S.disabled
    }, S));
  };
  let w = null;
  if (e.forEach((S, E) => {
    S.creatable ? x = E : S.group ? (w !== S.group && (w = S.group, b.push(/* @__PURE__ */ F.createElement("div", {
      className: v.separator,
      key: `__mantine-divider-${E}`
    }, /* @__PURE__ */ F.createElement(ol, {
      classNames: { label: v.separatorLabel },
      label: S.group
    })))), b.push(O(S, E))) : g.push(O(S, E));
  }), m) {
    const S = e[x];
    g.push(/* @__PURE__ */ F.createElement("div", {
      key: Yz(),
      className: v.item,
      "data-hovered": t === x || void 0,
      onMouseEnter: () => l(x),
      onMouseDown: (E) => {
        E.preventDefault(), c(S);
      },
      tabIndex: -1,
      ref: (E) => {
        u && u.current && (u.current[S.value] = E);
      }
    }, y));
  }
  return b.length > 0 && g.length > 0 && g.unshift(/* @__PURE__ */ F.createElement("div", {
    className: v.separator,
    key: "empty-group-separator"
  }, /* @__PURE__ */ F.createElement(ol, null))), b.length > 0 || g.length > 0 ? /* @__PURE__ */ F.createElement(F.Fragment, null, b, g) : /* @__PURE__ */ F.createElement($r, {
    size: f,
    unstyled: h,
    className: v.nothingFound
  }, p);
}
_g.displayName = "@mantine/core/SelectItems";
var YB = Object.defineProperty, Wu = Object.getOwnPropertySymbols, _$ = Object.prototype.hasOwnProperty, O$ = Object.prototype.propertyIsEnumerable, wx = (e, t, r) => t in e ? YB(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, qB = (e, t) => {
  for (var r in t || (t = {}))
    _$.call(t, r) && wx(e, r, t[r]);
  if (Wu)
    for (var r of Wu(t))
      O$.call(t, r) && wx(e, r, t[r]);
  return e;
}, GB = (e, t) => {
  var r = {};
  for (var n in e)
    _$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Wu)
    for (var n of Wu(e))
      t.indexOf(n) < 0 && O$.call(e, n) && (r[n] = e[n]);
  return r;
};
const Og = Ne((e, t) => {
  var r = e, { label: n, value: o } = r, a = GB(r, ["label", "value"]);
  return /* @__PURE__ */ F.createElement("div", qB({
    ref: t
  }, a), n || o);
});
Og.displayName = "@mantine/core/DefaultItem";
function KB(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function P$(...e) {
  return (t) => e.forEach(
    (r) => KB(r, t)
  );
}
function Va(...e) {
  return qn(P$(...e), e);
}
const S$ = /* @__PURE__ */ Ne((e, t) => {
  const { children: r, ...n } = e, o = Bo.toArray(r), a = o.find(QB);
  if (a) {
    const i = a.props.children, l = o.map((c) => c === a ? Bo.count(i) > 1 ? Bo.only(null) : /* @__PURE__ */ Wo(i) ? i.props.children : null : c);
    return /* @__PURE__ */ et(Kh, T({}, n, {
      ref: t
    }), /* @__PURE__ */ Wo(i) ? /* @__PURE__ */ on(i, void 0, l) : null);
  }
  return /* @__PURE__ */ et(Kh, T({}, n, {
    ref: t
  }), r);
});
S$.displayName = "Slot";
const Kh = /* @__PURE__ */ Ne((e, t) => {
  const { children: r, ...n } = e;
  return /* @__PURE__ */ Wo(r) ? /* @__PURE__ */ on(r, {
    ...ZB(n, r.props),
    ref: P$(t, r.ref)
  }) : Bo.count(r) > 1 ? Bo.only(null) : null;
});
Kh.displayName = "SlotClone";
const XB = ({ children: e }) => /* @__PURE__ */ et(Yi, null, e);
function QB(e) {
  return /* @__PURE__ */ Wo(e) && e.type === XB;
}
function ZB(e, t) {
  const r = {
    ...t
  };
  for (const n in t) {
    const o = e[n], a = t[n];
    /^on[A-Z]/.test(n) ? o && a ? r[n] = (...l) => {
      a(...l), o(...l);
    } : o && (r[n] = o) : n === "style" ? r[n] = {
      ...o,
      ...a
    } : n === "className" && (r[n] = [
      o,
      a
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...r
  };
}
const JB = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Sl = JB.reduce((e, t) => {
  const r = /* @__PURE__ */ Ne((n, o) => {
    const { asChild: a, ...i } = n, l = a ? S$ : t;
    return Ue(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ et(l, T({}, i, {
      ref: o
    }));
  });
  return r.displayName = `Primitive.${t}`, {
    ...e,
    [t]: r
  };
}, {}), Xh = globalThis != null && globalThis.document ? Zf : () => {
};
function e6(e, t) {
  return hl((r, n) => {
    const o = t[r][n];
    return o ?? r;
  }, e);
}
const Tl = (e) => {
  const { present: t, children: r } = e, n = t6(t), o = typeof r == "function" ? r({
    present: n.isPresent
  }) : Bo.only(r), a = Va(n.ref, o.ref);
  return typeof r == "function" || n.isPresent ? /* @__PURE__ */ on(o, {
    ref: a
  }) : null;
};
Tl.displayName = "Presence";
function t6(e) {
  const [t, r] = Me(), n = qe({}), o = qe(e), a = qe("none"), i = e ? "mounted" : "unmounted", [l, c] = e6(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Ue(() => {
    const u = ql(n.current);
    a.current = l === "mounted" ? u : "none";
  }, [
    l
  ]), Xh(() => {
    const u = n.current, d = o.current;
    if (d !== e) {
      const p = a.current, m = ql(u);
      e ? c("MOUNT") : m === "none" || (u == null ? void 0 : u.display) === "none" ? c("UNMOUNT") : c(d && p !== m ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [
    e,
    c
  ]), Xh(() => {
    if (t) {
      const u = (f) => {
        const m = ql(n.current).includes(f.animationName);
        f.target === t && m && W2(
          () => c("ANIMATION_END")
        );
      }, d = (f) => {
        f.target === t && (a.current = ql(n.current));
      };
      return t.addEventListener("animationstart", d), t.addEventListener("animationcancel", u), t.addEventListener("animationend", u), () => {
        t.removeEventListener("animationstart", d), t.removeEventListener("animationcancel", u), t.removeEventListener("animationend", u);
      };
    } else
      c("ANIMATION_END");
  }, [
    t,
    c
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(l),
    ref: qn((u) => {
      u && (n.current = getComputedStyle(u)), r(u);
    }, [])
  };
}
function ql(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function r6(e, t = []) {
  let r = [];
  function n(a, i) {
    const l = /* @__PURE__ */ Br(i), c = r.length;
    r = [
      ...r,
      i
    ];
    function u(f) {
      const { scope: p, children: m, ...y } = f, h = (p == null ? void 0 : p[e][c]) || l, v = fn(
        () => y,
        Object.values(y)
      );
      return /* @__PURE__ */ et(h.Provider, {
        value: v
      }, m);
    }
    function d(f, p) {
      const m = (p == null ? void 0 : p[e][c]) || l, y = ar(m);
      if (y)
        return y;
      if (i !== void 0)
        return i;
      throw new Error(`\`${f}\` must be used within \`${a}\``);
    }
    return u.displayName = a + "Provider", [
      u,
      d
    ];
  }
  const o = () => {
    const a = r.map((i) => /* @__PURE__ */ Br(i));
    return function(l) {
      const c = (l == null ? void 0 : l[e]) || a;
      return fn(
        () => ({
          [`__scope${e}`]: {
            ...l,
            [e]: c
          }
        }),
        [
          l,
          c
        ]
      );
    };
  };
  return o.scopeName = e, [
    n,
    n6(o, ...t)
  ];
}
function n6(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const r = () => {
    const n = e.map(
      (o) => ({
        useScope: o(),
        scopeName: o.scopeName
      })
    );
    return function(a) {
      const i = n.reduce((l, { useScope: c, scopeName: u }) => {
        const f = c(a)[`__scope${u}`];
        return {
          ...l,
          ...f
        };
      }, {});
      return fn(
        () => ({
          [`__scope${t.scopeName}`]: i
        }),
        [
          i
        ]
      );
    };
  };
  return r.scopeName = t.scopeName, r;
}
function va(e) {
  const t = qe(e);
  return Ue(() => {
    t.current = e;
  }), fn(
    () => (...r) => {
      var n;
      return (n = t.current) === null || n === void 0 ? void 0 : n.call(t, ...r);
    },
    []
  );
}
const o6 = /* @__PURE__ */ Br(void 0);
function a6(e) {
  const t = ar(o6);
  return e || t || "ltr";
}
function i6(e, [t, r]) {
  return Math.min(r, Math.max(t, e));
}
function Oa(e, t, { checkForDefaultPrevented: r = !0 } = {}) {
  return function(o) {
    if (e == null || e(o), r === !1 || !o.defaultPrevented)
      return t == null ? void 0 : t(o);
  };
}
function s6(e, t) {
  return hl((r, n) => {
    const o = t[r][n];
    return o ?? r;
  }, e);
}
const T$ = "ScrollArea", [E$, Cve] = r6(T$), [l6, gn] = E$(T$), c6 = /* @__PURE__ */ Ne((e, t) => {
  const { __scopeScrollArea: r, type: n = "hover", dir: o, scrollHideDelay: a = 600, ...i } = e, [l, c] = Me(null), [u, d] = Me(null), [f, p] = Me(null), [m, y] = Me(null), [h, v] = Me(null), [g, b] = Me(0), [x, O] = Me(0), [w, S] = Me(!1), [E, C] = Me(!1), N = Va(
    t,
    (j) => c(j)
  ), $ = a6(o);
  return /* @__PURE__ */ et(l6, {
    scope: r,
    type: n,
    dir: $,
    scrollHideDelay: a,
    scrollArea: l,
    viewport: u,
    onViewportChange: d,
    content: f,
    onContentChange: p,
    scrollbarX: m,
    onScrollbarXChange: y,
    scrollbarXEnabled: w,
    onScrollbarXEnabledChange: S,
    scrollbarY: h,
    onScrollbarYChange: v,
    scrollbarYEnabled: E,
    onScrollbarYEnabledChange: C,
    onCornerWidthChange: b,
    onCornerHeightChange: O
  }, /* @__PURE__ */ et(Sl.div, T({
    dir: $
  }, i, {
    ref: N,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      ["--radix-scroll-area-corner-width"]: g + "px",
      ["--radix-scroll-area-corner-height"]: x + "px",
      ...e.style
    }
  })));
}), u6 = "ScrollAreaViewport", d6 = /* @__PURE__ */ Ne((e, t) => {
  const { __scopeScrollArea: r, children: n, ...o } = e, a = gn(u6, r), i = qe(null), l = Va(t, i, a.onViewportChange);
  return /* @__PURE__ */ et(Yi, null, /* @__PURE__ */ et("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ et(Sl.div, T({
    "data-radix-scroll-area-viewport": ""
  }, o, {
    ref: l,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
      ...e.style
    }
  }), /* @__PURE__ */ et("div", {
    ref: a.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, n)));
}), Po = "ScrollAreaScrollbar", f6 = /* @__PURE__ */ Ne((e, t) => {
  const { forceMount: r, ...n } = e, o = gn(Po, e.__scopeScrollArea), { onScrollbarXEnabledChange: a, onScrollbarYEnabledChange: i } = o, l = e.orientation === "horizontal";
  return Ue(() => (l ? a(!0) : i(!0), () => {
    l ? a(!1) : i(!1);
  }), [
    l,
    a,
    i
  ]), o.type === "hover" ? /* @__PURE__ */ et(p6, T({}, n, {
    ref: t,
    forceMount: r
  })) : o.type === "scroll" ? /* @__PURE__ */ et(m6, T({}, n, {
    ref: t,
    forceMount: r
  })) : o.type === "auto" ? /* @__PURE__ */ et($$, T({}, n, {
    ref: t,
    forceMount: r
  })) : o.type === "always" ? /* @__PURE__ */ et(Pg, T({}, n, {
    ref: t
  })) : null;
}), p6 = /* @__PURE__ */ Ne((e, t) => {
  const { forceMount: r, ...n } = e, o = gn(Po, e.__scopeScrollArea), [a, i] = Me(!1);
  return Ue(() => {
    const l = o.scrollArea;
    let c = 0;
    if (l) {
      const u = () => {
        window.clearTimeout(c), i(!0);
      }, d = () => {
        c = window.setTimeout(
          () => i(!1),
          o.scrollHideDelay
        );
      };
      return l.addEventListener("pointerenter", u), l.addEventListener("pointerleave", d), () => {
        window.clearTimeout(c), l.removeEventListener("pointerenter", u), l.removeEventListener("pointerleave", d);
      };
    }
  }, [
    o.scrollArea,
    o.scrollHideDelay
  ]), /* @__PURE__ */ et(Tl, {
    present: r || a
  }, /* @__PURE__ */ et($$, T({
    "data-state": a ? "visible" : "hidden"
  }, n, {
    ref: t
  })));
}), m6 = /* @__PURE__ */ Ne((e, t) => {
  const { forceMount: r, ...n } = e, o = gn(Po, e.__scopeScrollArea), a = e.orientation === "horizontal", i = Ep(
    () => c("SCROLL_END"),
    100
  ), [l, c] = s6("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return Ue(() => {
    if (l === "idle") {
      const u = window.setTimeout(
        () => c("HIDE"),
        o.scrollHideDelay
      );
      return () => window.clearTimeout(u);
    }
  }, [
    l,
    o.scrollHideDelay,
    c
  ]), Ue(() => {
    const u = o.viewport, d = a ? "scrollLeft" : "scrollTop";
    if (u) {
      let f = u[d];
      const p = () => {
        const m = u[d];
        f !== m && (c("SCROLL"), i()), f = m;
      };
      return u.addEventListener("scroll", p), () => u.removeEventListener("scroll", p);
    }
  }, [
    o.viewport,
    a,
    c,
    i
  ]), /* @__PURE__ */ et(Tl, {
    present: r || l !== "hidden"
  }, /* @__PURE__ */ et(Pg, T({
    "data-state": l === "hidden" ? "hidden" : "visible"
  }, n, {
    ref: t,
    onPointerEnter: Oa(
      e.onPointerEnter,
      () => c("POINTER_ENTER")
    ),
    onPointerLeave: Oa(
      e.onPointerLeave,
      () => c("POINTER_LEAVE")
    )
  })));
}), $$ = /* @__PURE__ */ Ne((e, t) => {
  const r = gn(Po, e.__scopeScrollArea), { forceMount: n, ...o } = e, [a, i] = Me(!1), l = e.orientation === "horizontal", c = Ep(() => {
    if (r.viewport) {
      const u = r.viewport.offsetWidth < r.viewport.scrollWidth, d = r.viewport.offsetHeight < r.viewport.scrollHeight;
      i(l ? u : d);
    }
  }, 10);
  return Ni(r.viewport, c), Ni(r.content, c), /* @__PURE__ */ et(Tl, {
    present: n || a
  }, /* @__PURE__ */ et(Pg, T({
    "data-state": a ? "visible" : "hidden"
  }, o, {
    ref: t
  })));
}), Pg = /* @__PURE__ */ Ne((e, t) => {
  const { orientation: r = "vertical", ...n } = e, o = gn(Po, e.__scopeScrollArea), a = qe(null), i = qe(0), [l, c] = Me({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), u = D$(l.viewport, l.content), d = {
    ...n,
    sizes: l,
    onSizesChange: c,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (p) => a.current = p,
    onThumbPointerUp: () => i.current = 0,
    onThumbPointerDown: (p) => i.current = p
  };
  function f(p, m) {
    return _6(p, i.current, l, m);
  }
  return r === "horizontal" ? /* @__PURE__ */ et(h6, T({}, d, {
    ref: t,
    onThumbPositionChange: () => {
      if (o.viewport && a.current) {
        const p = o.viewport.scrollLeft, m = xx(p, l, o.dir);
        a.current.style.transform = `translate3d(${m}px, 0, 0)`;
      }
    },
    onWheelScroll: (p) => {
      o.viewport && (o.viewport.scrollLeft = p);
    },
    onDragScroll: (p) => {
      o.viewport && (o.viewport.scrollLeft = f(p, o.dir));
    }
  })) : r === "vertical" ? /* @__PURE__ */ et(y6, T({}, d, {
    ref: t,
    onThumbPositionChange: () => {
      if (o.viewport && a.current) {
        const p = o.viewport.scrollTop, m = xx(p, l);
        a.current.style.transform = `translate3d(0, ${m}px, 0)`;
      }
    },
    onWheelScroll: (p) => {
      o.viewport && (o.viewport.scrollTop = p);
    },
    onDragScroll: (p) => {
      o.viewport && (o.viewport.scrollTop = f(p));
    }
  })) : null;
}), h6 = /* @__PURE__ */ Ne((e, t) => {
  const { sizes: r, onSizesChange: n, ...o } = e, a = gn(Po, e.__scopeScrollArea), [i, l] = Me(), c = qe(null), u = Va(t, c, a.onScrollbarXChange);
  return Ue(() => {
    c.current && l(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ et(k$, T({
    "data-orientation": "horizontal"
  }, o, {
    ref: u,
    sizes: r,
    style: {
      bottom: 0,
      left: a.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: a.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      ["--radix-scroll-area-thumb-width"]: Tp(r) + "px",
      ...e.style
    },
    onThumbPointerDown: (d) => e.onThumbPointerDown(d.x),
    onDragScroll: (d) => e.onDragScroll(d.x),
    onWheelScroll: (d, f) => {
      if (a.viewport) {
        const p = a.viewport.scrollLeft + d.deltaX;
        e.onWheelScroll(p), I$(p, f) && d.preventDefault();
      }
    },
    onResize: () => {
      c.current && a.viewport && i && n({
        content: a.viewport.scrollWidth,
        viewport: a.viewport.offsetWidth,
        scrollbar: {
          size: c.current.clientWidth,
          paddingStart: Uu(i.paddingLeft),
          paddingEnd: Uu(i.paddingRight)
        }
      });
    }
  }));
}), y6 = /* @__PURE__ */ Ne((e, t) => {
  const { sizes: r, onSizesChange: n, ...o } = e, a = gn(Po, e.__scopeScrollArea), [i, l] = Me(), c = qe(null), u = Va(t, c, a.onScrollbarYChange);
  return Ue(() => {
    c.current && l(getComputedStyle(c.current));
  }, [
    c
  ]), /* @__PURE__ */ et(k$, T({
    "data-orientation": "vertical"
  }, o, {
    ref: u,
    sizes: r,
    style: {
      top: 0,
      right: a.dir === "ltr" ? 0 : void 0,
      left: a.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      ["--radix-scroll-area-thumb-height"]: Tp(r) + "px",
      ...e.style
    },
    onThumbPointerDown: (d) => e.onThumbPointerDown(d.y),
    onDragScroll: (d) => e.onDragScroll(d.y),
    onWheelScroll: (d, f) => {
      if (a.viewport) {
        const p = a.viewport.scrollTop + d.deltaY;
        e.onWheelScroll(p), I$(p, f) && d.preventDefault();
      }
    },
    onResize: () => {
      c.current && a.viewport && i && n({
        content: a.viewport.scrollHeight,
        viewport: a.viewport.offsetHeight,
        scrollbar: {
          size: c.current.clientHeight,
          paddingStart: Uu(i.paddingTop),
          paddingEnd: Uu(i.paddingBottom)
        }
      });
    }
  }));
}), [v6, C$] = E$(Po), k$ = /* @__PURE__ */ Ne((e, t) => {
  const { __scopeScrollArea: r, sizes: n, hasThumb: o, onThumbChange: a, onThumbPointerUp: i, onThumbPointerDown: l, onThumbPositionChange: c, onDragScroll: u, onWheelScroll: d, onResize: f, ...p } = e, m = gn(Po, r), [y, h] = Me(null), v = Va(
    t,
    (N) => h(N)
  ), g = qe(null), b = qe(""), x = m.viewport, O = n.content - n.viewport, w = va(d), S = va(c), E = Ep(f, 10);
  function C(N) {
    if (g.current) {
      const $ = N.clientX - g.current.left, j = N.clientY - g.current.top;
      u({
        x: $,
        y: j
      });
    }
  }
  return Ue(() => {
    const N = ($) => {
      const j = $.target;
      (y == null ? void 0 : y.contains(j)) && w($, O);
    };
    return document.addEventListener("wheel", N, {
      passive: !1
    }), () => document.removeEventListener("wheel", N, {
      passive: !1
    });
  }, [
    x,
    y,
    O,
    w
  ]), Ue(S, [
    n,
    S
  ]), Ni(y, E), Ni(m.content, E), /* @__PURE__ */ et(v6, {
    scope: r,
    scrollbar: y,
    hasThumb: o,
    onThumbChange: va(a),
    onThumbPointerUp: va(i),
    onThumbPositionChange: S,
    onThumbPointerDown: va(l)
  }, /* @__PURE__ */ et(Sl.div, T({}, p, {
    ref: v,
    style: {
      position: "absolute",
      ...p.style
    },
    onPointerDown: Oa(e.onPointerDown, (N) => {
      N.button === 0 && (N.target.setPointerCapture(N.pointerId), g.current = y.getBoundingClientRect(), b.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", C(N));
    }),
    onPointerMove: Oa(e.onPointerMove, C),
    onPointerUp: Oa(e.onPointerUp, (N) => {
      const $ = N.target;
      $.hasPointerCapture(N.pointerId) && $.releasePointerCapture(N.pointerId), document.body.style.webkitUserSelect = b.current, g.current = null;
    })
  })));
}), Qh = "ScrollAreaThumb", g6 = /* @__PURE__ */ Ne((e, t) => {
  const { forceMount: r, ...n } = e, o = C$(Qh, e.__scopeScrollArea);
  return /* @__PURE__ */ et(Tl, {
    present: r || o.hasThumb
  }, /* @__PURE__ */ et(b6, T({
    ref: t
  }, n)));
}), b6 = /* @__PURE__ */ Ne((e, t) => {
  const { __scopeScrollArea: r, style: n, ...o } = e, a = gn(Qh, r), i = C$(Qh, r), { onThumbPositionChange: l } = i, c = Va(
    t,
    (f) => i.onThumbChange(f)
  ), u = qe(), d = Ep(() => {
    u.current && (u.current(), u.current = void 0);
  }, 100);
  return Ue(() => {
    const f = a.viewport;
    if (f) {
      const p = () => {
        if (d(), !u.current) {
          const m = O6(f, l);
          u.current = m, l();
        }
      };
      return l(), f.addEventListener("scroll", p), () => f.removeEventListener("scroll", p);
    }
  }, [
    a.viewport,
    d,
    l
  ]), /* @__PURE__ */ et(Sl.div, T({
    "data-state": i.hasThumb ? "visible" : "hidden"
  }, o, {
    ref: c,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...n
    },
    onPointerDownCapture: Oa(e.onPointerDownCapture, (f) => {
      const m = f.target.getBoundingClientRect(), y = f.clientX - m.left, h = f.clientY - m.top;
      i.onThumbPointerDown({
        x: y,
        y: h
      });
    }),
    onPointerUp: Oa(e.onPointerUp, i.onThumbPointerUp)
  }));
}), R$ = "ScrollAreaCorner", w6 = /* @__PURE__ */ Ne((e, t) => {
  const r = gn(R$, e.__scopeScrollArea), n = !!(r.scrollbarX && r.scrollbarY);
  return r.type !== "scroll" && n ? /* @__PURE__ */ et(x6, T({}, e, {
    ref: t
  })) : null;
}), x6 = /* @__PURE__ */ Ne((e, t) => {
  const { __scopeScrollArea: r, ...n } = e, o = gn(R$, r), [a, i] = Me(0), [l, c] = Me(0), u = !!(a && l);
  return Ni(o.scrollbarX, () => {
    var d;
    const f = ((d = o.scrollbarX) === null || d === void 0 ? void 0 : d.offsetHeight) || 0;
    o.onCornerHeightChange(f), c(f);
  }), Ni(o.scrollbarY, () => {
    var d;
    const f = ((d = o.scrollbarY) === null || d === void 0 ? void 0 : d.offsetWidth) || 0;
    o.onCornerWidthChange(f), i(f);
  }), u ? /* @__PURE__ */ et(Sl.div, T({}, n, {
    ref: t,
    style: {
      width: a,
      height: l,
      position: "absolute",
      right: o.dir === "ltr" ? 0 : void 0,
      left: o.dir === "rtl" ? 0 : void 0,
      bottom: 0,
      ...e.style
    }
  })) : null;
});
function Uu(e) {
  return e ? parseInt(e, 10) : 0;
}
function D$(e, t) {
  const r = e / t;
  return isNaN(r) ? 0 : r;
}
function Tp(e) {
  const t = D$(e.viewport, e.content), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, n = (e.scrollbar.size - r) * t;
  return Math.max(n, 18);
}
function _6(e, t, r, n = "ltr") {
  const o = Tp(r), a = o / 2, i = t || a, l = o - i, c = r.scrollbar.paddingStart + i, u = r.scrollbar.size - r.scrollbar.paddingEnd - l, d = r.content - r.viewport, f = n === "ltr" ? [
    0,
    d
  ] : [
    d * -1,
    0
  ];
  return N$([
    c,
    u
  ], f)(e);
}
function xx(e, t, r = "ltr") {
  const n = Tp(t), o = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, a = t.scrollbar.size - o, i = t.content - t.viewport, l = a - n, c = r === "ltr" ? [
    0,
    i
  ] : [
    i * -1,
    0
  ], u = i6(e, c);
  return N$([
    0,
    i
  ], [
    0,
    l
  ])(u);
}
function N$(e, t) {
  return (r) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + n * (r - e[0]);
  };
}
function I$(e, t) {
  return e > 0 && e < t;
}
const O6 = (e, t = () => {
}) => {
  let r = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, n = 0;
  return function o() {
    const a = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, i = r.left !== a.left, l = r.top !== a.top;
    (i || l) && t(), r = a, n = window.requestAnimationFrame(o);
  }(), () => window.cancelAnimationFrame(n);
};
function Ep(e, t) {
  const r = va(e), n = qe(0);
  return Ue(
    () => () => window.clearTimeout(n.current),
    []
  ), qn(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(r, t);
  }, [
    r,
    t
  ]);
}
function Ni(e, t) {
  const r = va(t);
  Xh(() => {
    let n = 0;
    if (e) {
      const o = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(r);
      });
      return o.observe(e), () => {
        window.cancelAnimationFrame(n), o.unobserve(e);
      };
    }
  }, [
    e,
    r
  ]);
}
const P6 = c6, S6 = d6, _x = f6, Ox = g6, T6 = w6;
var E6 = Qe((e, { scrollbarSize: t, offsetScrollbars: r, scrollbarHovered: n, hidden: o }, a) => ({
  root: {
    overflow: "hidden"
  },
  viewport: {
    width: "100%",
    height: "100%",
    paddingRight: r ? t : void 0,
    paddingBottom: r ? t : void 0
  },
  scrollbar: {
    display: o ? "none" : "flex",
    userSelect: "none",
    touchAction: "none",
    boxSizing: "border-box",
    padding: t / 5,
    transition: "background-color 150ms ease, opacity 150ms ease",
    "&:hover": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[0],
      [`& .${a("thumb")}`]: {
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, 0.5) : e.fn.rgba(e.black, 0.5)
      }
    },
    '&[data-orientation="vertical"]': {
      width: t
    },
    '&[data-orientation="horizontal"]': {
      flexDirection: "column",
      height: t
    },
    '&[data-state="hidden"]': {
      display: "none",
      opacity: 0
    }
  },
  thumb: {
    ref: a("thumb"),
    flex: 1,
    backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, 0.4) : e.fn.rgba(e.black, 0.4),
    borderRadius: t,
    position: "relative",
    transition: "background-color 150ms ease",
    display: o ? "none" : void 0,
    overflow: "hidden",
    "&::before": {
      content: '""',
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: "100%",
      height: "100%",
      minWidth: 44,
      minHeight: 44
    }
  },
  corner: {
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
    transition: "opacity 150ms ease",
    opacity: n ? 1 : 0,
    display: o ? "none" : void 0
  }
}));
const $6 = E6;
var C6 = Object.defineProperty, k6 = Object.defineProperties, R6 = Object.getOwnPropertyDescriptors, Hu = Object.getOwnPropertySymbols, M$ = Object.prototype.hasOwnProperty, A$ = Object.prototype.propertyIsEnumerable, Px = (e, t, r) => t in e ? C6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Zh = (e, t) => {
  for (var r in t || (t = {}))
    M$.call(t, r) && Px(e, r, t[r]);
  if (Hu)
    for (var r of Hu(t))
      A$.call(t, r) && Px(e, r, t[r]);
  return e;
}, j$ = (e, t) => k6(e, R6(t)), F$ = (e, t) => {
  var r = {};
  for (var n in e)
    M$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Hu)
    for (var n of Hu(e))
      t.indexOf(n) < 0 && A$.call(e, n) && (r[n] = e[n]);
  return r;
};
const L$ = {
  scrollbarSize: 12,
  scrollHideDelay: 1e3,
  type: "hover",
  offsetScrollbars: !1
}, $p = Ne((e, t) => {
  const r = Xe("ScrollArea", L$, e), {
    children: n,
    className: o,
    classNames: a,
    styles: i,
    scrollbarSize: l,
    scrollHideDelay: c,
    type: u,
    dir: d,
    offsetScrollbars: f,
    viewportRef: p,
    onScrollPositionChange: m,
    unstyled: y,
    viewportProps: h
  } = r, v = F$(r, [
    "children",
    "className",
    "classNames",
    "styles",
    "scrollbarSize",
    "scrollHideDelay",
    "type",
    "dir",
    "offsetScrollbars",
    "viewportRef",
    "onScrollPositionChange",
    "unstyled",
    "viewportProps"
  ]), [g, b] = Me(!1), x = fr(), { classes: O, cx: w } = $6({ scrollbarSize: l, offsetScrollbars: f, scrollbarHovered: g, hidden: u === "never" }, { name: "ScrollArea", classNames: a, styles: i, unstyled: y });
  return /* @__PURE__ */ F.createElement(P6, {
    type: u === "never" ? "always" : u,
    scrollHideDelay: c,
    dir: d || x.dir,
    ref: t,
    asChild: !0
  }, /* @__PURE__ */ F.createElement(Ke, Zh({
    className: w(O.root, o)
  }, v), /* @__PURE__ */ F.createElement(S6, j$(Zh({}, h), {
    className: O.viewport,
    ref: p,
    onScroll: typeof m == "function" ? ({ currentTarget: S }) => m({
      x: S.scrollLeft,
      y: S.scrollTop
    }) : void 0
  }), n), /* @__PURE__ */ F.createElement(_x, {
    orientation: "horizontal",
    className: O.scrollbar,
    forceMount: !0,
    onMouseEnter: () => b(!0),
    onMouseLeave: () => b(!1)
  }, /* @__PURE__ */ F.createElement(Ox, {
    className: O.thumb
  })), /* @__PURE__ */ F.createElement(_x, {
    orientation: "vertical",
    className: O.scrollbar,
    forceMount: !0,
    onMouseEnter: () => b(!0),
    onMouseLeave: () => b(!1)
  }, /* @__PURE__ */ F.createElement(Ox, {
    className: O.thumb
  })), /* @__PURE__ */ F.createElement(T6, {
    className: O.corner
  })));
}), V$ = Ne((e, t) => {
  const r = Xe("ScrollAreaAutosize", L$, e), {
    maxHeight: n,
    children: o,
    classNames: a,
    styles: i,
    scrollbarSize: l,
    scrollHideDelay: c,
    type: u,
    dir: d,
    offsetScrollbars: f,
    viewportRef: p,
    onScrollPositionChange: m,
    unstyled: y,
    sx: h
  } = r, v = F$(r, [
    "maxHeight",
    "children",
    "classNames",
    "styles",
    "scrollbarSize",
    "scrollHideDelay",
    "type",
    "dir",
    "offsetScrollbars",
    "viewportRef",
    "onScrollPositionChange",
    "unstyled",
    "sx"
  ]);
  return /* @__PURE__ */ F.createElement(Ke, j$(Zh({}, v), {
    ref: t,
    sx: [{ display: "flex", maxHeight: n }, ...nl(h)]
  }), /* @__PURE__ */ F.createElement(Ke, {
    sx: { display: "flex", flexDirection: "column", flex: 1 }
  }, /* @__PURE__ */ F.createElement($p, {
    classNames: a,
    styles: i,
    scrollHideDelay: c,
    scrollbarSize: l,
    type: u,
    dir: d,
    offsetScrollbars: f,
    viewportRef: p,
    onScrollPositionChange: m,
    unstyled: y
  }, o)));
});
V$.displayName = "@mantine/core/ScrollAreaAutosize";
$p.displayName = "@mantine/core/ScrollArea";
$p.Autosize = V$;
const D6 = $p;
var N6 = Object.defineProperty, I6 = Object.defineProperties, M6 = Object.getOwnPropertyDescriptors, Yu = Object.getOwnPropertySymbols, z$ = Object.prototype.hasOwnProperty, B$ = Object.prototype.propertyIsEnumerable, Sx = (e, t, r) => t in e ? N6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Tx = (e, t) => {
  for (var r in t || (t = {}))
    z$.call(t, r) && Sx(e, r, t[r]);
  if (Yu)
    for (var r of Yu(t))
      B$.call(t, r) && Sx(e, r, t[r]);
  return e;
}, A6 = (e, t) => I6(e, M6(t)), j6 = (e, t) => {
  var r = {};
  for (var n in e)
    z$.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Yu)
    for (var n of Yu(e))
      t.indexOf(n) < 0 && B$.call(e, n) && (r[n] = e[n]);
  return r;
};
const Cp = Ne((e, t) => {
  var r = e, { style: n } = r, o = j6(r, ["style"]);
  return /* @__PURE__ */ F.createElement(D6, A6(Tx({}, o), {
    style: Tx({ width: "100%" }, n),
    viewportRef: t
  }), o.children);
});
Cp.displayName = "@mantine/core/SelectScrollArea";
var F6 = Qe(() => ({
  dropdown: {},
  itemsWrapper: {
    padding: 4,
    display: "flex",
    width: "100%",
    boxSizing: "border-box"
  }
}));
const L6 = F6;
function Qi(e) {
  return e.split("-")[1];
}
function Sg(e) {
  return e === "y" ? "height" : "width";
}
function En(e) {
  return e.split("-")[0];
}
function ea(e) {
  return ["top", "bottom"].includes(En(e)) ? "x" : "y";
}
function Ex(e, t, r) {
  let { reference: n, floating: o } = e;
  const a = n.x + n.width / 2 - o.width / 2, i = n.y + n.height / 2 - o.height / 2, l = ea(t), c = Sg(l), u = n[c] / 2 - o[c] / 2, d = l === "x";
  let f;
  switch (En(t)) {
    case "top":
      f = { x: a, y: n.y - o.height };
      break;
    case "bottom":
      f = { x: a, y: n.y + n.height };
      break;
    case "right":
      f = { x: n.x + n.width, y: i };
      break;
    case "left":
      f = { x: n.x - o.width, y: i };
      break;
    default:
      f = { x: n.x, y: n.y };
  }
  switch (Qi(t)) {
    case "start":
      f[l] -= u * (r && d ? -1 : 1);
      break;
    case "end":
      f[l] += u * (r && d ? -1 : 1);
  }
  return f;
}
const V6 = async (e, t, r) => {
  const { placement: n = "bottom", strategy: o = "absolute", middleware: a = [], platform: i } = r, l = a.filter(Boolean), c = await (i.isRTL == null ? void 0 : i.isRTL(t));
  let u = await i.getElementRects({ reference: e, floating: t, strategy: o }), { x: d, y: f } = Ex(u, n, c), p = n, m = {}, y = 0;
  for (let h = 0; h < l.length; h++) {
    const { name: v, fn: g } = l[h], { x: b, y: x, data: O, reset: w } = await g({ x: d, y: f, initialPlacement: n, placement: p, strategy: o, middlewareData: m, rects: u, platform: i, elements: { reference: e, floating: t } });
    d = b ?? d, f = x ?? f, m = { ...m, [v]: { ...m[v], ...O } }, w && y <= 50 && (y++, typeof w == "object" && (w.placement && (p = w.placement), w.rects && (u = w.rects === !0 ? await i.getElementRects({ reference: e, floating: t, strategy: o }) : w.rects), { x: d, y: f } = Ex(u, p, c)), h = -1);
  }
  return { x: d, y: f, placement: p, strategy: o, middlewareData: m };
};
function vo(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Tg(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function Ii(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Eg(e, t) {
  var r;
  t === void 0 && (t = {});
  const { x: n, y: o, platform: a, rects: i, elements: l, strategy: c } = e, { boundary: u = "clippingAncestors", rootBoundary: d = "viewport", elementContext: f = "floating", altBoundary: p = !1, padding: m = 0 } = vo(t, e), y = Tg(m), h = l[p ? f === "floating" ? "reference" : "floating" : f], v = Ii(await a.getClippingRect({ element: (r = await (a.isElement == null ? void 0 : a.isElement(h))) == null || r ? h : h.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(l.floating)), boundary: u, rootBoundary: d, strategy: c })), g = f === "floating" ? { ...i.floating, x: n, y: o } : i.reference, b = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(l.floating)), x = await (a.isElement == null ? void 0 : a.isElement(b)) && await (a.getScale == null ? void 0 : a.getScale(b)) || { x: 1, y: 1 }, O = Ii(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: g, offsetParent: b, strategy: c }) : g);
  return { top: (v.top - O.top + y.top) / x.y, bottom: (O.bottom - v.bottom + y.bottom) / x.y, left: (v.left - O.left + y.left) / x.x, right: (O.right - v.right + y.right) / x.x };
}
const Ko = Math.min, jn = Math.max;
function Jh(e, t, r) {
  return jn(e, Ko(t, r));
}
const $x = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { x: r, y: n, placement: o, rects: a, platform: i, elements: l } = t, { element: c, padding: u = 0 } = vo(e, t) || {};
  if (c == null)
    return {};
  const d = Tg(u), f = { x: r, y: n }, p = ea(o), m = Sg(p), y = await i.getDimensions(c), h = p === "y", v = h ? "top" : "left", g = h ? "bottom" : "right", b = h ? "clientHeight" : "clientWidth", x = a.reference[m] + a.reference[p] - f[p] - a.floating[m], O = f[p] - a.reference[p], w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c));
  let S = w ? w[b] : 0;
  S && await (i.isElement == null ? void 0 : i.isElement(w)) || (S = l.floating[b] || a.floating[m]);
  const E = x / 2 - O / 2, C = S / 2 - y[m] / 2 - 1, N = Ko(d[v], C), $ = Ko(d[g], C), j = N, A = S - y[m] - $, k = S / 2 - y[m] / 2 + E, R = Jh(j, k, A), D = Qi(o) != null && k != R && a.reference[m] / 2 - (k < j ? N : $) - y[m] / 2 < 0;
  return { [p]: f[p] - (D ? k < j ? j - k : A - k : 0), data: { [p]: R, centerOffset: k - R } };
} }), z6 = ["top", "right", "bottom", "left"];
z6.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const B6 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function qu(e) {
  return e.replace(/left|right|bottom|top/g, (t) => B6[t]);
}
function W6(e, t, r) {
  r === void 0 && (r = !1);
  const n = Qi(e), o = ea(e), a = Sg(o);
  let i = o === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (i = qu(i)), { main: i, cross: qu(i) };
}
const U6 = { start: "end", end: "start" };
function km(e) {
  return e.replace(/start|end/g, (t) => U6[t]);
}
const W$ = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var r;
    const { placement: n, middlewareData: o, rects: a, initialPlacement: i, platform: l, elements: c } = t, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: m = "none", flipAlignment: y = !0, ...h } = vo(e, t), v = En(n), g = En(i) === i, b = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), x = f || (g || !y ? [qu(i)] : function(j) {
      const A = qu(j);
      return [km(j), A, km(A)];
    }(i));
    f || m === "none" || x.push(...function(j, A, k, R) {
      const D = Qi(j);
      let L = function(B, H, U) {
        const I = ["left", "right"], V = ["right", "left"], G = ["top", "bottom"], q = ["bottom", "top"];
        switch (B) {
          case "top":
          case "bottom":
            return U ? H ? V : I : H ? I : V;
          case "left":
          case "right":
            return H ? G : q;
          default:
            return [];
        }
      }(En(j), k === "start", R);
      return D && (L = L.map((B) => B + "-" + D), A && (L = L.concat(L.map(km)))), L;
    }(i, y, m, b));
    const O = [i, ...x], w = await Eg(t, h), S = [];
    let E = ((r = o.flip) == null ? void 0 : r.overflows) || [];
    if (u && S.push(w[v]), d) {
      const { main: j, cross: A } = W6(n, a, b);
      S.push(w[j], w[A]);
    }
    if (E = [...E, { placement: n, overflows: S }], !S.every((j) => j <= 0)) {
      var C, N;
      const j = (((C = o.flip) == null ? void 0 : C.index) || 0) + 1, A = O[j];
      if (A)
        return { data: { index: j, overflows: E }, reset: { placement: A } };
      let k = (N = E.filter((R) => R.overflows[0] <= 0).sort((R, D) => R.overflows[1] - D.overflows[1])[0]) == null ? void 0 : N.placement;
      if (!k)
        switch (p) {
          case "bestFit": {
            var $;
            const R = ($ = E.map((D) => [D.placement, D.overflows.filter((L) => L > 0).reduce((L, B) => L + B, 0)]).sort((D, L) => D[1] - L[1])[0]) == null ? void 0 : $[0];
            R && (k = R);
            break;
          }
          case "initialPlacement":
            k = i;
        }
      if (n !== k)
        return { reset: { placement: k } };
    }
    return {};
  } };
};
function Cx(e) {
  const t = Ko(...e.map((n) => n.left)), r = Ko(...e.map((n) => n.top));
  return { x: t, y: r, width: jn(...e.map((n) => n.right)) - t, height: jn(...e.map((n) => n.bottom)) - r };
}
const U$ = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: r, elements: n, rects: o, platform: a, strategy: i } = t, { padding: l = 2, x: c, y: u } = vo(e, t), d = Array.from(await (a.getClientRects == null ? void 0 : a.getClientRects(n.reference)) || []), f = function(h) {
      const v = h.slice().sort((x, O) => x.y - O.y), g = [];
      let b = null;
      for (let x = 0; x < v.length; x++) {
        const O = v[x];
        !b || O.y - b.y > b.height / 2 ? g.push([O]) : g[g.length - 1].push(O), b = O;
      }
      return g.map((x) => Ii(Cx(x)));
    }(d), p = Ii(Cx(d)), m = Tg(l), y = await a.getElementRects({ reference: { getBoundingClientRect: function() {
      if (f.length === 2 && f[0].left > f[1].right && c != null && u != null)
        return f.find((h) => c > h.left - m.left && c < h.right + m.right && u > h.top - m.top && u < h.bottom + m.bottom) || p;
      if (f.length >= 2) {
        if (ea(r) === "x") {
          const w = f[0], S = f[f.length - 1], E = En(r) === "top", C = w.top, N = S.bottom, $ = E ? w.left : S.left, j = E ? w.right : S.right;
          return { top: C, bottom: N, left: $, right: j, width: j - $, height: N - C, x: $, y: C };
        }
        const h = En(r) === "left", v = jn(...f.map((w) => w.right)), g = Ko(...f.map((w) => w.left)), b = f.filter((w) => h ? w.left === g : w.right === v), x = b[0].top, O = b[b.length - 1].bottom;
        return { top: x, bottom: O, left: g, right: v, width: v - g, height: O - x, x: g, y: x };
      }
      return p;
    } }, floating: n.floating, strategy: i });
    return o.reference.x !== y.reference.x || o.reference.y !== y.reference.y || o.reference.width !== y.reference.width || o.reference.height !== y.reference.height ? { reset: { rects: y } } : {};
  } };
}, H$ = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: r, y: n } = t, o = await async function(a, i) {
      const { placement: l, platform: c, elements: u } = a, d = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), f = En(l), p = Qi(l), m = ea(l) === "x", y = ["left", "top"].includes(f) ? -1 : 1, h = d && m ? -1 : 1, v = vo(i, a);
      let { mainAxis: g, crossAxis: b, alignmentAxis: x } = typeof v == "number" ? { mainAxis: v, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...v };
      return p && typeof x == "number" && (b = p === "end" ? -1 * x : x), m ? { x: b * h, y: g * y } : { x: g * y, y: b * h };
    }(t, e);
    return { x: r + o.x, y: n + o.y, data: o };
  } };
};
function Y$(e) {
  return e === "x" ? "y" : "x";
}
const $g = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: r, y: n, placement: o } = t, { mainAxis: a = !0, crossAxis: i = !1, limiter: l = { fn: (v) => {
      let { x: g, y: b } = v;
      return { x: g, y: b };
    } }, ...c } = vo(e, t), u = { x: r, y: n }, d = await Eg(t, c), f = ea(En(o)), p = Y$(f);
    let m = u[f], y = u[p];
    if (a) {
      const v = f === "y" ? "bottom" : "right";
      m = Jh(m + d[f === "y" ? "top" : "left"], m, m - d[v]);
    }
    if (i) {
      const v = p === "y" ? "bottom" : "right";
      y = Jh(y + d[p === "y" ? "top" : "left"], y, y - d[v]);
    }
    const h = l.fn({ ...t, [f]: m, [p]: y });
    return { ...h, data: { x: h.x - r, y: h.y - n } };
  } };
}, H6 = function(e) {
  return e === void 0 && (e = {}), { options: e, fn(t) {
    const { x: r, y: n, placement: o, rects: a, middlewareData: i } = t, { offset: l = 0, mainAxis: c = !0, crossAxis: u = !0 } = vo(e, t), d = { x: r, y: n }, f = ea(o), p = Y$(f);
    let m = d[f], y = d[p];
    const h = vo(l, t), v = typeof h == "number" ? { mainAxis: h, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...h };
    if (c) {
      const x = f === "y" ? "height" : "width", O = a.reference[f] - a.floating[x] + v.mainAxis, w = a.reference[f] + a.reference[x] - v.mainAxis;
      m < O ? m = O : m > w && (m = w);
    }
    if (u) {
      var g, b;
      const x = f === "y" ? "width" : "height", O = ["top", "left"].includes(En(o)), w = a.reference[p] - a.floating[x] + (O && ((g = i.offset) == null ? void 0 : g[p]) || 0) + (O ? 0 : v.crossAxis), S = a.reference[p] + a.reference[x] + (O ? 0 : ((b = i.offset) == null ? void 0 : b[p]) || 0) - (O ? v.crossAxis : 0);
      y < w ? y = w : y > S && (y = S);
    }
    return { [f]: m, [p]: y };
  } };
}, Y6 = function(e) {
  return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) {
    const { placement: r, rects: n, platform: o, elements: a } = t, { apply: i = () => {
    }, ...l } = vo(e, t), c = await Eg(t, l), u = En(r), d = Qi(r), f = ea(r) === "x", { width: p, height: m } = n.floating;
    let y, h;
    u === "top" || u === "bottom" ? (y = u, h = d === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (h = u, y = d === "end" ? "top" : "bottom");
    const v = m - c[y], g = p - c[h], b = !t.middlewareData.shift;
    let x = v, O = g;
    if (f) {
      const S = p - c.left - c.right;
      O = d || b ? Ko(g, S) : S;
    } else {
      const S = m - c.top - c.bottom;
      x = d || b ? Ko(v, S) : S;
    }
    if (b && !d) {
      const S = jn(c.left, 0), E = jn(c.right, 0), C = jn(c.top, 0), N = jn(c.bottom, 0);
      f ? O = p - 2 * (S !== 0 || E !== 0 ? S + E : jn(c.left, c.right)) : x = m - 2 * (C !== 0 || N !== 0 ? C + N : jn(c.top, c.bottom));
    }
    await i({ ...t, availableWidth: O, availableHeight: x });
    const w = await o.getDimensions(a.floating);
    return p !== w.width || m !== w.height ? { reset: { rects: !0 } } : {};
  } };
};
function ln(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function $n(e) {
  return ln(e).getComputedStyle(e);
}
function q$(e) {
  return e instanceof ln(e).Node;
}
function Xo(e) {
  return q$(e) ? (e.nodeName || "").toLowerCase() : "";
}
function kn(e) {
  return e instanceof ln(e).HTMLElement;
}
function Lr(e) {
  return e instanceof ln(e).Element;
}
function kx(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ln(e).ShadowRoot || e instanceof ShadowRoot;
}
function al(e) {
  const { overflow: t, overflowX: r, overflowY: n, display: o } = $n(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + r) && !["inline", "contents"].includes(o);
}
function q6(e) {
  return ["table", "td", "th"].includes(Xo(e));
}
function ey(e) {
  const t = Cg(), r = $n(e);
  return r.transform !== "none" || r.perspective !== "none" || !t && !!r.backdropFilter && r.backdropFilter !== "none" || !t && !!r.filter && r.filter !== "none" || ["transform", "perspective", "filter"].some((n) => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some((n) => (r.contain || "").includes(n));
}
function Cg() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function kp(e) {
  return ["html", "body", "#document"].includes(Xo(e));
}
const Rx = Math.min, zs = Math.max, Gu = Math.round;
function G$(e) {
  const t = $n(e);
  let r = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const o = kn(e), a = o ? e.offsetWidth : r, i = o ? e.offsetHeight : n, l = Gu(r) !== a || Gu(n) !== i;
  return l && (r = a, n = i), { width: r, height: n, fallback: l };
}
function K$(e) {
  return Lr(e) ? e : e.contextElement;
}
const X$ = { x: 1, y: 1 };
function Pi(e) {
  const t = K$(e);
  if (!kn(t))
    return X$;
  const r = t.getBoundingClientRect(), { width: n, height: o, fallback: a } = G$(t);
  let i = (a ? Gu(r.width) : r.width) / n, l = (a ? Gu(r.height) : r.height) / o;
  return i && Number.isFinite(i) || (i = 1), l && Number.isFinite(l) || (l = 1), { x: i, y: l };
}
const Dx = { x: 0, y: 0 };
function Q$(e, t, r) {
  var n, o;
  if (t === void 0 && (t = !0), !Cg())
    return Dx;
  const a = e ? ln(e) : window;
  return !r || t && r !== a ? Dx : { x: ((n = a.visualViewport) == null ? void 0 : n.offsetLeft) || 0, y: ((o = a.visualViewport) == null ? void 0 : o.offsetTop) || 0 };
}
function Da(e, t, r, n) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const o = e.getBoundingClientRect(), a = K$(e);
  let i = X$;
  t && (n ? Lr(n) && (i = Pi(n)) : i = Pi(e));
  const l = Q$(a, r, n);
  let c = (o.left + l.x) / i.x, u = (o.top + l.y) / i.y, d = o.width / i.x, f = o.height / i.y;
  if (a) {
    const p = ln(a), m = n && Lr(n) ? ln(n) : n;
    let y = p.frameElement;
    for (; y && n && m !== p; ) {
      const h = Pi(y), v = y.getBoundingClientRect(), g = getComputedStyle(y);
      v.x += (y.clientLeft + parseFloat(g.paddingLeft)) * h.x, v.y += (y.clientTop + parseFloat(g.paddingTop)) * h.y, c *= h.x, u *= h.y, d *= h.x, f *= h.y, c += v.x, u += v.y, y = ln(y).frameElement;
    }
  }
  return Ii({ width: d, height: f, x: c, y: u });
}
function Uo(e) {
  return ((q$(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function Rp(e) {
  return Lr(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Z$(e) {
  return Da(Uo(e)).left + Rp(e).scrollLeft;
}
function Mi(e) {
  if (Xo(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || kx(e) && e.host || Uo(e);
  return kx(t) ? t.host : t;
}
function J$(e) {
  const t = Mi(e);
  return kp(t) ? t.ownerDocument.body : kn(t) && al(t) ? t : J$(t);
}
function uo(e, t) {
  var r;
  t === void 0 && (t = []);
  const n = J$(e), o = n === ((r = e.ownerDocument) == null ? void 0 : r.body), a = ln(n);
  return o ? t.concat(a, a.visualViewport || [], al(n) ? n : []) : t.concat(n, uo(n));
}
function Nx(e, t, r) {
  let n;
  if (t === "viewport")
    n = function(o, a) {
      const i = ln(o), l = Uo(o), c = i.visualViewport;
      let u = l.clientWidth, d = l.clientHeight, f = 0, p = 0;
      if (c) {
        u = c.width, d = c.height;
        const m = Cg();
        (!m || m && a === "fixed") && (f = c.offsetLeft, p = c.offsetTop);
      }
      return { width: u, height: d, x: f, y: p };
    }(e, r);
  else if (t === "document")
    n = function(o) {
      const a = Uo(o), i = Rp(o), l = o.ownerDocument.body, c = zs(a.scrollWidth, a.clientWidth, l.scrollWidth, l.clientWidth), u = zs(a.scrollHeight, a.clientHeight, l.scrollHeight, l.clientHeight);
      let d = -i.scrollLeft + Z$(o);
      const f = -i.scrollTop;
      return $n(l).direction === "rtl" && (d += zs(a.clientWidth, l.clientWidth) - c), { width: c, height: u, x: d, y: f };
    }(Uo(e));
  else if (Lr(t))
    n = function(o, a) {
      const i = Da(o, !0, a === "fixed"), l = i.top + o.clientTop, c = i.left + o.clientLeft, u = kn(o) ? Pi(o) : { x: 1, y: 1 };
      return { width: o.clientWidth * u.x, height: o.clientHeight * u.y, x: c * u.x, y: l * u.y };
    }(t, r);
  else {
    const o = Q$(e);
    n = { ...t, x: t.x - o.x, y: t.y - o.y };
  }
  return Ii(n);
}
function eC(e, t) {
  const r = Mi(e);
  return !(r === t || !Lr(r) || kp(r)) && ($n(r).position === "fixed" || eC(r, t));
}
function Ix(e, t) {
  return kn(e) && $n(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function Mx(e, t) {
  const r = ln(e);
  if (!kn(e))
    return r;
  let n = Ix(e, t);
  for (; n && q6(n) && $n(n).position === "static"; )
    n = Ix(n, t);
  return n && (Xo(n) === "html" || Xo(n) === "body" && $n(n).position === "static" && !ey(n)) ? r : n || function(o) {
    let a = Mi(o);
    for (; kn(a) && !kp(a); ) {
      if (ey(a))
        return a;
      a = Mi(a);
    }
    return null;
  }(e) || r;
}
function G6(e, t, r) {
  const n = kn(t), o = Uo(t), a = r === "fixed", i = Da(e, !0, a, t);
  let l = { scrollLeft: 0, scrollTop: 0 };
  const c = { x: 0, y: 0 };
  if (n || !n && !a)
    if ((Xo(t) !== "body" || al(o)) && (l = Rp(t)), kn(t)) {
      const u = Da(t, !0, a, t);
      c.x = u.x + t.clientLeft, c.y = u.y + t.clientTop;
    } else
      o && (c.x = Z$(o));
  return { x: i.left + l.scrollLeft - c.x, y: i.top + l.scrollTop - c.y, width: i.width, height: i.height };
}
const K6 = { getClippingRect: function(e) {
  let { element: t, boundary: r, rootBoundary: n, strategy: o } = e;
  const a = r === "clippingAncestors" ? function(u, d) {
    const f = d.get(u);
    if (f)
      return f;
    let p = uo(u).filter((v) => Lr(v) && Xo(v) !== "body"), m = null;
    const y = $n(u).position === "fixed";
    let h = y ? Mi(u) : u;
    for (; Lr(h) && !kp(h); ) {
      const v = $n(h), g = ey(h);
      g || v.position !== "fixed" || (m = null), (y ? !g && !m : !g && v.position === "static" && m && ["absolute", "fixed"].includes(m.position) || al(h) && !g && eC(u, h)) ? p = p.filter((b) => b !== h) : m = v, h = Mi(h);
    }
    return d.set(u, p), p;
  }(t, this._c) : [].concat(r), i = [...a, n], l = i[0], c = i.reduce((u, d) => {
    const f = Nx(t, d, o);
    return u.top = zs(f.top, u.top), u.right = Rx(f.right, u.right), u.bottom = Rx(f.bottom, u.bottom), u.left = zs(f.left, u.left), u;
  }, Nx(t, l, o));
  return { width: c.right - c.left, height: c.bottom - c.top, x: c.left, y: c.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: r, strategy: n } = e;
  const o = kn(r), a = Uo(r);
  if (r === a)
    return t;
  let i = { scrollLeft: 0, scrollTop: 0 }, l = { x: 1, y: 1 };
  const c = { x: 0, y: 0 };
  if ((o || !o && n !== "fixed") && ((Xo(r) !== "body" || al(a)) && (i = Rp(r)), kn(r))) {
    const u = Da(r);
    l = Pi(r), c.x = u.x + r.clientLeft, c.y = u.y + r.clientTop;
  }
  return { width: t.width * l.x, height: t.height * l.y, x: t.x * l.x - i.scrollLeft * l.x + c.x, y: t.y * l.y - i.scrollTop * l.y + c.y };
}, isElement: Lr, getDimensions: function(e) {
  return G$(e);
}, getOffsetParent: Mx, getDocumentElement: Uo, getScale: Pi, async getElementRects(e) {
  let { reference: t, floating: r, strategy: n } = e;
  const o = this.getOffsetParent || Mx, a = this.getDimensions;
  return { reference: G6(t, await o(r), n), floating: { x: 0, y: 0, ...await a(r) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => $n(e).direction === "rtl" };
function X6(e, t, r, n) {
  n === void 0 && (n = {});
  const { ancestorScroll: o = !0, ancestorResize: a = !0, elementResize: i = !0, animationFrame: l = !1 } = n, c = o || a ? [...Lr(e) ? uo(e) : e.contextElement ? uo(e.contextElement) : [], ...uo(t)] : [];
  c.forEach((p) => {
    const m = !Lr(p) && p.toString().includes("V");
    !o || l && !m || p.addEventListener("scroll", r, { passive: !0 }), a && p.addEventListener("resize", r);
  });
  let u, d = null;
  i && (d = new ResizeObserver(() => {
    r();
  }), Lr(e) && !l && d.observe(e), Lr(e) || !e.contextElement || l || d.observe(e.contextElement), d.observe(t));
  let f = l ? Da(e) : null;
  return l && function p() {
    const m = Da(e);
    !f || m.x === f.x && m.y === f.y && m.width === f.width && m.height === f.height || r(), f = m, u = requestAnimationFrame(p);
  }(), r(), () => {
    var p;
    c.forEach((m) => {
      o && m.removeEventListener("scroll", r), a && m.removeEventListener("resize", r);
    }), (p = d) == null || p.disconnect(), d = null, l && cancelAnimationFrame(u);
  };
}
const Q6 = (e, t, r) => {
  const n = /* @__PURE__ */ new Map(), o = { platform: K6, ...r }, a = { ...o.platform, _c: n };
  return V6(e, t, { ...o, platform: a });
}, tC = (e) => {
  const {
    element: t,
    padding: r
  } = e;
  function n(o) {
    return Object.prototype.hasOwnProperty.call(o, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(o) {
      return n(t) ? t.current != null ? $x({
        element: t.current,
        padding: r
      }).fn(o) : {} : t ? $x({
        element: t,
        padding: r
      }).fn(o) : {};
    }
  };
};
var Cc = typeof document < "u" ? Zf : Ue;
function Ku(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let r, n, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (r = e.length, r != t.length)
        return !1;
      for (n = r; n-- !== 0; )
        if (!Ku(e[n], t[n]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), r = o.length, r !== Object.keys(t).length)
      return !1;
    for (n = r; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[n]))
        return !1;
    for (n = r; n-- !== 0; ) {
      const a = o[n];
      if (!(a === "_owner" && e.$$typeof) && !Ku(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Ax(e) {
  const t = P.useRef(e);
  return Cc(() => {
    t.current = e;
  }), t;
}
function Z6(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: r = "absolute",
    middleware: n = [],
    platform: o,
    whileElementsMounted: a,
    open: i
  } = e, [l, c] = P.useState({
    x: null,
    y: null,
    strategy: r,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [u, d] = P.useState(n);
  Ku(u, n) || d(n);
  const f = P.useRef(null), p = P.useRef(null), m = P.useRef(l), y = Ax(a), h = Ax(o), [v, g] = P.useState(null), [b, x] = P.useState(null), O = P.useCallback(($) => {
    f.current !== $ && (f.current = $, g($));
  }, []), w = P.useCallback(($) => {
    p.current !== $ && (p.current = $, x($));
  }, []), S = P.useCallback(() => {
    if (!f.current || !p.current)
      return;
    const $ = {
      placement: t,
      strategy: r,
      middleware: u
    };
    h.current && ($.platform = h.current), Q6(f.current, p.current, $).then((j) => {
      const A = {
        ...j,
        isPositioned: !0
      };
      E.current && !Ku(m.current, A) && (m.current = A, rg.flushSync(() => {
        c(A);
      }));
    });
  }, [u, t, r, h]);
  Cc(() => {
    i === !1 && m.current.isPositioned && (m.current.isPositioned = !1, c(($) => ({
      ...$,
      isPositioned: !1
    })));
  }, [i]);
  const E = P.useRef(!1);
  Cc(() => (E.current = !0, () => {
    E.current = !1;
  }), []), Cc(() => {
    if (v && b) {
      if (y.current)
        return y.current(v, b, S);
      S();
    }
  }, [v, b, S, y]);
  const C = P.useMemo(() => ({
    reference: f,
    floating: p,
    setReference: O,
    setFloating: w
  }), [O, w]), N = P.useMemo(() => ({
    reference: v,
    floating: b
  }), [v, b]);
  return P.useMemo(() => ({
    ...l,
    update: S,
    refs: C,
    elements: N,
    reference: O,
    floating: w
  }), [l, S, C, N, O, w]);
}
var Ai = typeof document < "u" ? Zf : Ue;
let Rm = !1, J6 = 0;
const jx = () => "floating-ui-" + J6++;
function eW() {
  const [e, t] = P.useState(() => Rm ? jx() : void 0);
  return Ai(() => {
    e == null && t(jx());
  }, []), P.useEffect(() => {
    Rm || (Rm = !0);
  }, []), e;
}
const tW = P[/* @__PURE__ */ "useId".toString()], Fx = tW || eW;
function rW() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, r) {
      var n;
      (n = e.get(t)) == null || n.forEach((o) => o(r));
    },
    on(t, r) {
      e.set(t, [...e.get(t) || [], r]);
    },
    off(t, r) {
      e.set(t, (e.get(t) || []).filter((n) => n !== r));
    }
  };
}
const nW = /* @__PURE__ */ P.createContext(null), oW = /* @__PURE__ */ P.createContext(null), rC = () => {
  var e;
  return ((e = P.useContext(nW)) == null ? void 0 : e.id) || null;
}, kg = () => P.useContext(oW);
function Fo(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function aW() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function iW() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: r,
      version: n
    } = t;
    return r + "/" + n;
  }).join(" ") : navigator.userAgent;
}
function Rg(e) {
  return Fo(e).defaultView || window;
}
function Wn(e) {
  return e ? e instanceof Rg(e).Element : !1;
}
function nC(e) {
  return e ? e instanceof Rg(e).HTMLElement : !1;
}
function sW(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  const t = Rg(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function lW(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(aW()) || t.test(iW())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function cW(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333â€¢ for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function oC(e, t) {
  const r = ["mouse", "pen"];
  return t || r.push("", void 0), r.includes(e);
}
function Lx(e) {
  const t = qe(e);
  return Ai(() => {
    t.current = e;
  }), t;
}
const Vx = "data-floating-ui-safe-polygon";
function kc(e, t, r) {
  return r && !oC(r) ? 0 : typeof e == "number" ? e : e == null ? void 0 : e[t];
}
const uW = function(e, t) {
  let {
    enabled: r = !0,
    delay: n = 0,
    handleClose: o = null,
    mouseOnly: a = !1,
    restMs: i = 0,
    move: l = !0
  } = t === void 0 ? {} : t;
  const {
    open: c,
    onOpenChange: u,
    dataRef: d,
    events: f,
    elements: {
      domReference: p,
      floating: m
    },
    refs: y
  } = e, h = kg(), v = rC(), g = Lx(o), b = Lx(n), x = P.useRef(), O = P.useRef(), w = P.useRef(), S = P.useRef(), E = P.useRef(!0), C = P.useRef(!1), N = P.useRef(() => {
  }), $ = P.useCallback(() => {
    var R;
    const D = (R = d.current.openEvent) == null ? void 0 : R.type;
    return (D == null ? void 0 : D.includes("mouse")) && D !== "mousedown";
  }, [d]);
  P.useEffect(() => {
    if (!r)
      return;
    function R() {
      clearTimeout(O.current), clearTimeout(S.current), E.current = !0;
    }
    return f.on("dismiss", R), () => {
      f.off("dismiss", R);
    };
  }, [r, f]), P.useEffect(() => {
    if (!r || !g.current || !c)
      return;
    function R() {
      $() && u(!1);
    }
    const D = Fo(m).documentElement;
    return D.addEventListener("mouseleave", R), () => {
      D.removeEventListener("mouseleave", R);
    };
  }, [m, c, u, r, g, d, $]);
  const j = P.useCallback(function(R) {
    R === void 0 && (R = !0);
    const D = kc(b.current, "close", x.current);
    D && !w.current ? (clearTimeout(O.current), O.current = setTimeout(() => u(!1), D)) : R && (clearTimeout(O.current), u(!1));
  }, [b, u]), A = P.useCallback(() => {
    N.current(), w.current = void 0;
  }, []), k = P.useCallback(() => {
    if (C.current) {
      const R = Fo(y.floating.current).body;
      R.style.pointerEvents = "", R.removeAttribute(Vx), C.current = !1;
    }
  }, [y]);
  return P.useEffect(() => {
    if (!r)
      return;
    function R() {
      return d.current.openEvent ? ["click", "mousedown"].includes(d.current.openEvent.type) : !1;
    }
    function D(H) {
      if (clearTimeout(O.current), E.current = !1, a && !oC(x.current) || i > 0 && kc(b.current, "open") === 0)
        return;
      d.current.openEvent = H;
      const U = kc(b.current, "open", x.current);
      U ? O.current = setTimeout(() => {
        u(!0);
      }, U) : u(!0);
    }
    function L(H) {
      if (R())
        return;
      N.current();
      const U = Fo(m);
      if (clearTimeout(S.current), g.current) {
        c || clearTimeout(O.current), w.current = g.current({
          ...e,
          tree: h,
          x: H.clientX,
          y: H.clientY,
          onClose() {
            k(), A(), j();
          }
        });
        const I = w.current;
        U.addEventListener("mousemove", I), N.current = () => {
          U.removeEventListener("mousemove", I);
        };
        return;
      }
      j();
    }
    function B(H) {
      R() || g.current == null || g.current({
        ...e,
        tree: h,
        x: H.clientX,
        y: H.clientY,
        onClose() {
          k(), A(), j();
        }
      })(H);
    }
    if (Wn(p)) {
      const H = p;
      return c && H.addEventListener("mouseleave", B), m == null || m.addEventListener("mouseleave", B), l && H.addEventListener("mousemove", D, {
        once: !0
      }), H.addEventListener("mouseenter", D), H.addEventListener("mouseleave", L), () => {
        c && H.removeEventListener("mouseleave", B), m == null || m.removeEventListener("mouseleave", B), l && H.removeEventListener("mousemove", D), H.removeEventListener("mouseenter", D), H.removeEventListener("mouseleave", L);
      };
    }
  }, [p, m, r, e, a, i, l, j, A, k, u, c, h, b, g, d]), Ai(() => {
    var R;
    if (r && c && (R = g.current) != null && R.__options.blockPointerEvents && $()) {
      const B = Fo(m).body;
      if (B.setAttribute(Vx, ""), B.style.pointerEvents = "none", C.current = !0, Wn(p) && m) {
        var D, L;
        const H = p, U = h == null || (D = h.nodesRef.current.find((I) => I.id === v)) == null || (L = D.context) == null ? void 0 : L.elements.floating;
        return U && (U.style.pointerEvents = ""), H.style.pointerEvents = "auto", m.style.pointerEvents = "auto", () => {
          H.style.pointerEvents = "", m.style.pointerEvents = "";
        };
      }
    }
  }, [r, c, v, m, p, h, g, d, $]), Ai(() => {
    c || (x.current = void 0, A(), k());
  }, [c, A, k]), P.useEffect(() => () => {
    A(), clearTimeout(O.current), clearTimeout(S.current), k();
  }, [r, A, k]), P.useMemo(() => {
    if (!r)
      return {};
    function R(D) {
      x.current = D.pointerType;
    }
    return {
      reference: {
        onPointerDown: R,
        onPointerEnter: R,
        onMouseMove() {
          c || i === 0 || (clearTimeout(S.current), S.current = setTimeout(() => {
            E.current || u(!0);
          }, i));
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(O.current);
        },
        onMouseLeave() {
          f.emit("dismiss", {
            type: "mouseLeave",
            data: {
              returnFocus: !1
            }
          }), j(!1);
        }
      }
    };
  }, [f, r, i, c, u, j]);
}, aC = /* @__PURE__ */ P.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  },
  isInstantPhase: !1
}), iC = () => P.useContext(aC), dW = (e) => {
  let {
    children: t,
    delay: r,
    timeoutMs: n = 0
  } = e;
  const [o, a] = P.useReducer((c, u) => ({
    ...c,
    ...u
  }), {
    delay: r,
    timeoutMs: n,
    initialDelay: r,
    currentId: null,
    isInstantPhase: !1
  }), i = P.useRef(null), l = P.useCallback((c) => {
    a({
      currentId: c
    });
  }, []);
  return Ai(() => {
    o.currentId ? i.current === null ? i.current = o.currentId : a({
      isInstantPhase: !0
    }) : (a({
      isInstantPhase: !1
    }), i.current = null);
  }, [o.currentId]), /* @__PURE__ */ P.createElement(aC.Provider, {
    value: P.useMemo(() => ({
      ...o,
      setState: a,
      setCurrentId: l
    }), [o, a, l])
  }, t);
}, fW = (e, t) => {
  let {
    open: r,
    onOpenChange: n
  } = e, {
    id: o
  } = t;
  const {
    currentId: a,
    setCurrentId: i,
    initialDelay: l,
    setState: c,
    timeoutMs: u
  } = iC();
  P.useEffect(() => {
    a && (c({
      delay: {
        open: 1,
        close: kc(l, "close")
      }
    }), a !== o && n(!1));
  }, [o, n, c, a, l]), P.useEffect(() => {
    function d() {
      n(!1), c({
        delay: l,
        currentId: null
      });
    }
    if (!r && a === o)
      if (u) {
        const f = window.setTimeout(d, u);
        return () => {
          clearTimeout(f);
        };
      } else
        d();
  }, [r, c, a, o, n, l, u]), P.useEffect(() => {
    r && i(o);
  }, [r, i, o]);
};
function pW(e) {
  let t = e.activeElement;
  for (; ((r = t) == null || (n = r.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var r, n;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function zx(e, t) {
  if (!e || !t)
    return !1;
  const r = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (r && sW(r)) {
    let n = t;
    do {
      if (n && e === n)
        return !0;
      n = n.parentNode || n.host;
    } while (n);
  }
  return !1;
}
function Dm(e, t) {
  let r = e.filter((o) => {
    var a;
    return o.parentId === t && ((a = o.context) == null ? void 0 : a.open);
  }) || [], n = r;
  for (; n.length; )
    n = e.filter((o) => {
      var a;
      return (a = n) == null ? void 0 : a.some((i) => {
        var l;
        return o.parentId === i.id && ((l = o.context) == null ? void 0 : l.open);
      });
    }) || [], r = r.concat(n);
  return r;
}
function mW(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const hW = P[/* @__PURE__ */ "useInsertionEffect".toString()], yW = hW || ((e) => e());
function sC(e) {
  const t = P.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return yW(() => {
    t.current = e;
  }), P.useCallback(function() {
    for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)
      n[o] = arguments[o];
    return t.current == null ? void 0 : t.current(...n);
  }, []);
}
function Rc(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const r = e;
  return r.target != null && t.contains(r.target);
}
const vW = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, gW = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, bW = function(e) {
  var t, r;
  return e === void 0 && (e = !0), {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e.escapeKey) != null ? t : !0,
    outsidePressBubbles: typeof e == "boolean" ? e : (r = e.outsidePress) != null ? r : !0
  };
}, wW = function(e, t) {
  let {
    open: r,
    onOpenChange: n,
    events: o,
    nodeId: a,
    elements: {
      reference: i,
      domReference: l,
      floating: c
    },
    dataRef: u
  } = e, {
    enabled: d = !0,
    escapeKey: f = !0,
    outsidePress: p = !0,
    outsidePressEvent: m = "pointerdown",
    referencePress: y = !1,
    referencePressEvent: h = "pointerdown",
    ancestorScroll: v = !1,
    bubbles: g = !0
  } = t === void 0 ? {} : t;
  const b = kg(), x = rC() != null, O = sC(typeof p == "function" ? p : () => !1), w = typeof p == "function" ? O : p, S = P.useRef(!1), {
    escapeKeyBubbles: E,
    outsidePressBubbles: C
  } = bW(g);
  return P.useEffect(() => {
    if (!r || !d)
      return;
    u.current.__escapeKeyBubbles = E, u.current.__outsidePressBubbles = C;
    function N(R) {
      if (R.key === "Escape") {
        const D = b ? Dm(b.nodesRef.current, a) : [];
        if (D.length > 0) {
          let L = !0;
          if (D.forEach((B) => {
            var H;
            if ((H = B.context) != null && H.open && !B.context.dataRef.current.__escapeKeyBubbles) {
              L = !1;
              return;
            }
          }), !L)
            return;
        }
        o.emit("dismiss", {
          type: "escapeKey",
          data: {
            returnFocus: {
              preventScroll: !1
            }
          }
        }), n(!1);
      }
    }
    function $(R) {
      const D = S.current;
      if (S.current = !1, D || typeof w == "function" && !w(R))
        return;
      const L = mW(R);
      if (nC(L) && c) {
        const U = c.ownerDocument.defaultView || window, I = L.scrollWidth > L.clientWidth, V = L.scrollHeight > L.clientHeight;
        let G = V && R.offsetX > L.clientWidth;
        if (V && U.getComputedStyle(L).direction === "rtl" && (G = R.offsetX <= L.offsetWidth - L.clientWidth), G || I && R.offsetY > L.clientHeight)
          return;
      }
      const B = b && Dm(b.nodesRef.current, a).some((U) => {
        var I;
        return Rc(R, (I = U.context) == null ? void 0 : I.elements.floating);
      });
      if (Rc(R, c) || Rc(R, l) || B)
        return;
      const H = b ? Dm(b.nodesRef.current, a) : [];
      if (H.length > 0) {
        let U = !0;
        if (H.forEach((I) => {
          var V;
          if ((V = I.context) != null && V.open && !I.context.dataRef.current.__outsidePressBubbles) {
            U = !1;
            return;
          }
        }), !U)
          return;
      }
      o.emit("dismiss", {
        type: "outsidePress",
        data: {
          returnFocus: x ? {
            preventScroll: !0
          } : lW(R) || cW(R)
        }
      }), n(!1);
    }
    function j() {
      n(!1);
    }
    const A = Fo(c);
    f && A.addEventListener("keydown", N), w && A.addEventListener(m, $);
    let k = [];
    return v && (Wn(l) && (k = uo(l)), Wn(c) && (k = k.concat(uo(c))), !Wn(i) && i && i.contextElement && (k = k.concat(uo(i.contextElement)))), k = k.filter((R) => {
      var D;
      return R !== ((D = A.defaultView) == null ? void 0 : D.visualViewport);
    }), k.forEach((R) => {
      R.addEventListener("scroll", j, {
        passive: !0
      });
    }), () => {
      f && A.removeEventListener("keydown", N), w && A.removeEventListener(m, $), k.forEach((R) => {
        R.removeEventListener("scroll", j);
      });
    };
  }, [u, c, l, i, f, w, m, o, b, a, r, n, v, d, E, C, x]), P.useEffect(() => {
    S.current = !1;
  }, [w, m]), P.useMemo(() => d ? {
    reference: {
      [vW[h]]: () => {
        y && (o.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), n(!1));
      }
    },
    floating: {
      [gW[m]]: () => {
        S.current = !0;
      }
    }
  } : {}, [d, o, y, m, h, n]);
}, xW = function(e, t) {
  let {
    open: r,
    onOpenChange: n,
    dataRef: o,
    events: a,
    refs: i,
    elements: {
      floating: l,
      domReference: c
    }
  } = e, {
    enabled: u = !0,
    keyboardOnly: d = !0
  } = t === void 0 ? {} : t;
  const f = P.useRef(""), p = P.useRef(!1), m = P.useRef();
  return P.useEffect(() => {
    if (!u)
      return;
    const h = Fo(l).defaultView || window;
    function v() {
      !r && nC(c) && c === pW(Fo(c)) && (p.current = !0);
    }
    return h.addEventListener("blur", v), () => {
      h.removeEventListener("blur", v);
    };
  }, [l, c, r, u]), P.useEffect(() => {
    if (!u)
      return;
    function y(h) {
      (h.type === "referencePress" || h.type === "escapeKey") && (p.current = !0);
    }
    return a.on("dismiss", y), () => {
      a.off("dismiss", y);
    };
  }, [a, u]), P.useEffect(() => () => {
    clearTimeout(m.current);
  }, []), P.useMemo(() => u ? {
    reference: {
      onPointerDown(y) {
        let {
          pointerType: h
        } = y;
        f.current = h, p.current = !!(h && d);
      },
      onMouseLeave() {
        p.current = !1;
      },
      onFocus(y) {
        var h;
        p.current || y.type === "focus" && ((h = o.current.openEvent) == null ? void 0 : h.type) === "mousedown" && o.current.openEvent && Rc(o.current.openEvent, c) || (o.current.openEvent = y.nativeEvent, n(!0));
      },
      onBlur(y) {
        p.current = !1;
        const h = y.relatedTarget, v = Wn(h) && h.hasAttribute("data-floating-ui-focus-guard") && h.getAttribute("data-type") === "outside";
        m.current = setTimeout(() => {
          zx(i.floating.current, h) || zx(c, h) || v || n(!1);
        });
      }
    }
  } : {}, [u, d, c, i, o, n]);
}, _W = function(e, t) {
  let {
    open: r
  } = e, {
    enabled: n = !0,
    role: o = "dialog"
  } = t === void 0 ? {} : t;
  const a = Fx(), i = Fx();
  return P.useMemo(() => {
    const l = {
      id: a,
      role: o
    };
    return n ? o === "tooltip" ? {
      reference: {
        "aria-describedby": r ? a : void 0
      },
      floating: l
    } : {
      reference: {
        "aria-expanded": r ? "true" : "false",
        "aria-haspopup": o === "alertdialog" ? "dialog" : o,
        "aria-controls": r ? a : void 0,
        ...o === "listbox" && {
          role: "combobox"
        },
        ...o === "menu" && {
          id: i
        }
      },
      floating: {
        ...l,
        ...o === "menu" && {
          "aria-labelledby": i
        }
      }
    } : {};
  }, [n, o, r, a, i]);
};
function Dg(e) {
  e === void 0 && (e = {});
  const {
    open: t = !1,
    onOpenChange: r,
    nodeId: n
  } = e, o = Z6(e), a = kg(), i = P.useRef(null), l = P.useRef({}), c = P.useState(() => rW())[0], [u, d] = P.useState(null), f = P.useCallback((g) => {
    const b = Wn(g) ? {
      getBoundingClientRect: () => g.getBoundingClientRect(),
      contextElement: g
    } : g;
    o.refs.setReference(b);
  }, [o.refs]), p = P.useCallback((g) => {
    (Wn(g) || g === null) && (i.current = g, d(g)), (Wn(o.refs.reference.current) || o.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    g !== null && !Wn(g)) && o.refs.setReference(g);
  }, [o.refs]), m = P.useMemo(() => ({
    ...o.refs,
    setReference: p,
    setPositionReference: f,
    domReference: i
  }), [o.refs, p, f]), y = P.useMemo(() => ({
    ...o.elements,
    domReference: u
  }), [o.elements, u]), h = sC(r), v = P.useMemo(() => ({
    ...o,
    refs: m,
    elements: y,
    dataRef: l,
    nodeId: n,
    events: c,
    open: t,
    onOpenChange: h
  }), [o, n, c, t, h, m, y]);
  return Ai(() => {
    const g = a == null ? void 0 : a.nodesRef.current.find((b) => b.id === n);
    g && (g.context = v);
  }), P.useMemo(() => ({
    ...o,
    context: v,
    refs: m,
    reference: p,
    positionReference: f
  }), [o, m, v, p, f]);
}
function Nm(e, t, r) {
  const n = /* @__PURE__ */ new Map();
  return {
    ...r === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((o) => o ? o[r] : null).concat(e).reduce((o, a) => (a && Object.entries(a).forEach((i) => {
      let [l, c] = i;
      if (l.indexOf("on") === 0) {
        if (n.has(l) || n.set(l, []), typeof c == "function") {
          var u;
          (u = n.get(l)) == null || u.push(c), o[l] = function() {
            for (var d, f = arguments.length, p = new Array(f), m = 0; m < f; m++)
              p[m] = arguments[m];
            (d = n.get(l)) == null || d.forEach((y) => y(...p));
          };
        }
      } else
        o[l] = c;
    }), o), {})
  };
}
const OW = function(e) {
  e === void 0 && (e = []);
  const t = e, r = P.useCallback(
    (a) => Nm(a, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), n = P.useCallback(
    (a) => Nm(a, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), o = P.useCallback(
    (a) => Nm(a, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((a) => a == null ? void 0 : a.item)
  );
  return P.useMemo(() => ({
    getReferenceProps: r,
    getFloatingProps: n,
    getItemProps: o
  }), [r, n, o]);
};
function lC({ opened: e, floating: t, positionDependencies: r }) {
  const [n, o] = Me(0);
  Ue(() => {
    if (t.refs.reference.current && t.refs.floating.current)
      return X6(t.refs.reference.current, t.refs.floating.current, t.update);
  }, [t.refs.reference.current, t.refs.floating.current, e, n]), sn(() => {
    t.update();
  }, r), sn(() => {
    o((a) => a + 1);
  }, [e]);
}
function PW(e) {
  const t = [H$(e.offset)];
  return e.middlewares.shift && t.push($g({ limiter: H6() })), e.middlewares.flip && t.push(W$()), e.middlewares.inline && t.push(U$()), t.push(tC({ element: e.arrowRef, padding: e.arrowOffset })), t;
}
function SW(e) {
  const [t, r] = Kn({
    value: e.opened,
    defaultValue: e.defaultOpened,
    finalValue: !1,
    onChange: e.onChange
  }), n = () => {
    var i;
    (i = e.onClose) == null || i.call(e), r(!1);
  }, o = () => {
    var i, l;
    t ? ((i = e.onClose) == null || i.call(e), r(!1)) : ((l = e.onOpen) == null || l.call(e), r(!0));
  }, a = Dg({
    placement: e.position,
    middleware: [
      ...PW(e),
      ...e.width === "target" ? [
        Y6({
          apply({ rects: i }) {
            var l, c;
            Object.assign((c = (l = a.refs.floating.current) == null ? void 0 : l.style) != null ? c : {}, {
              width: `${i.reference.width}px`
            });
          }
        })
      ] : []
    ]
  });
  return lC({
    opened: e.opened,
    positionDependencies: e.positionDependencies,
    floating: a
  }), sn(() => {
    var i;
    (i = e.onPositionChange) == null || i.call(e, a.placement);
  }, [a.placement]), {
    floating: a,
    controlled: typeof e.opened == "boolean",
    opened: t,
    onClose: n,
    onToggle: o
  };
}
const cC = {
  context: "Popover component was not found in the tree",
  children: "Popover.Target component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
}, [TW, uC] = _p(cC.context);
var EW = Object.defineProperty, $W = Object.defineProperties, CW = Object.getOwnPropertyDescriptors, Xu = Object.getOwnPropertySymbols, dC = Object.prototype.hasOwnProperty, fC = Object.prototype.propertyIsEnumerable, Bx = (e, t, r) => t in e ? EW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Gl = (e, t) => {
  for (var r in t || (t = {}))
    dC.call(t, r) && Bx(e, r, t[r]);
  if (Xu)
    for (var r of Xu(t))
      fC.call(t, r) && Bx(e, r, t[r]);
  return e;
}, kW = (e, t) => $W(e, CW(t)), RW = (e, t) => {
  var r = {};
  for (var n in e)
    dC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Xu)
    for (var n of Xu(e))
      t.indexOf(n) < 0 && fC.call(e, n) && (r[n] = e[n]);
  return r;
};
const DW = {
  refProp: "ref",
  popupType: "dialog"
}, pC = Ne((e, t) => {
  const r = Xe("PopoverTarget", DW, e), { children: n, refProp: o, popupType: a } = r, i = RW(r, ["children", "refProp", "popupType"]);
  if (!_l(n))
    throw new Error(cC.children);
  const l = i, c = uC(), u = Jo(c.reference, n.ref, t), d = c.withRoles ? {
    "aria-haspopup": a,
    "aria-expanded": c.opened,
    "aria-controls": c.getDropdownId(),
    id: c.getTargetId()
  } : {};
  return on(n, Gl(kW(Gl(Gl(Gl({}, l), d), c.targetProps), {
    className: $E(c.targetProps.className, l.className, n.props.className),
    [o]: u
  }), c.controlled ? null : { onClick: c.onToggle }));
});
pC.displayName = "@mantine/core/PopoverTarget";
var NW = Qe((e, { radius: t, shadow: r }) => ({
  dropdown: {
    position: "absolute",
    backgroundColor: e.white,
    background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`,
    padding: `${e.spacing.sm}px ${e.spacing.md}px`,
    boxShadow: e.shadows[r] || r || "none",
    borderRadius: e.fn.radius(t),
    "&:focus": {
      outline: 0
    }
  },
  arrow: {
    backgroundColor: "inherit",
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`,
    zIndex: 1
  }
}));
const IW = NW;
var MW = Object.defineProperty, Wx = Object.getOwnPropertySymbols, AW = Object.prototype.hasOwnProperty, jW = Object.prototype.propertyIsEnumerable, Ux = (e, t, r) => t in e ? MW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ei = (e, t) => {
  for (var r in t || (t = {}))
    AW.call(t, r) && Ux(e, r, t[r]);
  if (Wx)
    for (var r of Wx(t))
      jW.call(t, r) && Ux(e, r, t[r]);
  return e;
};
const Hx = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function mC({
  transition: e,
  state: t,
  duration: r,
  timingFunction: n
}) {
  const o = {
    transitionDuration: `${r}ms`,
    transitionTimingFunction: n
  };
  return typeof e == "string" ? e in Ul ? ei(ei(ei({
    transitionProperty: Ul[e].transitionProperty
  }, o), Ul[e].common), Ul[e][Hx[t]]) : null : ei(ei(ei({
    transitionProperty: e.transitionProperty
  }, o), e.common), e[Hx[t]]);
}
function hC({
  duration: e,
  exitDuration: t,
  timingFunction: r,
  mounted: n,
  onEnter: o,
  onExit: a,
  onEntered: i,
  onExited: l
}) {
  const c = fr(), u = WE(), d = c.respectReducedMotion ? u : !1, [f, p] = Me(n ? "entered" : "exited");
  let m = d ? 0 : e;
  const y = qe(-1), h = (v) => {
    const g = v ? o : a, b = v ? i : l;
    if (p(v ? "pre-entering" : "pre-exiting"), window.clearTimeout(y.current), m = d ? 0 : v ? e : t, m === 0)
      typeof g == "function" && g(), typeof b == "function" && b(), p(v ? "entered" : "exited");
    else {
      const x = window.setTimeout(() => {
        typeof g == "function" && g(), p(v ? "entering" : "exiting");
      }, 10);
      y.current = window.setTimeout(() => {
        window.clearTimeout(x), typeof b == "function" && b(), p(v ? "entered" : "exited");
      }, m);
    }
  };
  return sn(() => {
    h(n);
  }, [n]), Ue(() => () => window.clearTimeout(y.current), []), {
    transitionDuration: m,
    transitionStatus: f,
    transitionTimingFunction: r || c.transitionTimingFunction
  };
}
function Dp({
  transition: e,
  duration: t = 250,
  exitDuration: r = t,
  mounted: n,
  children: o,
  timingFunction: a,
  onExit: i,
  onEntered: l,
  onEnter: c,
  onExited: u
}) {
  const { transitionDuration: d, transitionStatus: f, transitionTimingFunction: p } = hC({
    mounted: n,
    exitDuration: r,
    duration: t,
    timingFunction: a,
    onExit: i,
    onEntered: l,
    onEnter: c,
    onExited: u
  });
  return d === 0 ? n ? /* @__PURE__ */ F.createElement(F.Fragment, null, o({})) : null : f === "exited" ? null : /* @__PURE__ */ F.createElement(F.Fragment, null, o(mC({
    transition: e,
    duration: d,
    state: f,
    timingFunction: p
  })));
}
Dp.displayName = "@mantine/core/Transition";
function yC({
  children: e,
  active: t = !0,
  refProp: r = "ref"
}) {
  const n = BE(t), o = Jo(n, e == null ? void 0 : e.ref);
  return _l(e) ? on(e, { [r]: o }) : e;
}
yC.displayName = "@mantine/core/FocusTrap";
var FW = Object.defineProperty, LW = Object.defineProperties, VW = Object.getOwnPropertyDescriptors, Yx = Object.getOwnPropertySymbols, zW = Object.prototype.hasOwnProperty, BW = Object.prototype.propertyIsEnumerable, qx = (e, t, r) => t in e ? FW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ko = (e, t) => {
  for (var r in t || (t = {}))
    zW.call(t, r) && qx(e, r, t[r]);
  if (Yx)
    for (var r of Yx(t))
      BW.call(t, r) && qx(e, r, t[r]);
  return e;
}, Kl = (e, t) => LW(e, VW(t));
function Gx(e, t, r, n) {
  return e === "center" || n === "center" ? { top: t } : e === "end" ? { bottom: r } : e === "start" ? { top: r } : {};
}
function Kx(e, t, r, n, o) {
  return e === "center" || n === "center" ? { left: t } : e === "end" ? { [o === "ltr" ? "right" : "left"]: r } : e === "start" ? { [o === "ltr" ? "left" : "right"]: r } : {};
}
const WW = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function UW({
  position: e,
  withBorder: t,
  arrowSize: r,
  arrowOffset: n,
  arrowRadius: o,
  arrowPosition: a,
  arrowX: i,
  arrowY: l,
  dir: c
}) {
  const [u, d = "center"] = e.split("-"), f = {
    width: r,
    height: r,
    transform: "rotate(45deg)",
    position: "absolute",
    [WW[u]]: o
  }, p = t ? -r / 2 - 1 : -r / 2;
  return u === "left" ? Kl(ko(ko({}, f), Gx(d, l, n, a)), {
    right: p,
    borderLeft: 0,
    borderBottom: 0
  }) : u === "right" ? Kl(ko(ko({}, f), Gx(d, l, n, a)), {
    left: p,
    borderRight: 0,
    borderTop: 0
  }) : u === "top" ? Kl(ko(ko({}, f), Kx(d, i, n, a, c)), {
    bottom: p,
    borderTop: 0,
    borderLeft: 0
  }) : u === "bottom" ? Kl(ko(ko({}, f), Kx(d, i, n, a, c)), {
    top: p,
    borderBottom: 0,
    borderRight: 0
  }) : {};
}
var HW = Object.defineProperty, YW = Object.defineProperties, qW = Object.getOwnPropertyDescriptors, Qu = Object.getOwnPropertySymbols, vC = Object.prototype.hasOwnProperty, gC = Object.prototype.propertyIsEnumerable, Xx = (e, t, r) => t in e ? HW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, GW = (e, t) => {
  for (var r in t || (t = {}))
    vC.call(t, r) && Xx(e, r, t[r]);
  if (Qu)
    for (var r of Qu(t))
      gC.call(t, r) && Xx(e, r, t[r]);
  return e;
}, KW = (e, t) => YW(e, qW(t)), XW = (e, t) => {
  var r = {};
  for (var n in e)
    vC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Qu)
    for (var n of Qu(e))
      t.indexOf(n) < 0 && gC.call(e, n) && (r[n] = e[n]);
  return r;
};
const Ng = Ne((e, t) => {
  var r = e, {
    withBorder: n,
    position: o,
    arrowSize: a,
    arrowOffset: i,
    arrowRadius: l,
    arrowPosition: c,
    visible: u,
    arrowX: d,
    arrowY: f
  } = r, p = XW(r, [
    "withBorder",
    "position",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "visible",
    "arrowX",
    "arrowY"
  ]);
  const m = fr();
  return u ? /* @__PURE__ */ F.createElement("div", KW(GW({}, p), {
    ref: t,
    style: UW({
      withBorder: n,
      position: o,
      arrowSize: a,
      arrowOffset: i,
      arrowRadius: l,
      arrowPosition: c,
      dir: m.dir,
      arrowX: d,
      arrowY: f
    })
  })) : null;
});
Ng.displayName = "@mantine/core/FloatingArrow";
var QW = Object.defineProperty, ZW = Object.defineProperties, JW = Object.getOwnPropertyDescriptors, Zu = Object.getOwnPropertySymbols, bC = Object.prototype.hasOwnProperty, wC = Object.prototype.propertyIsEnumerable, Qx = (e, t, r) => t in e ? QW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Xl = (e, t) => {
  for (var r in t || (t = {}))
    bC.call(t, r) && Qx(e, r, t[r]);
  if (Zu)
    for (var r of Zu(t))
      wC.call(t, r) && Qx(e, r, t[r]);
  return e;
}, Zx = (e, t) => ZW(e, JW(t)), e4 = (e, t) => {
  var r = {};
  for (var n in e)
    bC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Zu)
    for (var n of Zu(e))
      t.indexOf(n) < 0 && wC.call(e, n) && (r[n] = e[n]);
  return r;
};
const t4 = {};
function xC(e) {
  const t = Xe("PopoverDropdown", t4, e), { style: r, className: n, children: o, onKeyDownCapture: a } = t, i = e4(t, ["style", "className", "children", "onKeyDownCapture"]), l = uC(), { classes: c, cx: u } = IW({ radius: l.radius, shadow: l.shadow }, {
    name: l.__staticSelector,
    classNames: l.classNames,
    styles: l.styles,
    unstyled: l.unstyled
  }), d = FE({
    opened: l.opened,
    shouldReturnFocus: l.returnFocus
  }), f = l.withRoles ? {
    "aria-labelledby": l.getTargetId(),
    id: l.getDropdownId(),
    role: "dialog"
  } : {};
  return l.disabled ? null : /* @__PURE__ */ F.createElement(Pl, {
    withinPortal: l.withinPortal
  }, /* @__PURE__ */ F.createElement(Dp, {
    mounted: l.opened,
    transition: l.transition,
    duration: l.transitionDuration,
    exitDuration: typeof l.exitTransitionDuration == "number" ? l.exitTransitionDuration : l.transitionDuration
  }, (p) => {
    var m, y;
    return /* @__PURE__ */ F.createElement(yC, {
      active: l.trapFocus
    }, /* @__PURE__ */ F.createElement(Ke, Xl(Zx(Xl({}, f), {
      tabIndex: -1,
      key: l.placement,
      ref: l.floating,
      style: Zx(Xl(Xl({}, r), p), {
        zIndex: l.zIndex,
        top: (m = l.y) != null ? m : 0,
        left: (y = l.x) != null ? y : 0,
        width: l.width === "target" ? void 0 : l.width
      }),
      className: u(c.dropdown, n),
      onKeyDownCapture: eV(l.onClose, {
        active: l.closeOnEscape,
        onTrigger: d,
        onKeyDown: a
      }),
      "data-position": l.placement
    }), i), o, /* @__PURE__ */ F.createElement(Ng, {
      ref: l.arrowRef,
      arrowX: l.arrowX,
      arrowY: l.arrowY,
      visible: l.withArrow,
      withBorder: !0,
      position: l.placement,
      arrowSize: l.arrowSize,
      arrowRadius: l.arrowRadius,
      arrowOffset: l.arrowOffset,
      arrowPosition: l.arrowPosition,
      className: c.arrow
    })));
  }));
}
xC.displayName = "@mantine/core/PopoverDropdown";
function _C(e, t) {
  if (e === "rtl" && (t.includes("right") || t.includes("left"))) {
    const [r, n] = t.split("-"), o = r === "right" ? "left" : "right";
    return n === void 0 ? o : `${o}-${n}`;
  }
  return t;
}
var Jx = Object.getOwnPropertySymbols, r4 = Object.prototype.hasOwnProperty, n4 = Object.prototype.propertyIsEnumerable, o4 = (e, t) => {
  var r = {};
  for (var n in e)
    r4.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Jx)
    for (var n of Jx(e))
      t.indexOf(n) < 0 && n4.call(e, n) && (r[n] = e[n]);
  return r;
};
const a4 = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transition: "fade",
  transitionDuration: 150,
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !1,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: Oo("popover"),
  __staticSelector: "Popover",
  width: "max-content"
};
function cn(e) {
  var t, r, n, o, a, i;
  const l = qe(null), c = Xe("Popover", a4, e), {
    children: u,
    position: d,
    offset: f,
    onPositionChange: p,
    positionDependencies: m,
    opened: y,
    transition: h,
    transitionDuration: v,
    width: g,
    middlewares: b,
    withArrow: x,
    arrowSize: O,
    arrowOffset: w,
    arrowRadius: S,
    arrowPosition: E,
    unstyled: C,
    classNames: N,
    styles: $,
    closeOnClickOutside: j,
    withinPortal: A,
    closeOnEscape: k,
    clickOutsideEvents: R,
    trapFocus: D,
    onClose: L,
    onOpen: B,
    onChange: H,
    zIndex: U,
    radius: I,
    shadow: V,
    id: G,
    defaultOpened: q,
    exitTransitionDuration: J,
    __staticSelector: ne,
    withRoles: te,
    disabled: ee,
    returnFocus: K
  } = c, Q = o4(c, [
    "children",
    "position",
    "offset",
    "onPositionChange",
    "positionDependencies",
    "opened",
    "transition",
    "transitionDuration",
    "width",
    "middlewares",
    "withArrow",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "unstyled",
    "classNames",
    "styles",
    "closeOnClickOutside",
    "withinPortal",
    "closeOnEscape",
    "clickOutsideEvents",
    "trapFocus",
    "onClose",
    "onOpen",
    "onChange",
    "zIndex",
    "radius",
    "shadow",
    "id",
    "defaultOpened",
    "exitTransitionDuration",
    "__staticSelector",
    "withRoles",
    "disabled",
    "returnFocus"
  ]), [ae, ie] = Me(null), [oe, se] = Me(null), re = Zo(G), le = fr(), M = SW({
    middlewares: b,
    width: g,
    position: _C(le.dir, d),
    offset: f + (x ? O / 2 : 0),
    arrowRef: l,
    arrowOffset: w,
    onPositionChange: p,
    positionDependencies: m,
    opened: y,
    defaultOpened: q,
    onChange: H,
    onOpen: B,
    onClose: L
  });
  wz(() => j && M.onClose(), R, [
    ae,
    oe
  ]);
  const W = qn((he) => {
    ie(he), M.floating.reference(he);
  }, [M.floating.reference]), Z = qn((he) => {
    se(he), M.floating.floating(he);
  }, [M.floating.floating]);
  return /* @__PURE__ */ F.createElement(TW, {
    value: {
      returnFocus: K,
      disabled: ee,
      controlled: M.controlled,
      reference: W,
      floating: Z,
      x: M.floating.x,
      y: M.floating.y,
      arrowX: (n = (r = (t = M.floating) == null ? void 0 : t.middlewareData) == null ? void 0 : r.arrow) == null ? void 0 : n.x,
      arrowY: (i = (a = (o = M.floating) == null ? void 0 : o.middlewareData) == null ? void 0 : a.arrow) == null ? void 0 : i.y,
      opened: M.opened,
      arrowRef: l,
      transition: h,
      transitionDuration: v,
      exitTransitionDuration: J,
      width: g,
      withArrow: x,
      arrowSize: O,
      arrowOffset: w,
      arrowRadius: S,
      arrowPosition: E,
      placement: M.floating.placement,
      trapFocus: D,
      withinPortal: A,
      zIndex: U,
      radius: I,
      shadow: V,
      closeOnEscape: k,
      onClose: M.onClose,
      onToggle: M.onToggle,
      getTargetId: () => `${re}-target`,
      getDropdownId: () => `${re}-dropdown`,
      withRoles: te,
      targetProps: Q,
      __staticSelector: ne,
      classNames: N,
      styles: $,
      unstyled: C
    }
  }, u);
}
cn.Target = pC;
cn.Dropdown = xC;
cn.displayName = "@mantine/core/Popover";
var i4 = Object.defineProperty, Ju = Object.getOwnPropertySymbols, OC = Object.prototype.hasOwnProperty, PC = Object.prototype.propertyIsEnumerable, e_ = (e, t, r) => t in e ? i4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, s4 = (e, t) => {
  for (var r in t || (t = {}))
    OC.call(t, r) && e_(e, r, t[r]);
  if (Ju)
    for (var r of Ju(t))
      PC.call(t, r) && e_(e, r, t[r]);
  return e;
}, l4 = (e, t) => {
  var r = {};
  for (var n in e)
    OC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Ju)
    for (var n of Ju(e))
      t.indexOf(n) < 0 && PC.call(e, n) && (r[n] = e[n]);
  return r;
};
function c4(e) {
  var t = e, {
    children: r,
    component: n = "div",
    maxHeight: o = 220,
    direction: a = "column",
    id: i,
    innerRef: l,
    __staticSelector: c,
    styles: u,
    classNames: d,
    unstyled: f
  } = t, p = l4(t, [
    "children",
    "component",
    "maxHeight",
    "direction",
    "id",
    "innerRef",
    "__staticSelector",
    "styles",
    "classNames",
    "unstyled"
  ]);
  const { classes: m } = L6(null, { name: c, styles: u, classNames: d, unstyled: f });
  return /* @__PURE__ */ F.createElement(cn.Dropdown, s4({
    p: 0,
    onMouseDown: (y) => y.preventDefault()
  }, p), /* @__PURE__ */ F.createElement("div", {
    style: { maxHeight: o, display: "flex" }
  }, /* @__PURE__ */ F.createElement(Ke, {
    component: n || "div",
    id: `${i}-items`,
    "aria-labelledby": `${i}-label`,
    role: "listbox",
    onMouseDown: (y) => y.preventDefault(),
    style: { flex: 1, overflowY: n !== Cp ? "auto" : void 0 },
    "data-combobox-popover": !0,
    ref: l
  }, /* @__PURE__ */ F.createElement("div", {
    className: m.itemsWrapper,
    style: { flexDirection: a }
  }, r))));
}
function Ho({
  opened: e,
  transition: t = "fade",
  transitionDuration: r = 0,
  shadow: n,
  withinPortal: o,
  children: a,
  __staticSelector: i,
  onDirectionChange: l,
  switchDirectionOnFlip: c,
  zIndex: u,
  dropdownPosition: d,
  positionDependencies: f = [],
  classNames: p,
  styles: m,
  unstyled: y,
  readOnly: h
}) {
  return /* @__PURE__ */ F.createElement(cn, {
    unstyled: y,
    classNames: p,
    styles: m,
    width: "target",
    withRoles: !1,
    opened: e,
    middlewares: { flip: d === "flip", shift: !1 },
    position: d === "flip" ? "bottom" : d,
    positionDependencies: f,
    zIndex: u,
    __staticSelector: i,
    withinPortal: o,
    transition: t,
    transitionDuration: r,
    shadow: n,
    disabled: h,
    onPositionChange: (v) => c && (l == null ? void 0 : l(v === "top" ? "column-reverse" : "column"))
  }, a);
}
Ho.Target = cn.Target;
Ho.Dropdown = c4;
var u4 = Object.defineProperty, d4 = Object.defineProperties, f4 = Object.getOwnPropertyDescriptors, ed = Object.getOwnPropertySymbols, SC = Object.prototype.hasOwnProperty, TC = Object.prototype.propertyIsEnumerable, t_ = (e, t, r) => t in e ? u4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ql = (e, t) => {
  for (var r in t || (t = {}))
    SC.call(t, r) && t_(e, r, t[r]);
  if (ed)
    for (var r of ed(t))
      TC.call(t, r) && t_(e, r, t[r]);
  return e;
}, p4 = (e, t) => d4(e, f4(t)), m4 = (e, t) => {
  var r = {};
  for (var n in e)
    SC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && ed)
    for (var n of ed(e))
      t.indexOf(n) < 0 && TC.call(e, n) && (r[n] = e[n]);
  return r;
};
function EC(e, t, r) {
  const n = Xe(e, t, r), {
    label: o,
    description: a,
    error: i,
    required: l,
    classNames: c,
    styles: u,
    className: d,
    unstyled: f,
    __staticSelector: p,
    sx: m,
    errorProps: y,
    labelProps: h,
    descriptionProps: v,
    wrapperProps: g,
    id: b,
    size: x,
    style: O,
    inputContainer: w,
    inputWrapperOrder: S,
    withAsterisk: E
  } = n, C = m4(n, [
    "label",
    "description",
    "error",
    "required",
    "classNames",
    "styles",
    "className",
    "unstyled",
    "__staticSelector",
    "sx",
    "errorProps",
    "labelProps",
    "descriptionProps",
    "wrapperProps",
    "id",
    "size",
    "style",
    "inputContainer",
    "inputWrapperOrder",
    "withAsterisk"
  ]), N = Zo(b), { systemStyles: $, rest: j } = Xi(C), A = Ql({
    label: o,
    description: a,
    error: i,
    required: l,
    classNames: c,
    className: d,
    __staticSelector: p,
    sx: m,
    errorProps: y,
    labelProps: h,
    descriptionProps: v,
    unstyled: f,
    styles: u,
    id: N,
    size: x,
    style: O,
    inputContainer: w,
    inputWrapperOrder: S,
    withAsterisk: E
  }, g);
  return p4(Ql({}, j), {
    classNames: c,
    styles: u,
    unstyled: f,
    wrapperProps: Ql(Ql({}, A), $),
    inputProps: {
      required: l,
      classNames: c,
      styles: u,
      unstyled: f,
      id: N,
      size: x,
      __staticSelector: p,
      invalid: !!i
    }
  });
}
var h4 = Qe((e, { size: t }) => ({
  label: {
    display: "inline-block",
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    fontWeight: 500,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[9],
    wordBreak: "break-word",
    cursor: "default",
    WebkitTapHighlightColor: "transparent"
  },
  required: {
    color: e.fn.variant({ variant: "filled", color: "red" }).background
  }
}));
const y4 = h4;
var v4 = Object.defineProperty, td = Object.getOwnPropertySymbols, $C = Object.prototype.hasOwnProperty, CC = Object.prototype.propertyIsEnumerable, r_ = (e, t, r) => t in e ? v4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, g4 = (e, t) => {
  for (var r in t || (t = {}))
    $C.call(t, r) && r_(e, r, t[r]);
  if (td)
    for (var r of td(t))
      CC.call(t, r) && r_(e, r, t[r]);
  return e;
}, b4 = (e, t) => {
  var r = {};
  for (var n in e)
    $C.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && td)
    for (var n of td(e))
      t.indexOf(n) < 0 && CC.call(e, n) && (r[n] = e[n]);
  return r;
};
const w4 = {
  labelElement: "label",
  size: "sm"
}, Ig = Ne((e, t) => {
  const r = Xe("InputLabel", w4, e), {
    labelElement: n,
    children: o,
    required: a,
    size: i,
    classNames: l,
    styles: c,
    unstyled: u,
    className: d,
    htmlFor: f,
    __staticSelector: p
  } = r, m = b4(r, [
    "labelElement",
    "children",
    "required",
    "size",
    "classNames",
    "styles",
    "unstyled",
    "className",
    "htmlFor",
    "__staticSelector"
  ]), { classes: y, cx: h } = y4({ size: i }, { name: ["InputWrapper", p], classNames: l, styles: c, unstyled: u });
  return /* @__PURE__ */ F.createElement(Ke, g4({
    component: n,
    ref: t,
    className: h(y.label, d),
    htmlFor: n === "label" ? f : void 0
  }, m), o, a && /* @__PURE__ */ F.createElement("span", {
    className: y.required,
    "aria-hidden": !0
  }, " *"));
});
Ig.displayName = "@mantine/core/InputLabel";
var x4 = Qe((e, { size: t }) => ({
  error: {
    wordBreak: "break-word",
    color: e.fn.variant({ variant: "filled", color: "red" }).background,
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }) - 2,
    lineHeight: 1.2,
    display: "block"
  }
}));
const _4 = x4;
var O4 = Object.defineProperty, rd = Object.getOwnPropertySymbols, kC = Object.prototype.hasOwnProperty, RC = Object.prototype.propertyIsEnumerable, n_ = (e, t, r) => t in e ? O4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, P4 = (e, t) => {
  for (var r in t || (t = {}))
    kC.call(t, r) && n_(e, r, t[r]);
  if (rd)
    for (var r of rd(t))
      RC.call(t, r) && n_(e, r, t[r]);
  return e;
}, S4 = (e, t) => {
  var r = {};
  for (var n in e)
    kC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && rd)
    for (var n of rd(e))
      t.indexOf(n) < 0 && RC.call(e, n) && (r[n] = e[n]);
  return r;
};
const T4 = {
  size: "sm"
}, Mg = Ne((e, t) => {
  const r = Xe("InputError", T4, e), { children: n, className: o, classNames: a, styles: i, unstyled: l, size: c, __staticSelector: u } = r, d = S4(r, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector"]), { classes: f, cx: p } = _4({ size: c }, { name: ["InputWrapper", u], classNames: a, styles: i, unstyled: l });
  return /* @__PURE__ */ F.createElement($r, P4({
    className: p(f.error, o),
    ref: t
  }, d), n);
});
Mg.displayName = "@mantine/core/InputError";
var E4 = Qe((e, { size: t }) => ({
  description: {
    wordBreak: "break-word",
    color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6],
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }) - 2,
    lineHeight: 1.2,
    display: "block"
  }
}));
const $4 = E4;
var C4 = Object.defineProperty, nd = Object.getOwnPropertySymbols, DC = Object.prototype.hasOwnProperty, NC = Object.prototype.propertyIsEnumerable, o_ = (e, t, r) => t in e ? C4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, k4 = (e, t) => {
  for (var r in t || (t = {}))
    DC.call(t, r) && o_(e, r, t[r]);
  if (nd)
    for (var r of nd(t))
      NC.call(t, r) && o_(e, r, t[r]);
  return e;
}, R4 = (e, t) => {
  var r = {};
  for (var n in e)
    DC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && nd)
    for (var n of nd(e))
      t.indexOf(n) < 0 && NC.call(e, n) && (r[n] = e[n]);
  return r;
};
const D4 = {
  size: "sm"
}, Ag = Ne((e, t) => {
  const r = Xe("InputDescription", D4, e), { children: n, className: o, classNames: a, styles: i, unstyled: l, size: c, __staticSelector: u } = r, d = R4(r, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector"]), { classes: f, cx: p } = $4({ size: c }, { name: ["InputWrapper", u], classNames: a, styles: i, unstyled: l });
  return /* @__PURE__ */ F.createElement($r, k4({
    color: "dimmed",
    className: p(f.description, o),
    ref: t,
    unstyled: l
  }, d), n);
});
Ag.displayName = "@mantine/core/InputDescription";
const IC = Br({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0
}), N4 = IC.Provider, I4 = () => ar(IC);
function M4(e, { hasDescription: t, hasError: r }) {
  const n = e.findIndex((c) => c === "input"), o = e[n - 1], a = e[n + 1];
  return { offsetBottom: t && a === "description" || r && a === "error", offsetTop: t && o === "description" || r && o === "error" };
}
var A4 = Object.defineProperty, j4 = Object.defineProperties, F4 = Object.getOwnPropertyDescriptors, a_ = Object.getOwnPropertySymbols, L4 = Object.prototype.hasOwnProperty, V4 = Object.prototype.propertyIsEnumerable, i_ = (e, t, r) => t in e ? A4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, z4 = (e, t) => {
  for (var r in t || (t = {}))
    L4.call(t, r) && i_(e, r, t[r]);
  if (a_)
    for (var r of a_(t))
      V4.call(t, r) && i_(e, r, t[r]);
  return e;
}, B4 = (e, t) => j4(e, F4(t)), W4 = Qe((e) => ({
  root: B4(z4({}, e.fn.fontStyles()), {
    lineHeight: e.lineHeight
  })
}));
const U4 = W4;
var H4 = Object.defineProperty, Y4 = Object.defineProperties, q4 = Object.getOwnPropertyDescriptors, od = Object.getOwnPropertySymbols, MC = Object.prototype.hasOwnProperty, AC = Object.prototype.propertyIsEnumerable, s_ = (e, t, r) => t in e ? H4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ro = (e, t) => {
  for (var r in t || (t = {}))
    MC.call(t, r) && s_(e, r, t[r]);
  if (od)
    for (var r of od(t))
      AC.call(t, r) && s_(e, r, t[r]);
  return e;
}, l_ = (e, t) => Y4(e, q4(t)), G4 = (e, t) => {
  var r = {};
  for (var n in e)
    MC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && od)
    for (var n of od(e))
      t.indexOf(n) < 0 && AC.call(e, n) && (r[n] = e[n]);
  return r;
};
const K4 = {
  labelElement: "label",
  size: "sm",
  inputContainer: (e) => e,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, jC = Ne((e, t) => {
  const r = Xe("InputWrapper", K4, e), {
    className: n,
    label: o,
    children: a,
    required: i,
    id: l,
    error: c,
    description: u,
    labelElement: d,
    labelProps: f,
    descriptionProps: p,
    errorProps: m,
    classNames: y,
    styles: h,
    size: v,
    inputContainer: g,
    __staticSelector: b,
    unstyled: x,
    inputWrapperOrder: O,
    withAsterisk: w
  } = r, S = G4(r, [
    "className",
    "label",
    "children",
    "required",
    "id",
    "error",
    "description",
    "labelElement",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "classNames",
    "styles",
    "size",
    "inputContainer",
    "__staticSelector",
    "unstyled",
    "inputWrapperOrder",
    "withAsterisk"
  ]), { classes: E, cx: C } = U4(null, {
    classNames: y,
    styles: h,
    name: ["InputWrapper", b],
    unstyled: x
  }), N = {
    classNames: y,
    styles: h,
    unstyled: x,
    size: v,
    __staticSelector: b
  }, $ = typeof w == "boolean" ? w : i, j = l ? `${l}-error` : m == null ? void 0 : m.id, A = l ? `${l}-description` : p == null ? void 0 : p.id, R = `${!!c && typeof c != "boolean" ? j : ""} ${u ? A : ""}`, D = R.trim().length > 0 ? R.trim() : void 0, L = o && /* @__PURE__ */ F.createElement(Ig, Ro(Ro({
    key: "label",
    labelElement: d,
    id: l ? `${l}-label` : void 0,
    htmlFor: l,
    required: $
  }, N), f), o), B = u && /* @__PURE__ */ F.createElement(Ag, l_(Ro(Ro({
    key: "description"
  }, p), N), {
    size: (p == null ? void 0 : p.size) || N.size,
    id: (p == null ? void 0 : p.id) || A
  }), u), H = /* @__PURE__ */ F.createElement(Yi, {
    key: "input"
  }, g(a)), U = typeof c != "boolean" && c && /* @__PURE__ */ F.createElement(Mg, l_(Ro(Ro({}, m), N), {
    size: (m == null ? void 0 : m.size) || N.size,
    key: "error",
    id: (m == null ? void 0 : m.id) || j
  }), c), I = O.map((V) => {
    switch (V) {
      case "label":
        return L;
      case "input":
        return H;
      case "description":
        return B;
      case "error":
        return U;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ F.createElement(N4, {
    value: Ro({
      describedBy: D
    }, M4(O, {
      hasDescription: !!B,
      hasError: !!U
    }))
  }, /* @__PURE__ */ F.createElement(Ke, Ro({
    className: C(E.root, n),
    ref: t
  }, S), I));
});
jC.displayName = "@mantine/core/InputWrapper";
var X4 = Object.defineProperty, ad = Object.getOwnPropertySymbols, FC = Object.prototype.hasOwnProperty, LC = Object.prototype.propertyIsEnumerable, c_ = (e, t, r) => t in e ? X4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Q4 = (e, t) => {
  for (var r in t || (t = {}))
    FC.call(t, r) && c_(e, r, t[r]);
  if (ad)
    for (var r of ad(t))
      LC.call(t, r) && c_(e, r, t[r]);
  return e;
}, Z4 = (e, t) => {
  var r = {};
  for (var n in e)
    FC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && ad)
    for (var n of ad(e))
      t.indexOf(n) < 0 && LC.call(e, n) && (r[n] = e[n]);
  return r;
};
const J4 = {}, VC = Ne((e, t) => {
  const r = Xe("InputPlaceholder", J4, e), { sx: n } = r, o = Z4(r, ["sx"]);
  return /* @__PURE__ */ F.createElement(Ke, Q4({
    component: "span",
    sx: [(a) => a.fn.placeholderStyles(), ...nl(n)],
    ref: t
  }, o));
});
VC.displayName = "@mantine/core/InputPlaceholder";
var e3 = Object.defineProperty, t3 = Object.defineProperties, r3 = Object.getOwnPropertyDescriptors, u_ = Object.getOwnPropertySymbols, n3 = Object.prototype.hasOwnProperty, o3 = Object.prototype.propertyIsEnumerable, d_ = (e, t, r) => t in e ? e3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Zl = (e, t) => {
  for (var r in t || (t = {}))
    n3.call(t, r) && d_(e, r, t[r]);
  if (u_)
    for (var r of u_(t))
      o3.call(t, r) && d_(e, r, t[r]);
  return e;
}, Im = (e, t) => t3(e, r3(t));
const Sr = {
  xs: 30,
  sm: 36,
  md: 42,
  lg: 50,
  xl: 60
};
function a3({ theme: e, variant: t }) {
  return t === "default" ? {
    border: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4]}`,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
    transition: "border-color 100ms ease",
    "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
  } : t === "filled" ? {
    border: "1px solid transparent",
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1],
    "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
  } : {
    borderWidth: 0,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    backgroundColor: "transparent",
    minHeight: 28,
    outline: 0,
    "&:focus, &:focus-within": {
      outline: "none",
      borderColor: "transparent"
    },
    "&:disabled": {
      backgroundColor: "transparent",
      "&:focus, &:focus-within": {
        outline: "none",
        borderColor: "transparent"
      }
    }
  };
}
var i3 = Qe((e, {
  size: t,
  multiline: r,
  radius: n,
  variant: o,
  invalid: a,
  rightSectionWidth: i,
  withRightSection: l,
  iconWidth: c,
  offsetBottom: u,
  offsetTop: d,
  pointer: f
}) => {
  const p = e.fn.variant({ variant: "filled", color: "red" }).background, m = o === "default" || o === "filled" ? {
    minHeight: e.fn.size({ size: t, sizes: Sr }),
    paddingLeft: e.fn.size({ size: t, sizes: Sr }) / 3,
    paddingRight: l ? i : e.fn.size({ size: t, sizes: Sr }) / 3,
    borderRadius: e.fn.radius(n)
  } : null;
  return {
    wrapper: {
      position: "relative",
      marginTop: d ? `calc(${e.spacing.xs}px / 2)` : void 0,
      marginBottom: u ? `calc(${e.spacing.xs}px / 2)` : void 0
    },
    input: Zl(Im(Zl(Im(Zl({}, e.fn.fontStyles()), {
      height: r ? o === "unstyled" ? void 0 : "auto" : e.fn.size({ size: t, sizes: Sr }),
      WebkitTapHighlightColor: "transparent",
      lineHeight: r ? e.lineHeight : `${e.fn.size({ size: t, sizes: Sr }) - 2}px`,
      appearance: "none",
      resize: "none",
      boxSizing: "border-box",
      fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
      width: "100%",
      color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
      display: "block",
      textAlign: "left",
      cursor: f ? "pointer" : void 0
    }), m), {
      "&:disabled": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[1],
        color: e.colors.dark[2],
        opacity: 0.6,
        cursor: "not-allowed",
        "&::placeholder": {
          color: e.colors.dark[2]
        }
      },
      "&::placeholder": Im(Zl({}, e.fn.placeholderStyles()), {
        opacity: 1
      }),
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration": {
        appearance: "none"
      },
      "&[type=number]": {
        MozAppearance: "textfield"
      }
    }), a3({ theme: e, variant: o })),
    withIcon: {
      paddingLeft: typeof c == "number" ? c : e.fn.size({ size: t, sizes: Sr })
    },
    invalid: {
      color: p,
      borderColor: p,
      "&::placeholder": {
        opacity: 1,
        color: p
      }
    },
    disabled: {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[1],
      color: e.colors.dark[2],
      opacity: 0.6,
      cursor: "not-allowed",
      "&::placeholder": {
        color: e.colors.dark[2]
      }
    },
    icon: {
      pointerEvents: "none",
      position: "absolute",
      zIndex: 1,
      left: 0,
      top: 0,
      bottom: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: typeof c == "number" ? c : e.fn.size({ size: t, sizes: Sr }),
      color: a ? e.colors.red[e.colorScheme === "dark" ? 6 : 7] : e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[5]
    },
    rightSection: {
      position: "absolute",
      top: 0,
      bottom: 0,
      right: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: i
    }
  };
});
const s3 = i3;
var l3 = Object.defineProperty, c3 = Object.defineProperties, u3 = Object.getOwnPropertyDescriptors, id = Object.getOwnPropertySymbols, zC = Object.prototype.hasOwnProperty, BC = Object.prototype.propertyIsEnumerable, f_ = (e, t, r) => t in e ? l3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Jl = (e, t) => {
  for (var r in t || (t = {}))
    zC.call(t, r) && f_(e, r, t[r]);
  if (id)
    for (var r of id(t))
      BC.call(t, r) && f_(e, r, t[r]);
  return e;
}, p_ = (e, t) => c3(e, u3(t)), d3 = (e, t) => {
  var r = {};
  for (var n in e)
    zC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && id)
    for (var n of id(e))
      t.indexOf(n) < 0 && BC.call(e, n) && (r[n] = e[n]);
  return r;
};
const f3 = {
  rightSectionWidth: 36,
  size: "sm",
  variant: "default"
}, za = Ne((e, t) => {
  const r = Xe("Input", f3, e), {
    className: n,
    invalid: o,
    required: a,
    disabled: i,
    variant: l,
    icon: c,
    style: u,
    rightSectionWidth: d,
    iconWidth: f,
    rightSection: p,
    rightSectionProps: m,
    radius: y,
    size: h,
    wrapperProps: v,
    classNames: g,
    styles: b,
    __staticSelector: x,
    multiline: O,
    sx: w,
    unstyled: S,
    pointer: E
  } = r, C = d3(r, [
    "className",
    "invalid",
    "required",
    "disabled",
    "variant",
    "icon",
    "style",
    "rightSectionWidth",
    "iconWidth",
    "rightSection",
    "rightSectionProps",
    "radius",
    "size",
    "wrapperProps",
    "classNames",
    "styles",
    "__staticSelector",
    "multiline",
    "sx",
    "unstyled",
    "pointer"
  ]), { offsetBottom: N, offsetTop: $, describedBy: j } = I4(), { classes: A, cx: k } = s3({
    radius: y,
    size: h,
    multiline: O,
    variant: l,
    invalid: o,
    rightSectionWidth: d,
    iconWidth: f,
    withRightSection: !!p,
    offsetBottom: N,
    offsetTop: $,
    pointer: E
  }, { classNames: g, styles: b, name: ["Input", x], unstyled: S }), { systemStyles: R, rest: D } = Xi(C);
  return /* @__PURE__ */ F.createElement(Ke, Jl(Jl({
    className: k(A.wrapper, n),
    sx: w,
    style: u
  }, R), v), c && /* @__PURE__ */ F.createElement("div", {
    className: A.icon
  }, c), /* @__PURE__ */ F.createElement(Ke, p_(Jl({
    component: "input"
  }, D), {
    ref: t,
    required: a,
    "aria-invalid": o,
    "aria-describedby": j,
    disabled: i,
    className: k(A[`${l}Variant`], A.input, {
      [A.withIcon]: c,
      [A.invalid]: o,
      [A.disabled]: i
    })
  })), p && /* @__PURE__ */ F.createElement("div", p_(Jl({}, m), {
    className: A.rightSection
  }), p));
});
za.displayName = "@mantine/core/Input";
za.Wrapper = jC;
za.Label = Ig;
za.Description = Ag;
za.Error = Mg;
za.Placeholder = VC;
const Xn = za;
var p3 = Qe((e, { orientation: t, buttonBorderWidth: r }) => ({
  root: {
    display: "flex",
    flexDirection: t === "vertical" ? "column" : "row",
    "& [data-button]": {
      "&:first-of-type": {
        borderBottomRightRadius: 0,
        [t === "vertical" ? "borderBottomLeftRadius" : "borderTopRightRadius"]: 0,
        [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: r / 2
      },
      "&:last-of-type": {
        borderTopLeftRadius: 0,
        [t === "vertical" ? "borderTopRightRadius" : "borderBottomLeftRadius"]: 0,
        [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: r / 2
      },
      "&:not(:first-of-type):not(:last-of-type)": {
        borderRadius: 0,
        [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: r / 2,
        [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: r / 2
      },
      "& + [data-button]": {
        [t === "vertical" ? "marginTop" : "marginLeft"]: -r,
        "@media (min-resolution: 192dpi)": {
          [t === "vertical" ? "marginTop" : "marginLeft"]: 0
        }
      }
    }
  }
}));
const m3 = p3;
var h3 = Object.defineProperty, sd = Object.getOwnPropertySymbols, WC = Object.prototype.hasOwnProperty, UC = Object.prototype.propertyIsEnumerable, m_ = (e, t, r) => t in e ? h3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, y3 = (e, t) => {
  for (var r in t || (t = {}))
    WC.call(t, r) && m_(e, r, t[r]);
  if (sd)
    for (var r of sd(t))
      UC.call(t, r) && m_(e, r, t[r]);
  return e;
}, v3 = (e, t) => {
  var r = {};
  for (var n in e)
    WC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && sd)
    for (var n of sd(e))
      t.indexOf(n) < 0 && UC.call(e, n) && (r[n] = e[n]);
  return r;
};
const g3 = {
  orientation: "horizontal",
  buttonBorderWidth: 1
}, HC = Ne((e, t) => {
  const r = Xe("ButtonGroup", g3, e), { className: n, orientation: o, buttonBorderWidth: a, unstyled: i } = r, l = v3(r, ["className", "orientation", "buttonBorderWidth", "unstyled"]), { classes: c, cx: u } = m3({ orientation: o, buttonBorderWidth: a }, { name: "ButtonGroup", unstyled: i });
  return /* @__PURE__ */ F.createElement(Ke, y3({
    className: u(c.root, n),
    ref: t
  }, l));
});
HC.displayName = "@mantine/core/ButtonGroup";
var b3 = Object.defineProperty, w3 = Object.defineProperties, x3 = Object.getOwnPropertyDescriptors, h_ = Object.getOwnPropertySymbols, _3 = Object.prototype.hasOwnProperty, O3 = Object.prototype.propertyIsEnumerable, y_ = (e, t, r) => t in e ? b3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ga = (e, t) => {
  for (var r in t || (t = {}))
    _3.call(t, r) && y_(e, r, t[r]);
  if (h_)
    for (var r of h_(t))
      O3.call(t, r) && y_(e, r, t[r]);
  return e;
}, ty = (e, t) => w3(e, x3(t));
const ry = {
  xs: { height: Sr.xs, paddingLeft: 14, paddingRight: 14 },
  sm: { height: Sr.sm, paddingLeft: 18, paddingRight: 18 },
  md: { height: Sr.md, paddingLeft: 22, paddingRight: 22 },
  lg: { height: Sr.lg, paddingLeft: 26, paddingRight: 26 },
  xl: { height: Sr.xl, paddingLeft: 32, paddingRight: 32 },
  "compact-xs": { height: 22, paddingLeft: 7, paddingRight: 7 },
  "compact-sm": { height: 26, paddingLeft: 8, paddingRight: 8 },
  "compact-md": { height: 30, paddingLeft: 10, paddingRight: 10 },
  "compact-lg": { height: 34, paddingLeft: 12, paddingRight: 12 },
  "compact-xl": { height: 40, paddingLeft: 14, paddingRight: 14 }
};
function P3({ compact: e, size: t, withLeftIcon: r, withRightIcon: n }) {
  if (e)
    return ry[`compact-${t}`];
  const o = ry[t];
  return ty(ga({}, o), {
    paddingLeft: r ? o.paddingLeft / 1.5 : o.paddingLeft,
    paddingRight: n ? o.paddingRight / 1.5 : o.paddingRight
  });
}
const S3 = (e) => ({
  display: e ? "block" : "inline-block",
  width: e ? "100%" : "auto"
});
function T3({ variant: e, theme: t, color: r, gradient: n }) {
  const o = t.fn.variant({ color: r, variant: e, gradient: n });
  return e === "gradient" ? {
    border: 0,
    backgroundImage: o.background,
    color: o.color,
    "&:hover": t.fn.hover({
      backgroundSize: "200%"
    })
  } : ga({
    border: `1px solid ${o.border}`,
    backgroundColor: o.background,
    color: o.color
  }, t.fn.hover({
    backgroundColor: o.hover
  }));
}
var E3 = Qe((e, {
  color: t,
  size: r,
  radius: n,
  fullWidth: o,
  compact: a,
  gradient: i,
  variant: l,
  withLeftIcon: c,
  withRightIcon: u
}) => ({
  root: ty(ga(ty(ga(ga(ga(ga({}, P3({ compact: a, size: r, withLeftIcon: c, withRightIcon: u })), e.fn.fontStyles()), e.fn.focusStyles()), S3(o)), {
    borderRadius: e.fn.radius(n),
    fontWeight: 600,
    position: "relative",
    lineHeight: 1,
    fontSize: e.fn.size({ size: r, sizes: e.fontSizes }),
    userSelect: "none",
    cursor: "pointer"
  }), T3({ variant: l, theme: e, color: t, gradient: i })), {
    "&:active": e.activeStyles,
    "&:disabled, &[data-disabled]": {
      borderColor: "transparent",
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
      color: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[5],
      cursor: "not-allowed",
      backgroundImage: "none",
      pointerEvents: "none",
      "&:active": {
        transform: "none"
      }
    },
    "&[data-loading]": {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        top: -1,
        left: -1,
        right: -1,
        bottom: -1,
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], 0.5) : "rgba(255, 255, 255, .5)",
        borderRadius: e.fn.radius(n),
        cursor: "not-allowed"
      }
    }
  }),
  icon: {
    display: "flex",
    alignItems: "center"
  },
  leftIcon: {
    marginRight: 10
  },
  rightIcon: {
    marginLeft: 10
  },
  centerLoader: {
    position: "absolute",
    left: "50%",
    transform: "translateX(-50%)",
    opacity: 0.5
  },
  inner: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "100%",
    overflow: "visible"
  },
  label: {
    whiteSpace: "nowrap",
    height: "100%",
    overflow: "hidden",
    display: "flex",
    alignItems: "center"
  }
}));
const $3 = E3;
var C3 = Object.defineProperty, ld = Object.getOwnPropertySymbols, YC = Object.prototype.hasOwnProperty, qC = Object.prototype.propertyIsEnumerable, v_ = (e, t, r) => t in e ? C3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, g_ = (e, t) => {
  for (var r in t || (t = {}))
    YC.call(t, r) && v_(e, r, t[r]);
  if (ld)
    for (var r of ld(t))
      qC.call(t, r) && v_(e, r, t[r]);
  return e;
}, k3 = (e, t) => {
  var r = {};
  for (var n in e)
    YC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && ld)
    for (var n of ld(e))
      t.indexOf(n) < 0 && qC.call(e, n) && (r[n] = e[n]);
  return r;
};
const R3 = {
  size: "sm",
  type: "button",
  variant: "filled",
  loaderPosition: "left"
}, jg = Ne((e, t) => {
  const r = Xe("Button", R3, e), {
    className: n,
    size: o,
    color: a,
    type: i,
    disabled: l,
    children: c,
    leftIcon: u,
    rightIcon: d,
    fullWidth: f,
    variant: p,
    radius: m,
    uppercase: y,
    compact: h,
    loading: v,
    loaderPosition: g,
    loaderProps: b,
    gradient: x,
    classNames: O,
    styles: w,
    unstyled: S
  } = r, E = k3(r, [
    "className",
    "size",
    "color",
    "type",
    "disabled",
    "children",
    "leftIcon",
    "rightIcon",
    "fullWidth",
    "variant",
    "radius",
    "uppercase",
    "compact",
    "loading",
    "loaderPosition",
    "loaderProps",
    "gradient",
    "classNames",
    "styles",
    "unstyled"
  ]), { classes: C, cx: N, theme: $ } = $3({
    radius: m,
    color: a,
    size: o,
    fullWidth: f,
    compact: h,
    gradient: x,
    variant: p,
    withLeftIcon: !!u,
    withRightIcon: !!d
  }, { name: "Button", unstyled: S, classNames: O, styles: w }), j = $.fn.variant({ color: a, variant: p }), A = /* @__PURE__ */ F.createElement(Pp, g_({
    color: j.color,
    size: $.fn.size({ size: o, sizes: ry }).height / 2
  }, b));
  return /* @__PURE__ */ F.createElement(Op, g_({
    className: N(C.root, n),
    type: i,
    disabled: l,
    "data-button": !0,
    "data-disabled": l || void 0,
    "data-loading": v || void 0,
    ref: t,
    unstyled: S
  }, E), /* @__PURE__ */ F.createElement("div", {
    className: C.inner
  }, (u || v && g === "left") && /* @__PURE__ */ F.createElement("span", {
    className: N(C.icon, C.leftIcon)
  }, v && g === "left" ? A : u), v && g === "center" && /* @__PURE__ */ F.createElement("span", {
    className: C.centerLoader
  }, A), /* @__PURE__ */ F.createElement("span", {
    className: C.label,
    style: { textTransform: y ? "uppercase" : void 0 }
  }, c), (d || v && g === "right") && /* @__PURE__ */ F.createElement("span", {
    className: N(C.icon, C.rightIcon)
  }, v && g === "right" ? A : d)));
});
jg.displayName = "@mantine/core/Button";
jg.Group = HC;
const ji = jg;
var D3 = Qe((e, { radius: t, shadow: r, withBorder: n }) => ({
  root: {
    outline: 0,
    WebkitTapHighlightColor: "transparent",
    display: "block",
    textDecoration: "none",
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
    boxSizing: "border-box",
    borderRadius: e.fn.radius(t),
    boxShadow: e.shadows[r] || r || "none",
    border: n ? `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}` : void 0
  }
}));
const N3 = D3;
var I3 = Object.defineProperty, cd = Object.getOwnPropertySymbols, GC = Object.prototype.hasOwnProperty, KC = Object.prototype.propertyIsEnumerable, b_ = (e, t, r) => t in e ? I3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, M3 = (e, t) => {
  for (var r in t || (t = {}))
    GC.call(t, r) && b_(e, r, t[r]);
  if (cd)
    for (var r of cd(t))
      KC.call(t, r) && b_(e, r, t[r]);
  return e;
}, A3 = (e, t) => {
  var r = {};
  for (var n in e)
    GC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && cd)
    for (var n of cd(e))
      t.indexOf(n) < 0 && KC.call(e, n) && (r[n] = e[n]);
  return r;
};
const j3 = {}, XC = Ne((e, t) => {
  const r = Xe("Paper", j3, e), { className: n, children: o, radius: a, withBorder: i, shadow: l, unstyled: c } = r, u = A3(r, ["className", "children", "radius", "withBorder", "shadow", "unstyled"]), { classes: d, cx: f } = N3({ radius: a, shadow: l, withBorder: i }, { name: "Paper", unstyled: c });
  return /* @__PURE__ */ F.createElement(Ke, M3({
    className: f(d.root, n),
    ref: t
  }, u), o);
});
XC.displayName = "@mantine/core/Paper";
const ud = XC, QC = Br(null), F3 = QC.Provider, L3 = () => ar(QC);
function V3(e) {
  return Bo.toArray(e).filter(Boolean);
}
const ZC = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  apart: "space-between"
};
var z3 = Qe((e, { spacing: t, position: r, noWrap: n, grow: o, align: a, count: i }) => ({
  root: {
    boxSizing: "border-box",
    display: "flex",
    flexDirection: "row",
    alignItems: a || "center",
    flexWrap: n ? "nowrap" : "wrap",
    justifyContent: ZC[r],
    gap: e.fn.size({ size: t, sizes: e.spacing }),
    "& > *": {
      boxSizing: "border-box",
      maxWidth: o ? `calc(${100 / i}% - ${e.fn.size({ size: t, sizes: e.spacing }) - e.fn.size({ size: t, sizes: e.spacing }) / i}px)` : void 0,
      flexGrow: o ? 1 : 0
    }
  }
}));
const B3 = z3;
var W3 = Object.defineProperty, dd = Object.getOwnPropertySymbols, JC = Object.prototype.hasOwnProperty, ek = Object.prototype.propertyIsEnumerable, w_ = (e, t, r) => t in e ? W3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, U3 = (e, t) => {
  for (var r in t || (t = {}))
    JC.call(t, r) && w_(e, r, t[r]);
  if (dd)
    for (var r of dd(t))
      ek.call(t, r) && w_(e, r, t[r]);
  return e;
}, H3 = (e, t) => {
  var r = {};
  for (var n in e)
    JC.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && dd)
    for (var n of dd(e))
      t.indexOf(n) < 0 && ek.call(e, n) && (r[n] = e[n]);
  return r;
};
const Y3 = {
  position: "left",
  spacing: "md"
}, Rn = Ne((e, t) => {
  const r = Xe("Group", Y3, e), { className: n, position: o, align: a, children: i, noWrap: l, grow: c, spacing: u, unstyled: d } = r, f = H3(r, ["className", "position", "align", "children", "noWrap", "grow", "spacing", "unstyled"]), p = V3(i), { classes: m, cx: y } = B3({
    align: a,
    grow: c,
    noWrap: l,
    spacing: u,
    position: o,
    count: p.length
  }, { unstyled: d, name: "Group" });
  return /* @__PURE__ */ F.createElement(Ke, U3({
    className: y(m.root, n),
    ref: t
  }, f), p);
});
Rn.displayName = "@mantine/core/Group";
var q3 = Qe((e, { spacing: t, align: r, justify: n }) => ({
  root: {
    display: "flex",
    flexDirection: "column",
    alignItems: r,
    justifyContent: n,
    gap: e.fn.size({ size: t, sizes: e.spacing })
  }
}));
const G3 = q3;
var K3 = Object.defineProperty, fd = Object.getOwnPropertySymbols, tk = Object.prototype.hasOwnProperty, rk = Object.prototype.propertyIsEnumerable, x_ = (e, t, r) => t in e ? K3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, X3 = (e, t) => {
  for (var r in t || (t = {}))
    tk.call(t, r) && x_(e, r, t[r]);
  if (fd)
    for (var r of fd(t))
      rk.call(t, r) && x_(e, r, t[r]);
  return e;
}, Q3 = (e, t) => {
  var r = {};
  for (var n in e)
    tk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && fd)
    for (var n of fd(e))
      t.indexOf(n) < 0 && rk.call(e, n) && (r[n] = e[n]);
  return r;
};
const Z3 = {
  spacing: "md",
  align: "stretch",
  justify: "flex-start"
}, El = Ne((e, t) => {
  const r = Xe("Stack", Z3, e), { spacing: n, className: o, align: a, justify: i, unstyled: l } = r, c = Q3(r, ["spacing", "className", "align", "justify", "unstyled"]), { classes: u, cx: d } = G3({ spacing: n, align: a, justify: i }, { name: "Stack", unstyled: l });
  return /* @__PURE__ */ F.createElement(Ke, X3({
    className: d(u.root, o),
    ref: t
  }, c));
});
El.displayName = "@mantine/core/Stack";
function nk({
  spacing: e,
  offset: t,
  orientation: r,
  children: n,
  role: o,
  unstyled: a
}) {
  return r === "horizontal" ? /* @__PURE__ */ F.createElement(Rn, {
    pt: t,
    spacing: e,
    role: o,
    unstyled: a
  }, n) : /* @__PURE__ */ F.createElement(El, {
    pt: t,
    spacing: e,
    role: o,
    unstyled: a
  }, n);
}
var J3 = Object.defineProperty, pd = Object.getOwnPropertySymbols, ok = Object.prototype.hasOwnProperty, ak = Object.prototype.propertyIsEnumerable, __ = (e, t, r) => t in e ? J3(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, O_ = (e, t) => {
  for (var r in t || (t = {}))
    ok.call(t, r) && __(e, r, t[r]);
  if (pd)
    for (var r of pd(t))
      ak.call(t, r) && __(e, r, t[r]);
  return e;
}, eU = (e, t) => {
  var r = {};
  for (var n in e)
    ok.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && pd)
    for (var n of pd(e))
      t.indexOf(n) < 0 && ak.call(e, n) && (r[n] = e[n]);
  return r;
};
const tU = {
  orientation: "horizontal",
  spacing: "lg",
  size: "sm",
  offset: "xs"
}, ik = Ne((e, t) => {
  const r = Xe("CheckboxGroup", tU, e), {
    children: n,
    value: o,
    defaultValue: a,
    onChange: i,
    orientation: l,
    spacing: c,
    size: u,
    wrapperProps: d,
    offset: f
  } = r, p = eU(r, [
    "children",
    "value",
    "defaultValue",
    "onChange",
    "orientation",
    "spacing",
    "size",
    "wrapperProps",
    "offset"
  ]), [m, y] = Kn({
    value: o,
    defaultValue: a,
    finalValue: [],
    onChange: i
  }), h = (v) => {
    const g = v.currentTarget.value;
    y(m.includes(g) ? m.filter((b) => b !== g) : [...m, g]);
  };
  return /* @__PURE__ */ F.createElement(F3, {
    value: { value: m, onChange: h, size: u }
  }, /* @__PURE__ */ F.createElement(Xn.Wrapper, O_(O_({
    labelElement: "div",
    size: u,
    __staticSelector: "CheckboxGroup",
    ref: t
  }, d), p), /* @__PURE__ */ F.createElement(nk, {
    spacing: c,
    orientation: l,
    offset: f
  }, n)));
});
ik.displayName = "@mantine/core/CheckboxGroup";
var rU = Object.defineProperty, md = Object.getOwnPropertySymbols, sk = Object.prototype.hasOwnProperty, lk = Object.prototype.propertyIsEnumerable, P_ = (e, t, r) => t in e ? rU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ny = (e, t) => {
  for (var r in t || (t = {}))
    sk.call(t, r) && P_(e, r, t[r]);
  if (md)
    for (var r of md(t))
      lk.call(t, r) && P_(e, r, t[r]);
  return e;
}, nU = (e, t) => {
  var r = {};
  for (var n in e)
    sk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && md)
    for (var n of md(e))
      t.indexOf(n) < 0 && lk.call(e, n) && (r[n] = e[n]);
  return r;
};
function oU(e) {
  return /* @__PURE__ */ F.createElement("svg", ny({
    viewBox: "0 0 10 7",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e), /* @__PURE__ */ F.createElement("path", {
    d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function aU(e) {
  var t = e, { indeterminate: r } = t, n = nU(t, ["indeterminate"]);
  return r ? /* @__PURE__ */ F.createElement("svg", ny({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 32 6"
  }, n), /* @__PURE__ */ F.createElement("rect", {
    width: "32",
    height: "6",
    fill: "currentColor",
    rx: "3"
  })) : /* @__PURE__ */ F.createElement(oU, ny({}, n));
}
var iU = Object.defineProperty, sU = Object.defineProperties, lU = Object.getOwnPropertyDescriptors, S_ = Object.getOwnPropertySymbols, cU = Object.prototype.hasOwnProperty, uU = Object.prototype.propertyIsEnumerable, T_ = (e, t, r) => t in e ? iU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, dU = (e, t) => {
  for (var r in t || (t = {}))
    cU.call(t, r) && T_(e, r, t[r]);
  if (S_)
    for (var r of S_(t))
      uU.call(t, r) && T_(e, r, t[r]);
  return e;
}, fU = (e, t) => sU(e, lU(t));
const pU = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
}, mU = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 16,
  xl: 20
};
var hU = Qe((e, {
  size: t,
  radius: r,
  color: n,
  transitionDuration: o,
  labelPosition: a,
  error: i,
  indeterminate: l
}, c) => {
  const u = e.fn.size({ size: t, sizes: pU }), d = e.fn.variant({ variant: "filled", color: n }), f = e.fn.variant({ variant: "filled", color: "red" }).background;
  return {
    icon: {
      ref: c("icon"),
      color: l ? "inherit" : e.white,
      transform: l ? "none" : "translateY(5px) scale(0.5)",
      opacity: l ? 1 : 0,
      transitionProperty: "opacity, transform",
      transitionTimingFunction: "ease",
      transitionDuration: `${o}ms`,
      pointerEvents: "none",
      width: e.fn.size({ size: t, sizes: mU }),
      position: "absolute",
      zIndex: 1,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      margin: "auto",
      "@media (prefers-reduced-motion)": {
        transitionDuration: e.respectReducedMotion ? "0ms" : void 0
      }
    },
    inner: {
      position: "relative",
      width: u,
      height: u,
      order: a === "left" ? 2 : 1
    },
    input: fU(dU({}, e.fn.focusStyles()), {
      appearance: "none",
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
      border: `1px solid ${i ? f : e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4]}`,
      width: u,
      height: u,
      borderRadius: e.fn.radius(r),
      padding: 0,
      display: "block",
      margin: 0,
      transition: `border-color ${o}ms ease, background-color ${o}ms ease`,
      cursor: e.cursorType,
      "&:checked": {
        backgroundColor: d.background,
        borderColor: d.background,
        [`& + .${c("icon")}`]: {
          opacity: 1,
          color: e.white,
          transform: "translateY(0) scale(1)"
        }
      },
      "&:disabled": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        borderColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[3],
        cursor: "not-allowed",
        [`& + .${c("icon")}`]: {
          color: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[5]
        }
      }
    })
  };
});
const yU = hU;
var vU = Object.defineProperty, gU = Object.defineProperties, bU = Object.getOwnPropertyDescriptors, E_ = Object.getOwnPropertySymbols, wU = Object.prototype.hasOwnProperty, xU = Object.prototype.propertyIsEnumerable, $_ = (e, t, r) => t in e ? vU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, _U = (e, t) => {
  for (var r in t || (t = {}))
    wU.call(t, r) && $_(e, r, t[r]);
  if (E_)
    for (var r of E_(t))
      xU.call(t, r) && $_(e, r, t[r]);
  return e;
}, OU = (e, t) => gU(e, bU(t));
const PU = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
};
var SU = Qe((e, { labelPosition: t, size: r }) => ({
  root: {},
  body: {
    display: "flex"
  },
  labelWrapper: OU(_U({}, e.fn.fontStyles()), {
    display: "inline-flex",
    flexDirection: "column",
    WebkitTapHighlightColor: "transparent",
    fontSize: e.fn.size({ size: r, sizes: e.fontSizes }),
    lineHeight: `${e.fn.size({ size: r, sizes: PU })}px`,
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    cursor: e.cursorType,
    order: t === "left" ? 1 : 2
  }),
  description: {
    marginTop: `calc(${e.spacing.xs}px / 2)`,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
  },
  error: {
    marginTop: `calc(${e.spacing.xs}px / 2)`,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
  },
  label: {
    cursor: e.cursorType,
    [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm,
    "&[data-disabled]": {
      color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
    }
  }
}));
const TU = SU;
var EU = Object.defineProperty, hd = Object.getOwnPropertySymbols, ck = Object.prototype.hasOwnProperty, uk = Object.prototype.propertyIsEnumerable, C_ = (e, t, r) => t in e ? EU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, $U = (e, t) => {
  for (var r in t || (t = {}))
    ck.call(t, r) && C_(e, r, t[r]);
  if (hd)
    for (var r of hd(t))
      uk.call(t, r) && C_(e, r, t[r]);
  return e;
}, CU = (e, t) => {
  var r = {};
  for (var n in e)
    ck.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && hd)
    for (var n of hd(e))
      t.indexOf(n) < 0 && uk.call(e, n) && (r[n] = e[n]);
  return r;
};
function Fg(e) {
  var t = e, {
    __staticSelector: r,
    className: n,
    classNames: o,
    styles: a,
    unstyled: i,
    children: l,
    label: c,
    description: u,
    id: d,
    disabled: f,
    error: p,
    size: m,
    labelPosition: y
  } = t, h = CU(t, [
    "__staticSelector",
    "className",
    "classNames",
    "styles",
    "unstyled",
    "children",
    "label",
    "description",
    "id",
    "disabled",
    "error",
    "size",
    "labelPosition"
  ]);
  const { classes: v, cx: g } = TU({ size: m, labelPosition: y }, { name: r, styles: a, classNames: o, unstyled: i });
  return /* @__PURE__ */ F.createElement(Ke, $U({
    className: g(v.root, n)
  }, h), /* @__PURE__ */ F.createElement("div", {
    className: g(v.body)
  }, l, /* @__PURE__ */ F.createElement("div", {
    className: v.labelWrapper
  }, c && /* @__PURE__ */ F.createElement("label", {
    className: v.label,
    "data-disabled": f || void 0,
    htmlFor: d
  }, c), u && /* @__PURE__ */ F.createElement(Xn.Description, {
    className: v.description
  }, u), p && p !== "boolean" && /* @__PURE__ */ F.createElement(Xn.Error, {
    className: v.error
  }, p))));
}
Fg.displayName = "@mantine/core/InlineInput";
var kU = Object.defineProperty, yd = Object.getOwnPropertySymbols, dk = Object.prototype.hasOwnProperty, fk = Object.prototype.propertyIsEnumerable, k_ = (e, t, r) => t in e ? kU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ec = (e, t) => {
  for (var r in t || (t = {}))
    dk.call(t, r) && k_(e, r, t[r]);
  if (yd)
    for (var r of yd(t))
      fk.call(t, r) && k_(e, r, t[r]);
  return e;
}, RU = (e, t) => {
  var r = {};
  for (var n in e)
    dk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && yd)
    for (var n of yd(e))
      t.indexOf(n) < 0 && fk.call(e, n) && (r[n] = e[n]);
  return r;
};
const DU = {
  size: "sm",
  transitionDuration: 100,
  icon: aU,
  labelPosition: "right"
}, vd = Ne((e, t) => {
  const r = Xe("Checkbox", DU, e), {
    className: n,
    style: o,
    sx: a,
    checked: i,
    disabled: l,
    color: c,
    label: u,
    indeterminate: d,
    id: f,
    size: p,
    radius: m,
    wrapperProps: y,
    children: h,
    classNames: v,
    styles: g,
    transitionDuration: b,
    icon: x,
    unstyled: O,
    labelPosition: w,
    description: S,
    error: E
  } = r, C = RU(r, [
    "className",
    "style",
    "sx",
    "checked",
    "disabled",
    "color",
    "label",
    "indeterminate",
    "id",
    "size",
    "radius",
    "wrapperProps",
    "children",
    "classNames",
    "styles",
    "transitionDuration",
    "icon",
    "unstyled",
    "labelPosition",
    "description",
    "error"
  ]), N = L3(), $ = Zo(f), { systemStyles: j, rest: A } = Xi(C), { classes: k } = yU({
    size: (N == null ? void 0 : N.size) || p,
    radius: m,
    color: c,
    transitionDuration: b,
    labelPosition: w,
    error: !!E,
    indeterminate: d
  }, { name: "Checkbox", classNames: v, styles: g, unstyled: O }), R = N ? {
    checked: N.value.includes(A.value),
    onChange: N.onChange
  } : {};
  return /* @__PURE__ */ F.createElement(Fg, ec(ec({
    className: n,
    sx: a,
    style: o,
    id: $,
    size: (N == null ? void 0 : N.size) || p,
    labelPosition: w,
    label: u,
    description: S,
    error: E,
    disabled: l,
    __staticSelector: "Checkbox",
    classNames: v,
    styles: g,
    unstyled: O,
    "data-checked": R.checked || void 0
  }, j), y), /* @__PURE__ */ F.createElement("div", {
    className: k.inner
  }, /* @__PURE__ */ F.createElement("input", ec(ec({
    id: $,
    ref: t,
    type: "checkbox",
    className: k.input,
    checked: i,
    disabled: l
  }, A), R)), /* @__PURE__ */ F.createElement(x, {
    indeterminate: d,
    className: k.icon
  })));
});
vd.displayName = "@mantine/core/Checkbox";
vd.Group = ik;
function pk({
  transitions: e,
  duration: t = 250,
  exitDuration: r = t,
  mounted: n,
  children: o,
  timingFunction: a,
  onExit: i,
  onEntered: l,
  onEnter: c,
  onExited: u
}) {
  const { transitionDuration: d, transitionStatus: f, transitionTimingFunction: p } = hC({
    mounted: n,
    duration: t,
    exitDuration: r,
    timingFunction: a,
    onExit: i,
    onEntered: l,
    onEnter: c,
    onExited: u
  });
  if (d === 0)
    return n ? /* @__PURE__ */ F.createElement(F.Fragment, null, o({})) : null;
  if (f === "exited")
    return null;
  const m = Object.keys(e).reduce((y, h) => (y[h] = mC({
    duration: e[h].duration,
    transition: e[h].transition,
    timingFunction: e[h].timingFunction || p,
    state: f
  }), y), {});
  return /* @__PURE__ */ F.createElement(F.Fragment, null, o(m));
}
pk.displayName = "@mantine/core/GroupedTransition";
var NU = Qe((e, { zIndex: t }) => ({
  root: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    zIndex: t
  }
}));
const IU = NU;
var MU = Object.defineProperty, AU = Object.defineProperties, jU = Object.getOwnPropertyDescriptors, gd = Object.getOwnPropertySymbols, mk = Object.prototype.hasOwnProperty, hk = Object.prototype.propertyIsEnumerable, R_ = (e, t, r) => t in e ? MU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Mm = (e, t) => {
  for (var r in t || (t = {}))
    mk.call(t, r) && R_(e, r, t[r]);
  if (gd)
    for (var r of gd(t))
      hk.call(t, r) && R_(e, r, t[r]);
  return e;
}, FU = (e, t) => AU(e, jU(t)), LU = (e, t) => {
  var r = {};
  for (var n in e)
    mk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && gd)
    for (var n of gd(e))
      t.indexOf(n) < 0 && hk.call(e, n) && (r[n] = e[n]);
  return r;
};
const VU = {
  opacity: 0.6,
  color: "#fff",
  zIndex: Oo("modal"),
  radius: 0,
  blur: 0
}, yk = Ne((e, t) => {
  const r = Xe("Overlay", VU, e), { opacity: n, blur: o, color: a, gradient: i, zIndex: l, radius: c, sx: u, unstyled: d, className: f } = r, p = LU(r, ["opacity", "blur", "color", "gradient", "zIndex", "radius", "sx", "unstyled", "className"]), { classes: m, cx: y } = IU({ zIndex: l }, { name: "Overlay", unstyled: d }), h = i ? { backgroundImage: i } : { backgroundColor: a }, v = (g) => /* @__PURE__ */ F.createElement(Ke, Mm({
    ref: t,
    className: y(m.root, f),
    sx: [
      (b) => FU(Mm({}, h), {
        opacity: n,
        borderRadius: b.fn.size({ size: c, sizes: b.radius })
      }),
      ...nl(u)
    ]
  }, g));
  return o ? /* @__PURE__ */ F.createElement(Ke, Mm({
    className: y(m.root, f),
    sx: [{ backdropFilter: `blur(${o}px)` }, ...nl(u)]
  }, p), v()) : v(p);
});
yk.displayName = "@mantine/core/Overlay";
const vk = yk, [zU, BU] = _p("Grid component was not found in tree");
var WU = Object.defineProperty, D_ = Object.getOwnPropertySymbols, UU = Object.prototype.hasOwnProperty, HU = Object.prototype.propertyIsEnumerable, N_ = (e, t, r) => t in e ? WU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, YU = (e, t) => {
  for (var r in t || (t = {}))
    UU.call(t, r) && N_(e, r, t[r]);
  if (D_)
    for (var r of D_(t))
      HU.call(t, r) && N_(e, r, t[r]);
  return e;
};
const Lg = (e, t) => e === "content" ? "auto" : e === "auto" ? "0px" : e ? `${100 / (t / e)}%` : void 0, gk = (e, t, r) => r || e === "auto" || e === "content" ? "unset" : Lg(e, t), bk = (e, t) => {
  if (e)
    return e === "auto" || t ? 1 : 0;
}, wk = (e, t) => e === 0 ? 0 : e ? `${100 / (t / e)}%` : void 0, xk = (e, t) => typeof e < "u" ? t.fn.size({ size: e, sizes: t.spacing }) / 2 : void 0;
function qU({
  sizes: e,
  offsets: t,
  orders: r,
  theme: n,
  columns: o,
  gutters: a,
  grow: i
}) {
  return DE.reduce((l, c) => (l[`@media (min-width: ${n.breakpoints[c]}px)`] = {
    order: r[c],
    flexBasis: Lg(e[c], o),
    padding: xk(a[c], n),
    flexShrink: 0,
    width: e[c] === "content" ? "auto" : void 0,
    maxWidth: gk(e[c], o, i),
    marginLeft: wk(t[c], o),
    flexGrow: bk(e[c], i)
  }, l), {});
}
var GU = Qe((e, {
  gutter: t,
  gutterXs: r,
  gutterSm: n,
  gutterMd: o,
  gutterLg: a,
  gutterXl: i,
  grow: l,
  offset: c,
  offsetXs: u,
  offsetSm: d,
  offsetMd: f,
  offsetLg: p,
  offsetXl: m,
  columns: y,
  span: h,
  xs: v,
  sm: g,
  md: b,
  lg: x,
  xl: O,
  order: w,
  orderXs: S,
  orderSm: E,
  orderMd: C,
  orderLg: N,
  orderXl: $
}) => ({
  col: YU({
    boxSizing: "border-box",
    flexGrow: bk(h, l),
    order: w,
    padding: xk(t, e),
    marginLeft: wk(c, y),
    flexBasis: Lg(h, y),
    flexShrink: 0,
    width: h === "content" ? "auto" : void 0,
    maxWidth: gk(h, y, l)
  }, qU({
    sizes: { xs: v, sm: g, md: b, lg: x, xl: O },
    offsets: { xs: u, sm: d, md: f, lg: p, xl: m },
    orders: { xs: S, sm: E, md: C, lg: N, xl: $ },
    gutters: { xs: r, sm: n, md: o, lg: a, xl: i },
    theme: e,
    columns: y,
    grow: l
  }))
}));
const KU = GU;
var XU = Object.defineProperty, bd = Object.getOwnPropertySymbols, _k = Object.prototype.hasOwnProperty, Ok = Object.prototype.propertyIsEnumerable, I_ = (e, t, r) => t in e ? XU(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, QU = (e, t) => {
  for (var r in t || (t = {}))
    _k.call(t, r) && I_(e, r, t[r]);
  if (bd)
    for (var r of bd(t))
      Ok.call(t, r) && I_(e, r, t[r]);
  return e;
}, ZU = (e, t) => {
  var r = {};
  for (var n in e)
    _k.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && bd)
    for (var n of bd(e))
      t.indexOf(n) < 0 && Ok.call(e, n) && (r[n] = e[n]);
  return r;
};
const JU = {};
function eH(e) {
  return e === "auto" || e === "content" ? !0 : typeof e == "number" && e > 0 && e % 1 === 0;
}
const Pk = Ne((e, t) => {
  const r = Xe("GridCol", JU, e), {
    children: n,
    span: o,
    offset: a,
    offsetXs: i,
    offsetSm: l,
    offsetMd: c,
    offsetLg: u,
    offsetXl: d,
    xs: f,
    sm: p,
    md: m,
    lg: y,
    xl: h,
    order: v,
    orderXs: g,
    orderSm: b,
    orderMd: x,
    orderLg: O,
    orderXl: w,
    className: S,
    id: E,
    unstyled: C
  } = r, N = ZU(r, [
    "children",
    "span",
    "offset",
    "offsetXs",
    "offsetSm",
    "offsetMd",
    "offsetLg",
    "offsetXl",
    "xs",
    "sm",
    "md",
    "lg",
    "xl",
    "order",
    "orderXs",
    "orderSm",
    "orderMd",
    "orderLg",
    "orderXl",
    "className",
    "id",
    "unstyled"
  ]), $ = BU(), j = o || $.columns, { classes: A, cx: k } = KU({
    gutter: $.gutter,
    gutterXs: $.gutterXs,
    gutterSm: $.gutterSm,
    gutterMd: $.gutterMd,
    gutterLg: $.gutterLg,
    gutterXl: $.gutterXl,
    offset: a,
    offsetXs: i,
    offsetSm: l,
    offsetMd: c,
    offsetLg: u,
    offsetXl: d,
    xs: f,
    sm: p,
    md: m,
    lg: y,
    xl: h,
    order: v,
    orderXs: g,
    orderSm: b,
    orderMd: x,
    orderLg: O,
    orderXl: w,
    grow: $.grow,
    columns: $.columns,
    span: j
  }, { unstyled: C, name: "Grid" });
  return !eH(j) || j > $.columns ? null : /* @__PURE__ */ F.createElement(Ke, QU({
    className: k(A.col, S),
    ref: t
  }, N), n);
});
Pk.displayName = "@mantine/core/Col";
var tH = Object.defineProperty, M_ = Object.getOwnPropertySymbols, rH = Object.prototype.hasOwnProperty, nH = Object.prototype.propertyIsEnumerable, A_ = (e, t, r) => t in e ? tH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, oH = (e, t) => {
  for (var r in t || (t = {}))
    rH.call(t, r) && A_(e, r, t[r]);
  if (M_)
    for (var r of M_(t))
      nH.call(t, r) && A_(e, r, t[r]);
  return e;
};
function aH(e, t) {
  return DE.reduce((r, n) => (typeof e[n] < "u" && (r[`@media (min-width: ${t.breakpoints[n]}px)`] = {
    margin: -t.fn.size({ size: e[n], sizes: t.spacing }) / 2
  }), r), {});
}
var iH = Qe((e, { justify: t, align: r, gutter: n, gutterXs: o, gutterSm: a, gutterMd: i, gutterLg: l, gutterXl: c }) => ({
  root: oH({
    margin: -e.fn.size({ size: n, sizes: e.spacing }) / 2,
    display: "flex",
    flexWrap: "wrap",
    justifyContent: t,
    alignItems: r
  }, aH({ xs: o, sm: a, md: i, lg: l, xl: c }, e))
}));
const sH = iH;
var lH = Object.defineProperty, wd = Object.getOwnPropertySymbols, Sk = Object.prototype.hasOwnProperty, Tk = Object.prototype.propertyIsEnumerable, j_ = (e, t, r) => t in e ? lH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, cH = (e, t) => {
  for (var r in t || (t = {}))
    Sk.call(t, r) && j_(e, r, t[r]);
  if (wd)
    for (var r of wd(t))
      Tk.call(t, r) && j_(e, r, t[r]);
  return e;
}, uH = (e, t) => {
  var r = {};
  for (var n in e)
    Sk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && wd)
    for (var n of wd(e))
      t.indexOf(n) < 0 && Tk.call(e, n) && (r[n] = e[n]);
  return r;
};
const dH = {
  gutter: "md",
  justify: "flex-start",
  align: "stretch",
  columns: 12
}, pi = Ne((e, t) => {
  const r = Xe("Grid", dH, e), {
    gutter: n,
    gutterXs: o,
    gutterSm: a,
    gutterMd: i,
    gutterLg: l,
    gutterXl: c,
    children: u,
    grow: d,
    justify: f,
    align: p,
    columns: m,
    className: y,
    id: h,
    unstyled: v
  } = r, g = uH(r, [
    "gutter",
    "gutterXs",
    "gutterSm",
    "gutterMd",
    "gutterLg",
    "gutterXl",
    "children",
    "grow",
    "justify",
    "align",
    "columns",
    "className",
    "id",
    "unstyled"
  ]), { classes: b, cx: x } = sH({ gutter: n, justify: f, align: p, gutterXs: o, gutterSm: a, gutterMd: i, gutterLg: l, gutterXl: c }, { unstyled: v, name: "Grid" });
  return /* @__PURE__ */ F.createElement(zU, {
    value: { gutter: n, gutterXs: o, gutterSm: a, gutterMd: i, gutterLg: l, gutterXl: c, grow: d, columns: m }
  }, /* @__PURE__ */ F.createElement(Ke, cH({
    className: x(b.root, y),
    ref: t
  }, g), u));
});
pi.Col = Pk;
pi.displayName = "@mantine/core/Grid";
function fH({ open: e, close: t, openDelay: r, closeDelay: n }) {
  const o = qe(-1), a = qe(-1), i = () => {
    window.clearTimeout(o.current), window.clearTimeout(a.current);
  }, l = () => {
    i(), r === 0 ? e() : o.current = window.setTimeout(e, r);
  }, c = () => {
    i(), n === 0 ? t() : a.current = window.setTimeout(t, n);
  };
  return Ue(() => i, []), { openDropdown: l, closeDropdown: c };
}
var pH = Object.defineProperty, mH = Object.defineProperties, hH = Object.getOwnPropertyDescriptors, F_ = Object.getOwnPropertySymbols, yH = Object.prototype.hasOwnProperty, vH = Object.prototype.propertyIsEnumerable, L_ = (e, t, r) => t in e ? pH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, V_ = (e, t) => {
  for (var r in t || (t = {}))
    yH.call(t, r) && L_(e, r, t[r]);
  if (F_)
    for (var r of F_(t))
      vH.call(t, r) && L_(e, r, t[r]);
  return e;
}, z_ = (e, t) => mH(e, hH(t));
const gH = (e) => _o({
  from: {
    boxShadow: `0 0 0.5px 0 ${e}`,
    opacity: 0.6
  },
  to: {
    boxShadow: `0 0 0.5px 4.4px ${e}`,
    opacity: 0
  }
});
function B_(e, t = 0) {
  const r = {}, [n, o] = e.split("-");
  let a = "", i = "";
  return n === "top" && (r.top = t, i = "-50%"), n === "middle" && (r.top = "50%", i = "-50%"), n === "bottom" && (r.bottom = t, i = "50%"), o === "start" && (r.left = t, a = "-50%"), o === "center" && (r.left = "50%", a = "-50%"), o === "end" && (r.right = t, a = "50%"), r.transform = `translate(${a}, ${i})`, r;
}
var bH = Qe((e, {
  radius: t,
  size: r,
  color: n,
  position: o,
  offset: a,
  inline: i,
  withBorder: l,
  withLabel: c,
  zIndex: u
}) => {
  const { background: d } = e.fn.variant({
    variant: "filled",
    primaryFallback: !1,
    color: n || e.primaryColor
  });
  return {
    root: {
      position: "relative",
      display: i ? "inline-block" : "block"
    },
    indicator: z_(V_({}, B_(o, a)), {
      zIndex: u,
      position: "absolute",
      [c ? "minWidth" : "width"]: r,
      height: r,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      fontSize: e.fontSizes.xs,
      paddingLeft: c ? `calc(${e.spacing.xs}px / 2)` : 0,
      paddingRight: c ? `calc(${e.spacing.xs}px / 2)` : 0,
      borderRadius: e.fn.size({ size: t, sizes: e.radius }),
      backgroundColor: e.fn.variant({
        variant: "filled",
        primaryFallback: !1,
        color: n || e.primaryColor
      }).background,
      border: l ? `2px solid ${e.colorScheme === "dark" ? e.colors.dark[7] : e.white}` : void 0,
      color: e.white,
      whiteSpace: "nowrap"
    }),
    processing: {
      animation: `${gH(d)} 1000ms linear infinite`
    },
    common: z_(V_({}, B_(o, a)), {
      position: "absolute",
      [c ? "minWidth" : "width"]: r,
      height: r,
      borderRadius: e.fn.size({ size: t, sizes: e.radius })
    })
  };
});
const wH = bH, xH = _o({
  from: {
    transform: "translateY(-60%)",
    opacity: 0
  },
  to: {
    transform: "translateY(0%)",
    opacity: 1
  }
}), _H = _o({
  from: {
    transform: "translateY(60%)",
    opacity: 0
  },
  to: {
    transform: "translateY(0%)",
    opacity: 1
  }
}), OH = _o({
  from: {
    transform: "translateY(0%)",
    opacity: 1
  },
  to: {
    transform: "translateY(-60%)",
    opacity: 0
  }
}), PH = _o({
  from: {
    transform: "translateY(0%)",
    opacity: 1
  },
  to: {
    transform: "translateY(60%)",
    opacity: 0
  }
});
var SH = Qe(() => ({
  baseNumber: {
    height: 18,
    width: "0.6em",
    maxWidth: "0.6em",
    position: "relative",
    display: "inline-block"
  },
  oldNumberTop: {
    transform: "translateY(-100%);"
  },
  oldNumberBottom: {
    transform: "translateY(100%);"
  },
  oldNumber: {
    display: "inline-block",
    opacity: 0,
    position: "absolute",
    left: 0,
    right: 0
  },
  currentNumberTop: {
    transform: "translateY(0%);"
  },
  currentNumber: {
    display: "inline-block",
    opacity: 1,
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  },
  currentNumberScrollDown: {
    animation: `${xH} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  currentNumberScrollUp: {
    animation: `${_H} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  oldNumberScrollUp: {
    animation: `${OH} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  },
  oldNumberScrollDown: {
    animation: `${PH} .2s cubic-bezier(0,0,.2, 1)`,
    animationIterationCount: 1
  }
}));
const TH = SH, EH = Ne((e, t) => {
  const [r, n] = Me(e.value), [o, a] = Me(e.value), [i, l] = Me("up"), [c, u] = Me(!1), d = HE(e.value), f = (g) => {
    u(!0), l(g), setTimeout(() => {
      u(!1);
    }, 180);
  }, p = () => {
    const { newOriginalNumber: g, oldOriginalNumber: b } = e;
    g == null || b == null || (g > b ? f("up") : g < b && f("down"));
  };
  Ue(() => {
    n(d), a(e.value), p();
  }, [e.value, d]);
  const { classes: m, cx: y } = TH(null, { name: "MachineNumber" }), h = fn(() => c ? i === "up" ? m.currentNumberScrollUp : m.currentNumberScrollDown : null, [c, i]), v = fn(() => c ? i === "up" ? m.oldNumberScrollUp : m.oldNumberScrollDown : null, [c, i]);
  return /* @__PURE__ */ F.createElement("span", {
    ref: t,
    className: m.baseNumber
  }, r && /* @__PURE__ */ F.createElement("span", {
    className: y(m.oldNumber, m.currentNumberTop, v)
  }, r) || null, /* @__PURE__ */ F.createElement("span", null, /* @__PURE__ */ F.createElement("span", {
    className: y(m.currentNumber, h)
  }, o)), r && /* @__PURE__ */ F.createElement("span", {
    className: y(m.oldNumber, m.oldNumberBottom, v)
  }, r) || null);
});
var $H = Qe(() => ({
  base: {
    display: "flex",
    alignItems: "center",
    overflow: "hidden"
  }
}));
const CH = $H, kH = Ne(({ value: e = 0, max: t }, r) => {
  const [n, o] = Me(), [a, i] = Me(), l = HE(e);
  Ue(() => {
    typeof e == "string" ? (o(void 0), i(void 0)) : typeof l == "string" ? (o(void 0), i(e)) : (o(l), i(e));
  }, [e, l]);
  const c = fn(() => {
    if (typeof e == "string")
      return [];
    if (e < 1)
      return [0];
    const d = [];
    let f = e;
    for (typeof t == "number" && (f = Math.min(t, f)); f >= 1; )
      d.push(f % 10), f /= 10, f = Math.floor(f);
    return d.reverse(), d;
  }, [e, t]), { classes: u } = CH(null, { name: "machine" });
  return typeof e == "string" ? /* @__PURE__ */ F.createElement("span", {
    ref: r
  }, e) : /* @__PURE__ */ F.createElement("span", {
    ref: r,
    className: u.base
  }, c.map((d, f) => /* @__PURE__ */ F.createElement(EH, {
    key: c.length - f - 1,
    value: d,
    oldOriginalNumber: n,
    newOriginalNumber: a
  })), typeof t == "number" && e > t && /* @__PURE__ */ F.createElement("span", null, "+"));
});
var RH = Object.defineProperty, xd = Object.getOwnPropertySymbols, Ek = Object.prototype.hasOwnProperty, $k = Object.prototype.propertyIsEnumerable, W_ = (e, t, r) => t in e ? RH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, DH = (e, t) => {
  for (var r in t || (t = {}))
    Ek.call(t, r) && W_(e, r, t[r]);
  if (xd)
    for (var r of xd(t))
      $k.call(t, r) && W_(e, r, t[r]);
  return e;
}, NH = (e, t) => {
  var r = {};
  for (var n in e)
    Ek.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && xd)
    for (var n of xd(e))
      t.indexOf(n) < 0 && $k.call(e, n) && (r[n] = e[n]);
  return r;
};
const IH = {
  position: "top-end",
  offset: 0,
  inline: !1,
  withBorder: !1,
  disabled: !1,
  showZero: !0,
  processing: !1,
  dot: !0,
  size: 10,
  overflowCount: 99,
  radius: 1e3,
  zIndex: Oo("app")
}, Vg = Ne((e, t) => {
  const r = Xe("Indicator", IH, e), {
    children: n,
    position: o,
    offset: a,
    size: i,
    radius: l,
    inline: c,
    withBorder: u,
    className: d,
    color: f,
    dot: p,
    styles: m,
    label: y,
    overflowCount: h,
    showZero: v,
    classNames: g,
    disabled: b,
    zIndex: x,
    unstyled: O,
    processing: w
  } = r, S = NH(r, [
    "children",
    "position",
    "offset",
    "size",
    "radius",
    "inline",
    "withBorder",
    "className",
    "color",
    "dot",
    "styles",
    "label",
    "overflowCount",
    "showZero",
    "classNames",
    "disabled",
    "zIndex",
    "unstyled",
    "processing"
  ]), { classes: E, cx: C } = wH({ position: o, offset: a, size: i, radius: l, inline: c, color: f, withBorder: u, zIndex: x, withLabel: !!y }, { name: "Indicator", classNames: g, styles: m, unstyled: O }), N = fn(() => typeof y == "number" ? /* @__PURE__ */ F.createElement(kH, {
    value: y,
    max: h
  }) : y, [y, h]), $ = fn(() => !b && (p || y != null && !(y <= 0 && !v)), [b, y, v]);
  return /* @__PURE__ */ F.createElement(Ke, DH({
    ref: t,
    className: C(E.root, d)
  }, S), $ && /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement("div", {
    className: C(E.indicator, E.common)
  }, N), w && /* @__PURE__ */ F.createElement("div", {
    className: C(E.processing, E.common)
  })), n);
});
Vg.displayName = "@mantine/core/Indicator";
var MH = Qe({
  root: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden"
  }
});
const AH = MH;
var jH = Object.defineProperty, FH = Object.defineProperties, LH = Object.getOwnPropertyDescriptors, _d = Object.getOwnPropertySymbols, Ck = Object.prototype.hasOwnProperty, kk = Object.prototype.propertyIsEnumerable, U_ = (e, t, r) => t in e ? jH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, tc = (e, t) => {
  for (var r in t || (t = {}))
    Ck.call(t, r) && U_(e, r, t[r]);
  if (_d)
    for (var r of _d(t))
      kk.call(t, r) && U_(e, r, t[r]);
  return e;
}, VH = (e, t) => FH(e, LH(t)), zH = (e, t) => {
  var r = {};
  for (var n in e)
    Ck.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && _d)
    for (var n of _d(e))
      t.indexOf(n) < 0 && kk.call(e, n) && (r[n] = e[n]);
  return r;
};
const BH = {
  overlayOpacity: 0.75,
  transitionDuration: 0,
  zIndex: Oo("overlay")
}, zg = Ne((e, t) => {
  const r = Xe("LoadingOverlay", BH, e), {
    className: n,
    visible: o,
    loaderProps: a,
    overlayOpacity: i,
    overlayColor: l,
    transitionDuration: c,
    exitTransitionDuration: u,
    zIndex: d,
    style: f,
    loader: p,
    radius: m,
    overlayBlur: y,
    unstyled: h
  } = r, v = zH(r, [
    "className",
    "visible",
    "loaderProps",
    "overlayOpacity",
    "overlayColor",
    "transitionDuration",
    "exitTransitionDuration",
    "zIndex",
    "style",
    "loader",
    "radius",
    "overlayBlur",
    "unstyled"
  ]), { classes: g, cx: b, theme: x } = AH(null, { name: "LoadingOverlay", unstyled: h }), O = `calc(${d} + 1)`;
  return /* @__PURE__ */ F.createElement(Dp, {
    duration: c,
    exitDuration: u,
    mounted: o,
    transition: "fade"
  }, (w) => /* @__PURE__ */ F.createElement(Ke, tc({
    className: b(g.root, n),
    style: VH(tc(tc({}, w), f), { zIndex: d }),
    ref: t
  }, v), p ? /* @__PURE__ */ F.createElement("div", {
    style: { zIndex: O }
  }, p) : /* @__PURE__ */ F.createElement(Pp, tc({
    style: { zIndex: O }
  }, a)), /* @__PURE__ */ F.createElement(vk, {
    opacity: i,
    zIndex: d,
    radius: m,
    blur: y,
    unstyled: h,
    color: l || (x.colorScheme === "dark" ? x.colors.dark[5] : x.white)
  })));
});
zg.displayName = "@mantine/core/LoadingOverlay";
const Rk = {
  context: "Menu component was not found in the tree",
  children: "Menu.Target component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
}, [WH, $l] = _p(Rk.context);
var UH = Qe((e) => ({
  divider: {
    margin: `calc(${e.spacing.xs}px / 2) -5px`,
    borderTop: `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2]}`
  }
}));
const HH = UH;
var YH = Object.defineProperty, Od = Object.getOwnPropertySymbols, Dk = Object.prototype.hasOwnProperty, Nk = Object.prototype.propertyIsEnumerable, H_ = (e, t, r) => t in e ? YH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, qH = (e, t) => {
  for (var r in t || (t = {}))
    Dk.call(t, r) && H_(e, r, t[r]);
  if (Od)
    for (var r of Od(t))
      Nk.call(t, r) && H_(e, r, t[r]);
  return e;
}, GH = (e, t) => {
  var r = {};
  for (var n in e)
    Dk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Od)
    for (var n of Od(e))
      t.indexOf(n) < 0 && Nk.call(e, n) && (r[n] = e[n]);
  return r;
};
const KH = {}, Ik = Ne((e, t) => {
  const r = Xe("MenuDivider", KH, e), { children: n, className: o } = r, a = GH(r, ["children", "className"]), { classNames: i, styles: l, unstyled: c } = $l(), { classes: u, cx: d } = HH(null, { name: "Menu", classNames: i, styles: l, unstyled: c });
  return /* @__PURE__ */ F.createElement(Ke, qH({
    className: d(u.divider, o),
    ref: t
  }, a));
});
Ik.displayName = "@mantine/core/MenuDivider";
var XH = Object.defineProperty, Pd = Object.getOwnPropertySymbols, Mk = Object.prototype.hasOwnProperty, Ak = Object.prototype.propertyIsEnumerable, Y_ = (e, t, r) => t in e ? XH(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, QH = (e, t) => {
  for (var r in t || (t = {}))
    Mk.call(t, r) && Y_(e, r, t[r]);
  if (Pd)
    for (var r of Pd(t))
      Ak.call(t, r) && Y_(e, r, t[r]);
  return e;
}, ZH = (e, t) => {
  var r = {};
  for (var n in e)
    Mk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Pd)
    for (var n of Pd(e))
      t.indexOf(n) < 0 && Ak.call(e, n) && (r[n] = e[n]);
  return r;
};
const JH = {};
function jk(e) {
  const t = Xe("MenuDropdown", JH, e), { children: r, onMouseEnter: n, onMouseLeave: o } = t, a = ZH(t, ["children", "onMouseEnter", "onMouseLeave"]), i = qe(), l = $l(), c = (f) => {
    (f.key === "ArrowUp" || f.key === "ArrowDown") && (f.preventDefault(), i.current.querySelectorAll("[data-menu-item]")[0].focus());
  }, u = lo(n, () => l.trigger === "hover" && l.openDropdown()), d = lo(o, () => l.trigger === "hover" && l.closeDropdown());
  return /* @__PURE__ */ F.createElement(cn.Dropdown, QH({
    onMouseEnter: u,
    onMouseLeave: d,
    role: "menu",
    "aria-orientation": "vertical"
  }, a), /* @__PURE__ */ F.createElement("div", {
    tabIndex: -1,
    "data-menu-dropdown": !0,
    "data-autofocus": !0,
    onKeyDown: c,
    ref: i,
    style: { outline: 0 }
  }, r));
}
jk.displayName = "@mantine/core/MenuDropdown";
var e8 = Object.defineProperty, t8 = Object.defineProperties, r8 = Object.getOwnPropertyDescriptors, q_ = Object.getOwnPropertySymbols, n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.propertyIsEnumerable, G_ = (e, t, r) => t in e ? e8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, a8 = (e, t) => {
  for (var r in t || (t = {}))
    n8.call(t, r) && G_(e, r, t[r]);
  if (q_)
    for (var r of q_(t))
      o8.call(t, r) && G_(e, r, t[r]);
  return e;
}, i8 = (e, t) => t8(e, r8(t)), s8 = Qe((e, { color: t, radius: r }) => ({
  item: i8(a8({}, e.fn.fontStyles()), {
    WebkitTapHighlightColor: "transparent",
    fontSize: e.fontSizes.sm,
    border: 0,
    backgroundColor: "transparent",
    outline: 0,
    width: "100%",
    textAlign: "left",
    textDecoration: "none",
    boxSizing: "border-box",
    padding: `${e.spacing.xs}px ${e.spacing.sm}px`,
    cursor: "pointer",
    borderRadius: e.fn.radius(r),
    color: t ? e.fn.variant({ variant: "filled", primaryFallback: !1, color: t }).background : e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    display: "flex",
    alignItems: "center",
    "&:disabled": {
      color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5],
      pointerEvents: "none",
      userSelect: "none"
    },
    "&[data-hovered]": {
      backgroundColor: t ? e.fn.variant({ variant: "light", color: t }).background : e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[3], 0.35) : e.colors.gray[1]
    }
  }),
  itemLabel: {
    flex: 1
  },
  itemIcon: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    marginRight: e.spacing.xs
  },
  itemRightSection: {}
}));
const l8 = s8;
var c8 = Object.defineProperty, u8 = Object.defineProperties, d8 = Object.getOwnPropertyDescriptors, Sd = Object.getOwnPropertySymbols, Fk = Object.prototype.hasOwnProperty, Lk = Object.prototype.propertyIsEnumerable, K_ = (e, t, r) => t in e ? c8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, f8 = (e, t) => {
  for (var r in t || (t = {}))
    Fk.call(t, r) && K_(e, r, t[r]);
  if (Sd)
    for (var r of Sd(t))
      Lk.call(t, r) && K_(e, r, t[r]);
  return e;
}, p8 = (e, t) => u8(e, d8(t)), m8 = (e, t) => {
  var r = {};
  for (var n in e)
    Fk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Sd)
    for (var n of Sd(e))
      t.indexOf(n) < 0 && Lk.call(e, n) && (r[n] = e[n]);
  return r;
};
const h8 = {}, Vk = Ne((e, t) => {
  const r = Xe("MenuItem", h8, e), { children: n, className: o, color: a, closeMenuOnClick: i, icon: l, rightSection: c } = r, u = m8(r, ["children", "className", "color", "closeMenuOnClick", "icon", "rightSection"]), d = $l(), { classes: f, cx: p, theme: m } = l8({ radius: d.radius, color: a }, { name: "Menu", classNames: d.classNames, styles: d.styles, unstyled: d.unstyled }), y = qe(), h = d.getItemIndex(y.current), v = u, g = lo(v.onMouseLeave, () => d.setHovered(-1)), b = lo(v.onMouseEnter, () => d.setHovered(d.getItemIndex(y.current))), x = lo(v.onClick, () => {
    typeof i == "boolean" ? i && d.closeDropdownImmediately() : d.closeOnItemClick && d.closeDropdownImmediately();
  }), O = lo(v.onFocus, () => d.setHovered(d.getItemIndex(y.current)));
  return /* @__PURE__ */ F.createElement(Ke, p8(f8({
    component: "button",
    type: "button"
  }, u), {
    tabIndex: -1,
    onFocus: O,
    className: p(f.item, o),
    ref: Jo(y, t),
    role: "menuitem",
    "data-menu-item": !0,
    "data-hovered": d.hovered === h ? !0 : void 0,
    onMouseEnter: b,
    onMouseLeave: g,
    onClick: x,
    onKeyDown: SE({
      siblingSelector: "[data-menu-item]",
      parentSelector: "[data-menu-dropdown]",
      activateOnFocus: !1,
      loop: d.loop,
      dir: m.dir,
      orientation: "vertical",
      onKeyDown: v.onKeydown
    })
  }), l && /* @__PURE__ */ F.createElement("div", {
    className: f.itemIcon
  }, l), n && /* @__PURE__ */ F.createElement("div", {
    className: f.itemLabel
  }, n), c && /* @__PURE__ */ F.createElement("div", {
    className: f.itemRightSection
  }, c));
});
Vk.displayName = "@mantine/core/MenuItem";
const y8 = Vk;
var v8 = Qe((e) => ({
  label: {
    color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6],
    fontWeight: 500,
    fontSize: e.fontSizes.xs,
    padding: `calc(${e.spacing.xs}px / 2) ${e.spacing.sm}px`,
    cursor: "default"
  }
}));
const g8 = v8;
var b8 = Object.defineProperty, Td = Object.getOwnPropertySymbols, zk = Object.prototype.hasOwnProperty, Bk = Object.prototype.propertyIsEnumerable, X_ = (e, t, r) => t in e ? b8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, w8 = (e, t) => {
  for (var r in t || (t = {}))
    zk.call(t, r) && X_(e, r, t[r]);
  if (Td)
    for (var r of Td(t))
      Bk.call(t, r) && X_(e, r, t[r]);
  return e;
}, x8 = (e, t) => {
  var r = {};
  for (var n in e)
    zk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Td)
    for (var n of Td(e))
      t.indexOf(n) < 0 && Bk.call(e, n) && (r[n] = e[n]);
  return r;
};
const _8 = {}, Wk = Ne((e, t) => {
  const r = Xe("MenuLabel", _8, e), { children: n, className: o } = r, a = x8(r, ["children", "className"]), { classNames: i, styles: l, unstyled: c } = $l(), { classes: u, cx: d } = g8(null, { name: "Menu", classNames: i, styles: l, unstyled: c });
  return /* @__PURE__ */ F.createElement($r, w8({
    className: d(u.label, o),
    ref: t
  }, a), n);
});
Wk.displayName = "@mantine/core/MenuLabel";
var O8 = Object.defineProperty, Ed = Object.getOwnPropertySymbols, Uk = Object.prototype.hasOwnProperty, Hk = Object.prototype.propertyIsEnumerable, Q_ = (e, t, r) => t in e ? O8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, P8 = (e, t) => {
  for (var r in t || (t = {}))
    Uk.call(t, r) && Q_(e, r, t[r]);
  if (Ed)
    for (var r of Ed(t))
      Hk.call(t, r) && Q_(e, r, t[r]);
  return e;
}, S8 = (e, t) => {
  var r = {};
  for (var n in e)
    Uk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Ed)
    for (var n of Ed(e))
      t.indexOf(n) < 0 && Hk.call(e, n) && (r[n] = e[n]);
  return r;
};
const T8 = {
  refProp: "ref"
}, Yk = Ne((e, t) => {
  const r = Xe("MenuTarget", T8, e), { children: n, refProp: o } = r, a = S8(r, ["children", "refProp"]);
  if (!_l(n))
    throw new Error(Rk.children);
  const i = $l(), l = lo(n.props.onClick, () => i.trigger === "click" && i.toggleDropdown()), c = lo(n.props.onMouseEnter, () => i.trigger === "hover" && i.openDropdown()), u = lo(n.props.onMouseLeave, () => i.trigger === "hover" && i.closeDropdown());
  return /* @__PURE__ */ F.createElement(cn.Target, P8({
    refProp: o,
    popupType: "menu",
    ref: t
  }, a), on(n, {
    onClick: l,
    onMouseEnter: c,
    onMouseLeave: u,
    "data-expanded": i.opened ? !0 : void 0
  }));
});
Yk.displayName = "@mantine/core/MenuTarget";
var E8 = Qe({
  dropdown: { padding: 4 }
});
const $8 = E8;
var C8 = Object.defineProperty, k8 = Object.defineProperties, R8 = Object.getOwnPropertyDescriptors, $d = Object.getOwnPropertySymbols, qk = Object.prototype.hasOwnProperty, Gk = Object.prototype.propertyIsEnumerable, Z_ = (e, t, r) => t in e ? C8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, J_ = (e, t) => {
  for (var r in t || (t = {}))
    qk.call(t, r) && Z_(e, r, t[r]);
  if ($d)
    for (var r of $d(t))
      Gk.call(t, r) && Z_(e, r, t[r]);
  return e;
}, eO = (e, t) => k8(e, R8(t)), D8 = (e, t) => {
  var r = {};
  for (var n in e)
    qk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && $d)
    for (var n of $d(e))
      t.indexOf(n) < 0 && Gk.call(e, n) && (r[n] = e[n]);
  return r;
};
const N8 = {
  closeOnItemClick: !0,
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100
};
function Bt(e) {
  const t = Xe("Menu", N8, e), {
    children: r,
    onOpen: n,
    onClose: o,
    opened: a,
    defaultOpened: i,
    onChange: l,
    closeOnItemClick: c,
    loop: u,
    closeOnEscape: d,
    trigger: f,
    openDelay: p,
    closeDelay: m,
    classNames: y,
    styles: h,
    unstyled: v,
    radius: g
  } = t, b = D8(t, [
    "children",
    "onOpen",
    "onClose",
    "opened",
    "defaultOpened",
    "onChange",
    "closeOnItemClick",
    "loop",
    "closeOnEscape",
    "trigger",
    "openDelay",
    "closeDelay",
    "classNames",
    "styles",
    "unstyled",
    "radius"
  ]), { classes: x, cx: O } = $8(), [w, { setHovered: S, resetHovered: E }] = tV(), [C, N] = Kn({
    value: a,
    defaultValue: i,
    finalValue: !1,
    onChange: l
  }), $ = () => {
    N(!1), C && (o == null || o());
  }, j = () => {
    N(!0), !C && (n == null || n());
  }, A = () => C ? $() : j(), { openDropdown: k, closeDropdown: R } = fH({ open: j, close: $, closeDelay: m, openDelay: p }), D = (L) => ZL("[data-menu-item]", "[data-menu-dropdown]", L);
  return sn(() => {
    E();
  }, [C]), /* @__PURE__ */ F.createElement(WH, {
    value: {
      opened: C,
      toggleDropdown: A,
      getItemIndex: D,
      hovered: w,
      setHovered: S,
      closeOnItemClick: c,
      closeDropdown: f === "click" ? $ : R,
      openDropdown: f === "click" ? j : k,
      closeDropdownImmediately: $,
      loop: u,
      trigger: f,
      radius: g,
      classNames: y,
      styles: h,
      unstyled: v
    }
  }, /* @__PURE__ */ F.createElement(cn, eO(J_({}, b), {
    radius: g,
    opened: C,
    onChange: N,
    defaultOpened: i,
    trapFocus: f === "click",
    closeOnEscape: d && f === "click",
    __staticSelector: "Menu",
    classNames: eO(J_({}, y), { dropdown: O(x.dropdown, y == null ? void 0 : y.dropdown) }),
    styles: h,
    unstyled: v,
    onClose: $,
    onOpen: j
  }), r));
}
Bt.displayName = "@mantine/core/Menu";
Bt.Item = y8;
Bt.Label = Wk;
Bt.Dropdown = jk;
Bt.Target = Yk;
Bt.Divider = Ik;
var I8 = Object.defineProperty, tO = Object.getOwnPropertySymbols, M8 = Object.prototype.hasOwnProperty, A8 = Object.prototype.propertyIsEnumerable, rO = (e, t, r) => t in e ? I8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, j8 = (e, t) => {
  for (var r in t || (t = {}))
    M8.call(t, r) && rO(e, r, t[r]);
  if (tO)
    for (var r of tO(t))
      A8.call(t, r) && rO(e, r, t[r]);
  return e;
};
const F8 = {
  xs: 320,
  sm: 380,
  md: 440,
  lg: 620,
  xl: 780
};
function L8(e) {
  return e ? {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    maxHeight: "100vh",
    overflowY: "auto"
  } : {};
}
var V8 = Qe((e, { overflow: t, size: r, centered: n, zIndex: o, fullScreen: a }) => ({
  close: {},
  overlay: {
    display: a ? "none" : void 0
  },
  root: {
    position: "fixed",
    zIndex: o,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  inner: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    overflowY: "auto",
    padding: a ? 0 : `${e.spacing.xl * 2}px ${e.spacing.md}px`,
    display: "flex",
    justifyContent: "center",
    alignItems: n ? "center" : "flex-start"
  },
  title: {
    marginRight: e.spacing.md,
    textOverflow: "ellipsis",
    display: "block",
    wordBreak: "break-word"
  },
  modal: j8({
    position: "relative",
    width: a ? "100vw" : e.fn.size({ sizes: F8, size: r }),
    borderRadius: a ? 0 : void 0,
    outline: 0,
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
    marginTop: n ? "auto" : void 0,
    marginBottom: n ? "auto" : void 0,
    zIndex: 1
  }, L8(a)),
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: e.spacing.md,
    marginRight: -9
  },
  body: {
    maxHeight: t === "inside" ? "calc(100vh - 185px)" : null,
    overflowY: t === "inside" ? "auto" : null,
    wordBreak: "break-word"
  }
}));
const z8 = V8;
var B8 = Object.defineProperty, Cd = Object.getOwnPropertySymbols, Kk = Object.prototype.hasOwnProperty, Xk = Object.prototype.propertyIsEnumerable, nO = (e, t, r) => t in e ? B8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, W8 = (e, t) => {
  for (var r in t || (t = {}))
    Kk.call(t, r) && nO(e, r, t[r]);
  if (Cd)
    for (var r of Cd(t))
      Xk.call(t, r) && nO(e, r, t[r]);
  return e;
}, U8 = (e, t) => {
  var r = {};
  for (var n in e)
    Kk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Cd)
    for (var n of Cd(e))
      t.indexOf(n) < 0 && Xk.call(e, n) && (r[n] = e[n]);
  return r;
};
const H8 = {
  size: "md",
  transitionDuration: 250,
  overflow: "outside",
  padding: "lg",
  shadow: "lg",
  closeOnClickOutside: !0,
  closeOnEscape: !0,
  trapFocus: !0,
  withCloseButton: !0,
  withinPortal: !0,
  lockScroll: !0,
  withFocusReturn: !0,
  overlayBlur: 0,
  zIndex: Oo("modal"),
  exitTransitionDuration: 0
};
function Zi(e) {
  const t = Xe("Modal", H8, e), {
    className: r,
    opened: n,
    title: o,
    onClose: a,
    children: i,
    withCloseButton: l,
    overlayOpacity: c,
    size: u,
    transitionDuration: d,
    exitTransitionDuration: f,
    closeButtonLabel: p,
    overlayColor: m,
    overflow: y,
    transition: h,
    padding: v,
    shadow: g,
    radius: b,
    id: x,
    classNames: O,
    styles: w,
    closeOnClickOutside: S,
    trapFocus: E,
    closeOnEscape: C,
    centered: N,
    target: $,
    withinPortal: j,
    zIndex: A,
    overlayBlur: k,
    transitionTimingFunction: R,
    fullScreen: D,
    unstyled: L,
    lockScroll: B,
    withFocusReturn: H
  } = t, U = U8(t, [
    "className",
    "opened",
    "title",
    "onClose",
    "children",
    "withCloseButton",
    "overlayOpacity",
    "size",
    "transitionDuration",
    "exitTransitionDuration",
    "closeButtonLabel",
    "overlayColor",
    "overflow",
    "transition",
    "padding",
    "shadow",
    "radius",
    "id",
    "classNames",
    "styles",
    "closeOnClickOutside",
    "trapFocus",
    "closeOnEscape",
    "centered",
    "target",
    "withinPortal",
    "zIndex",
    "overlayBlur",
    "transitionTimingFunction",
    "fullScreen",
    "unstyled",
    "lockScroll",
    "withFocusReturn"
  ]), I = Zo(x), V = `${I}-title`, G = `${I}-body`, { classes: q, cx: J, theme: ne } = z8({ size: u, overflow: y, centered: N, zIndex: A, fullScreen: D }, { unstyled: L, classNames: O, styles: w, name: "Modal" }), te = BE(E && n), ee = qe(null), K = Jo(te, ee), Q = typeof c == "number" ? c : ne.colorScheme === "dark" ? 0.85 : 0.75;
  Hz(B && n);
  const ae = (se) => {
    !E && se.key === "Escape" && C && a();
  };
  Ue(() => {
    if (!E)
      return window.addEventListener("keydown", ae), () => window.removeEventListener("keydown", ae);
  }, [E]), FE({ opened: n, shouldReturnFocus: E && H });
  const ie = qe(null);
  Gh("mousedown", (se) => {
    ie.current = se.target;
  });
  const oe = () => {
    ie.current === ee.current && S && a();
  };
  return /* @__PURE__ */ F.createElement(Pl, {
    withinPortal: j,
    target: $
  }, /* @__PURE__ */ F.createElement(pk, {
    mounted: n,
    duration: d,
    exitDuration: f,
    timingFunction: R,
    transitions: {
      modal: {
        duration: d,
        transition: h || (D ? "fade" : "pop")
      },
      overlay: {
        duration: d / 2,
        transition: "fade",
        timingFunction: "ease"
      }
    }
  }, (se) => /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(Ke, W8({
    id: I,
    className: J(q.root, r)
  }, U), /* @__PURE__ */ F.createElement("div", {
    style: se.overlay
  }, /* @__PURE__ */ F.createElement(vk, {
    className: q.overlay,
    sx: { position: "fixed" },
    zIndex: 0,
    blur: k,
    color: m || (ne.colorScheme === "dark" ? ne.colors.dark[9] : ne.black),
    opacity: Q,
    unstyled: L
  })), /* @__PURE__ */ F.createElement("div", {
    role: "presentation",
    className: q.inner,
    onClick: oe,
    onKeyDown: (re) => {
      var le;
      ((le = re.target) == null ? void 0 : le.getAttribute("data-mantine-stop-propagation")) !== "true" && re.key === "Escape" && C && a();
    },
    ref: K
  }, /* @__PURE__ */ F.createElement(ud, {
    className: q.modal,
    shadow: g,
    p: v,
    radius: b,
    role: "dialog",
    "aria-labelledby": V,
    "aria-describedby": G,
    "aria-modal": !0,
    tabIndex: -1,
    style: se.modal,
    unstyled: L,
    onClick: (re) => re.stopPropagation()
  }, (o || l) && /* @__PURE__ */ F.createElement("div", {
    className: q.header
  }, /* @__PURE__ */ F.createElement($r, {
    id: V,
    className: q.title
  }, o), l && /* @__PURE__ */ F.createElement(Sp, {
    iconSize: 16,
    onClick: a,
    "aria-label": p,
    className: q.close
  })), /* @__PURE__ */ F.createElement("div", {
    id: G,
    className: q.body
  }, i)))))));
}
Zi.displayName = "@mantine/core/Modal";
const Y8 = {
  xs: 16,
  sm: 22,
  md: 26,
  lg: 30,
  xl: 36
}, q8 = {
  xs: 10,
  sm: 12,
  md: 14,
  lg: 16,
  xl: 18
};
var G8 = Qe((e, { size: t, disabled: r, radius: n, readOnly: o, variant: a }) => ({
  defaultValue: {
    display: "flex",
    alignItems: "center",
    backgroundColor: r ? e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[3] : e.colorScheme === "dark" ? e.colors.dark[7] : a === "filled" ? e.white : e.colors.gray[1],
    color: r ? e.colorScheme === "dark" ? e.colors.dark[1] : e.colors.gray[7] : e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
    height: e.fn.size({ size: t, sizes: Y8 }),
    paddingLeft: e.fn.size({ size: t, sizes: e.spacing }),
    paddingRight: r || o ? e.fn.size({ size: t, sizes: e.spacing }) : 0,
    fontWeight: 500,
    fontSize: e.fn.size({ size: t, sizes: q8 }),
    borderRadius: e.fn.size({ size: n, sizes: e.radius }),
    cursor: r ? "not-allowed" : "default",
    userSelect: "none",
    maxWidth: "calc(100% - 20px)"
  },
  defaultValueRemove: {
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
    marginLeft: e.fn.size({ size: t, sizes: e.spacing }) / 6
  },
  defaultValueLabel: {
    display: "block",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }
}));
const K8 = G8;
var X8 = Object.defineProperty, kd = Object.getOwnPropertySymbols, Qk = Object.prototype.hasOwnProperty, Zk = Object.prototype.propertyIsEnumerable, oO = (e, t, r) => t in e ? X8(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Q8 = (e, t) => {
  for (var r in t || (t = {}))
    Qk.call(t, r) && oO(e, r, t[r]);
  if (kd)
    for (var r of kd(t))
      Zk.call(t, r) && oO(e, r, t[r]);
  return e;
}, Z8 = (e, t) => {
  var r = {};
  for (var n in e)
    Qk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && kd)
    for (var n of kd(e))
      t.indexOf(n) < 0 && Zk.call(e, n) && (r[n] = e[n]);
  return r;
};
const aO = {
  xs: 16,
  sm: 22,
  md: 24,
  lg: 26,
  xl: 30
};
function Jk(e) {
  var t = e, {
    label: r,
    classNames: n,
    styles: o,
    className: a,
    onRemove: i,
    disabled: l,
    readOnly: c,
    size: u,
    radius: d = "sm",
    variant: f
  } = t, p = Z8(t, [
    "label",
    "classNames",
    "styles",
    "className",
    "onRemove",
    "disabled",
    "readOnly",
    "size",
    "radius",
    "variant"
  ]);
  const { classes: m, cx: y } = K8({ size: u, disabled: l, readOnly: c, radius: d, variant: f }, { classNames: n, styles: o, name: "MultiSelect" });
  return /* @__PURE__ */ F.createElement("div", Q8({
    className: y(m.defaultValue, a)
  }, p), /* @__PURE__ */ F.createElement("span", {
    className: m.defaultValueLabel
  }, r), !l && !c && /* @__PURE__ */ F.createElement(Sp, {
    "aria-hidden": !0,
    onMouseDown: i,
    size: aO[u],
    radius: 2,
    color: "blue",
    variant: "transparent",
    iconSize: aO[u] / 2,
    className: m.defaultValueRemove,
    tabIndex: -1
  }));
}
Jk.displayName = "@mantine/core/MultiSelect/DefaultValue";
function J8({
  data: e,
  searchable: t,
  limit: r,
  searchValue: n,
  filter: o,
  value: a,
  disableSelectedItemFiltering: i
}) {
  if (!t && a.length === 0)
    return e;
  if (!t) {
    const c = [];
    for (let u = 0; u < e.length; u += 1)
      (i || !a.some((d) => d === e[u].value && !e[u].disabled)) && c.push(e[u]);
    return c;
  }
  const l = [];
  for (let c = 0; c < e.length && (o(n, a.some((u) => u === e[c].value && !e[c].disabled), e[c]) && l.push(e[c]), !(l.length >= r)); c += 1)
    ;
  return l;
}
var e9 = Object.defineProperty, Rd = Object.getOwnPropertySymbols, eR = Object.prototype.hasOwnProperty, tR = Object.prototype.propertyIsEnumerable, iO = (e, t, r) => t in e ? e9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, sO = (e, t) => {
  for (var r in t || (t = {}))
    eR.call(t, r) && iO(e, r, t[r]);
  if (Rd)
    for (var r of Rd(t))
      tR.call(t, r) && iO(e, r, t[r]);
  return e;
}, t9 = (e, t) => {
  var r = {};
  for (var n in e)
    eR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Rd)
    for (var n of Rd(e))
      t.indexOf(n) < 0 && tR.call(e, n) && (r[n] = e[n]);
  return r;
};
const r9 = {
  xs: 14,
  sm: 18,
  md: 20,
  lg: 24,
  xl: 28
};
function n9(e) {
  var t = e, { size: r, error: n, style: o } = t, a = t9(t, ["size", "error", "style"]);
  const i = fr(), l = i.fn.size({ size: r, sizes: r9 });
  return /* @__PURE__ */ F.createElement("svg", sO({
    width: l,
    height: l,
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: sO({ color: n ? i.colors.red[6] : i.colors.gray[6] }, o),
    "data-chevron": !0
  }, a), /* @__PURE__ */ F.createElement("path", {
    d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function rR({
  shouldClear: e,
  clearButtonLabel: t,
  onClear: r,
  size: n,
  error: o,
  clearButtonTabIndex: a
}) {
  return e ? /* @__PURE__ */ F.createElement(Sp, {
    variant: "transparent",
    "aria-label": t,
    onClick: r,
    size: n,
    tabIndex: a,
    onMouseDown: (i) => i.preventDefault()
  }) : /* @__PURE__ */ F.createElement(n9, {
    error: o,
    size: n
  });
}
rR.displayName = "@mantine/core/SelectRightSection";
var o9 = Object.defineProperty, a9 = Object.defineProperties, i9 = Object.getOwnPropertyDescriptors, Dd = Object.getOwnPropertySymbols, nR = Object.prototype.hasOwnProperty, oR = Object.prototype.propertyIsEnumerable, lO = (e, t, r) => t in e ? o9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Am = (e, t) => {
  for (var r in t || (t = {}))
    nR.call(t, r) && lO(e, r, t[r]);
  if (Dd)
    for (var r of Dd(t))
      oR.call(t, r) && lO(e, r, t[r]);
  return e;
}, cO = (e, t) => a9(e, i9(t)), s9 = (e, t) => {
  var r = {};
  for (var n in e)
    nR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Dd)
    for (var n of Dd(e))
      t.indexOf(n) < 0 && oR.call(e, n) && (r[n] = e[n]);
  return r;
};
const l9 = {
  xs: 24,
  sm: 30,
  md: 34,
  lg: 44,
  xl: 54
};
function aR(e) {
  var t = e, {
    styles: r,
    rightSection: n,
    rightSectionWidth: o,
    theme: a
  } = t, i = s9(t, [
    "styles",
    "rightSection",
    "rightSectionWidth",
    "theme"
  ]);
  if (n)
    return { rightSection: n, rightSectionWidth: o, styles: r };
  const l = typeof r == "function" ? r(a) : r;
  return {
    rightSectionWidth: a.fn.size({ size: i.size, sizes: l9 }),
    rightSection: !i.readOnly && !(i.disabled && i.shouldClear) && /* @__PURE__ */ F.createElement(rR, Am({}, i)),
    styles: cO(Am({}, l), {
      rightSection: cO(Am({}, l == null ? void 0 : l.rightSection), {
        pointerEvents: i.shouldClear ? void 0 : "none"
      })
    })
  };
}
var c9 = Object.defineProperty, u9 = Object.defineProperties, d9 = Object.getOwnPropertyDescriptors, uO = Object.getOwnPropertySymbols, f9 = Object.prototype.hasOwnProperty, p9 = Object.prototype.propertyIsEnumerable, dO = (e, t, r) => t in e ? c9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, m9 = (e, t) => {
  for (var r in t || (t = {}))
    f9.call(t, r) && dO(e, r, t[r]);
  if (uO)
    for (var r of uO(t))
      p9.call(t, r) && dO(e, r, t[r]);
  return e;
}, h9 = (e, t) => u9(e, d9(t)), y9 = Qe((e, { size: t, invalid: r }) => ({
  wrapper: {
    position: "relative"
  },
  values: {
    minHeight: e.fn.size({ size: t, sizes: Sr }) - 2,
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    marginLeft: `calc(${-e.spacing.xs}px / 2)`,
    boxSizing: "border-box"
  },
  value: {
    margin: `calc(${e.spacing.xs}px / 2 - 2px) calc(${e.spacing.xs}px / 2)`
  },
  searchInput: h9(m9({}, e.fn.fontStyles()), {
    flex: 1,
    minWidth: 60,
    backgroundColor: "transparent",
    border: 0,
    outline: 0,
    fontSize: e.fn.size({ size: t, sizes: e.fontSizes }),
    padding: 0,
    marginLeft: `calc(${e.spacing.xs}px / 2)`,
    appearance: "none",
    color: "inherit",
    lineHeight: `${e.fn.size({ size: t, sizes: Sr }) - 2}px`,
    "&::placeholder": {
      opacity: 1,
      color: r ? e.colors.red[e.colorScheme === "dark" ? 6 : 7] : e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
    },
    "&:disabled": {
      cursor: "not-allowed"
    }
  }),
  searchInputEmpty: {
    width: "100%"
  },
  searchInputInputHidden: {
    width: 0,
    height: 0,
    margin: 0,
    overflow: "hidden"
  },
  searchInputPointer: {
    cursor: "pointer",
    "&:disabled": {
      cursor: "not-allowed"
    }
  },
  input: {
    cursor: "pointer",
    "&:disabled": {
      cursor: "not-allowed"
    }
  }
}));
const v9 = y9;
var g9 = Object.defineProperty, b9 = Object.defineProperties, w9 = Object.getOwnPropertyDescriptors, Nd = Object.getOwnPropertySymbols, iR = Object.prototype.hasOwnProperty, sR = Object.prototype.propertyIsEnumerable, fO = (e, t, r) => t in e ? g9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ti = (e, t) => {
  for (var r in t || (t = {}))
    iR.call(t, r) && fO(e, r, t[r]);
  if (Nd)
    for (var r of Nd(t))
      sR.call(t, r) && fO(e, r, t[r]);
  return e;
}, pO = (e, t) => b9(e, w9(t)), x9 = (e, t) => {
  var r = {};
  for (var n in e)
    iR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Nd)
    for (var n of Nd(e))
      t.indexOf(n) < 0 && sR.call(e, n) && (r[n] = e[n]);
  return r;
};
function _9(e, t, r) {
  return t ? !1 : r.label.toLowerCase().trim().includes(e.toLowerCase().trim());
}
function O9(e, t) {
  return !!e && !t.some((r) => r.value.toLowerCase() === e.toLowerCase());
}
function mO(e, t) {
  if (!Array.isArray(e))
    return;
  if (t.length === 0)
    return [];
  const r = t.map((n) => typeof n == "object" ? n.value : n);
  return e.filter((n) => r.includes(n));
}
const P9 = {
  size: "sm",
  valueComponent: Jk,
  itemComponent: Og,
  transition: "pop-top-left",
  transitionDuration: 0,
  maxDropdownHeight: 220,
  shadow: "sm",
  searchable: !1,
  filter: _9,
  limit: 1 / 0,
  clearSearchOnChange: !0,
  clearable: !1,
  clearSearchOnBlur: !1,
  disabled: !1,
  initiallyOpened: !1,
  creatable: !1,
  shouldCreate: O9,
  switchDirectionOnFlip: !1,
  zIndex: Oo("popover"),
  selectOnBlur: !1,
  clearButtonTabIndex: 0,
  positionDependencies: [],
  dropdownPosition: "flip"
}, Np = Ne((e, t) => {
  const r = Xe("MultiSelect", P9, e), {
    className: n,
    style: o,
    required: a,
    label: i,
    description: l,
    size: c,
    error: u,
    classNames: d,
    styles: f,
    wrapperProps: p,
    value: m,
    defaultValue: y,
    data: h,
    onChange: v,
    valueComponent: g,
    itemComponent: b,
    id: x,
    transition: O,
    transitionDuration: w,
    transitionTimingFunction: S,
    maxDropdownHeight: E,
    shadow: C,
    nothingFound: N,
    onFocus: $,
    onBlur: j,
    searchable: A,
    placeholder: k,
    filter: R,
    limit: D,
    clearSearchOnChange: L,
    clearable: B,
    clearSearchOnBlur: H,
    clearButtonLabel: U,
    variant: I,
    onSearchChange: V,
    searchValue: G,
    disabled: q,
    initiallyOpened: J,
    radius: ne,
    icon: te,
    rightSection: ee,
    rightSectionWidth: K,
    creatable: Q,
    getCreateLabel: ae,
    shouldCreate: ie,
    onCreate: oe,
    sx: se,
    dropdownComponent: re,
    onDropdownClose: le,
    onDropdownOpen: M,
    maxSelectedValues: W,
    withinPortal: Z,
    switchDirectionOnFlip: he,
    zIndex: me,
    selectOnBlur: de,
    name: ue,
    dropdownPosition: Oe,
    errorProps: Se,
    labelProps: De,
    descriptionProps: nt,
    clearButtonTabIndex: rt,
    form: Be,
    positionDependencies: Ie,
    onKeyDown: it,
    unstyled: we,
    inputContainer: ye,
    inputWrapperOrder: _e,
    readOnly: Re,
    withAsterisk: je,
    hoverOnSearchChange: Fe,
    disableSelectedItemFiltering: Ze
  } = r, ft = x9(r, [
    "className",
    "style",
    "required",
    "label",
    "description",
    "size",
    "error",
    "classNames",
    "styles",
    "wrapperProps",
    "value",
    "defaultValue",
    "data",
    "onChange",
    "valueComponent",
    "itemComponent",
    "id",
    "transition",
    "transitionDuration",
    "transitionTimingFunction",
    "maxDropdownHeight",
    "shadow",
    "nothingFound",
    "onFocus",
    "onBlur",
    "searchable",
    "placeholder",
    "filter",
    "limit",
    "clearSearchOnChange",
    "clearable",
    "clearSearchOnBlur",
    "clearButtonLabel",
    "variant",
    "onSearchChange",
    "searchValue",
    "disabled",
    "initiallyOpened",
    "radius",
    "icon",
    "rightSection",
    "rightSectionWidth",
    "creatable",
    "getCreateLabel",
    "shouldCreate",
    "onCreate",
    "sx",
    "dropdownComponent",
    "onDropdownClose",
    "onDropdownOpen",
    "maxSelectedValues",
    "withinPortal",
    "switchDirectionOnFlip",
    "zIndex",
    "selectOnBlur",
    "name",
    "dropdownPosition",
    "errorProps",
    "labelProps",
    "descriptionProps",
    "clearButtonTabIndex",
    "form",
    "positionDependencies",
    "onKeyDown",
    "unstyled",
    "inputContainer",
    "inputWrapperOrder",
    "readOnly",
    "withAsterisk",
    "hoverOnSearchChange",
    "disableSelectedItemFiltering"
  ]), { classes: Je, cx: Ht, theme: at } = v9({ size: c, invalid: !!u }, { classNames: d, styles: f, unstyled: we, name: "MultiSelect" }), { systemStyles: Jt, rest: Yt } = Xi(ft), qt = qe(), Or = qe({}), Qt = Zo(x), [Gt, Rt] = Me(J), [ct, sr] = Me(-1), [Gr, Mt] = Me("column"), [er, Kr] = Kn({
    value: G,
    defaultValue: "",
    finalValue: void 0,
    onChange: V
  }), [wn, $o] = Me(!1), { scrollIntoView: Y, targetRef: ve, scrollableRef: Ee } = UE({
    duration: 0,
    offset: 5,
    cancelable: !1,
    isList: !0
  }), He = Q && typeof ae == "function";
  let be = null;
  const We = h.map((Ge) => typeof Ge == "string" ? { label: Ge, value: Ge } : Ge), Ye = TE({ data: We }), [fe, X] = Kn({
    value: mO(m, h),
    defaultValue: mO(y, h),
    finalValue: [],
    onChange: v
  }), pe = qe(!!W && W < fe.length), xe = (Ge) => {
    if (!Re) {
      const kt = fe.filter((ao) => ao !== Ge);
      X(kt), W && kt.length < W && (pe.current = !1);
    }
  }, tt = (Ge) => {
    Kr(Ge.currentTarget.value), !q && !pe.current && A && Rt(!0);
  }, Dt = (Ge) => {
    typeof $ == "function" && $(Ge), !q && !pe.current && A && Rt(!0);
  }, ut = J8({
    data: Ye,
    searchable: A,
    searchValue: er,
    limit: D,
    filter: R,
    value: fe,
    disableSelectedItemFiltering: Ze
  }), Tt = (Ge, kt, ao) => {
    let Co = Ge;
    for (; ao(Co); )
      if (Co = kt(Co), !ut[Co].disabled)
        return Co;
    return Ge;
  };
  sn(() => {
    sr(Fe && er ? 0 : -1);
  }, [er, Fe]), sn(() => {
    !q && fe.length > h.length && Rt(!1), W && fe.length < W && (pe.current = !1), W && fe.length >= W && (pe.current = !0, Rt(!1));
  }, [fe]);
  const lr = (Ge) => {
    if (!Re)
      if (L && Kr(""), fe.includes(Ge.value))
        xe(Ge.value);
      else {
        if (Ge.creatable && typeof oe == "function") {
          const kt = oe(Ge.value);
          typeof kt < "u" && kt !== null && X(typeof kt == "string" ? [...fe, kt] : [...fe, kt.value]);
        } else
          X([...fe, Ge.value]);
        fe.length === W - 1 && (pe.current = !0, Rt(!1)), ct === ut.length - 1 && sr(ut.length - 2), ut.length === 1 && Rt(!1);
      }
  }, oo = (Ge) => {
    typeof j == "function" && j(Ge), de && ut[ct] && Gt && lr(ut[ct]), H && Kr(""), Rt(!1);
  }, as = (Ge) => {
    if (wn || (it == null || it(Ge), Re) || Ge.key !== "Backspace" && W && pe.current)
      return;
    const kt = Gr === "column", ao = () => {
      sr((sa) => {
        var io;
        const is = Tt(sa, (la) => la + 1, (la) => la < ut.length - 1);
        return Gt && (ve.current = Or.current[(io = ut[is]) == null ? void 0 : io.value], Y({
          alignment: kt ? "end" : "start"
        })), is;
      });
    }, Co = () => {
      sr((sa) => {
        var io;
        const is = Tt(sa, (la) => la - 1, (la) => la > 0);
        return Gt && (ve.current = Or.current[(io = ut[is]) == null ? void 0 : io.value], Y({
          alignment: kt ? "start" : "end"
        })), is;
      });
    };
    switch (Ge.key) {
      case "ArrowUp": {
        Ge.preventDefault(), Rt(!0), kt ? Co() : ao();
        break;
      }
      case "ArrowDown": {
        Ge.preventDefault(), Rt(!0), kt ? ao() : Co();
        break;
      }
      case "Enter": {
        Ge.preventDefault(), ut[ct] && Gt ? lr(ut[ct]) : Rt(!0);
        break;
      }
      case " ": {
        A || (Ge.preventDefault(), ut[ct] && Gt ? lr(ut[ct]) : Rt(!0));
        break;
      }
      case "Backspace": {
        fe.length > 0 && er.length === 0 && (X(fe.slice(0, -1)), Rt(!0), W && (pe.current = !1));
        break;
      }
      case "Home": {
        if (!A) {
          Ge.preventDefault(), Gt || Rt(!0);
          const sa = ut.findIndex((io) => !io.disabled);
          sr(sa), Y({
            alignment: kt ? "end" : "start"
          });
        }
        break;
      }
      case "End": {
        if (!A) {
          Ge.preventDefault(), Gt || Rt(!0);
          const sa = ut.map((io) => !!io.disabled).lastIndexOf(!1);
          sr(sa), Y({
            alignment: kt ? "end" : "start"
          });
        }
        break;
      }
      case "Escape":
        Rt(!1);
    }
  }, Ll = fe.map((Ge) => {
    let kt = Ye.find((ao) => ao.value === Ge && !ao.disabled);
    return !kt && He && (kt = {
      value: Ge,
      label: Ge
    }), kt;
  }).filter((Ge) => !!Ge).map((Ge) => /* @__PURE__ */ F.createElement(g, pO(ti({}, Ge), {
    variant: I,
    disabled: q,
    className: Je.value,
    readOnly: Re,
    onRemove: (kt) => {
      kt.preventDefault(), kt.stopPropagation(), xe(Ge.value);
    },
    key: Ge.value,
    size: c,
    styles: f,
    classNames: d,
    radius: ne
  }))), _0 = (Ge) => fe.includes(Ge), V2 = () => {
    var Ge;
    Kr(""), X([]), (Ge = qt.current) == null || Ge.focus(), W && (pe.current = !1);
  };
  He && ie(er, Ye) && (be = ae(er), ut.push({ label: er, value: er, creatable: !0 }));
  const Vl = !Re && (ut.length > 0 ? Gt : Gt && !!N);
  return sn(() => {
    const Ge = Vl ? M : le;
    typeof Ge == "function" && Ge();
  }, [Vl]), /* @__PURE__ */ F.createElement(Xn.Wrapper, ti(ti({
    required: a,
    id: Qt,
    label: i,
    error: u,
    description: l,
    size: c,
    className: n,
    style: o,
    classNames: d,
    styles: f,
    __staticSelector: "MultiSelect",
    sx: se,
    errorProps: Se,
    descriptionProps: nt,
    labelProps: De,
    inputContainer: ye,
    inputWrapperOrder: _e,
    unstyled: we,
    withAsterisk: je
  }, Jt), p), /* @__PURE__ */ F.createElement(Ho, {
    opened: Vl,
    transition: O,
    transitionDuration: w,
    shadow: "sm",
    withinPortal: Z,
    __staticSelector: "MultiSelect",
    onDirectionChange: Mt,
    switchDirectionOnFlip: he,
    zIndex: me,
    dropdownPosition: Oe,
    positionDependencies: [...Ie, er],
    classNames: d,
    styles: f,
    unstyled: we
  }, /* @__PURE__ */ F.createElement(Ho.Target, null, /* @__PURE__ */ F.createElement("div", {
    className: Je.wrapper,
    role: "combobox",
    "aria-haspopup": "listbox",
    "aria-owns": Gt && Vl ? `${Qt}-items` : null,
    "aria-controls": Qt,
    "aria-expanded": Gt,
    onMouseLeave: () => sr(-1),
    tabIndex: -1
  }, /* @__PURE__ */ F.createElement("input", {
    type: "hidden",
    name: ue,
    value: fe.join(","),
    form: Be,
    disabled: q
  }), /* @__PURE__ */ F.createElement(Xn, ti({
    __staticSelector: "MultiSelect",
    style: { overflow: "hidden" },
    component: "div",
    multiline: !0,
    size: c,
    variant: I,
    disabled: q,
    invalid: !!u,
    required: a,
    radius: ne,
    icon: te,
    unstyled: we,
    onMouseDown: (Ge) => {
      var kt;
      Ge.preventDefault(), !q && !pe.current && Rt(!Gt), (kt = qt.current) == null || kt.focus();
    },
    classNames: pO(ti({}, d), {
      input: Ht({ [Je.input]: !A }, d == null ? void 0 : d.input)
    })
  }, aR({
    theme: at,
    rightSection: ee,
    rightSectionWidth: K,
    styles: f,
    size: c,
    shouldClear: B && fe.length > 0,
    clearButtonLabel: U,
    onClear: V2,
    error: u,
    disabled: q,
    clearButtonTabIndex: rt,
    readOnly: Re
  })), /* @__PURE__ */ F.createElement("div", {
    className: Je.values
  }, Ll, /* @__PURE__ */ F.createElement("input", ti({
    ref: Jo(t, qt),
    type: "search",
    id: Qt,
    className: Ht(Je.searchInput, {
      [Je.searchInputPointer]: !A,
      [Je.searchInputInputHidden]: !Gt && fe.length > 0 || !A && fe.length > 0,
      [Je.searchInputEmpty]: fe.length === 0
    }),
    onKeyDown: as,
    value: er,
    onChange: tt,
    onFocus: Dt,
    onBlur: oo,
    readOnly: !A || pe.current || Re,
    placeholder: fe.length === 0 ? k : void 0,
    disabled: q,
    "data-mantine-stop-propagation": Gt,
    autoComplete: "off",
    onCompositionStart: () => $o(!0),
    onCompositionEnd: () => $o(!1)
  }, Yt)))))), /* @__PURE__ */ F.createElement(Ho.Dropdown, {
    component: re || Cp,
    maxHeight: E,
    direction: Gr,
    id: Qt,
    innerRef: Ee,
    __staticSelector: "MultiSelect",
    classNames: d,
    styles: f
  }, /* @__PURE__ */ F.createElement(_g, {
    data: ut,
    hovered: ct,
    classNames: d,
    styles: f,
    uuid: Qt,
    __staticSelector: "MultiSelect",
    onItemHover: sr,
    onItemSelect: lr,
    itemsRefs: Or,
    itemComponent: b,
    size: c,
    nothingFound: N,
    isItemSelected: _0,
    creatable: Q && !!be,
    createLabel: be,
    unstyled: we
  }))));
});
Np.displayName = "@mantine/core/MultiSelect";
var S9 = Object.defineProperty, T9 = Object.defineProperties, E9 = Object.getOwnPropertyDescriptors, Id = Object.getOwnPropertySymbols, lR = Object.prototype.hasOwnProperty, cR = Object.prototype.propertyIsEnumerable, hO = (e, t, r) => t in e ? S9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, jm = (e, t) => {
  for (var r in t || (t = {}))
    lR.call(t, r) && hO(e, r, t[r]);
  if (Id)
    for (var r of Id(t))
      cR.call(t, r) && hO(e, r, t[r]);
  return e;
}, $9 = (e, t) => T9(e, E9(t)), C9 = (e, t) => {
  var r = {};
  for (var n in e)
    lR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Id)
    for (var n of Id(e))
      t.indexOf(n) < 0 && cR.call(e, n) && (r[n] = e[n]);
  return r;
};
const k9 = {
  type: "text",
  size: "sm",
  __staticSelector: "TextInput"
}, Ip = Ne((e, t) => {
  const r = EC("TextInput", k9, e), { inputProps: n, wrapperProps: o } = r, a = C9(r, ["inputProps", "wrapperProps"]);
  return /* @__PURE__ */ F.createElement(Xn.Wrapper, jm({}, o), /* @__PURE__ */ F.createElement(Xn, $9(jm(jm({}, n), a), {
    ref: t
  })));
});
Ip.displayName = "@mantine/core/TextInput";
const uR = Br(!1), R9 = uR.Provider, D9 = () => ar(uR);
function dR({ children: e, openDelay: t = 0, closeDelay: r = 0 }) {
  return /* @__PURE__ */ F.createElement(R9, {
    value: !0
  }, /* @__PURE__ */ F.createElement(dW, {
    delay: { open: t, close: r }
  }, e));
}
dR.displayName = "@mantine/core/TooltipGroup";
var N9 = Object.defineProperty, I9 = Object.defineProperties, M9 = Object.getOwnPropertyDescriptors, yO = Object.getOwnPropertySymbols, A9 = Object.prototype.hasOwnProperty, j9 = Object.prototype.propertyIsEnumerable, vO = (e, t, r) => t in e ? N9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, gO = (e, t) => {
  for (var r in t || (t = {}))
    A9.call(t, r) && vO(e, r, t[r]);
  if (yO)
    for (var r of yO(t))
      j9.call(t, r) && vO(e, r, t[r]);
  return e;
}, F9 = (e, t) => I9(e, M9(t));
function L9(e, t) {
  if (!t)
    return {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[9],
      color: e.white
    };
  const r = e.fn.variant({ variant: "filled", color: t, primaryFallback: !1 });
  return {
    backgroundColor: r.background,
    color: r.color
  };
}
var V9 = Qe((e, { color: t, radius: r, width: n, multiline: o }) => ({
  tooltip: F9(gO(gO({}, e.fn.fontStyles()), L9(e, t)), {
    lineHeight: e.lineHeight,
    fontSize: e.fontSizes.sm,
    borderRadius: e.fn.radius(r),
    padding: `calc(${e.spacing.xs}px / 2) ${e.spacing.xs}px`,
    position: "absolute",
    whiteSpace: o ? "unset" : "nowrap",
    pointerEvents: "none",
    width: n
  }),
  arrow: {
    backgroundColor: "inherit",
    border: 0,
    zIndex: 1
  }
}));
const fR = V9, pR = {
  children: "Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
};
function z9({
  offset: e,
  position: t
}) {
  const [r, n] = Me(!1), o = qe(), { x: a, y: i, reference: l, floating: c, refs: u, update: d, placement: f } = Dg({
    placement: t,
    middleware: [
      $g({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), p = f.includes("right") ? e : t.includes("left") ? e * -1 : 0, m = f.includes("bottom") ? e : t.includes("top") ? e * -1 : 0, y = qn(({ clientX: h, clientY: v }) => {
    l({
      getBoundingClientRect() {
        return {
          width: 0,
          height: 0,
          x: h,
          y: v,
          left: h + p,
          top: v + m,
          right: h,
          bottom: v
        };
      }
    });
  }, [l]);
  return Ue(() => {
    if (u.floating.current) {
      const h = o.current;
      h.addEventListener("mousemove", y);
      const v = uo(u.floating.current);
      return v.forEach((g) => {
        g.addEventListener("scroll", d);
      }), () => {
        h.removeEventListener("mousemove", y), v.forEach((g) => {
          g.removeEventListener("scroll", d);
        });
      };
    }
  }, [l, u.floating.current, d, y, r]), { handleMouseMove: y, x: a, y: i, opened: r, setOpened: n, boundaryRef: o, floating: c };
}
var B9 = Object.defineProperty, W9 = Object.defineProperties, U9 = Object.getOwnPropertyDescriptors, Md = Object.getOwnPropertySymbols, mR = Object.prototype.hasOwnProperty, hR = Object.prototype.propertyIsEnumerable, bO = (e, t, r) => t in e ? B9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Fm = (e, t) => {
  for (var r in t || (t = {}))
    mR.call(t, r) && bO(e, r, t[r]);
  if (Md)
    for (var r of Md(t))
      hR.call(t, r) && bO(e, r, t[r]);
  return e;
}, Lm = (e, t) => W9(e, U9(t)), H9 = (e, t) => {
  var r = {};
  for (var n in e)
    mR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Md)
    for (var n of Md(e))
      t.indexOf(n) < 0 && hR.call(e, n) && (r[n] = e[n]);
  return r;
};
const Y9 = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  position: "right",
  zIndex: Oo("popover")
};
function yR(e) {
  var t;
  const r = Xe("TooltipFloating", Y9, e), {
    children: n,
    refProp: o,
    withinPortal: a,
    style: i,
    className: l,
    classNames: c,
    styles: u,
    unstyled: d,
    radius: f,
    color: p,
    label: m,
    offset: y,
    position: h,
    multiline: v,
    width: g,
    zIndex: b,
    disabled: x
  } = r, O = H9(r, [
    "children",
    "refProp",
    "withinPortal",
    "style",
    "className",
    "classNames",
    "styles",
    "unstyled",
    "radius",
    "color",
    "label",
    "offset",
    "position",
    "multiline",
    "width",
    "zIndex",
    "disabled"
  ]), { handleMouseMove: w, x: S, y: E, opened: C, boundaryRef: N, floating: $, setOpened: j } = z9({
    offset: y,
    position: h
  }), { classes: A, cx: k } = fR({ radius: f, color: p, multiline: v, width: g }, { name: "TooltipFloating", classNames: c, styles: u, unstyled: d });
  if (!_l(n))
    throw new Error(pR.children);
  const R = Jo(N, n.ref), D = (B) => {
    var H, U;
    (U = (H = n.props).onMouseEnter) == null || U.call(H, B), w(B), j(!0);
  }, L = (B) => {
    var H, U;
    (U = (H = n.props).onMouseLeave) == null || U.call(H, B), j(!1);
  };
  return /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(Pl, {
    withinPortal: a
  }, /* @__PURE__ */ F.createElement(Ke, Lm(Fm({}, O), {
    ref: $,
    className: k(A.tooltip, l),
    style: Lm(Fm({}, i), {
      zIndex: b,
      display: !x && C ? "block" : "none",
      top: E ?? "",
      left: (t = Math.round(S)) != null ? t : ""
    })
  }), m)), on(n, Lm(Fm({}, n.props), {
    [o]: R,
    onMouseEnter: D,
    onMouseLeave: L
  })));
}
yR.displayName = "@mantine/core/TooltipFloating";
function q9(e) {
  const [t, r] = Me(!1), o = typeof e.opened == "boolean" ? e.opened : t, a = D9(), i = Zo(), { delay: l, currentId: c, setCurrentId: u } = iC(), d = qn((C) => {
    r(C), C && u(i);
  }, [u, i]), {
    x: f,
    y: p,
    reference: m,
    floating: y,
    context: h,
    refs: v,
    update: g,
    placement: b,
    middlewareData: { arrow: { x, y: O } = {} }
  } = Dg({
    placement: e.position,
    open: o,
    onOpenChange: d,
    middleware: [
      H$(e.offset),
      $g({ padding: 8 }),
      W$(),
      tC({ element: e.arrowRef, padding: e.arrowOffset }),
      ...e.inline ? [U$()] : []
    ]
  }), { getReferenceProps: w, getFloatingProps: S } = OW([
    uW(h, {
      enabled: e.events.hover,
      delay: a ? l : { open: e.openDelay, close: e.closeDelay },
      mouseOnly: !e.events.touch
    }),
    xW(h, { enabled: e.events.focus, keyboardOnly: !0 }),
    _W(h, { role: "tooltip" }),
    wW(h, { enabled: typeof e.opened === void 0 }),
    fW(h, { id: i })
  ]);
  return lC({
    opened: o,
    positionDependencies: e.positionDependencies,
    floating: { refs: v, update: g }
  }), sn(() => {
    var C;
    (C = e.onPositionChange) == null || C.call(e, b);
  }, [b]), {
    x: f,
    y: p,
    arrowX: x,
    arrowY: O,
    reference: m,
    floating: y,
    getFloatingProps: S,
    getReferenceProps: w,
    isGroupPhase: o && c && c !== i,
    opened: o,
    placement: b
  };
}
var G9 = Object.defineProperty, K9 = Object.defineProperties, X9 = Object.getOwnPropertyDescriptors, Ad = Object.getOwnPropertySymbols, vR = Object.prototype.hasOwnProperty, gR = Object.prototype.propertyIsEnumerable, wO = (e, t, r) => t in e ? G9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, ys = (e, t) => {
  for (var r in t || (t = {}))
    vR.call(t, r) && wO(e, r, t[r]);
  if (Ad)
    for (var r of Ad(t))
      gR.call(t, r) && wO(e, r, t[r]);
  return e;
}, Q9 = (e, t) => K9(e, X9(t)), Z9 = (e, t) => {
  var r = {};
  for (var n in e)
    vR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Ad)
    for (var n of Ad(e))
      t.indexOf(n) < 0 && gR.call(e, n) && (r[n] = e[n]);
  return r;
};
const J9 = {
  position: "top",
  refProp: "ref",
  withinPortal: !1,
  inline: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transition: "fade",
  transitionDuration: 100,
  width: "auto",
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: Oo("popover"),
  positionDependencies: []
}, Mp = Ne((e, t) => {
  const r = qe(null), n = Xe("Tooltip", J9, e), {
    children: o,
    position: a,
    refProp: i,
    label: l,
    openDelay: c,
    closeDelay: u,
    onPositionChange: d,
    opened: f,
    withinPortal: p,
    radius: m,
    color: y,
    classNames: h,
    styles: v,
    unstyled: g,
    style: b,
    className: x,
    withArrow: O,
    arrowSize: w,
    arrowOffset: S,
    arrowRadius: E,
    arrowPosition: C,
    offset: N,
    transition: $,
    transitionDuration: j,
    multiline: A,
    width: k,
    events: R,
    zIndex: D,
    disabled: L,
    positionDependencies: B,
    onClick: H,
    onMouseEnter: U,
    onMouseLeave: I,
    inline: V
  } = n, G = Z9(n, [
    "children",
    "position",
    "refProp",
    "label",
    "openDelay",
    "closeDelay",
    "onPositionChange",
    "opened",
    "withinPortal",
    "radius",
    "color",
    "classNames",
    "styles",
    "unstyled",
    "style",
    "className",
    "withArrow",
    "arrowSize",
    "arrowOffset",
    "arrowRadius",
    "arrowPosition",
    "offset",
    "transition",
    "transitionDuration",
    "multiline",
    "width",
    "events",
    "zIndex",
    "disabled",
    "positionDependencies",
    "onClick",
    "onMouseEnter",
    "onMouseLeave",
    "inline"
  ]), { classes: q, cx: J, theme: ne } = fR({ radius: m, color: y, width: k, multiline: A }, { name: "Tooltip", classNames: h, styles: v, unstyled: g }), te = q9({
    position: _C(ne.dir, a),
    closeDelay: u,
    openDelay: c,
    onPositionChange: d,
    opened: f,
    events: R,
    arrowRef: r,
    arrowOffset: S,
    offset: N + (O ? w / 2 : 0),
    positionDependencies: [...B, o],
    inline: V
  });
  if (!_l(o))
    throw new Error(pR.children);
  const ee = Jo(te.reference, o.ref, t);
  return /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(Pl, {
    withinPortal: p
  }, /* @__PURE__ */ F.createElement(Dp, {
    mounted: !L && te.opened,
    transition: $,
    duration: te.isGroupPhase ? 10 : j
  }, (K) => {
    var Q, ae;
    return /* @__PURE__ */ F.createElement(Ke, ys(ys({}, G), te.getFloatingProps({
      ref: te.floating,
      className: q.tooltip,
      style: Q9(ys(ys({}, b), K), {
        zIndex: D,
        top: (Q = te.y) != null ? Q : 0,
        left: (ae = te.x) != null ? ae : 0
      })
    })), l, /* @__PURE__ */ F.createElement(Ng, {
      ref: r,
      arrowX: te.arrowX,
      arrowY: te.arrowY,
      visible: O,
      withBorder: !1,
      position: te.placement,
      arrowSize: w,
      arrowOffset: S,
      arrowRadius: E,
      arrowPosition: C,
      className: q.arrow
    }));
  })), on(o, te.getReferenceProps(ys({
    onClick: H,
    onMouseEnter: U,
    onMouseLeave: I,
    onMouseMove: e.onMouseMove,
    onPointerDown: e.onPointerDown,
    onPointerEnter: e.onPointerEnter,
    [i]: ee,
    className: J(x, o.props.className)
  }, o.props))));
});
Mp.Group = dR;
Mp.Floating = yR;
Mp.displayName = "@mantine/core/Tooltip";
const Ba = Mp;
function e7({
  data: e,
  searchable: t,
  limit: r,
  searchValue: n,
  filter: o,
  value: a,
  filterDataOnExactSearchMatch: i
}) {
  if (!t)
    return e;
  const l = a != null && e.find((u) => u.value === a) || null;
  if (l && !i && (l == null ? void 0 : l.label) === n) {
    if (r) {
      if (r >= e.length)
        return e;
      const u = e.indexOf(l), d = u + r, f = d - e.length;
      return f > 0 ? e.slice(u - f) : e.slice(u, d);
    }
    return e;
  }
  const c = [];
  for (let u = 0; u < e.length && (o(n, e[u]) && c.push(e[u]), !(c.length >= r)); u += 1)
    ;
  return c;
}
var t7 = Qe(() => ({
  input: {
    "&:not(:disabled)": {
      cursor: "pointer",
      "&::selection": {
        backgroundColor: "transparent"
      }
    }
  }
}));
const r7 = t7;
var n7 = Object.defineProperty, o7 = Object.defineProperties, a7 = Object.getOwnPropertyDescriptors, jd = Object.getOwnPropertySymbols, bR = Object.prototype.hasOwnProperty, wR = Object.prototype.propertyIsEnumerable, xO = (e, t, r) => t in e ? n7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, vs = (e, t) => {
  for (var r in t || (t = {}))
    bR.call(t, r) && xO(e, r, t[r]);
  if (jd)
    for (var r of jd(t))
      wR.call(t, r) && xO(e, r, t[r]);
  return e;
}, Vm = (e, t) => o7(e, a7(t)), i7 = (e, t) => {
  var r = {};
  for (var n in e)
    bR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && jd)
    for (var n of jd(e))
      t.indexOf(n) < 0 && wR.call(e, n) && (r[n] = e[n]);
  return r;
};
function s7(e, t) {
  return t.label.toLowerCase().trim().includes(e.toLowerCase().trim());
}
function l7(e, t) {
  return !!e && !t.some((r) => r.label.toLowerCase() === e.toLowerCase());
}
const c7 = {
  required: !1,
  size: "sm",
  shadow: "sm",
  itemComponent: Og,
  transition: "fade",
  transitionDuration: 0,
  initiallyOpened: !1,
  filter: s7,
  maxDropdownHeight: 220,
  searchable: !1,
  clearable: !1,
  limit: 1 / 0,
  disabled: !1,
  creatable: !1,
  shouldCreate: l7,
  selectOnBlur: !1,
  switchDirectionOnFlip: !1,
  filterDataOnExactSearchMatch: !1,
  zIndex: Oo("popover"),
  clearButtonTabIndex: 0,
  positionDependencies: [],
  dropdownPosition: "flip"
}, Ji = Ne((e, t) => {
  const r = EC("Select", c7, e), {
    inputProps: n,
    wrapperProps: o,
    shadow: a,
    data: i,
    value: l,
    defaultValue: c,
    onChange: u,
    itemComponent: d,
    onKeyDown: f,
    onBlur: p,
    onFocus: m,
    transition: y,
    transitionDuration: h,
    initiallyOpened: v,
    transitionTimingFunction: g,
    unstyled: b,
    classNames: x,
    styles: O,
    filter: w,
    maxDropdownHeight: S,
    searchable: E,
    clearable: C,
    nothingFound: N,
    clearButtonLabel: $,
    limit: j,
    disabled: A,
    onSearchChange: k,
    searchValue: R,
    rightSection: D,
    rightSectionWidth: L,
    creatable: B,
    getCreateLabel: H,
    shouldCreate: U,
    selectOnBlur: I,
    onCreate: V,
    dropdownComponent: G,
    onDropdownClose: q,
    onDropdownOpen: J,
    withinPortal: ne,
    switchDirectionOnFlip: te,
    zIndex: ee,
    name: K,
    dropdownPosition: Q,
    allowDeselect: ae,
    placeholder: ie,
    filterDataOnExactSearchMatch: oe,
    clearButtonTabIndex: se,
    form: re,
    positionDependencies: le,
    readOnly: M,
    hoverOnSearchChange: W
  } = r, Z = i7(r, [
    "inputProps",
    "wrapperProps",
    "shadow",
    "data",
    "value",
    "defaultValue",
    "onChange",
    "itemComponent",
    "onKeyDown",
    "onBlur",
    "onFocus",
    "transition",
    "transitionDuration",
    "initiallyOpened",
    "transitionTimingFunction",
    "unstyled",
    "classNames",
    "styles",
    "filter",
    "maxDropdownHeight",
    "searchable",
    "clearable",
    "nothingFound",
    "clearButtonLabel",
    "limit",
    "disabled",
    "onSearchChange",
    "searchValue",
    "rightSection",
    "rightSectionWidth",
    "creatable",
    "getCreateLabel",
    "shouldCreate",
    "selectOnBlur",
    "onCreate",
    "dropdownComponent",
    "onDropdownClose",
    "onDropdownOpen",
    "withinPortal",
    "switchDirectionOnFlip",
    "zIndex",
    "name",
    "dropdownPosition",
    "allowDeselect",
    "placeholder",
    "filterDataOnExactSearchMatch",
    "clearButtonTabIndex",
    "form",
    "positionDependencies",
    "readOnly",
    "hoverOnSearchChange"
  ]), { classes: he, cx: me, theme: de } = r7(), [ue, Oe] = Me(v), [Se, De] = Me(-1), nt = qe(), rt = qe({}), [Be, Ie] = Me("column"), it = Be === "column", { scrollIntoView: we, targetRef: ye, scrollableRef: _e } = UE({
    duration: 0,
    offset: 5,
    cancelable: !1,
    isList: !0
  }), Re = ae === void 0 ? C : ae, je = (be) => {
    if (ue !== be) {
      Oe(be);
      const We = be ? J : q;
      typeof We == "function" && We();
    }
  }, Fe = B && typeof H == "function";
  let Ze = null;
  const ft = i.map((be) => typeof be == "string" ? { label: be, value: be } : be), Je = TE({ data: ft }), [Ht, at, Jt] = Kn({
    value: l,
    defaultValue: c,
    finalValue: null,
    onChange: u
  }), Yt = Je.find((be) => be.value === Ht), [qt, Or] = Kn({
    value: R,
    defaultValue: (Yt == null ? void 0 : Yt.label) || "",
    finalValue: void 0,
    onChange: k
  }), Qt = (be) => {
    Or(be), E && typeof k == "function" && k(be);
  }, Gt = () => {
    var be;
    M || (at(null), Jt || Qt(""), (be = nt.current) == null || be.focus());
  };
  Ue(() => {
    const be = Je.find((We) => We.value === Ht);
    be ? Qt(be.label) : (!Fe || !Ht) && Qt("");
  }, [Ht]), Ue(() => {
    Yt && (!E || !ue) && Qt(Yt.label);
  }, [Yt == null ? void 0 : Yt.label]);
  const Rt = (be) => {
    if (!M)
      if (Re && (Yt == null ? void 0 : Yt.value) === be.value)
        at(null), je(!1);
      else {
        if (be.creatable && typeof V == "function") {
          const We = V(be.value);
          typeof We < "u" && We !== null && at(typeof We == "string" ? We : We.value);
        } else
          at(be.value);
        Jt || Qt(be.label), De(-1), je(!1), nt.current.focus();
      }
  }, ct = e7({
    data: Je,
    searchable: E,
    limit: j,
    searchValue: qt,
    filter: w,
    filterDataOnExactSearchMatch: oe,
    value: Ht
  });
  Fe && U(qt, ct) && (Ze = H(qt), ct.push({ label: qt, value: qt, creatable: !0 }));
  const sr = (be, We, Ye) => {
    let fe = be;
    for (; Ye(fe); )
      if (fe = We(fe), !ct[fe].disabled)
        return fe;
    return be;
  };
  sn(() => {
    De(W && qt ? 0 : -1);
  }, [qt, W]);
  const Gr = Ht ? ct.findIndex((be) => be.value === Ht) : 0, Mt = !M && (ct.length > 0 ? ue : ue && !!N), er = () => {
    De((be) => {
      var We;
      const Ye = sr(be, (fe) => fe - 1, (fe) => fe > 0);
      return ye.current = rt.current[(We = ct[Ye]) == null ? void 0 : We.value], Mt && we({ alignment: it ? "start" : "end" }), Ye;
    });
  }, Kr = () => {
    De((be) => {
      var We;
      const Ye = sr(be, (fe) => fe + 1, (fe) => fe < ct.length - 1);
      return ye.current = rt.current[(We = ct[Ye]) == null ? void 0 : We.value], Mt && we({ alignment: it ? "end" : "start" }), Ye;
    });
  }, wn = () => window.setTimeout(() => {
    var be;
    ye.current = rt.current[(be = ct[Gr]) == null ? void 0 : be.value], we({ alignment: it ? "end" : "start" });
  }, 0);
  sn(() => {
    Mt && wn();
  }, [Mt]);
  const $o = (be) => {
    switch (typeof f == "function" && f(be), be.key) {
      case "ArrowUp": {
        be.preventDefault(), ue ? it ? er() : Kr() : (De(Gr), je(!0), wn());
        break;
      }
      case "ArrowDown": {
        be.preventDefault(), ue ? it ? Kr() : er() : (De(Gr), je(!0), wn());
        break;
      }
      case "Home": {
        if (!E) {
          be.preventDefault(), ue || je(!0);
          const We = ct.findIndex((Ye) => !Ye.disabled);
          De(We), Mt && we({ alignment: it ? "end" : "start" });
        }
        break;
      }
      case "End": {
        if (!E) {
          be.preventDefault(), ue || je(!0);
          const We = ct.map((Ye) => !!Ye.disabled).lastIndexOf(!1);
          De(We), Mt && we({ alignment: it ? "end" : "start" });
        }
        break;
      }
      case "Escape": {
        be.preventDefault(), je(!1), De(-1);
        break;
      }
      case " ": {
        E || (be.preventDefault(), ct[Se] && ue ? Rt(ct[Se]) : (je(!0), De(Gr), wn()));
        break;
      }
      case "Enter":
        E || be.preventDefault(), ct[Se] && ue && (be.preventDefault(), Rt(ct[Se]));
    }
  }, Y = (be) => {
    typeof p == "function" && p(be);
    const We = Je.find((Ye) => Ye.value === Ht);
    I && ct[Se] && ue && Rt(ct[Se]), Qt((We == null ? void 0 : We.label) || ""), je(!1);
  }, ve = (be) => {
    typeof m == "function" && m(be), E && je(!0);
  }, Ee = (be) => {
    M || (Qt(be.currentTarget.value), C && be.currentTarget.value === "" && at(null), De(-1), je(!0));
  }, He = () => {
    M || (je(!ue), Ht && !ue && De(Gr));
  };
  return /* @__PURE__ */ F.createElement(Xn.Wrapper, Vm(vs({}, o), {
    __staticSelector: "Select"
  }), /* @__PURE__ */ F.createElement(Ho, {
    opened: Mt,
    transition: y,
    transitionDuration: h,
    shadow: "sm",
    withinPortal: ne,
    __staticSelector: "Select",
    onDirectionChange: Ie,
    switchDirectionOnFlip: te,
    zIndex: ee,
    dropdownPosition: Q,
    positionDependencies: [...le, qt],
    classNames: x,
    styles: O,
    unstyled: b
  }, /* @__PURE__ */ F.createElement(Ho.Target, null, /* @__PURE__ */ F.createElement("div", {
    role: "combobox",
    "aria-haspopup": "listbox",
    "aria-owns": Mt ? `${n.id}-items` : null,
    "aria-controls": n.id,
    "aria-expanded": Mt,
    onMouseLeave: () => De(-1),
    tabIndex: -1
  }, /* @__PURE__ */ F.createElement("input", {
    type: "hidden",
    name: K,
    value: Ht || "",
    form: re,
    disabled: A
  }), /* @__PURE__ */ F.createElement(Xn, vs(Vm(vs(vs({
    autoComplete: "off",
    type: "search"
  }, n), Z), {
    ref: Jo(t, nt),
    onKeyDown: $o,
    __staticSelector: "Select",
    value: qt,
    placeholder: ie,
    onChange: Ee,
    "aria-autocomplete": "list",
    "aria-controls": Mt ? `${n.id}-items` : null,
    "aria-activedescendant": Se >= 0 ? `${n.id}-${Se}` : null,
    onMouseDown: He,
    onBlur: Y,
    onFocus: ve,
    readOnly: !E || M,
    disabled: A,
    "data-mantine-stop-propagation": Mt,
    name: null,
    classNames: Vm(vs({}, x), {
      input: me({ [he.input]: !E }, x == null ? void 0 : x.input)
    })
  }), aR({
    theme: de,
    rightSection: D,
    rightSectionWidth: L,
    styles: O,
    size: n.size,
    shouldClear: C && !!Yt,
    clearButtonLabel: $,
    onClear: Gt,
    error: o.error,
    clearButtonTabIndex: se,
    disabled: A,
    readOnly: M
  }))))), /* @__PURE__ */ F.createElement(Ho.Dropdown, {
    component: G || Cp,
    maxHeight: S,
    direction: Be,
    id: n.id,
    innerRef: _e,
    __staticSelector: "Select",
    classNames: x,
    styles: O
  }, /* @__PURE__ */ F.createElement(_g, {
    data: ct,
    hovered: Se,
    classNames: x,
    styles: O,
    isItemSelected: (be) => be === Ht,
    uuid: n.id,
    __staticSelector: "Select",
    onItemHover: De,
    onItemSelect: Rt,
    itemsRefs: rt,
    itemComponent: d,
    size: n.size,
    nothingFound: N,
    creatable: Fe && !!Ze,
    createLabel: Ze,
    "aria-label": o.label,
    unstyled: b
  }))));
});
Ji.displayName = "@mantine/core/Select";
const u7 = _o({
  "from, to": { opacity: 0.4 },
  "50%": { opacity: 1 }
});
var d7 = Qe((e, { height: t, width: r, radius: n, circle: o, animate: a }) => ({
  root: {
    height: t,
    width: o ? t : r,
    borderRadius: o ? t : e.fn.radius(n),
    position: "relative",
    WebkitTransform: "translateZ(0)"
  },
  visible: {
    overflow: "hidden",
    "&::before": {
      content: '""',
      position: "absolute",
      background: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      zIndex: 10
    },
    "&::after": {
      content: '""',
      position: "absolute",
      background: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3],
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      animation: a ? `${u7} 1500ms linear infinite` : "none",
      zIndex: 11
    }
  }
}));
const f7 = d7;
var p7 = Object.defineProperty, Fd = Object.getOwnPropertySymbols, xR = Object.prototype.hasOwnProperty, _R = Object.prototype.propertyIsEnumerable, _O = (e, t, r) => t in e ? p7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, m7 = (e, t) => {
  for (var r in t || (t = {}))
    xR.call(t, r) && _O(e, r, t[r]);
  if (Fd)
    for (var r of Fd(t))
      _R.call(t, r) && _O(e, r, t[r]);
  return e;
}, h7 = (e, t) => {
  var r = {};
  for (var n in e)
    xR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Fd)
    for (var n of Fd(e))
      t.indexOf(n) < 0 && _R.call(e, n) && (r[n] = e[n]);
  return r;
};
const y7 = {
  height: "auto",
  width: "100%",
  visible: !0,
  animate: !0
}, OR = Ne((e, t) => {
  const r = Xe("Skeleton", y7, e), { height: n, width: o, visible: a, animate: i, className: l, circle: c, radius: u, unstyled: d } = r, f = h7(r, ["height", "width", "visible", "animate", "className", "circle", "radius", "unstyled"]), { classes: p, cx: m } = f7({ height: n, width: o, circle: c, radius: u, animate: i }, { unstyled: d, name: "Skeleton" });
  return /* @__PURE__ */ F.createElement(Ke, m7({
    className: m(p.root, { [p.visible]: a }, l),
    ref: t
  }, f));
});
OR.displayName = "@mantine/core/Skeleton";
const PR = Br(null), v7 = PR.Provider, g7 = () => ar(PR);
var b7 = Object.defineProperty, Ld = Object.getOwnPropertySymbols, SR = Object.prototype.hasOwnProperty, TR = Object.prototype.propertyIsEnumerable, OO = (e, t, r) => t in e ? b7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, PO = (e, t) => {
  for (var r in t || (t = {}))
    SR.call(t, r) && OO(e, r, t[r]);
  if (Ld)
    for (var r of Ld(t))
      TR.call(t, r) && OO(e, r, t[r]);
  return e;
}, w7 = (e, t) => {
  var r = {};
  for (var n in e)
    SR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Ld)
    for (var n of Ld(e))
      t.indexOf(n) < 0 && TR.call(e, n) && (r[n] = e[n]);
  return r;
};
const x7 = {
  orientation: "horizontal",
  spacing: "lg",
  size: "sm",
  offset: "xs"
}, ER = Ne((e, t) => {
  const r = Xe("SwitchGroup", x7, e), {
    children: n,
    value: o,
    defaultValue: a,
    onChange: i,
    orientation: l,
    spacing: c,
    size: u,
    wrapperProps: d,
    offset: f
  } = r, p = w7(r, [
    "children",
    "value",
    "defaultValue",
    "onChange",
    "orientation",
    "spacing",
    "size",
    "wrapperProps",
    "offset"
  ]), [m, y] = Kn({
    value: o,
    defaultValue: a,
    finalValue: [],
    onChange: i
  }), h = (v) => {
    const g = v.currentTarget.value;
    y(m.includes(g) ? m.filter((b) => b !== g) : [...m, g]);
  };
  return /* @__PURE__ */ F.createElement(v7, {
    value: { value: m, onChange: h, size: u }
  }, /* @__PURE__ */ F.createElement(Xn.Wrapper, PO(PO({
    labelElement: "div",
    size: u,
    __staticSelector: "SwitchGroup",
    ref: t
  }, d), p), /* @__PURE__ */ F.createElement(nk, {
    spacing: c,
    orientation: l,
    offset: f
  }, n)));
});
ER.displayName = "@mantine/core/SwitchGroup";
var _7 = Object.defineProperty, O7 = Object.defineProperties, P7 = Object.getOwnPropertyDescriptors, SO = Object.getOwnPropertySymbols, S7 = Object.prototype.hasOwnProperty, T7 = Object.prototype.propertyIsEnumerable, TO = (e, t, r) => t in e ? _7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, E7 = (e, t) => {
  for (var r in t || (t = {}))
    S7.call(t, r) && TO(e, r, t[r]);
  if (SO)
    for (var r of SO(t))
      T7.call(t, r) && TO(e, r, t[r]);
  return e;
}, $7 = (e, t) => O7(e, P7(t));
const C7 = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
}, k7 = {
  xs: 32,
  sm: 38,
  md: 46,
  lg: 56,
  xl: 72
}, R7 = {
  xs: 12,
  sm: 14,
  md: 18,
  lg: 22,
  xl: 28
}, D7 = {
  xs: 5,
  sm: 6,
  md: 7,
  lg: 9,
  xl: 11
}, N7 = {
  xs: 4,
  sm: 5,
  md: 6,
  lg: 8,
  xl: 10
};
var I7 = Qe((e, { size: t, radius: r, color: n, labelPosition: o, error: a }) => {
  const i = e.fn.size({ size: t, sizes: R7 }), l = e.fn.size({ size: r, sizes: e.radius }), c = e.fn.variant({ variant: "filled", color: n }), u = e.fn.size({ size: t, sizes: k7 }), d = t === "xs" ? 1 : 2, f = e.fn.variant({ variant: "filled", color: "red" }).background;
  return {
    input: {
      clip: "rect(1px, 1px, 1px, 1px)",
      height: 0,
      width: 0,
      overflow: "hidden",
      whiteSpace: "nowrap",
      padding: 0,
      WebkitClipPath: "inset(50%)",
      clipPath: "inset(50%)",
      position: "absolute"
    },
    track: $7(E7({}, e.fn.focusStyles("input:focus + &")), {
      cursor: e.cursorType,
      overflow: "hidden",
      WebkitTapHighlightColor: "transparent",
      position: "relative",
      borderRadius: l,
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[2],
      border: `1px solid ${a ? f : e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}`,
      height: e.fn.size({ size: t, sizes: C7 }),
      minWidth: u,
      margin: 0,
      transitionProperty: "background-color, border-color",
      transitionTimingFunction: e.transitionTimingFunction,
      transitionDuration: "150ms",
      boxSizing: "border-box",
      appearance: "none",
      display: "flex",
      alignItems: "center",
      fontSize: e.fn.size({ size: t, sizes: D7 }),
      fontWeight: 600,
      order: o === "left" ? 2 : 1,
      userSelect: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none",
      MsUserSelect: "none",
      zIndex: 0,
      lineHeight: 0,
      color: e.colorScheme === "dark" ? e.colors.dark[1] : e.colors.gray[6],
      transition: `color 150ms ${e.transitionTimingFunction}`,
      "input:checked + &": {
        backgroundColor: c.background,
        borderColor: c.background,
        color: e.white,
        transition: `color 150ms ${e.transitionTimingFunction}`
      },
      "input:disabled + &": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        cursor: "not-allowed"
      }
    }),
    thumb: {
      position: "absolute",
      zIndex: 1,
      borderRadius: l,
      boxSizing: "border-box",
      display: "flex",
      backgroundColor: e.white,
      height: i,
      width: i,
      border: `1px solid ${e.colorScheme === "dark" ? e.white : e.colors.gray[3]}`,
      left: `${d}px`,
      transition: `left 150ms ${e.transitionTimingFunction}`,
      "& > *": {
        margin: "auto"
      },
      "@media (prefers-reduced-motion)": {
        transitionDuration: e.respectReducedMotion ? "0ms" : ""
      },
      "input:checked + * > &": {
        left: `calc(100% - ${i}px - ${d}px)`,
        borderColor: e.white
      },
      "input:disabled + * > &": {
        borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[0]
      }
    },
    trackLabel: {
      height: "100%",
      display: "grid",
      placeContent: "center",
      minWidth: u - i,
      paddingInline: e.fn.size({ size: t, sizes: N7 }),
      margin: `0 0 0 ${i + d}px`,
      transition: `margin 150ms ${e.transitionTimingFunction}`,
      "input:checked + * > &": {
        margin: `0 ${i + d}px 0 0`
      }
    }
  };
});
const M7 = I7;
var A7 = Object.defineProperty, j7 = Object.defineProperties, F7 = Object.getOwnPropertyDescriptors, Vd = Object.getOwnPropertySymbols, $R = Object.prototype.hasOwnProperty, CR = Object.prototype.propertyIsEnumerable, EO = (e, t, r) => t in e ? A7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, zm = (e, t) => {
  for (var r in t || (t = {}))
    $R.call(t, r) && EO(e, r, t[r]);
  if (Vd)
    for (var r of Vd(t))
      CR.call(t, r) && EO(e, r, t[r]);
  return e;
}, L7 = (e, t) => j7(e, F7(t)), V7 = (e, t) => {
  var r = {};
  for (var n in e)
    $R.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Vd)
    for (var n of Vd(e))
      t.indexOf(n) < 0 && CR.call(e, n) && (r[n] = e[n]);
  return r;
};
const z7 = {
  offLabel: "",
  onLabel: "",
  size: "sm",
  radius: "xl",
  error: !1
}, mi = Ne((e, t) => {
  var r;
  const n = Xe("Switch", z7, e), {
    className: o,
    color: a,
    label: i,
    offLabel: l,
    onLabel: c,
    id: u,
    style: d,
    size: f,
    radius: p,
    wrapperProps: m,
    children: y,
    unstyled: h,
    styles: v,
    classNames: g,
    thumbIcon: b,
    sx: x,
    checked: O,
    defaultChecked: w,
    onChange: S,
    labelPosition: E,
    description: C,
    error: N,
    disabled: $
  } = n, j = V7(n, [
    "className",
    "color",
    "label",
    "offLabel",
    "onLabel",
    "id",
    "style",
    "size",
    "radius",
    "wrapperProps",
    "children",
    "unstyled",
    "styles",
    "classNames",
    "thumbIcon",
    "sx",
    "checked",
    "defaultChecked",
    "onChange",
    "labelPosition",
    "description",
    "error",
    "disabled"
  ]), A = g7(), { classes: k } = M7({ size: (A == null ? void 0 : A.size) || f, color: a, radius: p, labelPosition: E, error: !!N }, { unstyled: h, styles: v, classNames: g, name: "Switch" }), { systemStyles: R, rest: D } = Xi(j), L = Zo(u), B = A ? {
    checked: A.value.includes(D.value),
    onChange: A.onChange
  } : {}, [H, U] = Kn({
    value: (r = B.checked) != null ? r : O,
    defaultValue: w,
    finalValue: !1
  });
  return /* @__PURE__ */ F.createElement(Fg, zm(zm({
    className: o,
    sx: x,
    style: d,
    id: L,
    size: (A == null ? void 0 : A.size) || f,
    labelPosition: E,
    label: i,
    description: C,
    error: N,
    disabled: $,
    __staticSelector: "Switch",
    classNames: g,
    styles: v,
    unstyled: h,
    "data-checked": B.checked || void 0
  }, R), m), /* @__PURE__ */ F.createElement("input", L7(zm({}, D), {
    disabled: $,
    checked: H,
    onChange: (I) => {
      A ? B.onChange(I) : S == null || S(I), U(I.currentTarget.checked);
    },
    id: L,
    ref: t,
    type: "checkbox",
    className: k.input
  })), /* @__PURE__ */ F.createElement("label", {
    htmlFor: L,
    className: k.track
  }, /* @__PURE__ */ F.createElement("div", {
    className: k.thumb
  }, b), /* @__PURE__ */ F.createElement("div", {
    className: k.trackLabel
  }, H ? c : l)));
});
mi.displayName = "@mantine/core/Switch";
mi.Group = ER;
var B7 = Object.defineProperty, W7 = Object.defineProperties, U7 = Object.getOwnPropertyDescriptors, $O = Object.getOwnPropertySymbols, H7 = Object.prototype.hasOwnProperty, Y7 = Object.prototype.propertyIsEnumerable, CO = (e, t, r) => t in e ? B7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, q7 = (e, t) => {
  for (var r in t || (t = {}))
    H7.call(t, r) && CO(e, r, t[r]);
  if ($O)
    for (var r of $O(t))
      Y7.call(t, r) && CO(e, r, t[r]);
  return e;
}, G7 = (e, t) => W7(e, U7(t)), K7 = Qe((e, {
  captionSide: t,
  horizontalSpacing: r,
  verticalSpacing: n,
  fontSize: o,
  withBorder: a,
  withColumnBorders: i
}) => {
  const l = `1px solid ${e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]}`;
  return {
    root: G7(q7({}, e.fn.fontStyles()), {
      width: "100%",
      borderCollapse: "collapse",
      captionSide: t,
      color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
      lineHeight: e.lineHeight,
      border: a ? l : "",
      "& caption": {
        marginTop: t === "top" ? 0 : e.spacing.xs,
        marginBottom: t === "bottom" ? 0 : e.spacing.xs,
        fontSize: e.fontSizes.sm,
        color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6]
      },
      "& thead tr th, & tfoot tr th, & tbody tr th": {
        textAlign: "left",
        fontWeight: "bold",
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
        fontSize: e.fn.size({ size: o, sizes: e.fontSizes }),
        padding: `${e.fn.size({
          size: n,
          sizes: e.spacing
        })}px ${e.fn.size({ size: r, sizes: e.spacing })}px`
      },
      "& thead tr th": {
        borderBottom: l
      },
      "& tfoot tr th, & tbody tr th": {
        borderTop: l
      },
      "& tbody tr td": {
        padding: `${e.fn.size({
          size: n,
          sizes: e.spacing
        })}px ${e.fn.size({ size: r, sizes: e.spacing })}px`,
        borderTop: l,
        fontSize: e.fn.size({ size: o, sizes: e.fontSizes })
      },
      "& tbody tr:first-of-type td, & tbody tr:first-of-type th": {
        borderTop: "none"
      },
      "& thead th, & tbody td": {
        borderRight: i ? l : "none",
        "&:last-of-type": {
          borderRight: "none",
          borderLeft: i ? l : "none"
        }
      },
      "& tbody tr th": {
        borderRight: i ? l : "none"
      },
      "&[data-striped] tbody tr:nth-of-type(odd)": {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
      },
      "&[data-hover] tbody tr": e.fn.hover({
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1]
      })
    })
  };
});
const X7 = K7;
var Q7 = Object.defineProperty, Z7 = Object.defineProperties, J7 = Object.getOwnPropertyDescriptors, zd = Object.getOwnPropertySymbols, kR = Object.prototype.hasOwnProperty, RR = Object.prototype.propertyIsEnumerable, kO = (e, t, r) => t in e ? Q7(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, eY = (e, t) => {
  for (var r in t || (t = {}))
    kR.call(t, r) && kO(e, r, t[r]);
  if (zd)
    for (var r of zd(t))
      RR.call(t, r) && kO(e, r, t[r]);
  return e;
}, tY = (e, t) => Z7(e, J7(t)), rY = (e, t) => {
  var r = {};
  for (var n in e)
    kR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && zd)
    for (var n of zd(e))
      t.indexOf(n) < 0 && RR.call(e, n) && (r[n] = e[n]);
  return r;
};
const nY = {
  striped: !1,
  highlightOnHover: !1,
  captionSide: "top",
  horizontalSpacing: "xs",
  fontSize: "sm",
  verticalSpacing: 7,
  withBorder: !1,
  withColumnBorders: !1
}, DR = Ne((e, t) => {
  const r = Xe("Table", nY, e), {
    className: n,
    children: o,
    striped: a,
    highlightOnHover: i,
    captionSide: l,
    horizontalSpacing: c,
    verticalSpacing: u,
    fontSize: d,
    unstyled: f,
    withBorder: p,
    withColumnBorders: m
  } = r, y = rY(r, [
    "className",
    "children",
    "striped",
    "highlightOnHover",
    "captionSide",
    "horizontalSpacing",
    "verticalSpacing",
    "fontSize",
    "unstyled",
    "withBorder",
    "withColumnBorders"
  ]), { classes: h, cx: v } = X7({ captionSide: l, verticalSpacing: u, horizontalSpacing: c, fontSize: d, withBorder: p, withColumnBorders: m }, { unstyled: f, name: "Table" });
  return /* @__PURE__ */ F.createElement(Ke, tY(eY({}, y), {
    component: "table",
    ref: t,
    className: v(h.root, n),
    "data-striped": a || void 0,
    "data-hover": i || void 0
  }), o);
});
DR.displayName = "@mantine/core/Table";
const oy = {
  context: "Tabs component was not found in the tree",
  value: "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value"
}, [oY, Bg] = _p(oy.context);
var aY = Object.defineProperty, RO = Object.getOwnPropertySymbols, iY = Object.prototype.hasOwnProperty, sY = Object.prototype.propertyIsEnumerable, DO = (e, t, r) => t in e ? aY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, lY = (e, t) => {
  for (var r in t || (t = {}))
    iY.call(t, r) && DO(e, r, t[r]);
  if (RO)
    for (var r of RO(t))
      sY.call(t, r) && DO(e, r, t[r]);
  return e;
};
function cY({ variant: e, orientation: t, inverted: r, placement: n }, o) {
  const a = t === "vertical";
  return e === "default" ? {
    [a ? n === "left" ? "borderRight" : "borderLeft" : r ? "borderTop" : "borderBottom"]: `2px solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`
  } : e === "outline" ? {
    [a ? n === "left" ? "borderRight" : "borderLeft" : r ? "borderTop" : "borderBottom"]: `1px solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`
  } : e === "pills" ? {
    gap: `calc(${o.spacing.sm}px / 2)`
  } : {};
}
var uY = Qe((e, t) => {
  const r = t.orientation === "vertical";
  return {
    tabsList: lY({
      display: "flex",
      flexWrap: "wrap",
      flexDirection: r ? "column" : "row",
      justifyContent: ZC[t.position],
      '& [role="tab"]': {
        flex: t.grow ? 1 : void 0
      }
    }, cY(t, e))
  };
});
const dY = uY;
var fY = Object.defineProperty, pY = Object.defineProperties, mY = Object.getOwnPropertyDescriptors, Bd = Object.getOwnPropertySymbols, NR = Object.prototype.hasOwnProperty, IR = Object.prototype.propertyIsEnumerable, NO = (e, t, r) => t in e ? fY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, hY = (e, t) => {
  for (var r in t || (t = {}))
    NR.call(t, r) && NO(e, r, t[r]);
  if (Bd)
    for (var r of Bd(t))
      IR.call(t, r) && NO(e, r, t[r]);
  return e;
}, yY = (e, t) => pY(e, mY(t)), vY = (e, t) => {
  var r = {};
  for (var n in e)
    NR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Bd)
    for (var n of Bd(e))
      t.indexOf(n) < 0 && IR.call(e, n) && (r[n] = e[n]);
  return r;
};
const gY = {
  grow: !1,
  position: "left"
}, MR = Ne((e, t) => {
  const r = Xe("TabsList", gY, e), { children: n, className: o, grow: a, position: i } = r, l = vY(r, ["children", "className", "grow", "position"]), { orientation: c, variant: u, color: d, radius: f, inverted: p, placement: m, classNames: y, styles: h, unstyled: v } = Bg(), { classes: g, cx: b } = dY({ orientation: c, grow: a, variant: u, color: d, position: i, radius: f, inverted: p, placement: m }, { name: "Tabs", unstyled: v, classNames: y, styles: h });
  return /* @__PURE__ */ F.createElement(Ke, yY(hY({}, l), {
    className: b(g.tabsList, o),
    ref: t,
    role: "tablist",
    "aria-orientation": c
  }), n);
});
MR.displayName = "@mantine/core/TabsList";
var bY = Qe((e, { orientation: t }) => ({
  panel: {
    flex: t === "vertical" ? 1 : void 0
  }
}));
const wY = bY;
var xY = Object.defineProperty, _Y = Object.defineProperties, OY = Object.getOwnPropertyDescriptors, Wd = Object.getOwnPropertySymbols, AR = Object.prototype.hasOwnProperty, jR = Object.prototype.propertyIsEnumerable, IO = (e, t, r) => t in e ? xY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, PY = (e, t) => {
  for (var r in t || (t = {}))
    AR.call(t, r) && IO(e, r, t[r]);
  if (Wd)
    for (var r of Wd(t))
      jR.call(t, r) && IO(e, r, t[r]);
  return e;
}, SY = (e, t) => _Y(e, OY(t)), TY = (e, t) => {
  var r = {};
  for (var n in e)
    AR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Wd)
    for (var n of Wd(e))
      t.indexOf(n) < 0 && jR.call(e, n) && (r[n] = e[n]);
  return r;
};
const EY = {}, FR = Ne((e, t) => {
  const r = Xe("TabsPanel", EY, e), { value: n, children: o, sx: a, className: i } = r, l = TY(r, ["value", "children", "sx", "className"]), c = Bg(), { classes: u, cx: d } = wY({
    orientation: c.orientation,
    variant: c.variant,
    color: c.color,
    radius: c.radius,
    inverted: c.inverted,
    placement: c.placement
  }, { name: "Tabs", unstyled: c.unstyled, classNames: c.classNames, styles: c.styles }), f = c.value === n, p = c.keepMounted || f ? o : null;
  return /* @__PURE__ */ F.createElement(Ke, SY(PY({}, l), {
    ref: t,
    sx: [{ display: f ? void 0 : "none" }, ...nl(a)],
    className: d(u.panel, i),
    role: "tabpanel",
    id: c.getPanelId(n),
    "aria-labelledby": c.getTabId(n)
  }), p);
});
FR.displayName = "@mantine/core/TabsPanel";
var $Y = Object.defineProperty, CY = Object.defineProperties, kY = Object.getOwnPropertyDescriptors, MO = Object.getOwnPropertySymbols, RY = Object.prototype.hasOwnProperty, DY = Object.prototype.propertyIsEnumerable, AO = (e, t, r) => t in e ? $Y(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, hi = (e, t) => {
  for (var r in t || (t = {}))
    RY.call(t, r) && AO(e, r, t[r]);
  if (MO)
    for (var r of MO(t))
      DY.call(t, r) && AO(e, r, t[r]);
  return e;
}, jO = (e, t) => CY(e, kY(t));
function NY(e, { variant: t, orientation: r, color: n, radius: o, inverted: a, placement: i }) {
  const l = r === "vertical", c = e.fn.variant({ color: n, variant: "filled" }), u = e.fn.radius(o), d = r === "vertical" ? i === "left" ? `${u}px 0 0 ${u}px` : ` 0 ${u}px ${u}px 0` : a ? `0 0 ${u}px ${u}px` : `${u}px ${u}px 0 0`;
  return t === "default" ? jO(hi({
    [l ? i === "left" ? "borderRight" : "borderLeft" : a ? "borderTop" : "borderBottom"]: "2px solid transparent",
    [l ? i === "left" ? "marginRight" : "marginLeft" : a ? "marginTop" : "marginBottom"]: -2,
    borderRadius: d
  }, e.fn.hover({
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
    borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3]
  })), {
    "&[data-active]": hi({
      borderColor: c.background,
      color: e.colorScheme === "dark" ? e.white : e.black
    }, e.fn.hover({ borderColor: c.background }))
  }) : t === "outline" ? {
    borderRadius: d,
    border: "1px solid transparent",
    [l ? i === "left" ? "borderRight" : "borderLeft" : a ? "borderTop" : "borderBottom"]: "none",
    "&[data-active]": {
      borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3],
      "&::before": {
        content: '""',
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
        position: "absolute",
        bottom: l ? 0 : a ? "unset" : -1,
        top: l ? 0 : a ? -1 : "unset",
        [l ? "width" : "height"]: 1,
        right: l ? i === "left" ? -1 : "unset" : 0,
        left: l ? i === "left" ? "unset" : -1 : 0
      }
    }
  } : t === "pills" ? jO(hi({
    borderRadius: e.fn.radius(o)
  }, e.fn.hover({
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
  })), {
    "&[data-active]": hi({
      backgroundColor: c.background,
      color: e.white
    }, e.fn.hover({ backgroundColor: c.background }))
  }) : {};
}
var IY = Qe((e, t) => ({
  tabLabel: {},
  tab: hi({
    position: "relative",
    padding: `${e.spacing.xs}px ${e.spacing.md}px`,
    paddingLeft: t.withIcon ? e.spacing.xs : void 0,
    paddingRight: t.withRightSection ? e.spacing.xs : void 0,
    fontSize: e.fontSizes.sm,
    whiteSpace: "nowrap",
    zIndex: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: t.orientation === "horizontal" ? "center" : void 0,
    lineHeight: 1,
    "&:disabled": hi({
      opacity: 0.5,
      cursor: "not-allowed"
    }, e.fn.hover({ backgroundColor: "transparent" })),
    "&:focus": {
      zIndex: 1
    }
  }, NY(e, t)),
  tabRightSection: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&:not(:only-child)": {
      marginLeft: 7
    }
  },
  tabIcon: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&:not(:only-child)": {
      marginRight: 7
    }
  }
}));
const MY = IY;
var AY = Object.defineProperty, jY = Object.defineProperties, FY = Object.getOwnPropertyDescriptors, Ud = Object.getOwnPropertySymbols, LR = Object.prototype.hasOwnProperty, VR = Object.prototype.propertyIsEnumerable, FO = (e, t, r) => t in e ? AY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, LY = (e, t) => {
  for (var r in t || (t = {}))
    LR.call(t, r) && FO(e, r, t[r]);
  if (Ud)
    for (var r of Ud(t))
      VR.call(t, r) && FO(e, r, t[r]);
  return e;
}, VY = (e, t) => jY(e, FY(t)), zY = (e, t) => {
  var r = {};
  for (var n in e)
    LR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Ud)
    for (var n of Ud(e))
      t.indexOf(n) < 0 && VR.call(e, n) && (r[n] = e[n]);
  return r;
};
const BY = {}, zR = Ne((e, t) => {
  const r = Xe("TabsTab", BY, e), { value: n, children: o, onKeyDown: a, onClick: i, className: l, icon: c, rightSection: u, color: d } = r, f = zY(r, ["value", "children", "onKeyDown", "onClick", "className", "icon", "rightSection", "color"]), p = Bg(), m = !!c, y = !!u, { theme: h, classes: v, cx: g } = MY({
    withIcon: m || y && !o,
    withRightSection: y || m && !o,
    orientation: p.orientation,
    color: d || p.color,
    variant: p.variant,
    radius: p.radius,
    inverted: p.inverted,
    placement: p.placement
  }, { name: "Tabs", unstyled: p.unstyled, classNames: p.classNames, styles: p.styles }), b = n === p.value, x = (O) => {
    p.onTabChange(p.allowTabDeactivation && n === p.value ? null : n), i == null || i(O);
  };
  return /* @__PURE__ */ F.createElement(Op, VY(LY({}, f), {
    unstyled: p.unstyled,
    className: g(v.tab, l),
    "data-active": b || void 0,
    ref: t,
    type: "button",
    role: "tab",
    id: p.getTabId(n),
    "aria-selected": b,
    tabIndex: b || p.value === null ? 0 : -1,
    "aria-controls": p.getPanelId(n),
    onClick: x,
    onKeyDown: SE({
      siblingSelector: '[role="tab"]',
      parentSelector: '[role="tablist"]',
      activateOnFocus: p.activateTabWithKeyboard,
      loop: p.loop,
      dir: h.dir,
      orientation: p.orientation,
      onKeyDown: a
    })
  }), c && /* @__PURE__ */ F.createElement("div", {
    className: v.tabIcon
  }, c), o && /* @__PURE__ */ F.createElement("div", {
    className: v.tabLabel
  }, o), u && /* @__PURE__ */ F.createElement("div", {
    className: v.tabRightSection
  }, u));
});
zR.displayName = "@mantine/core/Tab";
function BR({
  defaultValue: e,
  value: t,
  onTabChange: r,
  orientation: n,
  children: o,
  loop: a,
  id: i,
  activateTabWithKeyboard: l,
  allowTabDeactivation: c,
  variant: u,
  color: d,
  radius: f,
  inverted: p,
  placement: m,
  keepMounted: y = !0,
  classNames: h,
  styles: v,
  unstyled: g
}) {
  const b = Zo(i), [x, O] = Kn({
    value: t,
    defaultValue: e,
    finalValue: null,
    onChange: r
  });
  return /* @__PURE__ */ F.createElement(oY, {
    value: {
      placement: m,
      value: x,
      orientation: n,
      id: b,
      loop: a,
      activateTabWithKeyboard: l,
      getTabId: ww(`${b}-tab`, oy.value),
      getPanelId: ww(`${b}-panel`, oy.value),
      onTabChange: O,
      allowTabDeactivation: c,
      variant: u,
      color: d,
      radius: f,
      inverted: p,
      keepMounted: y,
      classNames: h,
      styles: v,
      unstyled: g
    }
  }, o);
}
BR.displayName = "@mantine/core/TabsProvider";
var WY = Qe((e, { orientation: t, placement: r }) => ({
  root: {
    display: t === "vertical" ? "flex" : void 0,
    flexDirection: r === "right" ? "row-reverse" : "row"
  }
}));
const UY = WY;
var HY = Object.defineProperty, YY = Object.defineProperties, qY = Object.getOwnPropertyDescriptors, Hd = Object.getOwnPropertySymbols, WR = Object.prototype.hasOwnProperty, UR = Object.prototype.propertyIsEnumerable, LO = (e, t, r) => t in e ? HY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, GY = (e, t) => {
  for (var r in t || (t = {}))
    WR.call(t, r) && LO(e, r, t[r]);
  if (Hd)
    for (var r of Hd(t))
      UR.call(t, r) && LO(e, r, t[r]);
  return e;
}, KY = (e, t) => YY(e, qY(t)), XY = (e, t) => {
  var r = {};
  for (var n in e)
    WR.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Hd)
    for (var n of Hd(e))
      t.indexOf(n) < 0 && UR.call(e, n) && (r[n] = e[n]);
  return r;
};
const QY = {
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, Fn = Ne((e, t) => {
  const r = Xe("Tabs", QY, e), {
    defaultValue: n,
    value: o,
    orientation: a,
    loop: i,
    activateTabWithKeyboard: l,
    allowTabDeactivation: c,
    children: u,
    id: d,
    onTabChange: f,
    variant: p,
    color: m,
    className: y,
    unstyled: h,
    classNames: v,
    styles: g,
    radius: b,
    inverted: x,
    keepMounted: O,
    placement: w
  } = r, S = XY(r, [
    "defaultValue",
    "value",
    "orientation",
    "loop",
    "activateTabWithKeyboard",
    "allowTabDeactivation",
    "children",
    "id",
    "onTabChange",
    "variant",
    "color",
    "className",
    "unstyled",
    "classNames",
    "styles",
    "radius",
    "inverted",
    "keepMounted",
    "placement"
  ]), { classes: E, cx: C } = UY({ orientation: a, color: m, variant: p, radius: b, inverted: x, placement: w }, { unstyled: h, name: "Tabs", classNames: v, styles: g });
  return /* @__PURE__ */ F.createElement(BR, {
    activateTabWithKeyboard: l,
    defaultValue: n,
    orientation: a,
    onTabChange: f,
    value: o,
    id: d,
    loop: i,
    allowTabDeactivation: c,
    color: m,
    variant: p,
    radius: b,
    inverted: x,
    keepMounted: O,
    placement: w,
    classNames: v,
    styles: g,
    unstyled: h
  }, /* @__PURE__ */ F.createElement(Ke, KY(GY({}, S), {
    className: C(E.root, y),
    id: d,
    ref: t
  }), u));
});
Fn.List = MR;
Fn.Tab = zR;
Fn.Panel = FR;
Fn.displayName = "@mantine/core/Tabs";
function Zr({
  path: e,
  method: t,
  body: r = void 0,
  queryParams: n = void 0
}) {
  let o = {};
  typeof n == "object" && (o = new URLSearchParams(n), e = e + "?" + o);
  const a = {
    method: t,
    mode: "cors",
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    },
    redirect: "follow",
    referrerPolicy: "no-referrer",
    body: r ? JSON.stringify(r) : null
  };
  return { fetchPath: e, options: a };
}
function ZY(e) {
  const t = [];
  if (e.length === 0)
    return "";
  if (typeof e[0] != "string")
    throw new TypeError("Url must be a string. Received " + e[0]);
  e[0].match(/^[^/:]+:\/*$/) && e.length > 1 && (e[0] = e.shift() + e[0]), e[0].match(/^file:\/\/\//) ? e[0] = e[0].replace(/^([^/:]+):\/*/, "$1:///") : e[0] = e[0].replace(/^([^/:]+):\/*/, "$1://");
  for (let o = 0; o < e.length; o++) {
    let a = e[o];
    if (typeof a != "string")
      throw new TypeError("Url must be a string. Received " + a);
    a !== "" && (o > 0 && (a = a.replace(/^[\/]+/, "")), o < e.length - 1 ? a = a.replace(/[\/]+$/, "") : a = a.replace(/[\/]+$/, "/"), t.push(a));
  }
  let r = t.join("/");
  r = r.replace(/\/(\?|&|#[^!])/g, "$1");
  const n = r.split("?");
  return r = n.shift() + (n.length > 0 ? "?" : "") + n.join("&"), r;
}
function Er(...e) {
  const t = Array.from(Array.isArray(e[0]) ? e[0] : e);
  return ZY(t);
}
const JY = { user: null, loading: !0 };
function eq(e, t) {
  switch (t.type) {
    case "initCall":
      return { ...e, loading: !0, error: null };
    case "setUser":
      return { ...e, user: t.payload, loading: !1, error: !1 };
    case "setError":
      return { ...e, user: null, loading: !1, error: t.payload };
    case "setLoading":
      return { ...e, loading: t.payload };
    default:
      return e;
  }
}
function tq(e) {
  const [t, r] = hl(eq, JY);
  Ue(() => {
    n();
  }, []);
  async function n() {
    r({ type: "initCall" });
    try {
      const { fetchPath: c, options: u } = Zr({ path: Er(e, "auth/user"), method: "GET" }), d = await fetch(c, u);
      if (d.ok) {
        const f = await d.json();
        return r({ payload: f, type: "setUser" }), f;
      }
      throw new Error(d.statusText);
    } catch {
      r({ payload: !1, type: "setLoading" });
    }
  }
  async function o({ username: c, password: u }) {
    r({ type: "initCall" });
    try {
      const { fetchPath: d, options: f } = Zr({
        path: Er(e, "auth/login"),
        method: "POST",
        body: { username: c, password: u }
      }), p = await fetch(d, f);
      if (p.ok) {
        const m = await p.json();
        r({ payload: m, type: "setUser" });
      } else
        r({ payload: "Username or password wrong.", type: "setError" });
    } catch {
      r({ payload: "Failed to fetch", type: "setError" });
    }
  }
  async function a() {
    r({ type: "initCall" });
    try {
      const { fetchPath: c, options: u } = Zr({ path: Er(e, "auth/logout"), method: "Get" });
      (await fetch(c, u)).ok ? r({ payload: null, type: "setUser" }) : r({ payload: "Couldn't sign out user", type: "setError" });
    } catch {
      r({ payload: "Failed to fetch", type: "setError" });
    }
  }
  async function i(c) {
    r({ type: "initCall" });
    try {
      const { fetchPath: u, options: d } = Zr({
        path: Er(e, "auth/user"),
        method: "PUT",
        body: c
      }), f = await fetch(u, d);
      if (f.ok) {
        const p = await f.json();
        r({ payload: p, type: "setUser" });
      }
      r({ payload: "Couldn't update user data", type: "setError" });
    } catch {
      r({ payload: "Failed to post", type: "setError" });
    }
  }
  async function l(c) {
    try {
      const { fetchPath: u, options: d } = Zr({
        path: Er(e, "auth/resetpassword"),
        method: "PUT",
        body: { password: c }
      });
      (await fetch(u, d)).ok ? r({ payload: { ...t.user }, type: "setUser" }) : r({ payload: "Couldn't reset password", type: "setError" });
    } catch {
      r({ payload: "Failed to post", type: "setError" });
    }
  }
  return {
    user: t.user,
    loading: t.loading,
    error: t.error,
    signin: o,
    signout: a,
    update: i,
    resetPassword: l
  };
}
function rq(e, t) {
  const { user: r } = t, [n, o] = Me(null), [a, i] = Me(!0), [l, c] = Me({ error: "401 Not authorized", message: "User is not logged in." });
  Ue(() => {
    r && u(e);
  }, [r]);
  const u = async (d) => {
    i(!0);
    try {
      const { fetchPath: f, options: p } = Zr({ path: Er(d, "info/"), method: "GET" }), m = await fetch(f, p);
      if (m.ok) {
        const y = await m.json();
        o(y);
      } else
        c({ error: "404 Not Found", message: "Couldn't fetch info" });
    } catch {
      c({ error: "Network error", message: "Failed to fetch" });
    } finally {
      i(!1);
    }
  };
  return { info: n, loading: a, error: l };
}
const Wg = Br({
  theme: {},
  //Provide a default theme here
  auth: {},
  info: {}
});
function nq() {
  return ar(Wg).auth;
}
function oq() {
  return ar(Wg).info;
}
function kve() {
  return fr() || {};
}
function Rve(e) {
  const t = { baseUrl: "", inheritMantineTheme: !1 }, { baseUrl: r, theme: n, inheritMantineTheme: o, children: a } = { ...t, ...e }, i = o ? { ...fr(), ...n } : { ...qL, ...n }, l = tq(r), c = { baseUrl: r, ...rq(r, l) };
  return /* @__PURE__ */ _.jsx(Wg.Provider, { value: { activeTheme: i, auth: l, info: c }, children: /* @__PURE__ */ _.jsx(ME, { theme: i, withCSSVariables: !0, withNormalizeCSS: !0, withGlobalStyles: !0, children: /* @__PURE__ */ _.jsx(Cu, { theme: GL, children: a }) }) });
}
const aq = async (e, t) => {
  try {
    const { fetchPath: r, options: n } = Zr({
      path: Er(e, "/"),
      method: "GET",
      queryParams: { q: JSON.stringify(t) }
    }), o = await fetch(r, n);
    if (o.ok)
      return await o.json();
    throw new Error(o.statusText);
  } catch (r) {
    throw new Error(r);
  }
}, iq = async (e) => {
  try {
    const { fetchPath: t, options: r } = Zr({ path: Er(e, "_info"), method: "GET" }), n = await fetch(t, r);
    if (n.ok)
      return await n.json();
    throw new Error(n.statusText);
  } catch (t) {
    throw new Error(t);
  }
}, sq = async (e, t) => {
  try {
    const { fetchPath: r, options: n } = Zr({ path: Er(e, t.toString()), method: "GET" }), o = await fetch(r, n);
    if (o.ok)
      return await o.json();
    throw new Error(z);
  } catch (r) {
    throw new Error(r);
  }
}, lq = async (e, t) => {
  try {
    const { fetchPath: r, options: n } = Zr({
      path: Er(e, "/"),
      method: "POST",
      body: t
    }), o = await fetch(r, n);
    if (o.ok)
      return await o.json();
    throw new Error(o.statusText);
  } catch (r) {
    throw new Error(r);
  }
}, cq = async (e, t, r) => {
  try {
    const { fetchPath: n, options: o } = Zr({ path: Er(e, t.toString()), method: "PUT", body: r }), a = await fetch(n, o);
    if (a.ok)
      return await a.json();
    throw new Error(a.statusText);
  } catch (n) {
    throw new Error(n);
  }
}, uq = async (e, t) => {
  try {
    const { fetchPath: r, options: n } = Zr({ path: Er(e, t.toString()), method: "DELETE" }), o = await fetch(r, n);
    if (o.ok)
      return await o.json();
    throw new Error(o.statusText);
  } catch (r) {
    throw new Error(r);
  }
};
function VO(e, t) {
  const r = e || {
    columns: [],
    filters: [],
    // keys: [],
    page: 0,
    page_size: 25
  };
  return t.hasOwnProperty("columns") && (r.columns = t.columns), t.hasOwnProperty("filters") && (r.filters = t.filters), t.hasOwnProperty("order_column") && (r.order_column = t.order_column), t.hasOwnProperty("order_direction") && (r.order_direction = t.order_direction), t.hasOwnProperty("page") && (r.page = t.page), t.hasOwnProperty("page_size") && (r.page_size = t.page_size), r;
}
const zO = (e) => {
  const t = {};
  for (const r of e)
    switch (r.type) {
      case "RelatedList":
        t[r.name] = [];
        break;
      case "Related":
        t[r.name] = {};
        break;
      case "Boolean":
        t[r.name] = "false";
        break;
      case "Date":
      case "DateTime":
        t[r.name] = null;
        break;
      case "Integer":
      case "Float":
        t[r.name] = null;
        break;
      default:
        t[r.name] = "";
    }
  return t;
};
function Wa(e) {
  this._maxSize = e, this.clear();
}
Wa.prototype.clear = function() {
  this._size = 0, this._values = /* @__PURE__ */ Object.create(null);
};
Wa.prototype.get = function(e) {
  return this._values[e];
};
Wa.prototype.set = function(e, t) {
  return this._size >= this._maxSize && this.clear(), e in this._values || this._size++, this._values[e] = t;
};
var dq = /[^.^\]^[]+|(?=\[\]|\.\.)/g, HR = /^\d+$/, fq = /^\d/, pq = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, mq = /^\s*(['"]?)(.*?)(\1)\s*$/, Ug = 512, BO = new Wa(Ug), WO = new Wa(Ug), UO = new Wa(Ug), Pa = {
  Cache: Wa,
  split: ay,
  normalizePath: Bm,
  setter: function(e) {
    var t = Bm(e);
    return WO.get(e) || WO.set(e, function(n, o) {
      for (var a = 0, i = t.length, l = n; a < i - 1; ) {
        var c = t[a];
        if (c === "__proto__" || c === "constructor" || c === "prototype")
          return n;
        l = l[t[a++]];
      }
      l[t[a]] = o;
    });
  },
  getter: function(e, t) {
    var r = Bm(e);
    return UO.get(e) || UO.set(e, function(o) {
      for (var a = 0, i = r.length; a < i; )
        if (o != null || !t)
          o = o[r[a++]];
        else
          return;
      return o;
    });
  },
  join: function(e) {
    return e.reduce(function(t, r) {
      return t + (Hg(r) || HR.test(r) ? "[" + r + "]" : (t ? "." : "") + r);
    }, "");
  },
  forEach: function(e, t, r) {
    hq(Array.isArray(e) ? e : ay(e), t, r);
  }
};
function Bm(e) {
  return BO.get(e) || BO.set(
    e,
    ay(e).map(function(t) {
      return t.replace(mq, "$2");
    })
  );
}
function ay(e) {
  return e.match(dq) || [""];
}
function hq(e, t, r) {
  var n = e.length, o, a, i, l;
  for (a = 0; a < n; a++)
    o = e[a], o && (gq(o) && (o = '"' + o + '"'), l = Hg(o), i = !l && /^\d+$/.test(o), t.call(r, o, l, i, a, e));
}
function Hg(e) {
  return typeof e == "string" && e && ["'", '"'].indexOf(e.charAt(0)) !== -1;
}
function yq(e) {
  return e.match(fq) && !e.match(HR);
}
function vq(e) {
  return pq.test(e);
}
function gq(e) {
  return !Hg(e) && (yq(e) || vq(e));
}
const bq = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['â€™](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['â€™](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['â€™](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['â€™](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g, Ap = (e) => e.match(bq) || [], jp = (e) => e[0].toUpperCase() + e.slice(1), Yg = (e, t) => Ap(e).join(t).toLowerCase(), YR = (e) => Ap(e).reduce(
  (t, r) => `${t}${t ? r[0].toUpperCase() + r.slice(1).toLowerCase() : r.toLowerCase()}`,
  ""
), wq = (e) => jp(YR(e)), xq = (e) => Yg(e, "_"), _q = (e) => Yg(e, "-"), Oq = (e) => jp(Yg(e, " ")), Pq = (e) => Ap(e).map(jp).join(" ");
var Wm = {
  words: Ap,
  upperFirst: jp,
  camelCase: YR,
  pascalCase: wq,
  snakeCase: xq,
  kebabCase: _q,
  sentenceCase: Oq,
  titleCase: Pq
}, qg = { exports: {} };
qg.exports = function(e) {
  return qR(Sq(e), e);
};
qg.exports.array = qR;
function qR(e, t) {
  var r = e.length, n = new Array(r), o = {}, a = r, i = Tq(t), l = Eq(e);
  for (t.forEach(function(u) {
    if (!l.has(u[0]) || !l.has(u[1]))
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
  }); a--; )
    o[a] || c(e[a], a, /* @__PURE__ */ new Set());
  return n;
  function c(u, d, f) {
    if (f.has(u)) {
      var p;
      try {
        p = ", node was:" + JSON.stringify(u);
      } catch {
        p = "";
      }
      throw new Error("Cyclic dependency" + p);
    }
    if (!l.has(u))
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(u));
    if (!o[d]) {
      o[d] = !0;
      var m = i.get(u) || /* @__PURE__ */ new Set();
      if (m = Array.from(m), d = m.length) {
        f.add(u);
        do {
          var y = m[--d];
          c(y, l.get(y), f);
        } while (d);
        f.delete(u);
      }
      n[--r] = u;
    }
  }
}
function Sq(e) {
  for (var t = /* @__PURE__ */ new Set(), r = 0, n = e.length; r < n; r++) {
    var o = e[r];
    t.add(o[0]), t.add(o[1]);
  }
  return Array.from(t);
}
function Tq(e) {
  for (var t = /* @__PURE__ */ new Map(), r = 0, n = e.length; r < n; r++) {
    var o = e[r];
    t.has(o[0]) || t.set(o[0], /* @__PURE__ */ new Set()), t.has(o[1]) || t.set(o[1], /* @__PURE__ */ new Set()), t.get(o[0]).add(o[1]);
  }
  return t;
}
function Eq(e) {
  for (var t = /* @__PURE__ */ new Map(), r = 0, n = e.length; r < n; r++)
    t.set(e[r], r);
  return t;
}
var $q = qg.exports;
const Cq = /* @__PURE__ */ qi($q), kq = Object.prototype.toString, Rq = Error.prototype.toString, Dq = RegExp.prototype.toString, Nq = typeof Symbol < "u" ? Symbol.prototype.toString : () => "", Iq = /^Symbol\((.*)\)(.*)$/;
function Mq(e) {
  return e != +e ? "NaN" : e === 0 && 1 / e < 0 ? "-0" : "" + e;
}
function HO(e, t = !1) {
  if (e == null || e === !0 || e === !1)
    return "" + e;
  const r = typeof e;
  if (r === "number")
    return Mq(e);
  if (r === "string")
    return t ? `"${e}"` : e;
  if (r === "function")
    return "[Function " + (e.name || "anonymous") + "]";
  if (r === "symbol")
    return Nq.call(e).replace(Iq, "Symbol($1)");
  const n = kq.call(e).slice(8, -1);
  return n === "Date" ? isNaN(e.getTime()) ? "" + e : e.toISOString(e) : n === "Error" || e instanceof Error ? "[" + Rq.call(e) + "]" : n === "RegExp" ? Dq.call(e) : null;
}
function fo(e, t) {
  let r = HO(e, t);
  return r !== null ? r : JSON.stringify(e, function(n, o) {
    let a = HO(this[n], t);
    return a !== null ? a : o;
  }, 2);
}
function GR(e) {
  return e == null ? [] : [].concat(e);
}
let Aq = /\$\{\s*(\w+)\s*\}/g;
class br extends Error {
  static formatError(t, r) {
    const n = r.label || r.path || "this";
    return n !== r.path && (r = Object.assign({}, r, {
      path: n
    })), typeof t == "string" ? t.replace(Aq, (o, a) => fo(r[a])) : typeof t == "function" ? t(r) : t;
  }
  static isError(t) {
    return t && t.name === "ValidationError";
  }
  constructor(t, r, n, o) {
    super(), this.value = void 0, this.path = void 0, this.type = void 0, this.errors = void 0, this.params = void 0, this.inner = void 0, this.name = "ValidationError", this.value = r, this.path = n, this.type = o, this.errors = [], this.inner = [], GR(t).forEach((a) => {
      br.isError(a) ? (this.errors.push(...a.errors), this.inner = this.inner.concat(a.inner.length ? a.inner : a)) : this.errors.push(a);
    }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0], Error.captureStackTrace && Error.captureStackTrace(this, br);
  }
}
let Mn = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path: e,
    type: t,
    value: r,
    originalValue: n
  }) => {
    const o = n != null && n !== r ? ` (cast from the value \`${fo(n, !0)}\`).` : ".";
    return t !== "mixed" ? `${e} must be a \`${t}\` type, but the final value was: \`${fo(r, !0)}\`` + o : `${e} must match the configured type. The validated value was: \`${fo(r, !0)}\`` + o;
  }
}, _n = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
}, Mo = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
}, iy = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
}, sy = {
  isValue: "${path} field must be ${value}"
}, ly = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
}, Dc = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
}, jq = {
  notType: (e) => {
    const {
      path: t,
      value: r,
      spec: n
    } = e, o = n.types.length;
    if (Array.isArray(r)) {
      if (r.length < o)
        return `${t} tuple value has too few items, expected a length of ${o} but got ${r.length} for value: \`${fo(r, !0)}\``;
      if (r.length > o)
        return `${t} tuple value has too many items, expected a length of ${o} but got ${r.length} for value: \`${fo(r, !0)}\``;
    }
    return br.formatError(Mn.notType, e);
  }
};
var KR = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed: Mn,
  string: _n,
  number: Mo,
  date: iy,
  object: ly,
  array: Dc,
  boolean: sy
});
const Ua = (e) => e && e.__isYupSchema__;
class Yd {
  static fromOptions(t, r) {
    if (!r.then && !r.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: n,
      then: o,
      otherwise: a
    } = r, i = typeof n == "function" ? n : (...l) => l.every((c) => c === n);
    return new Yd(t, (l, c) => {
      var u;
      let d = i(...l) ? o : a;
      return (u = d == null ? void 0 : d(c)) != null ? u : c;
    });
  }
  constructor(t, r) {
    this.fn = void 0, this.refs = t, this.refs = t, this.fn = r;
  }
  resolve(t, r) {
    let n = this.refs.map((a) => (
      // TODO: ? operator here?
      a.getValue(r == null ? void 0 : r.value, r == null ? void 0 : r.parent, r == null ? void 0 : r.context)
    )), o = this.fn(n, t, r);
    if (o === void 0 || // @ts-ignore this can be base
    o === t)
      return t;
    if (!Ua(o))
      throw new TypeError("conditions must return a schema object");
    return o.resolve(r);
  }
}
const rc = {
  context: "$",
  value: "."
};
function Fq(e, t) {
  return new ta(e, t);
}
class ta {
  constructor(t, r = {}) {
    if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof t != "string")
      throw new TypeError("ref must be a string, got: " + t);
    if (this.key = t.trim(), t === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === rc.context, this.isValue = this.key[0] === rc.value, this.isSibling = !this.isContext && !this.isValue;
    let n = this.isContext ? rc.context : this.isValue ? rc.value : "";
    this.path = this.key.slice(n.length), this.getter = this.path && Pa.getter(this.path, !0), this.map = r.map;
  }
  getValue(t, r, n) {
    let o = this.isContext ? n : this.isValue ? t : r;
    return this.getter && (o = this.getter(o || {})), this.map && (o = this.map(o)), o;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(t, r) {
    return this.getValue(t, r == null ? void 0 : r.parent, r == null ? void 0 : r.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(t) {
    return t && t.__isYupRef;
  }
}
ta.prototype.__isYupRef = !0;
const rn = (e) => e == null;
function ri(e) {
  function t({
    value: r,
    path: n = "",
    options: o,
    originalValue: a,
    schema: i
  }, l, c) {
    const {
      name: u,
      test: d,
      params: f,
      message: p,
      skipAbsent: m
    } = e;
    let {
      parent: y,
      context: h,
      abortEarly: v = i.spec.abortEarly
    } = o;
    function g($) {
      return ta.isRef($) ? $.getValue(r, y, h) : $;
    }
    function b($ = {}) {
      const j = Object.assign({
        value: r,
        originalValue: a,
        label: i.spec.label,
        path: $.path || n,
        spec: i.spec
      }, f, $.params);
      for (const k of Object.keys(j))
        j[k] = g(j[k]);
      const A = new br(br.formatError($.message || p, j), r, j.path, $.type || u);
      return A.params = j, A;
    }
    const x = v ? l : c;
    let O = {
      path: n,
      parent: y,
      type: u,
      from: o.from,
      createError: b,
      resolve: g,
      options: o,
      originalValue: a,
      schema: i
    };
    const w = ($) => {
      br.isError($) ? x($) : $ ? c(null) : x(b());
    }, S = ($) => {
      br.isError($) ? x($) : l($);
    }, E = m && rn(r);
    if (!o.sync) {
      try {
        Promise.resolve(E ? !0 : d.call(O, r, O)).then(w, S);
      } catch ($) {
        S($);
      }
      return;
    }
    let C;
    try {
      var N;
      if (C = E ? !0 : d.call(O, r, O), typeof ((N = C) == null ? void 0 : N.then) == "function")
        throw new Error(`Validation test of type: "${O.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
    } catch ($) {
      S($);
      return;
    }
    w(C);
  }
  return t.OPTIONS = e, t;
}
function Gg(e, t, r, n = r) {
  let o, a, i;
  return t ? (Pa.forEach(t, (l, c, u) => {
    let d = c ? l.slice(1, l.length - 1) : l;
    e = e.resolve({
      context: n,
      parent: o,
      value: r
    });
    let f = e.type === "tuple", p = u ? parseInt(d, 10) : 0;
    if (e.innerType || f) {
      if (f && !u)
        throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${i}" must contain an index to the tuple element, e.g. "${i}[0]"`);
      if (r && p >= r.length)
        throw new Error(`Yup.reach cannot resolve an array item at index: ${l}, in the path: ${t}. because there is no value at that index. `);
      o = r, r = r && r[p], e = f ? e.spec.types[p] : e.innerType;
    }
    if (!u) {
      if (!e.fields || !e.fields[d])
        throw new Error(`The schema does not contain the path: ${t}. (failed at: ${i} which is a type: "${e.type}")`);
      o = r, r = r && r[d], e = e.fields[d];
    }
    a = d, i = c ? "[" + l + "]" : "." + l;
  }), {
    schema: e,
    parent: o,
    parentPath: a
  }) : {
    parent: o,
    parentPath: t,
    schema: e
  };
}
function Lq(e, t, r, n) {
  return Gg(e, t, r, n).schema;
}
class qd extends Set {
  describe() {
    const t = [];
    for (const r of this.values())
      t.push(ta.isRef(r) ? r.describe() : r);
    return t;
  }
  resolveAll(t) {
    let r = [];
    for (const n of this.values())
      r.push(t(n));
    return r;
  }
  clone() {
    return new qd(this.values());
  }
  merge(t, r) {
    const n = this.clone();
    return t.forEach((o) => n.add(o)), r.forEach((o) => n.delete(o)), n;
  }
}
function yi(e, t = /* @__PURE__ */ new Map()) {
  if (Ua(e) || !e || typeof e != "object")
    return e;
  if (t.has(e))
    return t.get(e);
  let r;
  if (e instanceof Date)
    r = new Date(e.getTime()), t.set(e, r);
  else if (e instanceof RegExp)
    r = new RegExp(e), t.set(e, r);
  else if (Array.isArray(e)) {
    r = new Array(e.length), t.set(e, r);
    for (let n = 0; n < e.length; n++)
      r[n] = yi(e[n], t);
  } else if (e instanceof Map) {
    r = /* @__PURE__ */ new Map(), t.set(e, r);
    for (const [n, o] of e.entries())
      r.set(n, yi(o, t));
  } else if (e instanceof Set) {
    r = /* @__PURE__ */ new Set(), t.set(e, r);
    for (const n of e)
      r.add(yi(n, t));
  } else if (e instanceof Object) {
    r = {}, t.set(e, r);
    for (const [n, o] of Object.entries(e))
      r[n] = yi(o, t);
  } else
    throw Error(`Unable to clone ${e}`);
  return r;
}
class yr {
  constructor(t) {
    this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new qd(), this._blacklist = new qd(), this.exclusiveTests = /* @__PURE__ */ Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => {
      this.typeError(Mn.notType);
    }), this.type = t.type, this._typeCheck = t.check, this.spec = Object.assign({
      strip: !1,
      strict: !1,
      abortEarly: !0,
      recursive: !0,
      nullable: !1,
      optional: !0,
      coerce: !0
    }, t == null ? void 0 : t.spec), this.withMutation((r) => {
      r.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(t) {
    if (this._mutate)
      return t && Object.assign(this.spec, t), this;
    const r = Object.create(Object.getPrototypeOf(this));
    return r.type = this.type, r._typeCheck = this._typeCheck, r._whitelist = this._whitelist.clone(), r._blacklist = this._blacklist.clone(), r.internalTests = Object.assign({}, this.internalTests), r.exclusiveTests = Object.assign({}, this.exclusiveTests), r.deps = [...this.deps], r.conditions = [...this.conditions], r.tests = [...this.tests], r.transforms = [...this.transforms], r.spec = yi(Object.assign({}, this.spec, t)), r;
  }
  label(t) {
    let r = this.clone();
    return r.spec.label = t, r;
  }
  meta(...t) {
    if (t.length === 0)
      return this.spec.meta;
    let r = this.clone();
    return r.spec.meta = Object.assign(r.spec.meta || {}, t[0]), r;
  }
  withMutation(t) {
    let r = this._mutate;
    this._mutate = !0;
    let n = t(this);
    return this._mutate = r, n;
  }
  concat(t) {
    if (!t || t === this)
      return this;
    if (t.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`);
    let r = this, n = t.clone();
    const o = Object.assign({}, r.spec, n.spec);
    return n.spec = o, n.internalTests = Object.assign({}, r.internalTests, n.internalTests), n._whitelist = r._whitelist.merge(t._whitelist, t._blacklist), n._blacklist = r._blacklist.merge(t._blacklist, t._whitelist), n.tests = r.tests, n.exclusiveTests = r.exclusiveTests, n.withMutation((a) => {
      t.tests.forEach((i) => {
        a.test(i.OPTIONS);
      });
    }), n.transforms = [...r.transforms, ...n.transforms], n;
  }
  isType(t) {
    return t == null ? !!(this.spec.nullable && t === null || this.spec.optional && t === void 0) : this._typeCheck(t);
  }
  resolve(t) {
    let r = this;
    if (r.conditions.length) {
      let n = r.conditions;
      r = r.clone(), r.conditions = [], r = n.reduce((o, a) => a.resolve(o, t), r), r = r.resolve(t);
    }
    return r;
  }
  resolveOptions(t) {
    var r, n, o;
    return Object.assign({}, t, {
      from: t.from || [],
      strict: (r = t.strict) != null ? r : this.spec.strict,
      abortEarly: (n = t.abortEarly) != null ? n : this.spec.abortEarly,
      recursive: (o = t.recursive) != null ? o : this.spec.recursive
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(t, r = {}) {
    let n = this.resolve(Object.assign({
      value: t
    }, r)), o = r.assert === "ignore-optionality", a = n._cast(t, r);
    if (r.assert !== !1 && !n.isType(a)) {
      if (o && rn(a))
        return a;
      let i = fo(t), l = fo(a);
      throw new TypeError(`The value of ${r.path || "field"} could not be cast to a value that satisfies the schema type: "${n.type}". 

attempted value: ${i} 
` + (l !== i ? `result of cast: ${l}` : ""));
    }
    return a;
  }
  _cast(t, r) {
    let n = t === void 0 ? t : this.transforms.reduce((o, a) => a.call(this, o, t, this), t);
    return n === void 0 && (n = this.getDefault()), n;
  }
  _validate(t, r = {}, n, o) {
    let {
      path: a,
      originalValue: i = t,
      strict: l = this.spec.strict
    } = r, c = t;
    l || (c = this._cast(c, Object.assign({
      assert: !1
    }, r)));
    let u = [];
    for (let d of Object.values(this.internalTests))
      d && u.push(d);
    this.runTests({
      path: a,
      value: c,
      originalValue: i,
      options: r,
      tests: u
    }, n, (d) => {
      if (d.length)
        return o(d, c);
      this.runTests({
        path: a,
        value: c,
        originalValue: i,
        options: r,
        tests: this.tests
      }, n, o);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(t, r, n) {
    let o = !1, {
      tests: a,
      value: i,
      originalValue: l,
      path: c,
      options: u
    } = t, d = (h) => {
      o || (o = !0, r(h, i));
    }, f = (h) => {
      o || (o = !0, n(h, i));
    }, p = a.length, m = [];
    if (!p)
      return f([]);
    let y = {
      value: i,
      originalValue: l,
      path: c,
      options: u,
      schema: this
    };
    for (let h = 0; h < a.length; h++) {
      const v = a[h];
      v(y, d, function(b) {
        b && (m = m.concat(b)), --p <= 0 && f(m);
      });
    }
  }
  asNestedTest({
    key: t,
    index: r,
    parent: n,
    parentPath: o,
    originalParent: a,
    options: i
  }) {
    const l = t ?? r;
    if (l == null)
      throw TypeError("Must include `key` or `index` for nested validations");
    const c = typeof l == "number";
    let u = n[l];
    const d = Object.assign({}, i, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: !0,
      parent: n,
      value: u,
      originalValue: a[l],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [c ? "index" : "key"]: l,
      path: c || l.includes(".") ? `${o || ""}[${u ? l : `"${l}"`}]` : (o ? `${o}.` : "") + t
    });
    return (f, p, m) => this.resolve(d)._validate(u, d, p, m);
  }
  validate(t, r) {
    let n = this.resolve(Object.assign({}, r, {
      value: t
    }));
    return new Promise((o, a) => n._validate(t, r, (i, l) => {
      br.isError(i) && (i.value = l), a(i);
    }, (i, l) => {
      i.length ? a(new br(i, l)) : o(l);
    }));
  }
  validateSync(t, r) {
    let n = this.resolve(Object.assign({}, r, {
      value: t
    })), o;
    return n._validate(t, Object.assign({}, r, {
      sync: !0
    }), (a, i) => {
      throw br.isError(a) && (a.value = i), a;
    }, (a, i) => {
      if (a.length)
        throw new br(a, t);
      o = i;
    }), o;
  }
  isValid(t, r) {
    return this.validate(t, r).then(() => !0, (n) => {
      if (br.isError(n))
        return !1;
      throw n;
    });
  }
  isValidSync(t, r) {
    try {
      return this.validateSync(t, r), !0;
    } catch (n) {
      if (br.isError(n))
        return !1;
      throw n;
    }
  }
  _getDefault() {
    let t = this.spec.default;
    return t == null ? t : typeof t == "function" ? t.call(this) : yi(t);
  }
  getDefault(t) {
    return this.resolve(t || {})._getDefault();
  }
  default(t) {
    return arguments.length === 0 ? this._getDefault() : this.clone({
      default: t
    });
  }
  strict(t = !0) {
    return this.clone({
      strict: t
    });
  }
  nullability(t, r) {
    const n = this.clone({
      nullable: t
    });
    return n.internalTests.nullable = ri({
      message: r,
      name: "nullable",
      test(o) {
        return o === null ? this.schema.spec.nullable : !0;
      }
    }), n;
  }
  optionality(t, r) {
    const n = this.clone({
      optional: t
    });
    return n.internalTests.optionality = ri({
      message: r,
      name: "optionality",
      test(o) {
        return o === void 0 ? this.schema.spec.optional : !0;
      }
    }), n;
  }
  optional() {
    return this.optionality(!0);
  }
  defined(t = Mn.defined) {
    return this.optionality(!1, t);
  }
  nullable() {
    return this.nullability(!0);
  }
  nonNullable(t = Mn.notNull) {
    return this.nullability(!1, t);
  }
  required(t = Mn.required) {
    return this.clone().withMutation((r) => r.nonNullable(t).defined(t));
  }
  notRequired() {
    return this.clone().withMutation((t) => t.nullable().optional());
  }
  transform(t) {
    let r = this.clone();
    return r.transforms.push(t), r;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...t) {
    let r;
    if (t.length === 1 ? typeof t[0] == "function" ? r = {
      test: t[0]
    } : r = t[0] : t.length === 2 ? r = {
      name: t[0],
      test: t[1]
    } : r = {
      name: t[0],
      message: t[1],
      test: t[2]
    }, r.message === void 0 && (r.message = Mn.default), typeof r.test != "function")
      throw new TypeError("`test` is a required parameters");
    let n = this.clone(), o = ri(r), a = r.exclusive || r.name && n.exclusiveTests[r.name] === !0;
    if (r.exclusive && !r.name)
      throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    return r.name && (n.exclusiveTests[r.name] = !!r.exclusive), n.tests = n.tests.filter((i) => !(i.OPTIONS.name === r.name && (a || i.OPTIONS.test === o.OPTIONS.test))), n.tests.push(o), n;
  }
  when(t, r) {
    !Array.isArray(t) && typeof t != "string" && (r = t, t = ".");
    let n = this.clone(), o = GR(t).map((a) => new ta(a));
    return o.forEach((a) => {
      a.isSibling && n.deps.push(a.key);
    }), n.conditions.push(typeof r == "function" ? new Yd(o, r) : Yd.fromOptions(o, r)), n;
  }
  typeError(t) {
    let r = this.clone();
    return r.internalTests.typeError = ri({
      message: t,
      name: "typeError",
      test(n) {
        return !rn(n) && !this.schema._typeCheck(n) ? this.createError({
          params: {
            type: this.schema.type
          }
        }) : !0;
      }
    }), r;
  }
  oneOf(t, r = Mn.oneOf) {
    let n = this.clone();
    return t.forEach((o) => {
      n._whitelist.add(o), n._blacklist.delete(o);
    }), n.internalTests.whiteList = ri({
      message: r,
      name: "oneOf",
      skipAbsent: !0,
      test(o) {
        let a = this.schema._whitelist, i = a.resolveAll(this.resolve);
        return i.includes(o) ? !0 : this.createError({
          params: {
            values: Array.from(a).join(", "),
            resolved: i
          }
        });
      }
    }), n;
  }
  notOneOf(t, r = Mn.notOneOf) {
    let n = this.clone();
    return t.forEach((o) => {
      n._blacklist.add(o), n._whitelist.delete(o);
    }), n.internalTests.blacklist = ri({
      message: r,
      name: "notOneOf",
      test(o) {
        let a = this.schema._blacklist, i = a.resolveAll(this.resolve);
        return i.includes(o) ? this.createError({
          params: {
            values: Array.from(a).join(", "),
            resolved: i
          }
        }) : !0;
      }
    }), n;
  }
  strip(t = !0) {
    let r = this.clone();
    return r.spec.strip = t, r;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(t) {
    const r = (t ? this.resolve(t) : this).clone(), {
      label: n,
      meta: o,
      optional: a,
      nullable: i
    } = r.spec;
    return {
      meta: o,
      label: n,
      optional: a,
      nullable: i,
      default: r.getDefault(t),
      type: r.type,
      oneOf: r._whitelist.describe(),
      notOneOf: r._blacklist.describe(),
      tests: r.tests.map((c) => ({
        name: c.OPTIONS.name,
        params: c.OPTIONS.params
      })).filter((c, u, d) => d.findIndex((f) => f.name === c.name) === u)
    };
  }
}
yr.prototype.__isYupSchema__ = !0;
for (const e of ["validate", "validateSync"])
  yr.prototype[`${e}At`] = function(t, r, n = {}) {
    const {
      parent: o,
      parentPath: a,
      schema: i
    } = Gg(this, t, r, n.context);
    return i[e](o && o[a], Object.assign({}, n, {
      parent: o,
      path: t
    }));
  };
for (const e of ["equals", "is"])
  yr.prototype[e] = yr.prototype.oneOf;
for (const e of ["not", "nope"])
  yr.prototype[e] = yr.prototype.notOneOf;
const Vq = () => !0;
function Kg(e) {
  return new Xg(e);
}
class Xg extends yr {
  constructor(t) {
    super(typeof t == "function" ? {
      type: "mixed",
      check: t
    } : Object.assign({
      type: "mixed",
      check: Vq
    }, t));
  }
}
Kg.prototype = Xg.prototype;
function cy() {
  return new Qg();
}
class Qg extends yr {
  constructor() {
    super({
      type: "boolean",
      check(t) {
        return t instanceof Boolean && (t = t.valueOf()), typeof t == "boolean";
      }
    }), this.withMutation(() => {
      this.transform((t, r, n) => {
        if (n.spec.coerce && !n.isType(t)) {
          if (/^(true|1)$/i.test(String(t)))
            return !0;
          if (/^(false|0)$/i.test(String(t)))
            return !1;
        }
        return t;
      });
    });
  }
  isTrue(t = sy.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "true"
      },
      test(r) {
        return rn(r) || r === !0;
      }
    });
  }
  isFalse(t = sy.isValue) {
    return this.test({
      message: t,
      name: "is-value",
      exclusive: !0,
      params: {
        value: "false"
      },
      test(r) {
        return rn(r) || r === !1;
      }
    });
  }
  default(t) {
    return super.default(t);
  }
  defined(t) {
    return super.defined(t);
  }
  optional() {
    return super.optional();
  }
  required(t) {
    return super.required(t);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(t) {
    return super.nonNullable(t);
  }
  strip(t) {
    return super.strip(t);
  }
}
cy.prototype = Qg.prototype;
let zq = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
), Bq = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
), Wq = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Uq = (e) => rn(e) || e === e.trim(), Hq = {}.toString();
function Gd() {
  return new Zg();
}
class Zg extends yr {
  constructor() {
    super({
      type: "string",
      check(t) {
        return t instanceof String && (t = t.valueOf()), typeof t == "string";
      }
    }), this.withMutation(() => {
      this.transform((t, r, n) => {
        if (!n.spec.coerce || n.isType(t) || Array.isArray(t))
          return t;
        const o = t != null && t.toString ? t.toString() : t;
        return o === Hq ? t : o;
      });
    });
  }
  required(t) {
    return super.required(t).withMutation((r) => r.test({
      message: t || Mn.required,
      name: "required",
      skipAbsent: !0,
      test: (n) => !!n.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((t) => (t.tests = t.tests.filter((r) => r.OPTIONS.name !== "required"), t));
  }
  length(t, r = _n.length) {
    return this.test({
      message: r,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      skipAbsent: !0,
      test(n) {
        return n.length === this.resolve(t);
      }
    });
  }
  min(t, r = _n.min) {
    return this.test({
      message: r,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(n) {
        return n.length >= this.resolve(t);
      }
    });
  }
  max(t, r = _n.max) {
    return this.test({
      name: "max",
      exclusive: !0,
      message: r,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(n) {
        return n.length <= this.resolve(t);
      }
    });
  }
  matches(t, r) {
    let n = !1, o, a;
    return r && (typeof r == "object" ? {
      excludeEmptyString: n = !1,
      message: o,
      name: a
    } = r : o = r), this.test({
      name: a || "matches",
      message: o || _n.matches,
      params: {
        regex: t
      },
      skipAbsent: !0,
      test: (i) => i === "" && n || i.search(t) !== -1
    });
  }
  email(t = _n.email) {
    return this.matches(zq, {
      name: "email",
      message: t,
      excludeEmptyString: !0
    });
  }
  url(t = _n.url) {
    return this.matches(Bq, {
      name: "url",
      message: t,
      excludeEmptyString: !0
    });
  }
  uuid(t = _n.uuid) {
    return this.matches(Wq, {
      name: "uuid",
      message: t,
      excludeEmptyString: !1
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((t) => t === null ? "" : t);
  }
  trim(t = _n.trim) {
    return this.transform((r) => r != null ? r.trim() : r).test({
      message: t,
      name: "trim",
      test: Uq
    });
  }
  lowercase(t = _n.lowercase) {
    return this.transform((r) => rn(r) ? r : r.toLowerCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (r) => rn(r) || r === r.toLowerCase()
    });
  }
  uppercase(t = _n.uppercase) {
    return this.transform((r) => rn(r) ? r : r.toUpperCase()).test({
      message: t,
      name: "string_case",
      exclusive: !0,
      skipAbsent: !0,
      test: (r) => rn(r) || r === r.toUpperCase()
    });
  }
}
Gd.prototype = Zg.prototype;
let Yq = (e) => e != +e;
function XR() {
  return new Jg();
}
class Jg extends yr {
  constructor() {
    super({
      type: "number",
      check(t) {
        return t instanceof Number && (t = t.valueOf()), typeof t == "number" && !Yq(t);
      }
    }), this.withMutation(() => {
      this.transform((t, r, n) => {
        if (!n.spec.coerce)
          return t;
        let o = t;
        if (typeof o == "string") {
          if (o = o.replace(/\s/g, ""), o === "")
            return NaN;
          o = +o;
        }
        return n.isType(o) ? o : parseFloat(o);
      });
    });
  }
  min(t, r = Mo.min) {
    return this.test({
      message: r,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(n) {
        return n >= this.resolve(t);
      }
    });
  }
  max(t, r = Mo.max) {
    return this.test({
      message: r,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(n) {
        return n <= this.resolve(t);
      }
    });
  }
  lessThan(t, r = Mo.lessThan) {
    return this.test({
      message: r,
      name: "max",
      exclusive: !0,
      params: {
        less: t
      },
      skipAbsent: !0,
      test(n) {
        return n < this.resolve(t);
      }
    });
  }
  moreThan(t, r = Mo.moreThan) {
    return this.test({
      message: r,
      name: "min",
      exclusive: !0,
      params: {
        more: t
      },
      skipAbsent: !0,
      test(n) {
        return n > this.resolve(t);
      }
    });
  }
  positive(t = Mo.positive) {
    return this.moreThan(0, t);
  }
  negative(t = Mo.negative) {
    return this.lessThan(0, t);
  }
  integer(t = Mo.integer) {
    return this.test({
      name: "integer",
      message: t,
      skipAbsent: !0,
      test: (r) => Number.isInteger(r)
    });
  }
  truncate() {
    return this.transform((t) => rn(t) ? t : t | 0);
  }
  round(t) {
    var r;
    let n = ["ceil", "floor", "round", "trunc"];
    if (t = ((r = t) == null ? void 0 : r.toLowerCase()) || "round", t === "trunc")
      return this.truncate();
    if (n.indexOf(t.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + n.join(", "));
    return this.transform((o) => rn(o) ? o : Math[t](o));
  }
}
XR.prototype = Jg.prototype;
var qq = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function Gq(e) {
  var t = [1, 4, 5, 6, 7, 10, 11], r = 0, n, o;
  if (o = qq.exec(e)) {
    for (var a = 0, i; i = t[a]; ++a)
      o[i] = +o[i] || 0;
    o[2] = (+o[2] || 1) - 1, o[3] = +o[3] || 1, o[7] = o[7] ? String(o[7]).substr(0, 3) : 0, (o[8] === void 0 || o[8] === "") && (o[9] === void 0 || o[9] === "") ? n = +new Date(o[1], o[2], o[3], o[4], o[5], o[6], o[7]) : (o[8] !== "Z" && o[9] !== void 0 && (r = o[10] * 60 + o[11], o[9] === "+" && (r = 0 - r)), n = Date.UTC(o[1], o[2], o[3], o[4], o[5] + r, o[6], o[7]));
  } else
    n = Date.parse ? Date.parse(e) : NaN;
  return n;
}
let QR = /* @__PURE__ */ new Date(""), Kq = (e) => Object.prototype.toString.call(e) === "[object Date]";
function eb() {
  return new es();
}
class es extends yr {
  constructor() {
    super({
      type: "date",
      check(t) {
        return Kq(t) && !isNaN(t.getTime());
      }
    }), this.withMutation(() => {
      this.transform((t, r, n) => !n.spec.coerce || n.isType(t) ? t : (t = Gq(t), isNaN(t) ? es.INVALID_DATE : new Date(t)));
    });
  }
  prepareParam(t, r) {
    let n;
    if (ta.isRef(t))
      n = t;
    else {
      let o = this.cast(t);
      if (!this._typeCheck(o))
        throw new TypeError(`\`${r}\` must be a Date or a value that can be \`cast()\` to a Date`);
      n = o;
    }
    return n;
  }
  min(t, r = iy.min) {
    let n = this.prepareParam(t, "min");
    return this.test({
      message: r,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      test(o) {
        return o >= this.resolve(n);
      }
    });
  }
  max(t, r = iy.max) {
    let n = this.prepareParam(t, "max");
    return this.test({
      message: r,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(o) {
        return o <= this.resolve(n);
      }
    });
  }
}
es.INVALID_DATE = QR;
eb.prototype = es.prototype;
eb.INVALID_DATE = QR;
function Xq(e, t = []) {
  let r = [], n = /* @__PURE__ */ new Set(), o = new Set(t.map(([i, l]) => `${i}-${l}`));
  function a(i, l) {
    let c = Pa.split(i)[0];
    n.add(c), o.has(`${l}-${c}`) || r.push([l, c]);
  }
  for (const i of Object.keys(e)) {
    let l = e[i];
    n.add(i), ta.isRef(l) && l.isSibling ? a(l.path, i) : Ua(l) && "deps" in l && l.deps.forEach((c) => a(c, i));
  }
  return Cq.array(Array.from(n), r).reverse();
}
function YO(e, t) {
  let r = 1 / 0;
  return e.some((n, o) => {
    var a;
    if ((a = t.path) != null && a.includes(n))
      return r = o, !0;
  }), r;
}
function ZR(e) {
  return (t, r) => YO(e, t) - YO(e, r);
}
const JR = (e, t, r) => {
  if (typeof e != "string")
    return e;
  let n = e;
  try {
    n = JSON.parse(e);
  } catch {
  }
  return r.isType(n) ? n : e;
};
function Nc(e) {
  if ("fields" in e) {
    const t = {};
    for (const [r, n] of Object.entries(e.fields))
      t[r] = Nc(n);
    return e.setFields(t);
  }
  if (e.type === "array") {
    const t = e.optional();
    return t.innerType && (t.innerType = Nc(t.innerType)), t;
  }
  return e.type === "tuple" ? e.optional().clone({
    types: e.spec.types.map(Nc)
  }) : "optional" in e ? e.optional() : e;
}
const Qq = (e, t) => {
  const r = [...Pa.normalizePath(t)];
  if (r.length === 1)
    return r[0] in e;
  let n = r.pop(), o = Pa.getter(Pa.join(r), !0)(e);
  return !!(o && n in o);
};
let qO = (e) => Object.prototype.toString.call(e) === "[object Object]";
function Zq(e, t) {
  let r = Object.keys(e.fields);
  return Object.keys(t).filter((n) => r.indexOf(n) === -1);
}
const Jq = ZR([]);
function il(e) {
  return new tb(e);
}
class tb extends yr {
  constructor(t) {
    super({
      type: "object",
      check(r) {
        return qO(r) || typeof r == "function";
      }
    }), this.fields = /* @__PURE__ */ Object.create(null), this._sortErrors = Jq, this._nodes = [], this._excludedEdges = [], this.withMutation(() => {
      t && this.shape(t);
    });
  }
  _cast(t, r = {}) {
    var n;
    let o = super._cast(t, r);
    if (o === void 0)
      return this.getDefault();
    if (!this._typeCheck(o))
      return o;
    let a = this.fields, i = (n = r.stripUnknown) != null ? n : this.spec.noUnknown, l = [].concat(this._nodes, Object.keys(o).filter((f) => !this._nodes.includes(f))), c = {}, u = Object.assign({}, r, {
      parent: c,
      __validating: r.__validating || !1
    }), d = !1;
    for (const f of l) {
      let p = a[f], m = f in o;
      if (p) {
        let y, h = o[f];
        u.path = (r.path ? `${r.path}.` : "") + f, p = p.resolve({
          value: h,
          context: r.context,
          parent: c
        });
        let v = p instanceof yr ? p.spec : void 0, g = v == null ? void 0 : v.strict;
        if (v != null && v.strip) {
          d = d || f in o;
          continue;
        }
        y = !r.__validating || !g ? (
          // TODO: use _cast, this is double resolving
          p.cast(o[f], u)
        ) : o[f], y !== void 0 && (c[f] = y);
      } else
        m && !i && (c[f] = o[f]);
      (m !== f in c || c[f] !== o[f]) && (d = !0);
    }
    return d ? c : o;
  }
  _validate(t, r = {}, n, o) {
    let {
      from: a = [],
      originalValue: i = t,
      recursive: l = this.spec.recursive
    } = r;
    r.from = [{
      schema: this,
      value: i
    }, ...a], r.__validating = !0, r.originalValue = i, super._validate(t, r, n, (c, u) => {
      if (!l || !qO(u)) {
        o(c, u);
        return;
      }
      i = i || u;
      let d = [];
      for (let f of this._nodes) {
        let p = this.fields[f];
        !p || ta.isRef(p) || d.push(p.asNestedTest({
          options: r,
          key: f,
          parent: u,
          parentPath: r.path,
          originalParent: i
        }));
      }
      this.runTests({
        tests: d,
        value: u,
        originalValue: i,
        options: r
      }, n, (f) => {
        o(f.sort(this._sortErrors).concat(c), u);
      });
    });
  }
  clone(t) {
    const r = super.clone(t);
    return r.fields = Object.assign({}, this.fields), r._nodes = this._nodes, r._excludedEdges = this._excludedEdges, r._sortErrors = this._sortErrors, r;
  }
  concat(t) {
    let r = super.concat(t), n = r.fields;
    for (let [o, a] of Object.entries(this.fields)) {
      const i = n[o];
      n[o] = i === void 0 ? a : i;
    }
    return r.withMutation((o) => o.setFields(n, this._excludedEdges));
  }
  _getDefault() {
    if ("default" in this.spec)
      return super._getDefault();
    if (!this._nodes.length)
      return;
    let t = {};
    return this._nodes.forEach((r) => {
      const n = this.fields[r];
      t[r] = n && "getDefault" in n ? n.getDefault() : void 0;
    }), t;
  }
  setFields(t, r) {
    let n = this.clone();
    return n.fields = t, n._nodes = Xq(t, r), n._sortErrors = ZR(Object.keys(t)), r && (n._excludedEdges = r), n;
  }
  shape(t, r = []) {
    return this.clone().withMutation((n) => {
      let o = n._excludedEdges;
      return r.length && (Array.isArray(r[0]) || (r = [r]), o = [...n._excludedEdges, ...r]), n.setFields(Object.assign(n.fields, t), o);
    });
  }
  partial() {
    const t = {};
    for (const [r, n] of Object.entries(this.fields))
      t[r] = "optional" in n && n.optional instanceof Function ? n.optional() : n;
    return this.setFields(t);
  }
  deepPartial() {
    return Nc(this);
  }
  pick(t) {
    const r = {};
    for (const n of t)
      this.fields[n] && (r[n] = this.fields[n]);
    return this.setFields(r);
  }
  omit(t) {
    const r = Object.assign({}, this.fields);
    for (const n of t)
      delete r[n];
    return this.setFields(r);
  }
  from(t, r, n) {
    let o = Pa.getter(t, !0);
    return this.transform((a) => {
      if (!a)
        return a;
      let i = a;
      return Qq(a, t) && (i = Object.assign({}, a), n || delete i[t], i[r] = o(a)), i;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(JR);
  }
  noUnknown(t = !0, r = ly.noUnknown) {
    typeof t != "boolean" && (r = t, t = !0);
    let n = this.test({
      name: "noUnknown",
      exclusive: !0,
      message: r,
      test(o) {
        if (o == null)
          return !0;
        const a = Zq(this.schema, o);
        return !t || a.length === 0 || this.createError({
          params: {
            unknown: a.join(", ")
          }
        });
      }
    });
    return n.spec.noUnknown = t, n;
  }
  unknown(t = !0, r = ly.noUnknown) {
    return this.noUnknown(!t, r);
  }
  transformKeys(t) {
    return this.transform((r) => {
      if (!r)
        return r;
      const n = {};
      for (const o of Object.keys(r))
        n[t(o)] = r[o];
      return n;
    });
  }
  camelCase() {
    return this.transformKeys(Wm.camelCase);
  }
  snakeCase() {
    return this.transformKeys(Wm.snakeCase);
  }
  constantCase() {
    return this.transformKeys((t) => Wm.snakeCase(t).toUpperCase());
  }
  describe(t) {
    let r = super.describe(t);
    r.fields = {};
    for (const [o, a] of Object.entries(this.fields)) {
      var n;
      let i = t;
      (n = i) != null && n.value && (i = Object.assign({}, i, {
        parent: i.value,
        value: i.value[o]
      })), r.fields[o] = a.describe(i);
    }
    return r;
  }
}
il.prototype = tb.prototype;
function rb(e) {
  return new nb(e);
}
class nb extends yr {
  constructor(t) {
    super({
      type: "array",
      check(r) {
        return Array.isArray(r);
      }
    }), this.innerType = void 0, this.innerType = t;
  }
  _cast(t, r) {
    const n = super._cast(t, r);
    if (!this._typeCheck(n) || !this.innerType)
      return n;
    let o = !1;
    const a = n.map((i, l) => {
      const c = this.innerType.cast(i, Object.assign({}, r, {
        path: `${r.path || ""}[${l}]`
      }));
      return c !== i && (o = !0), c;
    });
    return o ? a : n;
  }
  _validate(t, r = {}, n, o) {
    var a;
    let i = this.innerType, l = (a = r.recursive) != null ? a : this.spec.recursive;
    r.originalValue != null && r.originalValue, super._validate(t, r, n, (c, u) => {
      var d;
      if (!l || !i || !this._typeCheck(u)) {
        o(c, u);
        return;
      }
      let f = new Array(u.length);
      for (let m = 0; m < u.length; m++) {
        var p;
        f[m] = i.asNestedTest({
          options: r,
          index: m,
          parent: u,
          parentPath: r.path,
          originalParent: (p = r.originalValue) != null ? p : t
        });
      }
      this.runTests({
        value: u,
        tests: f,
        originalValue: (d = r.originalValue) != null ? d : t,
        options: r
      }, n, (m) => o(m.concat(c), u));
    });
  }
  clone(t) {
    const r = super.clone(t);
    return r.innerType = this.innerType, r;
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(JR);
  }
  concat(t) {
    let r = super.concat(t);
    return r.innerType = this.innerType, t.innerType && (r.innerType = r.innerType ? (
      // @ts-expect-error Lazy doesn't have concat and will break
      r.innerType.concat(t.innerType)
    ) : t.innerType), r;
  }
  of(t) {
    let r = this.clone();
    if (!Ua(t))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + fo(t));
    return r.innerType = t, r;
  }
  length(t, r = Dc.length) {
    return this.test({
      message: r,
      name: "length",
      exclusive: !0,
      params: {
        length: t
      },
      skipAbsent: !0,
      test(n) {
        return n.length === this.resolve(t);
      }
    });
  }
  min(t, r) {
    return r = r || Dc.min, this.test({
      message: r,
      name: "min",
      exclusive: !0,
      params: {
        min: t
      },
      skipAbsent: !0,
      // FIXME(ts): Array<typeof T>
      test(n) {
        return n.length >= this.resolve(t);
      }
    });
  }
  max(t, r) {
    return r = r || Dc.max, this.test({
      message: r,
      name: "max",
      exclusive: !0,
      params: {
        max: t
      },
      skipAbsent: !0,
      test(n) {
        return n.length <= this.resolve(t);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((t, r) => this._typeCheck(t) ? t : r == null ? [] : [].concat(r));
  }
  compact(t) {
    let r = t ? (n, o, a) => !t(n, o, a) : (n) => !!n;
    return this.transform((n) => n != null ? n.filter(r) : n);
  }
  describe(t) {
    let r = super.describe(t);
    if (this.innerType) {
      var n;
      let o = t;
      (n = o) != null && n.value && (o = Object.assign({}, o, {
        parent: o.value,
        value: o.value[0]
      })), r.innerType = this.innerType.describe(t);
    }
    return r;
  }
}
rb.prototype = nb.prototype;
function eD(e) {
  return new ob(e);
}
class ob extends yr {
  constructor(t) {
    super({
      type: "tuple",
      spec: {
        types: t
      },
      check(r) {
        const n = this.spec.types;
        return Array.isArray(r) && r.length === n.length;
      }
    }), this.withMutation(() => {
      this.typeError(jq.notType);
    });
  }
  _cast(t, r) {
    const {
      types: n
    } = this.spec, o = super._cast(t, r);
    if (!this._typeCheck(o))
      return o;
    let a = !1;
    const i = n.map((l, c) => {
      const u = l.cast(o[c], Object.assign({}, r, {
        path: `${r.path || ""}[${c}]`
      }));
      return u !== o[c] && (a = !0), u;
    });
    return a ? i : o;
  }
  _validate(t, r = {}, n, o) {
    let a = this.spec.types;
    super._validate(t, r, n, (i, l) => {
      var c;
      if (!this._typeCheck(l)) {
        o(i, l);
        return;
      }
      let u = [];
      for (let [f, p] of a.entries()) {
        var d;
        u[f] = p.asNestedTest({
          options: r,
          index: f,
          parent: l,
          parentPath: r.path,
          originalParent: (d = r.originalValue) != null ? d : t
        });
      }
      this.runTests({
        value: l,
        tests: u,
        originalValue: (c = r.originalValue) != null ? c : t,
        options: r
      }, n, (f) => o(f.concat(i), l));
    });
  }
}
eD.prototype = ob.prototype;
function eG(e) {
  return new ab(e);
}
class ab {
  constructor(t) {
    this.type = "lazy", this.__isYupSchema__ = !0, this.spec = void 0, this._resolve = (r, n = {}) => {
      let o = this.builder(r, n);
      if (!Ua(o))
        throw new TypeError("lazy() functions must return a valid schema");
      return this.spec.optional && (o = o.optional()), o.resolve(n);
    }, this.builder = t, this.spec = {
      meta: void 0,
      optional: !1
    };
  }
  clone(t) {
    const r = new ab(this.builder);
    return r.spec = Object.assign({}, this.spec, t), r;
  }
  optionality(t) {
    return this.clone({
      optional: t
    });
  }
  optional() {
    return this.optionality(!0);
  }
  resolve(t) {
    return this._resolve(t.value, t);
  }
  cast(t, r) {
    return this._resolve(t, r).cast(t, r);
  }
  asNestedTest(t) {
    let {
      key: r,
      index: n,
      parent: o,
      options: a
    } = t, i = o[n ?? r];
    return this._resolve(i, Object.assign({}, a, {
      value: i,
      parent: o
    })).asNestedTest(t);
  }
  validate(t, r) {
    return this._resolve(t, r).validate(t, r);
  }
  validateSync(t, r) {
    return this._resolve(t, r).validateSync(t, r);
  }
  validateAt(t, r, n) {
    return this._resolve(r, n).validateAt(t, r, n);
  }
  validateSyncAt(t, r, n) {
    return this._resolve(r, n).validateSyncAt(t, r, n);
  }
  isValid(t, r) {
    return this._resolve(t, r).isValid(t, r);
  }
  isValidSync(t, r) {
    return this._resolve(t, r).isValidSync(t, r);
  }
  describe(t) {
    return t ? this.resolve(t).describe(t) : {
      type: "lazy",
      meta: this.spec.meta,
      label: void 0
    };
  }
  meta(...t) {
    if (t.length === 0)
      return this.spec.meta;
    let r = this.clone();
    return r.spec.meta = Object.assign(r.spec.meta || {}, t[0]), r;
  }
}
function tG(e) {
  Object.keys(e).forEach((t) => {
    Object.keys(e[t]).forEach((r) => {
      KR[t][r] = e[t][r];
    });
  });
}
function rG(e, t, r) {
  if (!e || !Ua(e.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof t != "string")
    throw new TypeError("A Method name must be provided");
  if (typeof r != "function")
    throw new TypeError("Method function must be provided");
  e.prototype[t] = r;
}
const GO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArraySchema: nb,
  BooleanSchema: Qg,
  DateSchema: es,
  MixedSchema: Xg,
  NumberSchema: Jg,
  ObjectSchema: tb,
  Schema: yr,
  StringSchema: Zg,
  TupleSchema: ob,
  ValidationError: br,
  addMethod: rG,
  array: rb,
  bool: cy,
  boolean: cy,
  date: eb,
  defaultLocale: KR,
  getIn: Gg,
  isSchema: Ua,
  lazy: eG,
  mixed: Kg,
  number: XR,
  object: il,
  reach: Lq,
  ref: Fq,
  setLocale: tG,
  string: Gd,
  tuple: eD
}, Symbol.toStringTag, { value: "Module" })), KO = (e) => {
  const t = e.reduce((r, n) => {
    let { name: o, required: a, type: i } = n;
    switch (i) {
      case "RelatedList":
        i = "array";
        break;
      case "Related":
        i = "object";
        break;
      case "Date":
        i = "string";
        break;
      case "Integer":
      case "Float":
        i = "number";
        break;
      default:
        i = "string";
    }
    let l;
    try {
      a ? l = GO[i]().typeError(`Field must be of type ${i}`).required("Field is required") : l = GO[i]().typeError(`Field must be of type ${i}`).nullable(!0);
    } catch (c) {
      console.log(c);
    }
    return r[o] = l, r;
  }, {});
  return il().shape(t);
}, nG = {
  data: null,
  info: null,
  queryParams: null,
  loading: !1,
  error: null
};
function oG(e, t) {
  switch (t.type) {
    case "setData":
      return { ...e, data: t.payload, loading: !1, error: null };
    case "setInfo":
      return { ...e, info: t.payload };
    case "setQueryParams":
      return { ...e, queryParams: { ...t.payload } };
    case "setLoading":
      return { ...e, loading: t.payload };
    case "setError":
      return {
        ...e,
        error: t.payload
      };
    default:
      throw new Error();
  }
}
function aG(e) {
  const [t, r] = hl(oG, {
    ...nG,
    queryParams: e.initialQueryParams ? VO(null, e.initialQueryParams) : null
  });
  Ue(() => {
    t.queryParams && o();
  }, [t.queryParams]), Ue(() => {
    a();
  }, [e.path]);
  const n = (d) => {
    r({ type: "setLoading", payload: !0 });
    const f = VO(t.queryParams, d);
    r({ type: "setQueryParams", payload: f });
  }, o = async () => {
    try {
      const d = e.relation ? {
        ...t.queryParams,
        filters: [
          ...t.queryParams.filters,
          { col: e.relation.foreign_key, opr: e.relation.type, value: e.relation.id }
        ]
      } : t.queryParams, f = await aq(e.path, d);
      return r({ type: "setData", payload: f }), f;
    } catch (d) {
      r({ type: "setError", payload: { message: "Couldn't fetch list", originalError: d } });
    }
  }, a = async () => {
    try {
      const d = await iq(e.path), f = {
        ...d,
        add: {
          columns: d.add_columns,
          title: d.add_title,
          schema: KO(d.add_columns),
          defaultValues: zO(d.add_columns)
        },
        edit: {
          columns: d.edit_columns,
          title: d.edit_title,
          schema: KO(d.edit_columns),
          defaultValues: zO(d.edit_columns)
        }
      };
      return await r({ type: "setInfo", payload: f }), f;
    } catch (d) {
      r({ type: "setError", payload: { message: "Couldn't fetch list info", originalError: d } });
    }
  }, i = async (d) => {
    try {
      return await sq(e.path, d);
    } catch (f) {
      r({ type: "setError", payload: { message: `Couldn't fetch item with id ${d}`, originalError: f } });
    }
  }, l = async (d) => {
    try {
      const f = await lq(e.path, d);
      return a(), o(), f;
    } catch (f) {
      r({ type: "setError", payload: { message: "Couldnt add item.", originalError: f } });
    }
  }, c = async (d, f) => {
    try {
      const p = await cq(e.path, d, f);
      return a(), o(), p;
    } catch (p) {
      r({ type: "setError", payload: { message: `Couldn't update item with id ${d}`, originalError: p } });
    }
  }, u = async (d) => {
    try {
      const f = await uq(e.path, d);
      return a(), o(), f;
    } catch (f) {
      r({ type: "setError", payload: { message: `Couldn't delete item with id ${d}`, originalError: f } });
    }
  };
  return {
    path: e.path,
    data: t.data,
    info: t.info,
    queryParams: t.queryParams,
    loading: t.loading,
    error: t.error,
    setQueryParams: n,
    getEntry: i,
    addEntry: l,
    updateEntry: c,
    deleteEntry: u
  };
}
const tD = Br({
  Api: {}
});
function ir() {
  const e = ar(tD);
  if (e === void 0)
    throw new Error("useApi must be used within a SeidrApiProvider");
  return e.Api;
}
function iG({ path: e = "", initialQueryParams: t, relation: r, children: n }) {
  const { baseUrl: o } = oq(), a = aG({ path: Er(o, e), initialQueryParams: t, relation: r });
  return /* @__PURE__ */ _.jsx(tD.Provider, { value: { Api: a }, children: n });
}
const sG = Qe((e, { dense: t }) => ({
  toolbarRoot: {
    display: "flex",
    justifyContent: "space-between",
    padding: e.spacing.md,
    paddingBottom: t ? 0.5 * e.spacing.xs : e.spacing.md
  }
}));
var lG = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
}, cG = Object.defineProperty, uG = Object.defineProperties, dG = Object.getOwnPropertyDescriptors, Kd = Object.getOwnPropertySymbols, rD = Object.prototype.hasOwnProperty, nD = Object.prototype.propertyIsEnumerable, XO = (e, t, r) => t in e ? cG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, QO = (e, t) => {
  for (var r in t || (t = {}))
    rD.call(t, r) && XO(e, r, t[r]);
  if (Kd)
    for (var r of Kd(t))
      nD.call(t, r) && XO(e, r, t[r]);
  return e;
}, fG = (e, t) => uG(e, dG(t)), pG = (e, t) => {
  var r = {};
  for (var n in e)
    rD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && Kd)
    for (var n of Kd(e))
      t.indexOf(n) < 0 && nD.call(e, n) && (r[n] = e[n]);
  return r;
}, Ut = (e, t, r) => {
  const n = Ne(
    (o, a) => {
      var i = o, { color: l = "currentColor", size: c = 24, stroke: u = 2, children: d } = i, f = pG(i, ["color", "size", "stroke", "children"]);
      return et(
        "svg",
        QO(fG(QO({
          ref: a
        }, lG), {
          width: c,
          height: c,
          stroke: l,
          strokeWidth: u,
          className: `tabler-icon tabler-icon-${e}`
        }), f),
        [...r.map(([p, m]) => et(p, m)), ...d || []]
      );
    }
  );
  return n.propTypes = {
    color: s.string,
    size: s.oneOfType([s.string, s.number]),
    stroke: s.oneOfType([s.string, s.number])
  }, n.displayName = `${t}`, n;
}, mG = Ut("alert-circle", "IconAlertCircle", [
  ["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }],
  ["path", { d: "M12 8v4", key: "svg-1" }],
  ["path", { d: "M12 16h.01", key: "svg-2" }]
]), hG = Ut("app-window", "IconAppWindow", [
  [
    "path",
    {
      d: "M3 5m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M6 8h.01", key: "svg-1" }],
  ["path", { d: "M9 8h.01", key: "svg-2" }]
]), yG = Ut("arrow-bar-to-left", "IconArrowBarToLeft", [
  ["path", { d: "M10 12l10 0", key: "svg-0" }],
  ["path", { d: "M10 12l4 4", key: "svg-1" }],
  ["path", { d: "M10 12l4 -4", key: "svg-2" }],
  ["path", { d: "M4 4l0 16", key: "svg-3" }]
]), vG = Ut(
  "arrow-bar-to-right",
  "IconArrowBarToRight",
  [
    ["path", { d: "M14 12l-10 0", key: "svg-0" }],
    ["path", { d: "M14 12l-4 4", key: "svg-1" }],
    ["path", { d: "M14 12l-4 -4", key: "svg-2" }],
    ["path", { d: "M20 4l0 16", key: "svg-3" }]
  ]
), ZO = Ut("border-right", "IconBorderRight", [
  ["path", { d: "M20 4l0 16", key: "svg-0" }],
  ["path", { d: "M4 4l0 .01", key: "svg-1" }],
  ["path", { d: "M8 4l0 .01", key: "svg-2" }],
  ["path", { d: "M12 4l0 .01", key: "svg-3" }],
  ["path", { d: "M16 4l0 .01", key: "svg-4" }],
  ["path", { d: "M4 8l0 .01", key: "svg-5" }],
  ["path", { d: "M12 8l0 .01", key: "svg-6" }],
  ["path", { d: "M4 12l0 .01", key: "svg-7" }],
  ["path", { d: "M8 12l0 .01", key: "svg-8" }],
  ["path", { d: "M12 12l0 .01", key: "svg-9" }],
  ["path", { d: "M16 12l0 .01", key: "svg-10" }],
  ["path", { d: "M4 16l0 .01", key: "svg-11" }],
  ["path", { d: "M12 16l0 .01", key: "svg-12" }],
  ["path", { d: "M4 20l0 .01", key: "svg-13" }],
  ["path", { d: "M8 20l0 .01", key: "svg-14" }],
  ["path", { d: "M12 20l0 .01", key: "svg-15" }],
  ["path", { d: "M16 20l0 .01", key: "svg-16" }]
]), oD = Ut("calendar", "IconCalendar", [
  [
    "path",
    {
      d: "M4 7a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M16 3v4", key: "svg-1" }],
  ["path", { d: "M8 3v4", key: "svg-2" }],
  ["path", { d: "M4 11h16", key: "svg-3" }],
  ["path", { d: "M11 15h1", key: "svg-4" }],
  ["path", { d: "M12 15v3", key: "svg-5" }]
]), uy = Ut("chevron-down", "IconChevronDown", [
  ["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]
]), gG = Ut("chevron-left", "IconChevronLeft", [
  ["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]
]), bG = Ut("chevron-right", "IconChevronRight", [
  ["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]
]), JO = Ut("chevron-up", "IconChevronUp", [
  ["path", { d: "M6 15l6 -6l6 6", key: "svg-0" }]
]), wG = Ut("contrast-2", "IconContrast2", [
  [
    "path",
    {
      d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M4 18h2a6 6 0 0 0 6 -6a6 6 0 0 1 6 -6h2", key: "svg-1" }]
]), xG = Ut("eye", "IconEye", [
  ["path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0", key: "svg-0" }],
  [
    "path",
    {
      d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6",
      key: "svg-1"
    }
  ]
]), eP = Ut("filter", "IconFilter", [
  [
    "path",
    {
      d: "M4 4h16v2.172a2 2 0 0 1 -.586 1.414l-4.414 4.414v7l-6 2v-8.5l-4.48 -4.928a2 2 0 0 1 -.52 -1.345v-2.227z",
      key: "svg-0"
    }
  ]
]), _G = Ut("id-badge-2", "IconIdBadge2", [
  ["path", { d: "M7 12h3v4h-3z", key: "svg-0" }],
  [
    "path",
    {
      d: "M10 6h-6a1 1 0 0 0 -1 1v12a1 1 0 0 0 1 1h16a1 1 0 0 0 1 -1v-12a1 1 0 0 0 -1 -1h-6",
      key: "svg-1"
    }
  ],
  [
    "path",
    {
      d: "M10 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v3a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z",
      key: "svg-2"
    }
  ],
  ["path", { d: "M14 16h2", key: "svg-3" }],
  ["path", { d: "M14 12h4", key: "svg-4" }]
]), tP = Ut("lock", "IconLock", [
  [
    "path",
    {
      d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }],
  ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]
]), OG = Ut("logout", "IconLogout", [
  [
    "path",
    {
      d: "M14 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2",
      key: "svg-0"
    }
  ],
  ["path", { d: "M7 12h14l-3 -3m0 6l3 -3", key: "svg-1" }]
]), PG = Ut("pencil", "IconPencil", [
  [
    "path",
    { d: "M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4", key: "svg-0" }
  ],
  ["path", { d: "M13.5 6.5l4 4", key: "svg-1" }]
]), aD = Ut("plus", "IconPlus", [
  ["path", { d: "M12 5l0 14", key: "svg-0" }],
  ["path", { d: "M5 12l14 0", key: "svg-1" }]
]), SG = Ut("resize", "IconResize", [
  [
    "path",
    {
      d: "M4 11v8a1 1 0 0 0 1 1h8m-9 -14v-1a1 1 0 0 1 1 -1h1m5 0h2m5 0h1a1 1 0 0 1 1 1v1m0 5v2m0 5v1a1 1 0 0 1 -1 1h-1",
      key: "svg-0"
    }
  ],
  ["path", { d: "M4 12h7a1 1 0 0 1 1 1v7", key: "svg-1" }]
]), TG = Ut("settings", "IconSettings", [
  [
    "path",
    {
      d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z",
      key: "svg-0"
    }
  ],
  ["path", { d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-1" }]
]), iD = Ut("trash", "IconTrash", [
  ["path", { d: "M4 7l16 0", key: "svg-0" }],
  ["path", { d: "M10 11l0 6", key: "svg-1" }],
  ["path", { d: "M14 11l0 6", key: "svg-2" }],
  [
    "path",
    { d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12", key: "svg-3" }
  ],
  ["path", { d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3", key: "svg-4" }]
]), EG = Ut("users", "IconUsers", [
  ["path", { d: "M9 7m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }],
  ["path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "svg-2" }],
  ["path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85", key: "svg-3" }]
]);
function $G({ onSettingsChange: e, settings: t }) {
  const [r, n] = Me(!1);
  return /* @__PURE__ */ _.jsxs(
    Bt,
    {
      position: "bottom-start",
      onOpen: () => n(!0),
      onClose: () => n(!1),
      opened: r,
      closeOnItemClick: !1,
      children: [
        /* @__PURE__ */ _.jsx(Bt.Target, { children: /* @__PURE__ */ _.jsx(Ba, { opened: r ? !1 : void 0, label: "Settings", children: /* @__PURE__ */ _.jsx(tn, { children: /* @__PURE__ */ _.jsx(TG, {}) }) }) }),
        /* @__PURE__ */ _.jsxs(Bt.Dropdown, { children: [
          /* @__PURE__ */ _.jsx(Bt.Label, { children: "Theme" }),
          /* @__PURE__ */ _.jsx(
            Bt.Item,
            {
              icon: /* @__PURE__ */ _.jsx(wG, { size: 16 }),
              rightSection: /* @__PURE__ */ _.jsx(
                mi,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.striped,
                  onChange: (o) => e({ ...t, striped: !t.striped })
                }
              ),
              children: "Striped"
            }
          ),
          /* @__PURE__ */ _.jsx(
            Bt.Item,
            {
              icon: /* @__PURE__ */ _.jsx(ZO, { size: 16 }),
              rightSection: /* @__PURE__ */ _.jsx(
                mi,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.rightBorder,
                  onChange: (o) => e({ ...t, rightBorder: !t.rightBorder })
                }
              ),
              children: "Right Border"
            }
          ),
          /* @__PURE__ */ _.jsx(Bt.Label, { children: "Layout" }),
          /* @__PURE__ */ _.jsx(
            Bt.Item,
            {
              icon: /* @__PURE__ */ _.jsx(SG, { size: 16 }),
              rightSection: /* @__PURE__ */ _.jsx(
                mi,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.dense,
                  onChange: (o) => e({ ...t, dense: !t.dense })
                }
              ),
              children: "Dense"
            }
          ),
          /* @__PURE__ */ _.jsx(
            Bt.Item,
            {
              icon: /* @__PURE__ */ _.jsx(ZO, { size: 16 }),
              rightSection: /* @__PURE__ */ _.jsx(
                mi,
                {
                  styles: { trackLabel: { minWidth: "12px" } },
                  size: "xs",
                  checked: t.rtl,
                  onChange: (o) => e({ ...t, rtl: !t.rtl })
                }
              ),
              children: "RTL"
            }
          )
        ] })
      ]
    }
  );
}
var Cl = (e) => e.type === "checkbox", gi = (e) => e instanceof Date, gr = (e) => e == null;
const sD = (e) => typeof e == "object";
var or = (e) => !gr(e) && !Array.isArray(e) && sD(e) && !gi(e), lD = (e) => or(e) && e.target ? Cl(e.target) ? e.target.checked : e.target.value : e, CG = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, cD = (e, t) => e.has(CG(t)), kG = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return or(t) && t.hasOwnProperty("isPrototypeOf");
}, ib = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function Tr(e) {
  let t;
  const r = Array.isArray(e);
  if (e instanceof Date)
    t = new Date(e);
  else if (e instanceof Set)
    t = new Set(e);
  else if (!(ib && (e instanceof Blob || e instanceof FileList)) && (r || or(e)))
    if (t = r ? [] : {}, !Array.isArray(e) && !kG(e))
      t = e;
    else
      for (const n in e)
        t[n] = Tr(e[n]);
  else
    return e;
  return t;
}
var ts = (e) => Array.isArray(e) ? e.filter(Boolean) : [], Nt = (e) => e === void 0, Ce = (e, t, r) => {
  if (!t || !or(e))
    return r;
  const n = ts(t.split(/[,[\].]+?/)).reduce((o, a) => gr(o) ? o : o[a], e);
  return Nt(n) || n === e ? Nt(e[t]) ? r : e[t] : n;
};
const Xd = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, Jr = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, so = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, RG = F.createContext(null), Fp = () => F.useContext(RG);
var uD = (e, t, r, n = !0) => {
  const o = {
    defaultValues: t._defaultValues
  };
  for (const a in e)
    Object.defineProperty(o, a, {
      get: () => {
        const i = a;
        return t._proxyFormState[i] !== Jr.all && (t._proxyFormState[i] = !n || Jr.all), r && (r[i] = !0), e[i];
      }
    });
  return o;
}, jr = (e) => or(e) && !Object.keys(e).length, dD = (e, t, r, n) => {
  r(e);
  const { name: o, ...a } = e;
  return jr(a) || Object.keys(a).length >= Object.keys(t).length || Object.keys(a).find((i) => t[i] === (!n || Jr.all));
}, Vr = (e) => Array.isArray(e) ? e : [e], fD = (e, t, r) => r && t ? e === t : !e || !t || e === t || Vr(e).some((n) => n && (n.startsWith(t) || t.startsWith(n)));
function Lp(e) {
  const t = F.useRef(e);
  t.current = e, F.useEffect(() => {
    const r = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      r && r.unsubscribe();
    };
  }, [e.disabled]);
}
function DG(e) {
  const t = Fp(), { control: r = t.control, disabled: n, name: o, exact: a } = e || {}, [i, l] = F.useState(r._formState), c = F.useRef(!0), u = F.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }), d = F.useRef(o);
  return d.current = o, Lp({
    disabled: n,
    next: (f) => c.current && fD(d.current, f.name, a) && dD(f, u.current, r._updateFormState) && l({
      ...r._formState,
      ...f
    }),
    subject: r._subjects.state
  }), F.useEffect(() => (c.current = !0, u.current.isValid && r._updateValid(!0), () => {
    c.current = !1;
  }), [r]), uD(i, r, u.current, !1);
}
var Un = (e) => typeof e == "string", pD = (e, t, r, n, o) => Un(e) ? (n && t.watch.add(e), Ce(r, e, o)) : Array.isArray(e) ? e.map((a) => (n && t.watch.add(a), Ce(r, a))) : (n && (t.watchAll = !0), r);
function NG(e) {
  const t = Fp(), { control: r = t.control, name: n, defaultValue: o, disabled: a, exact: i } = e || {}, l = F.useRef(n);
  l.current = n, Lp({
    disabled: a,
    subject: r._subjects.values,
    next: (d) => {
      fD(l.current, d.name, i) && u(Tr(pD(l.current, r._names, d.values || r._formValues, !1, o)));
    }
  });
  const [c, u] = F.useState(r._getWatch(n, o));
  return F.useEffect(() => r._removeUnmounted()), c;
}
var sb = (e) => /^\w*$/.test(e), mD = (e) => ts(e.replace(/["|']|\]/g, "").split(/\.|\[/));
function Et(e, t, r) {
  let n = -1;
  const o = sb(t) ? [t] : mD(t), a = o.length, i = a - 1;
  for (; ++n < a; ) {
    const l = o[n];
    let c = r;
    if (n !== i) {
      const u = e[l];
      c = or(u) || Array.isArray(u) ? u : isNaN(+o[n + 1]) ? {} : [];
    }
    e[l] = c, e = e[l];
  }
  return e;
}
function So(e) {
  const t = Fp(), { name: r, control: n = t.control, shouldUnregister: o } = e, a = cD(n._names.array, r), i = NG({
    control: n,
    name: r,
    defaultValue: Ce(n._formValues, r, Ce(n._defaultValues, r, e.defaultValue)),
    exact: !0
  }), l = DG({
    control: n,
    name: r
  }), c = F.useRef(n.register(r, {
    ...e.rules,
    value: i
  }));
  return F.useEffect(() => {
    const u = n._options.shouldUnregister || o, d = (f, p) => {
      const m = Ce(n._fields, f);
      m && (m._f.mount = p);
    };
    if (d(r, !0), u) {
      const f = Tr(Ce(n._options.defaultValues, r));
      Et(n._defaultValues, r, f), Nt(Ce(n._formValues, r)) && Et(n._formValues, r, f);
    }
    return () => {
      (a ? u && !n._state.action : u) ? n.unregister(r) : d(r, !1);
    };
  }, [r, n, a, o]), {
    field: {
      name: r,
      value: i,
      onChange: F.useCallback((u) => c.current.onChange({
        target: {
          value: lD(u),
          name: r
        },
        type: Xd.CHANGE
      }), [r]),
      onBlur: F.useCallback(() => c.current.onBlur({
        target: {
          value: Ce(n._formValues, r),
          name: r
        },
        type: Xd.BLUR
      }), [r, n]),
      ref: (u) => {
        const d = Ce(n._fields, r);
        d && u && (d._f.ref = {
          focus: () => u.focus(),
          select: () => u.select(),
          setCustomValidity: (f) => u.setCustomValidity(f),
          reportValidity: () => u.reportValidity()
        });
      }
    },
    formState: l,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: !0,
        get: () => !!Ce(l.errors, r)
      },
      isDirty: {
        enumerable: !0,
        get: () => !!Ce(l.dirtyFields, r)
      },
      isTouched: {
        enumerable: !0,
        get: () => !!Ce(l.touchedFields, r)
      },
      error: {
        enumerable: !0,
        get: () => Ce(l.errors, r)
      }
    })
  };
}
var hD = (e, t, r, n, o) => t ? {
  ...r[e],
  types: {
    ...r[e] && r[e].types ? r[e].types : {},
    [n]: o || !0
  }
} : {};
const Qd = (e, t, r) => {
  for (const n of r || Object.keys(e)) {
    const o = Ce(e, n);
    if (o) {
      const { _f: a, ...i } = o;
      if (a && t(a.name)) {
        if (a.ref.focus) {
          a.ref.focus();
          break;
        } else if (a.refs && a.refs[0].focus) {
          a.refs[0].focus();
          break;
        }
      } else
        or(i) && Qd(i, t);
    }
  }
};
var Do = () => {
  const e = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
    const r = (Math.random() * 16 + e) % 16 | 0;
    return (t == "x" ? r : r & 3 | 8).toString(16);
  });
}, Um = (e, t, r = {}) => r.shouldFocus || Nt(r.shouldFocus) ? r.focusName || `${e}.${Nt(r.focusIndex) ? t : r.focusIndex}.` : "", dy = (e) => ({
  isOnSubmit: !e || e === Jr.onSubmit,
  isOnBlur: e === Jr.onBlur,
  isOnChange: e === Jr.onChange,
  isOnAll: e === Jr.all,
  isOnTouch: e === Jr.onTouched
}), fy = (e, t, r) => !r && (t.watchAll || t.watch.has(e) || [...t.watch].some((n) => e.startsWith(n) && /^\.\w+/.test(e.slice(n.length)))), yD = (e, t, r) => {
  const n = ts(Ce(e, r));
  return Et(n, "root", t[r]), Et(e, r, n), e;
}, Si = (e) => typeof e == "boolean", lb = (e) => e.type === "file", Lo = (e) => typeof e == "function", Zd = (e) => {
  if (!ib)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, Ic = (e) => Un(e), cb = (e) => e.type === "radio", Jd = (e) => e instanceof RegExp;
const rP = {
  value: !1,
  isValid: !1
}, nP = { value: !0, isValid: !0 };
var vD = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((r) => r && r.checked && !r.disabled).map((r) => r.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !Nt(e[0].attributes.value) ? Nt(e[0].value) || e[0].value === "" ? nP : { value: e[0].value, isValid: !0 } : nP
    ) : rP;
  }
  return rP;
};
const oP = {
  isValid: !1,
  value: null
};
var gD = (e) => Array.isArray(e) ? e.reduce((t, r) => r && r.checked && !r.disabled ? {
  isValid: !0,
  value: r.value
} : t, oP) : oP;
function aP(e, t, r = "validate") {
  if (Ic(e) || Array.isArray(e) && e.every(Ic) || Si(e) && !e)
    return {
      type: r,
      message: Ic(e) ? e : "",
      ref: t
    };
}
var ni = (e) => or(e) && !Jd(e) ? e : {
  value: e,
  message: ""
}, py = async (e, t, r, n, o) => {
  const { ref: a, refs: i, required: l, maxLength: c, minLength: u, min: d, max: f, pattern: p, validate: m, name: y, valueAsNumber: h, mount: v, disabled: g } = e._f, b = Ce(t, y);
  if (!v || g)
    return {};
  const x = i ? i[0] : a, O = (A) => {
    n && x.reportValidity && (x.setCustomValidity(Si(A) ? "" : A || ""), x.reportValidity());
  }, w = {}, S = cb(a), E = Cl(a), C = S || E, N = (h || lb(a)) && Nt(a.value) && Nt(b) || Zd(a) && a.value === "" || b === "" || Array.isArray(b) && !b.length, $ = hD.bind(null, y, r, w), j = (A, k, R, D = so.maxLength, L = so.minLength) => {
    const B = A ? k : R;
    w[y] = {
      type: A ? D : L,
      message: B,
      ref: a,
      ...$(A ? D : L, B)
    };
  };
  if (o ? !Array.isArray(b) || !b.length : l && (!C && (N || gr(b)) || Si(b) && !b || E && !vD(i).isValid || S && !gD(i).isValid)) {
    const { value: A, message: k } = Ic(l) ? { value: !!l, message: l } : ni(l);
    if (A && (w[y] = {
      type: so.required,
      message: k,
      ref: x,
      ...$(so.required, k)
    }, !r))
      return O(k), w;
  }
  if (!N && (!gr(d) || !gr(f))) {
    let A, k;
    const R = ni(f), D = ni(d);
    if (!gr(b) && !isNaN(b)) {
      const L = a.valueAsNumber || b && +b;
      gr(R.value) || (A = L > R.value), gr(D.value) || (k = L < D.value);
    } else {
      const L = a.valueAsDate || new Date(b), B = (I) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + I), H = a.type == "time", U = a.type == "week";
      Un(R.value) && b && (A = H ? B(b) > B(R.value) : U ? b > R.value : L > new Date(R.value)), Un(D.value) && b && (k = H ? B(b) < B(D.value) : U ? b < D.value : L < new Date(D.value));
    }
    if ((A || k) && (j(!!A, R.message, D.message, so.max, so.min), !r))
      return O(w[y].message), w;
  }
  if ((c || u) && !N && (Un(b) || o && Array.isArray(b))) {
    const A = ni(c), k = ni(u), R = !gr(A.value) && b.length > +A.value, D = !gr(k.value) && b.length < +k.value;
    if ((R || D) && (j(R, A.message, k.message), !r))
      return O(w[y].message), w;
  }
  if (p && !N && Un(b)) {
    const { value: A, message: k } = ni(p);
    if (Jd(A) && !b.match(A) && (w[y] = {
      type: so.pattern,
      message: k,
      ref: a,
      ...$(so.pattern, k)
    }, !r))
      return O(k), w;
  }
  if (m) {
    if (Lo(m)) {
      const A = await m(b, t), k = aP(A, x);
      if (k && (w[y] = {
        ...k,
        ...$(so.validate, k.message)
      }, !r))
        return O(k.message), w;
    } else if (or(m)) {
      let A = {};
      for (const k in m) {
        if (!jr(A) && !r)
          break;
        const R = aP(await m[k](b, t), x, k);
        R && (A = {
          ...R,
          ...$(k, R.message)
        }, O(R.message), r && (w[y] = A));
      }
      if (!jr(A) && (w[y] = {
        ref: x,
        ...A
      }, !r))
        return w;
    }
  }
  return O(!0), w;
};
function Hm(e, t) {
  return [...e, ...Vr(t)];
}
var Ym = (e) => Array.isArray(e) ? e.map(() => {
}) : void 0;
function qm(e, t, r) {
  return [
    ...e.slice(0, t),
    ...Vr(r),
    ...e.slice(t)
  ];
}
var Gm = (e, t, r) => Array.isArray(e) ? (Nt(e[r]) && (e[r] = void 0), e.splice(r, 0, e.splice(t, 1)[0]), e) : [];
function Km(e, t) {
  return [...Vr(t), ...Vr(e)];
}
function IG(e, t) {
  let r = 0;
  const n = [...e];
  for (const o of t)
    n.splice(o - r, 1), r++;
  return ts(n).length ? n : [];
}
var Xm = (e, t) => Nt(t) ? [] : IG(e, Vr(t).sort((r, n) => r - n)), Qm = (e, t, r) => {
  e[t] = [e[r], e[r] = e[t]][0];
};
function MG(e, t) {
  const r = t.slice(0, -1).length;
  let n = 0;
  for (; n < r; )
    e = Nt(e) ? n++ : e[t[n++]];
  return e;
}
function AG(e) {
  for (const t in e)
    if (!Nt(e[t]))
      return !1;
  return !0;
}
function cr(e, t) {
  const r = Array.isArray(t) ? t : sb(t) ? [t] : mD(t), n = r.length === 1 ? e : MG(e, r), o = r.length - 1, a = r[o];
  return n && delete n[a], o !== 0 && (or(n) && jr(n) || Array.isArray(n) && AG(n)) && cr(e, r.slice(0, -1)), e;
}
var iP = (e, t, r) => (e[t] = r, e);
function jG(e) {
  const t = Fp(), { control: r = t.control, name: n, keyName: o = "id", shouldUnregister: a } = e, [i, l] = F.useState(r._getFieldArray(n)), c = F.useRef(r._getFieldArray(n).map(Do)), u = F.useRef(i), d = F.useRef(n), f = F.useRef(!1);
  d.current = n, u.current = i, r._names.array.add(n), e.rules && r.register(n, e.rules), Lp({
    next: ({ values: w, name: S }) => {
      if (S === d.current || !S) {
        const E = Ce(w, d.current);
        Array.isArray(E) && (l(E), c.current = E.map(Do));
      }
    },
    subject: r._subjects.array
  });
  const p = F.useCallback((w) => {
    f.current = !0, r._updateFieldArray(n, w);
  }, [r, n]), m = (w, S) => {
    const E = Vr(Tr(w)), C = Hm(r._getFieldArray(n), E);
    r._names.focus = Um(n, C.length - 1, S), c.current = Hm(c.current, E.map(Do)), p(C), l(C), r._updateFieldArray(n, C, Hm, {
      argA: Ym(w)
    });
  }, y = (w, S) => {
    const E = Vr(Tr(w)), C = Km(r._getFieldArray(n), E);
    r._names.focus = Um(n, 0, S), c.current = Km(c.current, E.map(Do)), p(C), l(C), r._updateFieldArray(n, C, Km, {
      argA: Ym(w)
    });
  }, h = (w) => {
    const S = Xm(r._getFieldArray(n), w);
    c.current = Xm(c.current, w), p(S), l(S), r._updateFieldArray(n, S, Xm, {
      argA: w
    });
  }, v = (w, S, E) => {
    const C = Vr(Tr(S)), N = qm(r._getFieldArray(n), w, C);
    r._names.focus = Um(n, w, E), c.current = qm(c.current, w, C.map(Do)), p(N), l(N), r._updateFieldArray(n, N, qm, {
      argA: w,
      argB: Ym(S)
    });
  }, g = (w, S) => {
    const E = r._getFieldArray(n);
    Qm(E, w, S), Qm(c.current, w, S), p(E), l(E), r._updateFieldArray(n, E, Qm, {
      argA: w,
      argB: S
    }, !1);
  }, b = (w, S) => {
    const E = r._getFieldArray(n);
    Gm(E, w, S), Gm(c.current, w, S), p(E), l(E), r._updateFieldArray(n, E, Gm, {
      argA: w,
      argB: S
    }, !1);
  }, x = (w, S) => {
    const E = Tr(S), C = iP(r._getFieldArray(n), w, E);
    c.current = [...C].map((N, $) => !N || $ === w ? Do() : c.current[$]), p(C), l([...C]), r._updateFieldArray(n, C, iP, {
      argA: w,
      argB: E
    }, !0, !1);
  }, O = (w) => {
    const S = Vr(Tr(w));
    c.current = S.map(Do), p([...S]), l([...S]), r._updateFieldArray(n, [...S], (E) => E, {}, !0, !1);
  };
  return F.useEffect(() => {
    if (r._state.action = !1, fy(n, r._names) && r._subjects.state.next({
      ...r._formState
    }), f.current && (!dy(r._options.mode).isOnSubmit || r._formState.isSubmitted))
      if (r._options.resolver)
        r._executeSchema([n]).then((w) => {
          const S = Ce(w.errors, n), E = Ce(r._formState.errors, n);
          (E ? !S && E.type : S && S.type) && (S ? Et(r._formState.errors, n, S) : cr(r._formState.errors, n), r._subjects.state.next({
            errors: r._formState.errors
          }));
        });
      else {
        const w = Ce(r._fields, n);
        w && w._f && py(w, r._formValues, r._options.criteriaMode === Jr.all, r._options.shouldUseNativeValidation, !0).then((S) => !jr(S) && r._subjects.state.next({
          errors: yD(r._formState.errors, S, n)
        }));
      }
    r._subjects.values.next({
      name: n,
      values: { ...r._formValues }
    }), r._names.focus && Qd(r._fields, (w) => !!w && w.startsWith(r._names.focus || "")), r._names.focus = "", r._updateValid();
  }, [i, n, r]), F.useEffect(() => (!Ce(r._formValues, n) && r._updateFieldArray(n), () => {
    (r._options.shouldUnregister || a) && r.unregister(n);
  }), [n, r, o, a]), {
    swap: F.useCallback(g, [p, n, r]),
    move: F.useCallback(b, [p, n, r]),
    prepend: F.useCallback(y, [p, n, r]),
    append: F.useCallback(m, [p, n, r]),
    remove: F.useCallback(h, [p, n, r]),
    insert: F.useCallback(v, [p, n, r]),
    update: F.useCallback(x, [p, n, r]),
    replace: F.useCallback(O, [p, n, r]),
    fields: F.useMemo(() => i.map((w, S) => ({
      ...w,
      [o]: c.current[S] || Do()
    })), [i, o])
  };
}
function Zm() {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (o) => {
      for (const a of e)
        a.next && a.next(o);
    },
    subscribe: (o) => (e.push(o), {
      unsubscribe: () => {
        e = e.filter((a) => a !== o);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}
var ef = (e) => gr(e) || !sD(e);
function wa(e, t) {
  if (ef(e) || ef(t))
    return e === t;
  if (gi(e) && gi(t))
    return e.getTime() === t.getTime();
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const o of r) {
    const a = e[o];
    if (!n.includes(o))
      return !1;
    if (o !== "ref") {
      const i = t[o];
      if (gi(a) && gi(i) || or(a) && or(i) || Array.isArray(a) && Array.isArray(i) ? !wa(a, i) : a !== i)
        return !1;
    }
  }
  return !0;
}
var bD = (e) => e.type === "select-multiple", FG = (e) => cb(e) || Cl(e), Jm = (e) => Zd(e) && e.isConnected, wD = (e) => {
  for (const t in e)
    if (Lo(e[t]))
      return !0;
  return !1;
};
function tf(e, t = {}) {
  const r = Array.isArray(e);
  if (or(e) || r)
    for (const n in e)
      Array.isArray(e[n]) || or(e[n]) && !wD(e[n]) ? (t[n] = Array.isArray(e[n]) ? [] : {}, tf(e[n], t[n])) : gr(e[n]) || (t[n] = !0);
  return t;
}
function xD(e, t, r) {
  const n = Array.isArray(e);
  if (or(e) || n)
    for (const o in e)
      Array.isArray(e[o]) || or(e[o]) && !wD(e[o]) ? Nt(t) || ef(r[o]) ? r[o] = Array.isArray(e[o]) ? tf(e[o], []) : { ...tf(e[o]) } : xD(e[o], gr(t) ? {} : t[o], r[o]) : r[o] = !wa(e[o], t[o]);
  return r;
}
var eh = (e, t) => xD(e, t, tf(t)), _D = (e, { valueAsNumber: t, valueAsDate: r, setValueAs: n }) => Nt(e) ? e : t ? e === "" ? NaN : e && +e : r && Un(e) ? new Date(e) : n ? n(e) : e;
function th(e) {
  const t = e.ref;
  if (!(e.refs ? e.refs.every((r) => r.disabled) : t.disabled))
    return lb(t) ? t.files : cb(t) ? gD(e.refs).value : bD(t) ? [...t.selectedOptions].map(({ value: r }) => r) : Cl(t) ? vD(e.refs).value : _D(Nt(t.value) ? e.ref.value : t.value, e);
}
var LG = (e, t, r, n) => {
  const o = {};
  for (const a of e) {
    const i = Ce(t, a);
    i && Et(o, a, i._f);
  }
  return {
    criteriaMode: r,
    names: [...e],
    fields: o,
    shouldUseNativeValidation: n
  };
}, gs = (e) => Nt(e) ? e : Jd(e) ? e.source : or(e) ? Jd(e.value) ? e.value.source : e.value : e, VG = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function sP(e, t, r) {
  const n = Ce(e, r);
  if (n || sb(r))
    return {
      error: n,
      name: r
    };
  const o = r.split(".");
  for (; o.length; ) {
    const a = o.join("."), i = Ce(t, a), l = Ce(e, a);
    if (i && !Array.isArray(i) && r !== a)
      return { name: r };
    if (l && l.type)
      return {
        name: a,
        error: l
      };
    o.pop();
  }
  return {
    name: r
  };
}
var zG = (e, t, r, n, o) => o.isOnAll ? !1 : !r && o.isOnTouch ? !(t || e) : (r ? n.isOnBlur : o.isOnBlur) ? !e : (r ? n.isOnChange : o.isOnChange) ? e : !0, BG = (e, t) => !ts(Ce(e, t)).length && cr(e, t);
const WG = {
  mode: Jr.onSubmit,
  reValidateMode: Jr.onChange,
  shouldFocusError: !0
};
function UG(e = {}, t) {
  let r = {
    ...WG,
    ...e
  }, n = {
    submitCount: 0,
    isDirty: !1,
    isLoading: Lo(r.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    errors: {}
  }, o = {}, a = or(r.defaultValues) || or(r.values) ? Tr(r.defaultValues || r.values) || {} : {}, i = r.shouldUnregister ? {} : Tr(a), l = {
    action: !1,
    mount: !1,
    watch: !1
  }, c = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, u, d = 0;
  const f = {
    isDirty: !1,
    dirtyFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, p = {
    values: Zm(),
    array: Zm(),
    state: Zm()
  }, m = e.resetOptions && e.resetOptions.keepDirtyValues, y = dy(r.mode), h = dy(r.reValidateMode), v = r.criteriaMode === Jr.all, g = (M) => (W) => {
    clearTimeout(d), d = setTimeout(M, W);
  }, b = async (M) => {
    if (f.isValid || M) {
      const W = r.resolver ? jr((await N()).errors) : await j(o, !0);
      W !== n.isValid && p.state.next({
        isValid: W
      });
    }
  }, x = (M) => f.isValidating && p.state.next({
    isValidating: M
  }), O = (M, W = [], Z, he, me = !0, de = !0) => {
    if (he && Z) {
      if (l.action = !0, de && Array.isArray(Ce(o, M))) {
        const ue = Z(Ce(o, M), he.argA, he.argB);
        me && Et(o, M, ue);
      }
      if (de && Array.isArray(Ce(n.errors, M))) {
        const ue = Z(Ce(n.errors, M), he.argA, he.argB);
        me && Et(n.errors, M, ue), BG(n.errors, M);
      }
      if (f.touchedFields && de && Array.isArray(Ce(n.touchedFields, M))) {
        const ue = Z(Ce(n.touchedFields, M), he.argA, he.argB);
        me && Et(n.touchedFields, M, ue);
      }
      f.dirtyFields && (n.dirtyFields = eh(a, i)), p.state.next({
        name: M,
        isDirty: k(M, W),
        dirtyFields: n.dirtyFields,
        errors: n.errors,
        isValid: n.isValid
      });
    } else
      Et(i, M, W);
  }, w = (M, W) => {
    Et(n.errors, M, W), p.state.next({
      errors: n.errors
    });
  }, S = (M, W, Z, he) => {
    const me = Ce(o, M);
    if (me) {
      const de = Ce(i, M, Nt(Z) ? Ce(a, M) : Z);
      Nt(de) || he && he.defaultChecked || W ? Et(i, M, W ? de : th(me._f)) : L(M, de), l.mount && b();
    }
  }, E = (M, W, Z, he, me) => {
    let de = !1, ue = !1;
    const Oe = {
      name: M
    };
    if (!Z || he) {
      f.isDirty && (ue = n.isDirty, n.isDirty = Oe.isDirty = k(), de = ue !== Oe.isDirty);
      const Se = wa(Ce(a, M), W);
      ue = Ce(n.dirtyFields, M), Se ? cr(n.dirtyFields, M) : Et(n.dirtyFields, M, !0), Oe.dirtyFields = n.dirtyFields, de = de || f.dirtyFields && ue !== !Se;
    }
    if (Z) {
      const Se = Ce(n.touchedFields, M);
      Se || (Et(n.touchedFields, M, Z), Oe.touchedFields = n.touchedFields, de = de || f.touchedFields && Se !== Z);
    }
    return de && me && p.state.next(Oe), de ? Oe : {};
  }, C = (M, W, Z, he) => {
    const me = Ce(n.errors, M), de = f.isValid && Si(W) && n.isValid !== W;
    if (e.delayError && Z ? (u = g(() => w(M, Z)), u(e.delayError)) : (clearTimeout(d), u = null, Z ? Et(n.errors, M, Z) : cr(n.errors, M)), (Z ? !wa(me, Z) : me) || !jr(he) || de) {
      const ue = {
        ...he,
        ...de && Si(W) ? { isValid: W } : {},
        errors: n.errors,
        name: M
      };
      n = {
        ...n,
        ...ue
      }, p.state.next(ue);
    }
    x(!1);
  }, N = async (M) => r.resolver(i, r.context, LG(M || c.mount, o, r.criteriaMode, r.shouldUseNativeValidation)), $ = async (M) => {
    const { errors: W } = await N();
    if (M)
      for (const Z of M) {
        const he = Ce(W, Z);
        he ? Et(n.errors, Z, he) : cr(n.errors, Z);
      }
    else
      n.errors = W;
    return W;
  }, j = async (M, W, Z = {
    valid: !0
  }) => {
    for (const he in M) {
      const me = M[he];
      if (me) {
        const { _f: de, ...ue } = me;
        if (de) {
          const Oe = c.array.has(de.name), Se = await py(me, i, v, r.shouldUseNativeValidation && !W, Oe);
          if (Se[de.name] && (Z.valid = !1, W))
            break;
          !W && (Ce(Se, de.name) ? Oe ? yD(n.errors, Se, de.name) : Et(n.errors, de.name, Se[de.name]) : cr(n.errors, de.name));
        }
        ue && await j(ue, W, Z);
      }
    }
    return Z.valid;
  }, A = () => {
    for (const M of c.unMount) {
      const W = Ce(o, M);
      W && (W._f.refs ? W._f.refs.every((Z) => !Jm(Z)) : !Jm(W._f.ref)) && te(M);
    }
    c.unMount = /* @__PURE__ */ new Set();
  }, k = (M, W) => (M && W && Et(i, M, W), !wa(V(), a)), R = (M, W, Z) => pD(M, c, {
    ...l.mount ? i : Nt(W) ? a : Un(M) ? { [M]: W } : W
  }, Z, W), D = (M) => ts(Ce(l.mount ? i : a, M, e.shouldUnregister ? Ce(a, M, []) : [])), L = (M, W, Z = {}) => {
    const he = Ce(o, M);
    let me = W;
    if (he) {
      const de = he._f;
      de && (!de.disabled && Et(i, M, _D(W, de)), me = Zd(de.ref) && gr(W) ? "" : W, bD(de.ref) ? [...de.ref.options].forEach((ue) => ue.selected = me.includes(ue.value)) : de.refs ? Cl(de.ref) ? de.refs.length > 1 ? de.refs.forEach((ue) => (!ue.defaultChecked || !ue.disabled) && (ue.checked = Array.isArray(me) ? !!me.find((Oe) => Oe === ue.value) : me === ue.value)) : de.refs[0] && (de.refs[0].checked = !!me) : de.refs.forEach((ue) => ue.checked = ue.value === me) : lb(de.ref) ? de.ref.value = "" : (de.ref.value = me, de.ref.type || p.values.next({
        name: M,
        values: { ...i }
      })));
    }
    (Z.shouldDirty || Z.shouldTouch) && E(M, me, Z.shouldTouch, Z.shouldDirty, !0), Z.shouldValidate && I(M);
  }, B = (M, W, Z) => {
    for (const he in W) {
      const me = W[he], de = `${M}.${he}`, ue = Ce(o, de);
      (c.array.has(M) || !ef(me) || ue && !ue._f) && !gi(me) ? B(de, me, Z) : L(de, me, Z);
    }
  }, H = (M, W, Z = {}) => {
    const he = Ce(o, M), me = c.array.has(M), de = Tr(W);
    Et(i, M, de), me ? (p.array.next({
      name: M,
      values: { ...i }
    }), (f.isDirty || f.dirtyFields) && Z.shouldDirty && p.state.next({
      name: M,
      dirtyFields: eh(a, i),
      isDirty: k(M, de)
    })) : he && !he._f && !gr(de) ? B(M, de, Z) : L(M, de, Z), fy(M, c) && p.state.next({ ...n }), p.values.next({
      name: M,
      values: { ...i }
    }), !l.mount && t();
  }, U = async (M) => {
    const W = M.target;
    let Z = W.name, he = !0;
    const me = Ce(o, Z), de = () => W.type ? th(me._f) : lD(M);
    if (me) {
      let ue, Oe;
      const Se = de(), De = M.type === Xd.BLUR || M.type === Xd.FOCUS_OUT, nt = !VG(me._f) && !r.resolver && !Ce(n.errors, Z) && !me._f.deps || zG(De, Ce(n.touchedFields, Z), n.isSubmitted, h, y), rt = fy(Z, c, De);
      Et(i, Z, Se), De ? (me._f.onBlur && me._f.onBlur(M), u && u(0)) : me._f.onChange && me._f.onChange(M);
      const Be = E(Z, Se, De, !1), Ie = !jr(Be) || rt;
      if (!De && p.values.next({
        name: Z,
        type: M.type,
        values: { ...i }
      }), nt)
        return f.isValid && b(), Ie && p.state.next({ name: Z, ...rt ? {} : Be });
      if (!De && rt && p.state.next({ ...n }), x(!0), r.resolver) {
        const { errors: it } = await N([Z]), we = sP(n.errors, o, Z), ye = sP(it, o, we.name || Z);
        ue = ye.error, Z = ye.name, Oe = jr(it);
      } else
        ue = (await py(me, i, v, r.shouldUseNativeValidation))[Z], he = isNaN(Se) || Se === Ce(i, Z, Se), he && (ue ? Oe = !1 : f.isValid && (Oe = await j(o, !0)));
      he && (me._f.deps && I(me._f.deps), C(Z, Oe, ue, Be));
    }
  }, I = async (M, W = {}) => {
    let Z, he;
    const me = Vr(M);
    if (x(!0), r.resolver) {
      const de = await $(Nt(M) ? M : me);
      Z = jr(de), he = M ? !me.some((ue) => Ce(de, ue)) : Z;
    } else
      M ? (he = (await Promise.all(me.map(async (de) => {
        const ue = Ce(o, de);
        return await j(ue && ue._f ? { [de]: ue } : ue);
      }))).every(Boolean), !(!he && !n.isValid) && b()) : he = Z = await j(o);
    return p.state.next({
      ...!Un(M) || f.isValid && Z !== n.isValid ? {} : { name: M },
      ...r.resolver || !M ? { isValid: Z } : {},
      errors: n.errors,
      isValidating: !1
    }), W.shouldFocus && !he && Qd(o, (de) => de && Ce(n.errors, de), M ? me : c.mount), he;
  }, V = (M) => {
    const W = {
      ...a,
      ...l.mount ? i : {}
    };
    return Nt(M) ? W : Un(M) ? Ce(W, M) : M.map((Z) => Ce(W, Z));
  }, G = (M, W) => ({
    invalid: !!Ce((W || n).errors, M),
    isDirty: !!Ce((W || n).dirtyFields, M),
    isTouched: !!Ce((W || n).touchedFields, M),
    error: Ce((W || n).errors, M)
  }), q = (M) => {
    M && Vr(M).forEach((W) => cr(n.errors, W)), p.state.next({
      errors: M ? n.errors : {}
    });
  }, J = (M, W, Z) => {
    const he = (Ce(o, M, { _f: {} })._f || {}).ref;
    Et(n.errors, M, {
      ...W,
      ref: he
    }), p.state.next({
      name: M,
      errors: n.errors,
      isValid: !1
    }), Z && Z.shouldFocus && he && he.focus && he.focus();
  }, ne = (M, W) => Lo(M) ? p.values.subscribe({
    next: (Z) => M(R(void 0, W), Z)
  }) : R(M, W, !0), te = (M, W = {}) => {
    for (const Z of M ? Vr(M) : c.mount)
      c.mount.delete(Z), c.array.delete(Z), W.keepValue || (cr(o, Z), cr(i, Z)), !W.keepError && cr(n.errors, Z), !W.keepDirty && cr(n.dirtyFields, Z), !W.keepTouched && cr(n.touchedFields, Z), !r.shouldUnregister && !W.keepDefaultValue && cr(a, Z);
    p.values.next({
      values: { ...i }
    }), p.state.next({
      ...n,
      ...W.keepDirty ? { isDirty: k() } : {}
    }), !W.keepIsValid && b();
  }, ee = (M, W = {}) => {
    let Z = Ce(o, M);
    const he = Si(W.disabled);
    return Et(o, M, {
      ...Z || {},
      _f: {
        ...Z && Z._f ? Z._f : { ref: { name: M } },
        name: M,
        mount: !0,
        ...W
      }
    }), c.mount.add(M), Z ? he && Et(i, M, W.disabled ? void 0 : Ce(i, M, th(Z._f))) : S(M, !0, W.value), {
      ...he ? { disabled: W.disabled } : {},
      ...r.shouldUseNativeValidation ? {
        required: !!W.required,
        min: gs(W.min),
        max: gs(W.max),
        minLength: gs(W.minLength),
        maxLength: gs(W.maxLength),
        pattern: gs(W.pattern)
      } : {},
      name: M,
      onChange: U,
      onBlur: U,
      ref: (me) => {
        if (me) {
          ee(M, W), Z = Ce(o, M);
          const de = Nt(me.value) && me.querySelectorAll && me.querySelectorAll("input,select,textarea")[0] || me, ue = FG(de), Oe = Z._f.refs || [];
          if (ue ? Oe.find((Se) => Se === de) : de === Z._f.ref)
            return;
          Et(o, M, {
            _f: {
              ...Z._f,
              ...ue ? {
                refs: [
                  ...Oe.filter(Jm),
                  de,
                  ...Array.isArray(Ce(a, M)) ? [{}] : []
                ],
                ref: { type: de.type, name: M }
              } : { ref: de }
            }
          }), S(M, !1, void 0, de);
        } else
          Z = Ce(o, M, {}), Z._f && (Z._f.mount = !1), (r.shouldUnregister || W.shouldUnregister) && !(cD(c.array, M) && l.action) && c.unMount.add(M);
      }
    };
  }, K = () => r.shouldFocusError && Qd(o, (M) => M && Ce(n.errors, M), c.mount), Q = (M, W) => async (Z) => {
    Z && (Z.preventDefault && Z.preventDefault(), Z.persist && Z.persist());
    let he = Tr(i);
    if (p.state.next({
      isSubmitting: !0
    }), r.resolver) {
      const { errors: me, values: de } = await N();
      n.errors = me, he = de;
    } else
      await j(o);
    cr(n.errors, "root"), jr(n.errors) ? (p.state.next({
      errors: {}
    }), await M(he, Z)) : (W && await W({ ...n.errors }, Z), K(), setTimeout(K)), p.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: jr(n.errors),
      submitCount: n.submitCount + 1,
      errors: n.errors
    });
  }, ae = (M, W = {}) => {
    Ce(o, M) && (Nt(W.defaultValue) ? H(M, Ce(a, M)) : (H(M, W.defaultValue), Et(a, M, W.defaultValue)), W.keepTouched || cr(n.touchedFields, M), W.keepDirty || (cr(n.dirtyFields, M), n.isDirty = W.defaultValue ? k(M, Ce(a, M)) : k()), W.keepError || (cr(n.errors, M), f.isValid && b()), p.state.next({ ...n }));
  }, ie = (M, W = {}) => {
    const Z = M || a, he = Tr(Z), me = M && !jr(M) ? he : a;
    if (W.keepDefaultValues || (a = Z), !W.keepValues) {
      if (W.keepDirtyValues || m)
        for (const de of c.mount)
          Ce(n.dirtyFields, de) ? Et(me, de, Ce(i, de)) : H(de, Ce(me, de));
      else {
        if (ib && Nt(M))
          for (const de of c.mount) {
            const ue = Ce(o, de);
            if (ue && ue._f) {
              const Oe = Array.isArray(ue._f.refs) ? ue._f.refs[0] : ue._f.ref;
              if (Zd(Oe)) {
                const Se = Oe.closest("form");
                if (Se) {
                  Se.reset();
                  break;
                }
              }
            }
          }
        o = {};
      }
      i = e.shouldUnregister ? W.keepDefaultValues ? Tr(a) : {} : he, p.array.next({
        values: { ...me }
      }), p.values.next({
        values: { ...me }
      });
    }
    c = {
      mount: /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, !l.mount && t(), l.mount = !f.isValid || !!W.keepIsValid, l.watch = !!e.shouldUnregister, p.state.next({
      submitCount: W.keepSubmitCount ? n.submitCount : 0,
      isDirty: W.keepDirty ? n.isDirty : !!(W.keepDefaultValues && !wa(M, a)),
      isSubmitted: W.keepIsSubmitted ? n.isSubmitted : !1,
      dirtyFields: W.keepDirtyValues ? n.dirtyFields : W.keepDefaultValues && M ? eh(a, M) : {},
      touchedFields: W.keepTouched ? n.touchedFields : {},
      errors: W.keepErrors ? n.errors : {},
      isSubmitting: !1,
      isSubmitSuccessful: !1
    });
  }, oe = (M, W) => ie(Lo(M) ? M(i) : M, W);
  return {
    control: {
      register: ee,
      unregister: te,
      getFieldState: G,
      _executeSchema: N,
      _getWatch: R,
      _getDirty: k,
      _updateValid: b,
      _removeUnmounted: A,
      _updateFieldArray: O,
      _getFieldArray: D,
      _reset: ie,
      _resetDefaultValues: () => Lo(r.defaultValues) && r.defaultValues().then((M) => {
        oe(M, r.resetOptions), p.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (M) => {
        n = {
          ...n,
          ...M
        };
      },
      _subjects: p,
      _proxyFormState: f,
      get _fields() {
        return o;
      },
      get _formValues() {
        return i;
      },
      get _state() {
        return l;
      },
      set _state(M) {
        l = M;
      },
      get _defaultValues() {
        return a;
      },
      get _names() {
        return c;
      },
      set _names(M) {
        c = M;
      },
      get _formState() {
        return n;
      },
      set _formState(M) {
        n = M;
      },
      get _options() {
        return r;
      },
      set _options(M) {
        r = {
          ...r,
          ...M
        };
      }
    },
    trigger: I,
    register: ee,
    handleSubmit: Q,
    watch: ne,
    setValue: H,
    getValues: V,
    reset: oe,
    resetField: ae,
    clearErrors: q,
    unregister: te,
    setError: J,
    setFocus: (M, W = {}) => {
      const Z = Ce(o, M), he = Z && Z._f;
      if (he) {
        const me = he.refs ? he.refs[0] : he.ref;
        me.focus && (me.focus(), W.shouldSelect && me.select());
      }
    },
    getFieldState: G
  };
}
function ub(e = {}) {
  const t = F.useRef(), [r, n] = F.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Lo(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    errors: {},
    defaultValues: Lo(e.defaultValues) ? void 0 : e.defaultValues
  });
  t.current || (t.current = {
    ...UG(e, () => n((a) => ({ ...a }))),
    formState: r
  });
  const o = t.current.control;
  return o._options = e, Lp({
    subject: o._subjects.state,
    next: (a) => {
      dD(a, o._proxyFormState, o._updateFormState, !0) && n({ ...o._formState });
    }
  }), F.useEffect(() => {
    e.values && !wa(e.values, o._defaultValues) ? o._reset(e.values, o._options.resetOptions) : o._resetDefaultValues();
  }, [e.values, o]), F.useEffect(() => {
    o._state.mount || (o._updateValid(), o._state.mount = !0), o._state.watch && (o._state.watch = !1, o._subjects.state.next({ ...o._formState })), o._removeUnmounted();
  }), t.current.formState = uD(r, o), t.current;
}
var lP = function(e, t, r) {
  if (e && "reportValidity" in e) {
    var n = Ce(r, t);
    e.setCustomValidity(n && n.message || ""), e.reportValidity();
  }
}, OD = function(e, t) {
  var r = function(o) {
    var a = t.fields[o];
    a && a.ref && "reportValidity" in a.ref ? lP(a.ref, o, e) : a.refs && a.refs.forEach(function(i) {
      return lP(i, o, e);
    });
  };
  for (var n in t.fields)
    r(n);
}, HG = function(e, t) {
  t.shouldUseNativeValidation && OD(e, t);
  var r = {};
  for (var n in e) {
    var o = Ce(t.fields, n);
    Et(r, n, Object.assign(e[n] || {}, { ref: o && o.ref }));
  }
  return r;
}, db = function(e, t, r) {
  return t === void 0 && (t = {}), r === void 0 && (r = {}), function(n, o, a) {
    try {
      return Promise.resolve(function(i, l) {
        try {
          var c = (t.context && process.env.NODE_ENV === "development" && console.warn("You should not used the yup options context. Please, use the 'useForm' context object instead"), Promise.resolve(e[r.mode === "sync" ? "validateSync" : "validate"](n, Object.assign({ abortEarly: !1 }, t, { context: o }))).then(function(u) {
            return a.shouldUseNativeValidation && OD({}, a), { values: r.raw ? n : u, errors: {} };
          }));
        } catch (u) {
          return l(u);
        }
        return c && c.then ? c.then(void 0, l) : c;
      }(0, function(i) {
        if (!i.inner)
          throw i;
        return { values: {}, errors: HG((l = i, c = !a.shouldUseNativeValidation && a.criteriaMode === "all", (l.inner || []).reduce(function(u, d) {
          if (u[d.path] || (u[d.path] = { message: d.message, type: d.type }), c) {
            var f = u[d.path].types, p = f && f[d.type];
            u[d.path] = hD(d.path, c, u, d.type, p ? [].concat(p, d.message) : d.message);
          }
          return u;
        }, {})), a) };
        var l, c;
      }));
    } catch (i) {
      return Promise.reject(i);
    }
  };
};
function ht(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var t = Number(e);
  return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t);
}
function $e(e, t) {
  if (t.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function Mc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Mc = function(r) {
    return typeof r;
  } : Mc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Mc(e);
}
function ke(e) {
  $e(1, arguments);
  var t = Object.prototype.toString.call(e);
  return e instanceof Date || Mc(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function my(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return isNaN(n) ? /* @__PURE__ */ new Date(NaN) : (n && r.setDate(r.getDate() + n), r);
}
function Vp(e, t) {
  $e(2, arguments);
  var r = ke(e).getTime(), n = ht(t);
  return new Date(r + n);
}
function YG(e, t) {
  $e(2, arguments);
  var r = ht(t);
  return Vp(e, r * 1e3);
}
var qG = 6e4;
function GG(e, t) {
  $e(2, arguments);
  var r = ht(t);
  return Vp(e, r * qG);
}
var KG = 36e5;
function XG(e, t) {
  $e(2, arguments);
  var r = ht(t);
  return Vp(e, r * KG);
}
function QG(e, t) {
  $e(2, arguments);
  var r = ht(t), n = r * 7;
  return my(e, n);
}
function Ac(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  if (isNaN(n))
    return /* @__PURE__ */ new Date(NaN);
  if (!n)
    return r;
  var o = r.getDate(), a = new Date(r.getTime());
  a.setMonth(r.getMonth() + n + 1, 0);
  var i = a.getDate();
  return o >= i ? a : (r.setFullYear(a.getFullYear(), a.getMonth(), o), r);
}
function cP(e, t) {
  $e(2, arguments);
  var r = ht(t);
  return Ac(e, r * 12);
}
function ZG(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getFullYear() - n.getFullYear();
}
function Bs(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t), o = r.getTime() - n.getTime();
  return o < 0 ? -1 : o > 0 ? 1 : o;
}
function JG(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t), o = Bs(r, n), a = Math.abs(ZG(r, n));
  r.setFullYear(1584), n.setFullYear(1584);
  var i = Bs(r, n) === -o, l = o * (a - Number(i));
  return l === 0 ? 0 : l;
}
function eK(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t), o = r.getFullYear() - n.getFullYear(), a = r.getMonth() - n.getMonth();
  return o * 12 + a;
}
function hy(e) {
  $e(1, arguments);
  var t = ke(e);
  return t.setHours(23, 59, 59, 999), t;
}
function yy(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getMonth();
  return t.setFullYear(t.getFullYear(), r + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function tK(e) {
  $e(1, arguments);
  var t = ke(e);
  return hy(t).getTime() === yy(t).getTime();
}
function PD(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t), o = Bs(r, n), a = Math.abs(eK(r, n)), i;
  if (a < 1)
    i = 0;
  else {
    r.getMonth() === 1 && r.getDate() > 27 && r.setDate(30), r.setMonth(r.getMonth() - o * a);
    var l = Bs(r, n) === -o;
    tK(ke(e)) && a === 1 && Bs(e, n) === 1 && (l = !1), i = o * (a - Number(l));
  }
  return i === 0 ? 0 : i;
}
var uP = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(t) {
    return t < 0 ? Math.ceil(t) : Math.floor(t);
  }
  // Math.trunc is not supported by IE
}, rK = "trunc";
function kl(e) {
  return e ? uP[e] : uP[rK];
}
function nK(e, t, r) {
  $e(2, arguments);
  var n = PD(e, t) / 3;
  return kl(r == null ? void 0 : r.roundingMethod)(n);
}
function rf(e) {
  var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
  return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime();
}
function Fi(e) {
  $e(1, arguments);
  var t = ke(e);
  return t.setHours(0, 0, 0, 0), t;
}
var oK = 864e5;
function aK(e, t) {
  $e(2, arguments);
  var r = Fi(e), n = Fi(t), o = r.getTime() - rf(r), a = n.getTime() - rf(n);
  return Math.round((o - a) / oK);
}
function dP(e, t) {
  var r = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return r < 0 ? -1 : r > 0 ? 1 : r;
}
function SD(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t), o = dP(r, n), a = Math.abs(aK(r, n));
  r.setDate(r.getDate() - o * a);
  var i = +(dP(r, n) === -o), l = o * (a - i);
  return l === 0 ? 0 : l;
}
function iK(e, t, r) {
  $e(2, arguments);
  var n = SD(e, t) / 7;
  return kl(r == null ? void 0 : r.roundingMethod)(n);
}
var zp = 6e4, Bp = 36e5, sK = 1e3;
function Wp(e, t) {
  return $e(2, arguments), ke(e).getTime() - ke(t).getTime();
}
function lK(e, t, r) {
  $e(2, arguments);
  var n = Wp(e, t) / Bp;
  return kl(r == null ? void 0 : r.roundingMethod)(n);
}
function cK(e, t, r) {
  $e(2, arguments);
  var n = Wp(e, t) / zp;
  return kl(r == null ? void 0 : r.roundingMethod)(n);
}
function uK(e, t, r) {
  $e(2, arguments);
  var n = Wp(e, t) / 1e3;
  return kl(r == null ? void 0 : r.roundingMethod)(n);
}
function dK(e, t) {
  var r;
  $e(1, arguments);
  var n = e || {}, o = ke(n.start), a = ke(n.end), i = a.getTime();
  if (!(o.getTime() <= i))
    throw new RangeError("Invalid interval");
  var l = [], c = o;
  c.setHours(0, 0, 0, 0);
  var u = Number((r = t == null ? void 0 : t.step) !== null && r !== void 0 ? r : 1);
  if (u < 1 || isNaN(u))
    throw new RangeError("`options.step` must be a number greater than 1");
  for (; c.getTime() <= i; )
    l.push(ke(c)), c.setDate(c.getDate() + u), c.setHours(0, 0, 0, 0);
  return l;
}
var fK = {};
function ro() {
  return fK;
}
function rh(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ro(), f = ht((r = (n = (o = (a = t == null ? void 0 : t.weekStartsOn) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && o !== void 0 ? o : d.weekStartsOn) !== null && n !== void 0 ? n : (c = d.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
  if (!(f >= 0 && f <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var p = ke(e), m = p.getDay(), y = (m < f ? -7 : 0) + 6 - (m - f);
  return p.setDate(p.getDate() + y), p.setHours(23, 59, 59, 999), p;
}
function nh(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getFullYear();
  return t.setFullYear(r + 1, 0, 0), t.setHours(23, 59, 59, 999), t;
}
function jc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? jc = function(r) {
    return typeof r;
  } : jc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, jc(e);
}
function pK(e) {
  return $e(1, arguments), e instanceof Date || jc(e) === "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function TD(e) {
  if ($e(1, arguments), !pK(e) && typeof e != "number")
    return !1;
  var t = ke(e);
  return !isNaN(Number(t));
}
function ED(e, t) {
  $e(2, arguments);
  var r = ht(t);
  return Vp(e, -r);
}
var mK = 864e5;
function hK(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getTime();
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  var n = t.getTime(), o = r - n;
  return Math.floor(o / mK) + 1;
}
function Li(e) {
  $e(1, arguments);
  var t = 1, r = ke(e), n = r.getUTCDay(), o = (n < t ? 7 : 0) + n - t;
  return r.setUTCDate(r.getUTCDate() - o), r.setUTCHours(0, 0, 0, 0), r;
}
function $D(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getUTCFullYear(), n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(r + 1, 0, 4), n.setUTCHours(0, 0, 0, 0);
  var o = Li(n), a = /* @__PURE__ */ new Date(0);
  a.setUTCFullYear(r, 0, 4), a.setUTCHours(0, 0, 0, 0);
  var i = Li(a);
  return t.getTime() >= o.getTime() ? r + 1 : t.getTime() >= i.getTime() ? r : r - 1;
}
function yK(e) {
  $e(1, arguments);
  var t = $D(e), r = /* @__PURE__ */ new Date(0);
  r.setUTCFullYear(t, 0, 4), r.setUTCHours(0, 0, 0, 0);
  var n = Li(r);
  return n;
}
var vK = 6048e5;
function CD(e) {
  $e(1, arguments);
  var t = ke(e), r = Li(t).getTime() - yK(t).getTime();
  return Math.round(r / vK) + 1;
}
function Na(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ro(), f = ht((r = (n = (o = (a = t == null ? void 0 : t.weekStartsOn) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && o !== void 0 ? o : d.weekStartsOn) !== null && n !== void 0 ? n : (c = d.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
  if (!(f >= 0 && f <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var p = ke(e), m = p.getUTCDay(), y = (m < f ? 7 : 0) + m - f;
  return p.setUTCDate(p.getUTCDate() - y), p.setUTCHours(0, 0, 0, 0), p;
}
function fb(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ke(e), f = d.getUTCFullYear(), p = ro(), m = ht((r = (n = (o = (a = t == null ? void 0 : t.firstWeekContainsDate) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.firstWeekContainsDate) !== null && o !== void 0 ? o : p.firstWeekContainsDate) !== null && n !== void 0 ? n : (c = p.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1);
  if (!(m >= 1 && m <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var y = /* @__PURE__ */ new Date(0);
  y.setUTCFullYear(f + 1, 0, m), y.setUTCHours(0, 0, 0, 0);
  var h = Na(y, t), v = /* @__PURE__ */ new Date(0);
  v.setUTCFullYear(f, 0, m), v.setUTCHours(0, 0, 0, 0);
  var g = Na(v, t);
  return d.getTime() >= h.getTime() ? f + 1 : d.getTime() >= g.getTime() ? f : f - 1;
}
function gK(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ro(), f = ht((r = (n = (o = (a = t == null ? void 0 : t.firstWeekContainsDate) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.firstWeekContainsDate) !== null && o !== void 0 ? o : d.firstWeekContainsDate) !== null && n !== void 0 ? n : (c = d.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1), p = fb(e, t), m = /* @__PURE__ */ new Date(0);
  m.setUTCFullYear(p, 0, f), m.setUTCHours(0, 0, 0, 0);
  var y = Na(m, t);
  return y;
}
var bK = 6048e5;
function kD(e, t) {
  $e(1, arguments);
  var r = ke(e), n = Na(r, t).getTime() - gK(r, t).getTime();
  return Math.round(n / bK) + 1;
}
function st(e, t) {
  for (var r = e < 0 ? "-" : "", n = Math.abs(e).toString(); n.length < t; )
    n = "0" + n;
  return r + n;
}
var wK = {
  // Year
  y: function(t, r) {
    var n = t.getUTCFullYear(), o = n > 0 ? n : 1 - n;
    return st(r === "yy" ? o % 100 : o, r.length);
  },
  // Month
  M: function(t, r) {
    var n = t.getUTCMonth();
    return r === "M" ? String(n + 1) : st(n + 1, 2);
  },
  // Day of the month
  d: function(t, r) {
    return st(t.getUTCDate(), r.length);
  },
  // AM or PM
  a: function(t, r) {
    var n = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function(t, r) {
    return st(t.getUTCHours() % 12 || 12, r.length);
  },
  // Hour [0-23]
  H: function(t, r) {
    return st(t.getUTCHours(), r.length);
  },
  // Minute
  m: function(t, r) {
    return st(t.getUTCMinutes(), r.length);
  },
  // Second
  s: function(t, r) {
    return st(t.getUTCSeconds(), r.length);
  },
  // Fraction of second
  S: function(t, r) {
    var n = r.length, o = t.getUTCMilliseconds(), a = Math.floor(o * Math.pow(10, n - 3));
    return st(a, r.length);
  }
};
const No = wK;
var oi = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, xK = {
  // Era
  G: function(t, r, n) {
    var o = t.getUTCFullYear() > 0 ? 1 : 0;
    switch (r) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(o, {
          width: "abbreviated"
        });
      case "GGGGG":
        return n.era(o, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return n.era(o, {
          width: "wide"
        });
    }
  },
  // Year
  y: function(t, r, n) {
    if (r === "yo") {
      var o = t.getUTCFullYear(), a = o > 0 ? o : 1 - o;
      return n.ordinalNumber(a, {
        unit: "year"
      });
    }
    return No.y(t, r);
  },
  // Local week-numbering year
  Y: function(t, r, n, o) {
    var a = fb(t, o), i = a > 0 ? a : 1 - a;
    if (r === "YY") {
      var l = i % 100;
      return st(l, 2);
    }
    return r === "Yo" ? n.ordinalNumber(i, {
      unit: "year"
    }) : st(i, r.length);
  },
  // ISO week-numbering year
  R: function(t, r) {
    var n = $D(t);
    return st(n, r.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, r) {
    var n = t.getUTCFullYear();
    return st(n, r.length);
  },
  // Quarter
  Q: function(t, r, n) {
    var o = Math.ceil((t.getUTCMonth() + 1) / 3);
    switch (r) {
      case "Q":
        return String(o);
      case "QQ":
        return st(o, 2);
      case "Qo":
        return n.ordinalNumber(o, {
          unit: "quarter"
        });
      case "QQQ":
        return n.quarter(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(o, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, r, n) {
    var o = Math.ceil((t.getUTCMonth() + 1) / 3);
    switch (r) {
      case "q":
        return String(o);
      case "qq":
        return st(o, 2);
      case "qo":
        return n.ordinalNumber(o, {
          unit: "quarter"
        });
      case "qqq":
        return n.quarter(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(o, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(o, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, r, n) {
    var o = t.getUTCMonth();
    switch (r) {
      case "M":
      case "MM":
        return No.M(t, r);
      case "Mo":
        return n.ordinalNumber(o + 1, {
          unit: "month"
        });
      case "MMM":
        return n.month(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(o, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function(t, r, n) {
    var o = t.getUTCMonth();
    switch (r) {
      case "L":
        return String(o + 1);
      case "LL":
        return st(o + 1, 2);
      case "Lo":
        return n.ordinalNumber(o + 1, {
          unit: "month"
        });
      case "LLL":
        return n.month(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(o, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(o, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function(t, r, n, o) {
    var a = kD(t, o);
    return r === "wo" ? n.ordinalNumber(a, {
      unit: "week"
    }) : st(a, r.length);
  },
  // ISO week of year
  I: function(t, r, n) {
    var o = CD(t);
    return r === "Io" ? n.ordinalNumber(o, {
      unit: "week"
    }) : st(o, r.length);
  },
  // Day of the month
  d: function(t, r, n) {
    return r === "do" ? n.ordinalNumber(t.getUTCDate(), {
      unit: "date"
    }) : No.d(t, r);
  },
  // Day of year
  D: function(t, r, n) {
    var o = hK(t);
    return r === "Do" ? n.ordinalNumber(o, {
      unit: "dayOfYear"
    }) : st(o, r.length);
  },
  // Day of week
  E: function(t, r, n) {
    var o = t.getUTCDay();
    switch (r) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(o, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, r, n, o) {
    var a = t.getUTCDay(), i = (a - o.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "e":
        return String(i);
      case "ee":
        return st(i, 2);
      case "eo":
        return n.ordinalNumber(i, {
          unit: "day"
        });
      case "eee":
        return n.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(a, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, r, n, o) {
    var a = t.getUTCDay(), i = (a - o.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "c":
        return String(i);
      case "cc":
        return st(i, r.length);
      case "co":
        return n.ordinalNumber(i, {
          unit: "day"
        });
      case "ccc":
        return n.day(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(a, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, r, n) {
    var o = t.getUTCDay(), a = o === 0 ? 7 : o;
    switch (r) {
      case "i":
        return String(a);
      case "ii":
        return st(a, r.length);
      case "io":
        return n.ordinalNumber(a, {
          unit: "day"
        });
      case "iii":
        return n.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(o, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, r, n) {
    var o = t.getUTCHours(), a = o / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return n.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, r, n) {
    var o = t.getUTCHours(), a;
    switch (o === 12 ? a = oi.noon : o === 0 ? a = oi.midnight : a = o / 12 >= 1 ? "pm" : "am", r) {
      case "b":
      case "bb":
        return n.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, r, n) {
    var o = t.getUTCHours(), a;
    switch (o >= 17 ? a = oi.evening : o >= 12 ? a = oi.afternoon : o >= 4 ? a = oi.morning : a = oi.night, r) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, r, n) {
    if (r === "ho") {
      var o = t.getUTCHours() % 12;
      return o === 0 && (o = 12), n.ordinalNumber(o, {
        unit: "hour"
      });
    }
    return No.h(t, r);
  },
  // Hour [0-23]
  H: function(t, r, n) {
    return r === "Ho" ? n.ordinalNumber(t.getUTCHours(), {
      unit: "hour"
    }) : No.H(t, r);
  },
  // Hour [0-11]
  K: function(t, r, n) {
    var o = t.getUTCHours() % 12;
    return r === "Ko" ? n.ordinalNumber(o, {
      unit: "hour"
    }) : st(o, r.length);
  },
  // Hour [1-24]
  k: function(t, r, n) {
    var o = t.getUTCHours();
    return o === 0 && (o = 24), r === "ko" ? n.ordinalNumber(o, {
      unit: "hour"
    }) : st(o, r.length);
  },
  // Minute
  m: function(t, r, n) {
    return r === "mo" ? n.ordinalNumber(t.getUTCMinutes(), {
      unit: "minute"
    }) : No.m(t, r);
  },
  // Second
  s: function(t, r, n) {
    return r === "so" ? n.ordinalNumber(t.getUTCSeconds(), {
      unit: "second"
    }) : No.s(t, r);
  },
  // Fraction of second
  S: function(t, r) {
    return No.S(t, r);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, r, n, o) {
    var a = o._originalDate || t, i = a.getTimezoneOffset();
    if (i === 0)
      return "Z";
    switch (r) {
      case "X":
        return pP(i);
      case "XXXX":
      case "XX":
        return pa(i);
      case "XXXXX":
      case "XXX":
      default:
        return pa(i, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, r, n, o) {
    var a = o._originalDate || t, i = a.getTimezoneOffset();
    switch (r) {
      case "x":
        return pP(i);
      case "xxxx":
      case "xx":
        return pa(i);
      case "xxxxx":
      case "xxx":
      default:
        return pa(i, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, r, n, o) {
    var a = o._originalDate || t, i = a.getTimezoneOffset();
    switch (r) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + fP(i, ":");
      case "OOOO":
      default:
        return "GMT" + pa(i, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, r, n, o) {
    var a = o._originalDate || t, i = a.getTimezoneOffset();
    switch (r) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + fP(i, ":");
      case "zzzz":
      default:
        return "GMT" + pa(i, ":");
    }
  },
  // Seconds timestamp
  t: function(t, r, n, o) {
    var a = o._originalDate || t, i = Math.floor(a.getTime() / 1e3);
    return st(i, r.length);
  },
  // Milliseconds timestamp
  T: function(t, r, n, o) {
    var a = o._originalDate || t, i = a.getTime();
    return st(i, r.length);
  }
};
function fP(e, t) {
  var r = e > 0 ? "-" : "+", n = Math.abs(e), o = Math.floor(n / 60), a = n % 60;
  if (a === 0)
    return r + String(o);
  var i = t || "";
  return r + String(o) + i + st(a, 2);
}
function pP(e, t) {
  if (e % 60 === 0) {
    var r = e > 0 ? "-" : "+";
    return r + st(Math.abs(e) / 60, 2);
  }
  return pa(e, t);
}
function pa(e, t) {
  var r = t || "", n = e > 0 ? "-" : "+", o = Math.abs(e), a = st(Math.floor(o / 60), 2), i = st(o % 60, 2);
  return n + a + r + i;
}
const _K = xK;
var mP = function(t, r) {
  switch (t) {
    case "P":
      return r.date({
        width: "short"
      });
    case "PP":
      return r.date({
        width: "medium"
      });
    case "PPP":
      return r.date({
        width: "long"
      });
    case "PPPP":
    default:
      return r.date({
        width: "full"
      });
  }
}, RD = function(t, r) {
  switch (t) {
    case "p":
      return r.time({
        width: "short"
      });
    case "pp":
      return r.time({
        width: "medium"
      });
    case "ppp":
      return r.time({
        width: "long"
      });
    case "pppp":
    default:
      return r.time({
        width: "full"
      });
  }
}, OK = function(t, r) {
  var n = t.match(/(P+)(p+)?/) || [], o = n[1], a = n[2];
  if (!a)
    return mP(t, r);
  var i;
  switch (o) {
    case "P":
      i = r.dateTime({
        width: "short"
      });
      break;
    case "PP":
      i = r.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      i = r.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      i = r.dateTime({
        width: "full"
      });
      break;
  }
  return i.replace("{{date}}", mP(o, r)).replace("{{time}}", RD(a, r));
}, PK = {
  p: RD,
  P: OK
};
const vy = PK;
var SK = ["D", "DD"], TK = ["YY", "YYYY"];
function DD(e) {
  return SK.indexOf(e) !== -1;
}
function ND(e) {
  return TK.indexOf(e) !== -1;
}
function nf(e, t, r) {
  if (e === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var EK = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, $K = function(t, r, n) {
  var o, a = EK[t];
  return typeof a == "string" ? o = a : r === 1 ? o = a.one : o = a.other.replace("{{count}}", r.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + o : o + " ago" : o;
};
const CK = $K;
function oh(e) {
  return function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = t.width ? String(t.width) : e.defaultWidth, n = e.formats[r] || e.formats[e.defaultWidth];
    return n;
  };
}
var kK = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, RK = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, DK = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, NK = {
  date: oh({
    formats: kK,
    defaultWidth: "full"
  }),
  time: oh({
    formats: RK,
    defaultWidth: "full"
  }),
  dateTime: oh({
    formats: DK,
    defaultWidth: "full"
  })
};
const IK = NK;
var MK = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, AK = function(t, r, n, o) {
  return MK[t];
};
const jK = AK;
function bs(e) {
  return function(t, r) {
    var n = r != null && r.context ? String(r.context) : "standalone", o;
    if (n === "formatting" && e.formattingValues) {
      var a = e.defaultFormattingWidth || e.defaultWidth, i = r != null && r.width ? String(r.width) : a;
      o = e.formattingValues[i] || e.formattingValues[a];
    } else {
      var l = e.defaultWidth, c = r != null && r.width ? String(r.width) : e.defaultWidth;
      o = e.values[c] || e.values[l];
    }
    var u = e.argumentCallback ? e.argumentCallback(t) : t;
    return o[u];
  };
}
var FK = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, LK = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, VK = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, zK = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, BK = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, WK = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, UK = function(t, r) {
  var n = Number(t), o = n % 100;
  if (o > 20 || o < 10)
    switch (o % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, HK = {
  ordinalNumber: UK,
  era: bs({
    values: FK,
    defaultWidth: "wide"
  }),
  quarter: bs({
    values: LK,
    defaultWidth: "wide",
    argumentCallback: function(t) {
      return t - 1;
    }
  }),
  month: bs({
    values: VK,
    defaultWidth: "wide"
  }),
  day: bs({
    values: zK,
    defaultWidth: "wide"
  }),
  dayPeriod: bs({
    values: BK,
    defaultWidth: "wide",
    formattingValues: WK,
    defaultFormattingWidth: "wide"
  })
};
const YK = HK;
function ws(e) {
  return function(t) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = r.width, o = n && e.matchPatterns[n] || e.matchPatterns[e.defaultMatchWidth], a = t.match(o);
    if (!a)
      return null;
    var i = a[0], l = n && e.parsePatterns[n] || e.parsePatterns[e.defaultParseWidth], c = Array.isArray(l) ? GK(l, function(f) {
      return f.test(i);
    }) : qK(l, function(f) {
      return f.test(i);
    }), u;
    u = e.valueCallback ? e.valueCallback(c) : c, u = r.valueCallback ? r.valueCallback(u) : u;
    var d = t.slice(i.length);
    return {
      value: u,
      rest: d
    };
  };
}
function qK(e, t) {
  for (var r in e)
    if (e.hasOwnProperty(r) && t(e[r]))
      return r;
}
function GK(e, t) {
  for (var r = 0; r < e.length; r++)
    if (t(e[r]))
      return r;
}
function KK(e) {
  return function(t) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.match(e.matchPattern);
    if (!n)
      return null;
    var o = n[0], a = t.match(e.parsePattern);
    if (!a)
      return null;
    var i = e.valueCallback ? e.valueCallback(a[0]) : a[0];
    i = r.valueCallback ? r.valueCallback(i) : i;
    var l = t.slice(o.length);
    return {
      value: i,
      rest: l
    };
  };
}
var XK = /^(\d+)(th|st|nd|rd)?/i, QK = /\d+/i, ZK = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, JK = {
  any: [/^b/i, /^(a|c)/i]
}, eX = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, tX = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, rX = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, nX = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, oX = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, aX = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, iX = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, sX = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, lX = {
  ordinalNumber: KK({
    matchPattern: XK,
    parsePattern: QK,
    valueCallback: function(t) {
      return parseInt(t, 10);
    }
  }),
  era: ws({
    matchPatterns: ZK,
    defaultMatchWidth: "wide",
    parsePatterns: JK,
    defaultParseWidth: "any"
  }),
  quarter: ws({
    matchPatterns: eX,
    defaultMatchWidth: "wide",
    parsePatterns: tX,
    defaultParseWidth: "any",
    valueCallback: function(t) {
      return t + 1;
    }
  }),
  month: ws({
    matchPatterns: rX,
    defaultMatchWidth: "wide",
    parsePatterns: nX,
    defaultParseWidth: "any"
  }),
  day: ws({
    matchPatterns: oX,
    defaultMatchWidth: "wide",
    parsePatterns: aX,
    defaultParseWidth: "any"
  }),
  dayPeriod: ws({
    matchPatterns: iX,
    defaultMatchWidth: "any",
    parsePatterns: sX,
    defaultParseWidth: "any"
  })
};
const cX = lX;
var uX = {
  code: "en-US",
  formatDistance: CK,
  formatLong: IK,
  formatRelative: jK,
  localize: YK,
  match: cX,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const Up = uX;
var dX = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, fX = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, pX = /^'([^]*?)'?$/, mX = /''/g, hX = /[a-zA-Z]/;
function yX(e, t, r) {
  var n, o, a, i, l, c, u, d, f, p, m, y, h, v, g, b, x, O;
  $e(2, arguments);
  var w = String(t), S = ro(), E = (n = (o = r == null ? void 0 : r.locale) !== null && o !== void 0 ? o : S.locale) !== null && n !== void 0 ? n : Up, C = ht((a = (i = (l = (c = r == null ? void 0 : r.firstWeekContainsDate) !== null && c !== void 0 ? c : r == null || (u = r.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && l !== void 0 ? l : S.firstWeekContainsDate) !== null && i !== void 0 ? i : (f = S.locale) === null || f === void 0 || (p = f.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && a !== void 0 ? a : 1);
  if (!(C >= 1 && C <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var N = ht((m = (y = (h = (v = r == null ? void 0 : r.weekStartsOn) !== null && v !== void 0 ? v : r == null || (g = r.locale) === null || g === void 0 || (b = g.options) === null || b === void 0 ? void 0 : b.weekStartsOn) !== null && h !== void 0 ? h : S.weekStartsOn) !== null && y !== void 0 ? y : (x = S.locale) === null || x === void 0 || (O = x.options) === null || O === void 0 ? void 0 : O.weekStartsOn) !== null && m !== void 0 ? m : 0);
  if (!(N >= 0 && N <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!E.localize)
    throw new RangeError("locale must contain localize property");
  if (!E.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var $ = ke(e);
  if (!TD($))
    throw new RangeError("Invalid time value");
  var j = rf($), A = ED($, j), k = {
    firstWeekContainsDate: C,
    weekStartsOn: N,
    locale: E,
    _originalDate: $
  }, R = w.match(fX).map(function(D) {
    var L = D[0];
    if (L === "p" || L === "P") {
      var B = vy[L];
      return B(D, E.formatLong);
    }
    return D;
  }).join("").match(dX).map(function(D) {
    if (D === "''")
      return "'";
    var L = D[0];
    if (L === "'")
      return vX(D);
    var B = _K[L];
    if (B)
      return !(r != null && r.useAdditionalWeekYearTokens) && ND(D) && nf(D, t, String(e)), !(r != null && r.useAdditionalDayOfYearTokens) && DD(D) && nf(D, t, String(e)), B(A, D, E.localize, k);
    if (L.match(hX))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + L + "`");
    return D;
  }).join("");
  return R;
}
function vX(e) {
  var t = e.match(pX);
  return t ? t[1].replace(mX, "'") : e;
}
function gX(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getDate();
  return r;
}
function bX(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getDay();
  return r;
}
function ID(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getFullYear(), n = t.getMonth(), o = /* @__PURE__ */ new Date(0);
  return o.setFullYear(r, n + 1, 0), o.setHours(0, 0, 0, 0), o.getDate();
}
function wX(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getHours();
  return r;
}
function xX(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getMinutes();
  return r;
}
function _X(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getMonth();
  return r;
}
function OX(e) {
  $e(1, arguments);
  var t = ke(e), r = t.getSeconds();
  return r;
}
function PX(e) {
  return $e(1, arguments), ke(e).getFullYear();
}
function ah(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getTime() > n.getTime();
}
function xs(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getTime() < n.getTime();
}
function SX(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getTime() === n.getTime();
}
function TX(e, t) {
  $e(2, arguments);
  var r = Fi(e), n = Fi(t);
  return r.getTime() === n.getTime();
}
function EX(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getFullYear() === n.getFullYear();
}
function $X(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ke(t);
  return r.getFullYear() === n.getFullYear() && r.getMonth() === n.getMonth();
}
function hP(e) {
  $e(1, arguments);
  var t = ke(e);
  return t.setMinutes(0, 0, 0), t;
}
function CX(e, t) {
  $e(2, arguments);
  var r = hP(e), n = hP(t);
  return r.getTime() === n.getTime();
}
function kX(e, t) {
  if (e == null)
    throw new TypeError("assign requires that input parameter not be null or undefined");
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e;
}
function Fc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Fc = function(r) {
    return typeof r;
  } : Fc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Fc(e);
}
function MD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && gy(e, t);
}
function gy(e, t) {
  return gy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, gy(e, t);
}
function AD(e) {
  var t = DX();
  return function() {
    var n = of(e), o;
    if (t) {
      var a = of(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return RX(this, o);
  };
}
function RX(e, t) {
  return t && (Fc(t) === "object" || typeof t == "function") ? t : by(e);
}
function by(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function DX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function of(e) {
  return of = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, of(e);
}
function pb(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function mb(e, t, r) {
  return t && yP(e.prototype, t), r && yP(e, r), e;
}
function wy(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var NX = 10, jD = /* @__PURE__ */ function() {
  function e() {
    pb(this, e), wy(this, "subPriority", 0);
  }
  return mb(e, [{
    key: "validate",
    value: function(r, n) {
      return !0;
    }
  }]), e;
}(), IX = /* @__PURE__ */ function(e) {
  MD(r, e);
  var t = AD(r);
  function r(n, o, a, i, l) {
    var c;
    return pb(this, r), c = t.call(this), c.value = n, c.validateValue = o, c.setValue = a, c.priority = i, l && (c.subPriority = l), c;
  }
  return mb(r, [{
    key: "validate",
    value: function(o, a) {
      return this.validateValue(o, this.value, a);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return this.setValue(o, a, this.value, i);
    }
  }]), r;
}(jD), MX = /* @__PURE__ */ function(e) {
  MD(r, e);
  var t = AD(r);
  function r() {
    var n;
    pb(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), wy(by(n), "priority", NX), wy(by(n), "subPriority", -1), n;
  }
  return mb(r, [{
    key: "set",
    value: function(o, a) {
      if (a.timestampIsSet)
        return o;
      var i = /* @__PURE__ */ new Date(0);
      return i.setFullYear(o.getUTCFullYear(), o.getUTCMonth(), o.getUTCDate()), i.setHours(o.getUTCHours(), o.getUTCMinutes(), o.getUTCSeconds(), o.getUTCMilliseconds()), i;
    }
  }]), r;
}(jD);
function AX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function jX(e, t, r) {
  return t && vP(e.prototype, t), r && vP(e, r), e;
}
var bt = /* @__PURE__ */ function() {
  function e() {
    AX(this, e);
  }
  return jX(e, [{
    key: "run",
    value: function(r, n, o, a) {
      var i = this.parse(r, n, o, a);
      return i ? {
        setter: new IX(i.value, this.validate, this.set, this.priority, this.subPriority),
        rest: i.rest
      } : null;
    }
  }, {
    key: "validate",
    value: function(r, n, o) {
      return !0;
    }
  }]), e;
}();
function Lc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Lc = function(r) {
    return typeof r;
  } : Lc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Lc(e);
}
function FX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function LX(e, t, r) {
  return t && gP(e.prototype, t), r && gP(e, r), e;
}
function VX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && xy(e, t);
}
function xy(e, t) {
  return xy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, xy(e, t);
}
function zX(e) {
  var t = WX();
  return function() {
    var n = af(e), o;
    if (t) {
      var a = af(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return BX(this, o);
  };
}
function BX(e, t) {
  return t && (Lc(t) === "object" || typeof t == "function") ? t : _y(e);
}
function _y(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function WX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function af(e) {
  return af = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, af(e);
}
function bP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var UX = /* @__PURE__ */ function(e) {
  VX(r, e);
  var t = zX(r);
  function r() {
    var n;
    FX(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), bP(_y(n), "priority", 140), bP(_y(n), "incompatibleTokens", ["R", "u", "t", "T"]), n;
  }
  return LX(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "G":
        case "GG":
        case "GGG":
          return i.era(o, {
            width: "abbreviated"
          }) || i.era(o, {
            width: "narrow"
          });
        case "GGGGG":
          return i.era(o, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return i.era(o, {
            width: "wide"
          }) || i.era(o, {
            width: "abbreviated"
          }) || i.era(o, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return a.era = i, o.setUTCFullYear(i, 0, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt), Kt = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, Vn = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Xt(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  };
}
function Ft(e, t) {
  var r = t.match(e);
  return r ? {
    value: parseInt(r[0], 10),
    rest: t.slice(r[0].length)
  } : null;
}
function zn(e, t) {
  var r = t.match(e);
  if (!r)
    return null;
  if (r[0] === "Z")
    return {
      value: 0,
      rest: t.slice(1)
    };
  var n = r[1] === "+" ? 1 : -1, o = r[2] ? parseInt(r[2], 10) : 0, a = r[3] ? parseInt(r[3], 10) : 0, i = r[5] ? parseInt(r[5], 10) : 0;
  return {
    value: n * (o * Bp + a * zp + i * sK),
    rest: t.slice(r[0].length)
  };
}
function FD(e) {
  return Ft(Kt.anyDigitsSigned, e);
}
function Wt(e, t) {
  switch (e) {
    case 1:
      return Ft(Kt.singleDigit, t);
    case 2:
      return Ft(Kt.twoDigits, t);
    case 3:
      return Ft(Kt.threeDigits, t);
    case 4:
      return Ft(Kt.fourDigits, t);
    default:
      return Ft(new RegExp("^\\d{1," + e + "}"), t);
  }
}
function sf(e, t) {
  switch (e) {
    case 1:
      return Ft(Kt.singleDigitSigned, t);
    case 2:
      return Ft(Kt.twoDigitsSigned, t);
    case 3:
      return Ft(Kt.threeDigitsSigned, t);
    case 4:
      return Ft(Kt.fourDigitsSigned, t);
    default:
      return Ft(new RegExp("^-?\\d{1," + e + "}"), t);
  }
}
function hb(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function LD(e, t) {
  var r = t > 0, n = r ? t : 1 - t, o;
  if (n <= 50)
    o = e || 100;
  else {
    var a = n + 50, i = Math.floor(a / 100) * 100, l = e >= a % 100;
    o = e + i - (l ? 100 : 0);
  }
  return r ? o : 1 - o;
}
function VD(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function Vc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Vc = function(r) {
    return typeof r;
  } : Vc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Vc(e);
}
function HX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function YX(e, t, r) {
  return t && wP(e.prototype, t), r && wP(e, r), e;
}
function qX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Oy(e, t);
}
function Oy(e, t) {
  return Oy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Oy(e, t);
}
function GX(e) {
  var t = XX();
  return function() {
    var n = lf(e), o;
    if (t) {
      var a = lf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return KX(this, o);
  };
}
function KX(e, t) {
  return t && (Vc(t) === "object" || typeof t == "function") ? t : Py(e);
}
function Py(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function XX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function lf(e) {
  return lf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, lf(e);
}
function xP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var QX = /* @__PURE__ */ function(e) {
  qX(r, e);
  var t = GX(r);
  function r() {
    var n;
    HX(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), xP(Py(n), "priority", 130), xP(Py(n), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), n;
  }
  return YX(r, [{
    key: "parse",
    value: function(o, a, i) {
      var l = function(u) {
        return {
          year: u,
          isTwoDigitYear: a === "yy"
        };
      };
      switch (a) {
        case "y":
          return Xt(Wt(4, o), l);
        case "yo":
          return Xt(i.ordinalNumber(o, {
            unit: "year"
          }), l);
        default:
          return Xt(Wt(a.length, o), l);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a.isTwoDigitYear || a.year > 0;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      var l = o.getUTCFullYear();
      if (i.isTwoDigitYear) {
        var c = LD(i.year, l);
        return o.setUTCFullYear(c, 0, 1), o.setUTCHours(0, 0, 0, 0), o;
      }
      var u = !("era" in a) || a.era === 1 ? i.year : 1 - i.year;
      return o.setUTCFullYear(u, 0, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function zc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? zc = function(r) {
    return typeof r;
  } : zc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, zc(e);
}
function ZX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _P(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function JX(e, t, r) {
  return t && _P(e.prototype, t), r && _P(e, r), e;
}
function eQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Sy(e, t);
}
function Sy(e, t) {
  return Sy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Sy(e, t);
}
function tQ(e) {
  var t = nQ();
  return function() {
    var n = cf(e), o;
    if (t) {
      var a = cf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return rQ(this, o);
  };
}
function rQ(e, t) {
  return t && (zc(t) === "object" || typeof t == "function") ? t : Ty(e);
}
function Ty(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function nQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function cf(e) {
  return cf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, cf(e);
}
function OP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var oQ = /* @__PURE__ */ function(e) {
  eQ(r, e);
  var t = tQ(r);
  function r() {
    var n;
    ZX(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), OP(Ty(n), "priority", 130), OP(Ty(n), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), n;
  }
  return JX(r, [{
    key: "parse",
    value: function(o, a, i) {
      var l = function(u) {
        return {
          year: u,
          isTwoDigitYear: a === "YY"
        };
      };
      switch (a) {
        case "Y":
          return Xt(Wt(4, o), l);
        case "Yo":
          return Xt(i.ordinalNumber(o, {
            unit: "year"
          }), l);
        default:
          return Xt(Wt(a.length, o), l);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a.isTwoDigitYear || a.year > 0;
    }
  }, {
    key: "set",
    value: function(o, a, i, l) {
      var c = fb(o, l);
      if (i.isTwoDigitYear) {
        var u = LD(i.year, c);
        return o.setUTCFullYear(u, 0, l.firstWeekContainsDate), o.setUTCHours(0, 0, 0, 0), Na(o, l);
      }
      var d = !("era" in a) || a.era === 1 ? i.year : 1 - i.year;
      return o.setUTCFullYear(d, 0, l.firstWeekContainsDate), o.setUTCHours(0, 0, 0, 0), Na(o, l);
    }
  }]), r;
}(bt);
function Bc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Bc = function(r) {
    return typeof r;
  } : Bc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Bc(e);
}
function aQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function iQ(e, t, r) {
  return t && PP(e.prototype, t), r && PP(e, r), e;
}
function sQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ey(e, t);
}
function Ey(e, t) {
  return Ey = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ey(e, t);
}
function lQ(e) {
  var t = uQ();
  return function() {
    var n = uf(e), o;
    if (t) {
      var a = uf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return cQ(this, o);
  };
}
function cQ(e, t) {
  return t && (Bc(t) === "object" || typeof t == "function") ? t : $y(e);
}
function $y(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function uQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function uf(e) {
  return uf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, uf(e);
}
function SP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var dQ = /* @__PURE__ */ function(e) {
  sQ(r, e);
  var t = lQ(r);
  function r() {
    var n;
    aQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), SP($y(n), "priority", 130), SP($y(n), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n;
  }
  return iQ(r, [{
    key: "parse",
    value: function(o, a) {
      return sf(a === "R" ? 4 : a.length, o);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      var l = /* @__PURE__ */ new Date(0);
      return l.setUTCFullYear(i, 0, 4), l.setUTCHours(0, 0, 0, 0), Li(l);
    }
  }]), r;
}(bt);
function Wc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Wc = function(r) {
    return typeof r;
  } : Wc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Wc(e);
}
function fQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function TP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function pQ(e, t, r) {
  return t && TP(e.prototype, t), r && TP(e, r), e;
}
function mQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Cy(e, t);
}
function Cy(e, t) {
  return Cy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Cy(e, t);
}
function hQ(e) {
  var t = vQ();
  return function() {
    var n = df(e), o;
    if (t) {
      var a = df(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return yQ(this, o);
  };
}
function yQ(e, t) {
  return t && (Wc(t) === "object" || typeof t == "function") ? t : ky(e);
}
function ky(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function vQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function df(e) {
  return df = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, df(e);
}
function EP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var gQ = /* @__PURE__ */ function(e) {
  mQ(r, e);
  var t = hQ(r);
  function r() {
    var n;
    fQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), EP(ky(n), "priority", 130), EP(ky(n), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), n;
  }
  return pQ(r, [{
    key: "parse",
    value: function(o, a) {
      return sf(a === "u" ? 4 : a.length, o);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCFullYear(i, 0, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function Uc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Uc = function(r) {
    return typeof r;
  } : Uc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Uc(e);
}
function bQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $P(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function wQ(e, t, r) {
  return t && $P(e.prototype, t), r && $P(e, r), e;
}
function xQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ry(e, t);
}
function Ry(e, t) {
  return Ry = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ry(e, t);
}
function _Q(e) {
  var t = PQ();
  return function() {
    var n = ff(e), o;
    if (t) {
      var a = ff(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return OQ(this, o);
  };
}
function OQ(e, t) {
  return t && (Uc(t) === "object" || typeof t == "function") ? t : Dy(e);
}
function Dy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function PQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ff(e) {
  return ff = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, ff(e);
}
function CP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var SQ = /* @__PURE__ */ function(e) {
  xQ(r, e);
  var t = _Q(r);
  function r() {
    var n;
    bQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), CP(Dy(n), "priority", 120), CP(Dy(n), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n;
  }
  return wQ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "Q":
        case "QQ":
          return Wt(a.length, o);
        case "Qo":
          return i.ordinalNumber(o, {
            unit: "quarter"
          });
        case "QQQ":
          return i.quarter(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.quarter(o, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return i.quarter(o, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return i.quarter(o, {
            width: "wide",
            context: "formatting"
          }) || i.quarter(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.quarter(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 4;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMonth((i - 1) * 3, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function Hc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Hc = function(r) {
    return typeof r;
  } : Hc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Hc(e);
}
function TQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function EQ(e, t, r) {
  return t && kP(e.prototype, t), r && kP(e, r), e;
}
function $Q(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ny(e, t);
}
function Ny(e, t) {
  return Ny = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ny(e, t);
}
function CQ(e) {
  var t = RQ();
  return function() {
    var n = pf(e), o;
    if (t) {
      var a = pf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return kQ(this, o);
  };
}
function kQ(e, t) {
  return t && (Hc(t) === "object" || typeof t == "function") ? t : Iy(e);
}
function Iy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function RQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function pf(e) {
  return pf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, pf(e);
}
function RP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var DQ = /* @__PURE__ */ function(e) {
  $Q(r, e);
  var t = CQ(r);
  function r() {
    var n;
    TQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), RP(Iy(n), "priority", 120), RP(Iy(n), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n;
  }
  return EQ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "q":
        case "qq":
          return Wt(a.length, o);
        case "qo":
          return i.ordinalNumber(o, {
            unit: "quarter"
          });
        case "qqq":
          return i.quarter(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.quarter(o, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return i.quarter(o, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return i.quarter(o, {
            width: "wide",
            context: "standalone"
          }) || i.quarter(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.quarter(o, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 4;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMonth((i - 1) * 3, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function Yc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Yc = function(r) {
    return typeof r;
  } : Yc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Yc(e);
}
function NQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function IQ(e, t, r) {
  return t && DP(e.prototype, t), r && DP(e, r), e;
}
function MQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && My(e, t);
}
function My(e, t) {
  return My = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, My(e, t);
}
function AQ(e) {
  var t = FQ();
  return function() {
    var n = mf(e), o;
    if (t) {
      var a = mf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return jQ(this, o);
  };
}
function jQ(e, t) {
  return t && (Yc(t) === "object" || typeof t == "function") ? t : Ay(e);
}
function Ay(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function FQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function mf(e) {
  return mf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, mf(e);
}
function NP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var LQ = /* @__PURE__ */ function(e) {
  MQ(r, e);
  var t = AQ(r);
  function r() {
    var n;
    NQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), NP(Ay(n), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), NP(Ay(n), "priority", 110), n;
  }
  return IQ(r, [{
    key: "parse",
    value: function(o, a, i) {
      var l = function(u) {
        return u - 1;
      };
      switch (a) {
        case "M":
          return Xt(Ft(Kt.month, o), l);
        case "MM":
          return Xt(Wt(2, o), l);
        case "Mo":
          return Xt(i.ordinalNumber(o, {
            unit: "month"
          }), l);
        case "MMM":
          return i.month(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.month(o, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return i.month(o, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return i.month(o, {
            width: "wide",
            context: "formatting"
          }) || i.month(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.month(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 11;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMonth(i, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function qc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? qc = function(r) {
    return typeof r;
  } : qc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, qc(e);
}
function VQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function zQ(e, t, r) {
  return t && IP(e.prototype, t), r && IP(e, r), e;
}
function BQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && jy(e, t);
}
function jy(e, t) {
  return jy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, jy(e, t);
}
function WQ(e) {
  var t = HQ();
  return function() {
    var n = hf(e), o;
    if (t) {
      var a = hf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return UQ(this, o);
  };
}
function UQ(e, t) {
  return t && (qc(t) === "object" || typeof t == "function") ? t : Fy(e);
}
function Fy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function HQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function hf(e) {
  return hf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, hf(e);
}
function MP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var YQ = /* @__PURE__ */ function(e) {
  BQ(r, e);
  var t = WQ(r);
  function r() {
    var n;
    VQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), MP(Fy(n), "priority", 110), MP(Fy(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), n;
  }
  return zQ(r, [{
    key: "parse",
    value: function(o, a, i) {
      var l = function(u) {
        return u - 1;
      };
      switch (a) {
        case "L":
          return Xt(Ft(Kt.month, o), l);
        case "LL":
          return Xt(Wt(2, o), l);
        case "Lo":
          return Xt(i.ordinalNumber(o, {
            unit: "month"
          }), l);
        case "LLL":
          return i.month(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.month(o, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return i.month(o, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return i.month(o, {
            width: "wide",
            context: "standalone"
          }) || i.month(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.month(o, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 11;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMonth(i, 1), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function qQ(e, t, r) {
  $e(2, arguments);
  var n = ke(e), o = ht(t), a = kD(n, r) - o;
  return n.setUTCDate(n.getUTCDate() - a * 7), n;
}
function Gc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Gc = function(r) {
    return typeof r;
  } : Gc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Gc(e);
}
function GQ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function AP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function KQ(e, t, r) {
  return t && AP(e.prototype, t), r && AP(e, r), e;
}
function XQ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ly(e, t);
}
function Ly(e, t) {
  return Ly = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ly(e, t);
}
function QQ(e) {
  var t = JQ();
  return function() {
    var n = yf(e), o;
    if (t) {
      var a = yf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return ZQ(this, o);
  };
}
function ZQ(e, t) {
  return t && (Gc(t) === "object" || typeof t == "function") ? t : Vy(e);
}
function Vy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function JQ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function yf(e) {
  return yf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, yf(e);
}
function jP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var eZ = /* @__PURE__ */ function(e) {
  XQ(r, e);
  var t = QQ(r);
  function r() {
    var n;
    GQ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), jP(Vy(n), "priority", 100), jP(Vy(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), n;
  }
  return KQ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "w":
          return Ft(Kt.week, o);
        case "wo":
          return i.ordinalNumber(o, {
            unit: "week"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 53;
    }
  }, {
    key: "set",
    value: function(o, a, i, l) {
      return Na(qQ(o, i, l), l);
    }
  }]), r;
}(bt);
function tZ(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t), o = CD(r) - n;
  return r.setUTCDate(r.getUTCDate() - o * 7), r;
}
function Kc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Kc = function(r) {
    return typeof r;
  } : Kc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Kc(e);
}
function rZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function FP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function nZ(e, t, r) {
  return t && FP(e.prototype, t), r && FP(e, r), e;
}
function oZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && zy(e, t);
}
function zy(e, t) {
  return zy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, zy(e, t);
}
function aZ(e) {
  var t = sZ();
  return function() {
    var n = vf(e), o;
    if (t) {
      var a = vf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return iZ(this, o);
  };
}
function iZ(e, t) {
  return t && (Kc(t) === "object" || typeof t == "function") ? t : By(e);
}
function By(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function sZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function vf(e) {
  return vf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, vf(e);
}
function LP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var lZ = /* @__PURE__ */ function(e) {
  oZ(r, e);
  var t = aZ(r);
  function r() {
    var n;
    rZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), LP(By(n), "priority", 100), LP(By(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n;
  }
  return nZ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "I":
          return Ft(Kt.week, o);
        case "Io":
          return i.ordinalNumber(o, {
            unit: "week"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 53;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return Li(tZ(o, i));
    }
  }]), r;
}(bt);
function Xc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xc = function(r) {
    return typeof r;
  } : Xc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Xc(e);
}
function cZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function VP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function uZ(e, t, r) {
  return t && VP(e.prototype, t), r && VP(e, r), e;
}
function dZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Wy(e, t);
}
function Wy(e, t) {
  return Wy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Wy(e, t);
}
function fZ(e) {
  var t = mZ();
  return function() {
    var n = gf(e), o;
    if (t) {
      var a = gf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return pZ(this, o);
  };
}
function pZ(e, t) {
  return t && (Xc(t) === "object" || typeof t == "function") ? t : Qc(e);
}
function Qc(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function mZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function gf(e) {
  return gf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, gf(e);
}
function ih(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var hZ = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], yZ = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], vZ = /* @__PURE__ */ function(e) {
  dZ(r, e);
  var t = fZ(r);
  function r() {
    var n;
    cZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), ih(Qc(n), "priority", 90), ih(Qc(n), "subPriority", 1), ih(Qc(n), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), n;
  }
  return uZ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "d":
          return Ft(Kt.date, o);
        case "do":
          return i.ordinalNumber(o, {
            unit: "date"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      var i = o.getUTCFullYear(), l = VD(i), c = o.getUTCMonth();
      return l ? a >= 1 && a <= yZ[c] : a >= 1 && a <= hZ[c];
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCDate(i), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function Zc(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Zc = function(r) {
    return typeof r;
  } : Zc = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Zc(e);
}
function gZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function bZ(e, t, r) {
  return t && zP(e.prototype, t), r && zP(e, r), e;
}
function wZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Uy(e, t);
}
function Uy(e, t) {
  return Uy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Uy(e, t);
}
function xZ(e) {
  var t = OZ();
  return function() {
    var n = bf(e), o;
    if (t) {
      var a = bf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return _Z(this, o);
  };
}
function _Z(e, t) {
  return t && (Zc(t) === "object" || typeof t == "function") ? t : Jc(e);
}
function Jc(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function OZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function bf(e) {
  return bf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, bf(e);
}
function sh(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var PZ = /* @__PURE__ */ function(e) {
  wZ(r, e);
  var t = xZ(r);
  function r() {
    var n;
    gZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), sh(Jc(n), "priority", 90), sh(Jc(n), "subpriority", 1), sh(Jc(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), n;
  }
  return bZ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "D":
        case "DD":
          return Ft(Kt.dayOfYear, o);
        case "Do":
          return i.ordinalNumber(o, {
            unit: "date"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      var i = o.getUTCFullYear(), l = VD(i);
      return l ? a >= 1 && a <= 366 : a >= 1 && a <= 365;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMonth(0, i), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function yb(e, t, r) {
  var n, o, a, i, l, c, u, d;
  $e(2, arguments);
  var f = ro(), p = ht((n = (o = (a = (i = r == null ? void 0 : r.weekStartsOn) !== null && i !== void 0 ? i : r == null || (l = r.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && a !== void 0 ? a : f.weekStartsOn) !== null && o !== void 0 ? o : (u = f.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(p >= 0 && p <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var m = ke(e), y = ht(t), h = m.getUTCDay(), v = y % 7, g = (v + 7) % 7, b = (g < p ? 7 : 0) + y - h;
  return m.setUTCDate(m.getUTCDate() + b), m;
}
function eu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? eu = function(r) {
    return typeof r;
  } : eu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, eu(e);
}
function SZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function TZ(e, t, r) {
  return t && BP(e.prototype, t), r && BP(e, r), e;
}
function EZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Hy(e, t);
}
function Hy(e, t) {
  return Hy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Hy(e, t);
}
function $Z(e) {
  var t = kZ();
  return function() {
    var n = wf(e), o;
    if (t) {
      var a = wf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return CZ(this, o);
  };
}
function CZ(e, t) {
  return t && (eu(t) === "object" || typeof t == "function") ? t : Yy(e);
}
function Yy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function kZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function wf(e) {
  return wf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, wf(e);
}
function WP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var RZ = /* @__PURE__ */ function(e) {
  EZ(r, e);
  var t = $Z(r);
  function r() {
    var n;
    SZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), WP(Yy(n), "priority", 90), WP(Yy(n), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), n;
  }
  return TZ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "E":
        case "EE":
        case "EEE":
          return i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return i.day(o, {
            width: "wide",
            context: "formatting"
          }) || i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 6;
    }
  }, {
    key: "set",
    value: function(o, a, i, l) {
      return o = yb(o, i, l), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function tu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? tu = function(r) {
    return typeof r;
  } : tu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, tu(e);
}
function DZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function UP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function NZ(e, t, r) {
  return t && UP(e.prototype, t), r && UP(e, r), e;
}
function IZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && qy(e, t);
}
function qy(e, t) {
  return qy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, qy(e, t);
}
function MZ(e) {
  var t = jZ();
  return function() {
    var n = xf(e), o;
    if (t) {
      var a = xf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return AZ(this, o);
  };
}
function AZ(e, t) {
  return t && (tu(t) === "object" || typeof t == "function") ? t : Gy(e);
}
function Gy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function jZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function xf(e) {
  return xf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, xf(e);
}
function HP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var FZ = /* @__PURE__ */ function(e) {
  IZ(r, e);
  var t = MZ(r);
  function r() {
    var n;
    DZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), HP(Gy(n), "priority", 90), HP(Gy(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), n;
  }
  return NZ(r, [{
    key: "parse",
    value: function(o, a, i, l) {
      var c = function(d) {
        var f = Math.floor((d - 1) / 7) * 7;
        return (d + l.weekStartsOn + 6) % 7 + f;
      };
      switch (a) {
        case "e":
        case "ee":
          return Xt(Wt(a.length, o), c);
        case "eo":
          return Xt(i.ordinalNumber(o, {
            unit: "day"
          }), c);
        case "eee":
          return i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return i.day(o, {
            width: "wide",
            context: "formatting"
          }) || i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 6;
    }
  }, {
    key: "set",
    value: function(o, a, i, l) {
      return o = yb(o, i, l), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function ru(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ru = function(r) {
    return typeof r;
  } : ru = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, ru(e);
}
function LZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function YP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function VZ(e, t, r) {
  return t && YP(e.prototype, t), r && YP(e, r), e;
}
function zZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ky(e, t);
}
function Ky(e, t) {
  return Ky = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ky(e, t);
}
function BZ(e) {
  var t = UZ();
  return function() {
    var n = _f(e), o;
    if (t) {
      var a = _f(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return WZ(this, o);
  };
}
function WZ(e, t) {
  return t && (ru(t) === "object" || typeof t == "function") ? t : Xy(e);
}
function Xy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function UZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _f(e) {
  return _f = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, _f(e);
}
function qP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var HZ = /* @__PURE__ */ function(e) {
  zZ(r, e);
  var t = BZ(r);
  function r() {
    var n;
    LZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), qP(Xy(n), "priority", 90), qP(Xy(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), n;
  }
  return VZ(r, [{
    key: "parse",
    value: function(o, a, i, l) {
      var c = function(d) {
        var f = Math.floor((d - 1) / 7) * 7;
        return (d + l.weekStartsOn + 6) % 7 + f;
      };
      switch (a) {
        case "c":
        case "cc":
          return Xt(Wt(a.length, o), c);
        case "co":
          return Xt(i.ordinalNumber(o, {
            unit: "day"
          }), c);
        case "ccc":
          return i.day(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.day(o, {
            width: "short",
            context: "standalone"
          }) || i.day(o, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return i.day(o, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return i.day(o, {
            width: "short",
            context: "standalone"
          }) || i.day(o, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return i.day(o, {
            width: "wide",
            context: "standalone"
          }) || i.day(o, {
            width: "abbreviated",
            context: "standalone"
          }) || i.day(o, {
            width: "short",
            context: "standalone"
          }) || i.day(o, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 6;
    }
  }, {
    key: "set",
    value: function(o, a, i, l) {
      return o = yb(o, i, l), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function YZ(e, t) {
  $e(2, arguments);
  var r = ht(t);
  r % 7 === 0 && (r = r - 7);
  var n = 1, o = ke(e), a = o.getUTCDay(), i = r % 7, l = (i + 7) % 7, c = (l < n ? 7 : 0) + r - a;
  return o.setUTCDate(o.getUTCDate() + c), o;
}
function nu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? nu = function(r) {
    return typeof r;
  } : nu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, nu(e);
}
function qZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function GP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function GZ(e, t, r) {
  return t && GP(e.prototype, t), r && GP(e, r), e;
}
function KZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Qy(e, t);
}
function Qy(e, t) {
  return Qy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Qy(e, t);
}
function XZ(e) {
  var t = ZZ();
  return function() {
    var n = Of(e), o;
    if (t) {
      var a = Of(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return QZ(this, o);
  };
}
function QZ(e, t) {
  return t && (nu(t) === "object" || typeof t == "function") ? t : Zy(e);
}
function Zy(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ZZ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Of(e) {
  return Of = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Of(e);
}
function KP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var JZ = /* @__PURE__ */ function(e) {
  KZ(r, e);
  var t = XZ(r);
  function r() {
    var n;
    qZ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), KP(Zy(n), "priority", 90), KP(Zy(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), n;
  }
  return GZ(r, [{
    key: "parse",
    value: function(o, a, i) {
      var l = function(u) {
        return u === 0 ? 7 : u;
      };
      switch (a) {
        case "i":
        case "ii":
          return Wt(a.length, o);
        case "io":
          return i.ordinalNumber(o, {
            unit: "day"
          });
        case "iii":
          return Xt(i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          }), l);
        case "iiiii":
          return Xt(i.day(o, {
            width: "narrow",
            context: "formatting"
          }), l);
        case "iiiiii":
          return Xt(i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          }), l);
        case "iiii":
        default:
          return Xt(i.day(o, {
            width: "wide",
            context: "formatting"
          }) || i.day(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.day(o, {
            width: "short",
            context: "formatting"
          }) || i.day(o, {
            width: "narrow",
            context: "formatting"
          }), l);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 7;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o = YZ(o, i), o.setUTCHours(0, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function ou(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ou = function(r) {
    return typeof r;
  } : ou = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, ou(e);
}
function eJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function tJ(e, t, r) {
  return t && XP(e.prototype, t), r && XP(e, r), e;
}
function rJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Jy(e, t);
}
function Jy(e, t) {
  return Jy = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Jy(e, t);
}
function nJ(e) {
  var t = aJ();
  return function() {
    var n = Pf(e), o;
    if (t) {
      var a = Pf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return oJ(this, o);
  };
}
function oJ(e, t) {
  return t && (ou(t) === "object" || typeof t == "function") ? t : ev(e);
}
function ev(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function aJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Pf(e) {
  return Pf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Pf(e);
}
function QP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var iJ = /* @__PURE__ */ function(e) {
  rJ(r, e);
  var t = nJ(r);
  function r() {
    var n;
    eJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), QP(ev(n), "priority", 80), QP(ev(n), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), n;
  }
  return tJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "a":
        case "aa":
        case "aaa":
          return i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return i.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCHours(hb(i), 0, 0, 0), o;
    }
  }]), r;
}(bt);
function au(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? au = function(r) {
    return typeof r;
  } : au = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, au(e);
}
function sJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ZP(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function lJ(e, t, r) {
  return t && ZP(e.prototype, t), r && ZP(e, r), e;
}
function cJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && tv(e, t);
}
function tv(e, t) {
  return tv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, tv(e, t);
}
function uJ(e) {
  var t = fJ();
  return function() {
    var n = Sf(e), o;
    if (t) {
      var a = Sf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return dJ(this, o);
  };
}
function dJ(e, t) {
  return t && (au(t) === "object" || typeof t == "function") ? t : rv(e);
}
function rv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function fJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Sf(e) {
  return Sf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Sf(e);
}
function JP(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var pJ = /* @__PURE__ */ function(e) {
  cJ(r, e);
  var t = uJ(r);
  function r() {
    var n;
    sJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), JP(rv(n), "priority", 80), JP(rv(n), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), n;
  }
  return lJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "b":
        case "bb":
        case "bbb":
          return i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return i.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCHours(hb(i), 0, 0, 0), o;
    }
  }]), r;
}(bt);
function iu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? iu = function(r) {
    return typeof r;
  } : iu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, iu(e);
}
function mJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function eS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function hJ(e, t, r) {
  return t && eS(e.prototype, t), r && eS(e, r), e;
}
function yJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && nv(e, t);
}
function nv(e, t) {
  return nv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, nv(e, t);
}
function vJ(e) {
  var t = bJ();
  return function() {
    var n = Tf(e), o;
    if (t) {
      var a = Tf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return gJ(this, o);
  };
}
function gJ(e, t) {
  return t && (iu(t) === "object" || typeof t == "function") ? t : ov(e);
}
function ov(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function bJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Tf(e) {
  return Tf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Tf(e);
}
function tS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var wJ = /* @__PURE__ */ function(e) {
  yJ(r, e);
  var t = vJ(r);
  function r() {
    var n;
    mJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), tS(ov(n), "priority", 80), tS(ov(n), "incompatibleTokens", ["a", "b", "t", "T"]), n;
  }
  return hJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "B":
        case "BB":
        case "BBB":
          return i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return i.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }) || i.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCHours(hb(i), 0, 0, 0), o;
    }
  }]), r;
}(bt);
function su(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? su = function(r) {
    return typeof r;
  } : su = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, su(e);
}
function xJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function _J(e, t, r) {
  return t && rS(e.prototype, t), r && rS(e, r), e;
}
function OJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && av(e, t);
}
function av(e, t) {
  return av = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, av(e, t);
}
function PJ(e) {
  var t = TJ();
  return function() {
    var n = Ef(e), o;
    if (t) {
      var a = Ef(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return SJ(this, o);
  };
}
function SJ(e, t) {
  return t && (su(t) === "object" || typeof t == "function") ? t : iv(e);
}
function iv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function TJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ef(e) {
  return Ef = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Ef(e);
}
function nS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var EJ = /* @__PURE__ */ function(e) {
  OJ(r, e);
  var t = PJ(r);
  function r() {
    var n;
    xJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), nS(iv(n), "priority", 70), nS(iv(n), "incompatibleTokens", ["H", "K", "k", "t", "T"]), n;
  }
  return _J(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "h":
          return Ft(Kt.hour12h, o);
        case "ho":
          return i.ordinalNumber(o, {
            unit: "hour"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 12;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      var l = o.getUTCHours() >= 12;
      return l && i < 12 ? o.setUTCHours(i + 12, 0, 0, 0) : !l && i === 12 ? o.setUTCHours(0, 0, 0, 0) : o.setUTCHours(i, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function lu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? lu = function(r) {
    return typeof r;
  } : lu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, lu(e);
}
function $J(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function oS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function CJ(e, t, r) {
  return t && oS(e.prototype, t), r && oS(e, r), e;
}
function kJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && sv(e, t);
}
function sv(e, t) {
  return sv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, sv(e, t);
}
function RJ(e) {
  var t = NJ();
  return function() {
    var n = $f(e), o;
    if (t) {
      var a = $f(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return DJ(this, o);
  };
}
function DJ(e, t) {
  return t && (lu(t) === "object" || typeof t == "function") ? t : lv(e);
}
function lv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function NJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function $f(e) {
  return $f = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, $f(e);
}
function aS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var IJ = /* @__PURE__ */ function(e) {
  kJ(r, e);
  var t = RJ(r);
  function r() {
    var n;
    $J(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), aS(lv(n), "priority", 70), aS(lv(n), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), n;
  }
  return CJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "H":
          return Ft(Kt.hour23h, o);
        case "Ho":
          return i.ordinalNumber(o, {
            unit: "hour"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 23;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCHours(i, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function cu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? cu = function(r) {
    return typeof r;
  } : cu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, cu(e);
}
function MJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function AJ(e, t, r) {
  return t && iS(e.prototype, t), r && iS(e, r), e;
}
function jJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && cv(e, t);
}
function cv(e, t) {
  return cv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, cv(e, t);
}
function FJ(e) {
  var t = VJ();
  return function() {
    var n = Cf(e), o;
    if (t) {
      var a = Cf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return LJ(this, o);
  };
}
function LJ(e, t) {
  return t && (cu(t) === "object" || typeof t == "function") ? t : uv(e);
}
function uv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function VJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Cf(e) {
  return Cf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Cf(e);
}
function sS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var zJ = /* @__PURE__ */ function(e) {
  jJ(r, e);
  var t = FJ(r);
  function r() {
    var n;
    MJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), sS(uv(n), "priority", 70), sS(uv(n), "incompatibleTokens", ["h", "H", "k", "t", "T"]), n;
  }
  return AJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "K":
          return Ft(Kt.hour11h, o);
        case "Ko":
          return i.ordinalNumber(o, {
            unit: "hour"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 11;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      var l = o.getUTCHours() >= 12;
      return l && i < 12 ? o.setUTCHours(i + 12, 0, 0, 0) : o.setUTCHours(i, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function uu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? uu = function(r) {
    return typeof r;
  } : uu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, uu(e);
}
function BJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function WJ(e, t, r) {
  return t && lS(e.prototype, t), r && lS(e, r), e;
}
function UJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && dv(e, t);
}
function dv(e, t) {
  return dv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, dv(e, t);
}
function HJ(e) {
  var t = qJ();
  return function() {
    var n = kf(e), o;
    if (t) {
      var a = kf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return YJ(this, o);
  };
}
function YJ(e, t) {
  return t && (uu(t) === "object" || typeof t == "function") ? t : fv(e);
}
function fv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function qJ() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function kf(e) {
  return kf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, kf(e);
}
function cS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var GJ = /* @__PURE__ */ function(e) {
  UJ(r, e);
  var t = HJ(r);
  function r() {
    var n;
    BJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), cS(fv(n), "priority", 70), cS(fv(n), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), n;
  }
  return WJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "k":
          return Ft(Kt.hour24h, o);
        case "ko":
          return i.ordinalNumber(o, {
            unit: "hour"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 1 && a <= 24;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      var l = i <= 24 ? i % 24 : i;
      return o.setUTCHours(l, 0, 0, 0), o;
    }
  }]), r;
}(bt);
function du(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? du = function(r) {
    return typeof r;
  } : du = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, du(e);
}
function KJ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function XJ(e, t, r) {
  return t && uS(e.prototype, t), r && uS(e, r), e;
}
function QJ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && pv(e, t);
}
function pv(e, t) {
  return pv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, pv(e, t);
}
function ZJ(e) {
  var t = eee();
  return function() {
    var n = Rf(e), o;
    if (t) {
      var a = Rf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return JJ(this, o);
  };
}
function JJ(e, t) {
  return t && (du(t) === "object" || typeof t == "function") ? t : mv(e);
}
function mv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function eee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Rf(e) {
  return Rf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Rf(e);
}
function dS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var tee = /* @__PURE__ */ function(e) {
  QJ(r, e);
  var t = ZJ(r);
  function r() {
    var n;
    KJ(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), dS(mv(n), "priority", 60), dS(mv(n), "incompatibleTokens", ["t", "T"]), n;
  }
  return XJ(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "m":
          return Ft(Kt.minute, o);
        case "mo":
          return i.ordinalNumber(o, {
            unit: "minute"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 59;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMinutes(i, 0, 0), o;
    }
  }]), r;
}(bt);
function fu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fu = function(r) {
    return typeof r;
  } : fu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, fu(e);
}
function ree(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function nee(e, t, r) {
  return t && fS(e.prototype, t), r && fS(e, r), e;
}
function oee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && hv(e, t);
}
function hv(e, t) {
  return hv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, hv(e, t);
}
function aee(e) {
  var t = see();
  return function() {
    var n = Df(e), o;
    if (t) {
      var a = Df(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return iee(this, o);
  };
}
function iee(e, t) {
  return t && (fu(t) === "object" || typeof t == "function") ? t : yv(e);
}
function yv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function see() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Df(e) {
  return Df = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Df(e);
}
function pS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var lee = /* @__PURE__ */ function(e) {
  oee(r, e);
  var t = aee(r);
  function r() {
    var n;
    ree(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), pS(yv(n), "priority", 50), pS(yv(n), "incompatibleTokens", ["t", "T"]), n;
  }
  return nee(r, [{
    key: "parse",
    value: function(o, a, i) {
      switch (a) {
        case "s":
          return Ft(Kt.second, o);
        case "so":
          return i.ordinalNumber(o, {
            unit: "second"
          });
        default:
          return Wt(a.length, o);
      }
    }
  }, {
    key: "validate",
    value: function(o, a) {
      return a >= 0 && a <= 59;
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCSeconds(i, 0), o;
    }
  }]), r;
}(bt);
function pu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pu = function(r) {
    return typeof r;
  } : pu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, pu(e);
}
function cee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function uee(e, t, r) {
  return t && mS(e.prototype, t), r && mS(e, r), e;
}
function dee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && vv(e, t);
}
function vv(e, t) {
  return vv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, vv(e, t);
}
function fee(e) {
  var t = mee();
  return function() {
    var n = Nf(e), o;
    if (t) {
      var a = Nf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return pee(this, o);
  };
}
function pee(e, t) {
  return t && (pu(t) === "object" || typeof t == "function") ? t : gv(e);
}
function gv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function mee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Nf(e) {
  return Nf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Nf(e);
}
function hS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var hee = /* @__PURE__ */ function(e) {
  dee(r, e);
  var t = fee(r);
  function r() {
    var n;
    cee(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), hS(gv(n), "priority", 30), hS(gv(n), "incompatibleTokens", ["t", "T"]), n;
  }
  return uee(r, [{
    key: "parse",
    value: function(o, a) {
      var i = function(c) {
        return Math.floor(c * Math.pow(10, -a.length + 3));
      };
      return Xt(Wt(a.length, o), i);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return o.setUTCMilliseconds(i), o;
    }
  }]), r;
}(bt);
function mu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? mu = function(r) {
    return typeof r;
  } : mu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, mu(e);
}
function yee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function vee(e, t, r) {
  return t && yS(e.prototype, t), r && yS(e, r), e;
}
function gee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && bv(e, t);
}
function bv(e, t) {
  return bv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, bv(e, t);
}
function bee(e) {
  var t = xee();
  return function() {
    var n = If(e), o;
    if (t) {
      var a = If(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return wee(this, o);
  };
}
function wee(e, t) {
  return t && (mu(t) === "object" || typeof t == "function") ? t : wv(e);
}
function wv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function xee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function If(e) {
  return If = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, If(e);
}
function vS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var _ee = /* @__PURE__ */ function(e) {
  gee(r, e);
  var t = bee(r);
  function r() {
    var n;
    yee(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), vS(wv(n), "priority", 10), vS(wv(n), "incompatibleTokens", ["t", "T", "x"]), n;
  }
  return vee(r, [{
    key: "parse",
    value: function(o, a) {
      switch (a) {
        case "X":
          return zn(Vn.basicOptionalMinutes, o);
        case "XX":
          return zn(Vn.basic, o);
        case "XXXX":
          return zn(Vn.basicOptionalSeconds, o);
        case "XXXXX":
          return zn(Vn.extendedOptionalSeconds, o);
        case "XXX":
        default:
          return zn(Vn.extended, o);
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return a.timestampIsSet ? o : new Date(o.getTime() - i);
    }
  }]), r;
}(bt);
function hu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? hu = function(r) {
    return typeof r;
  } : hu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, hu(e);
}
function Oee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function Pee(e, t, r) {
  return t && gS(e.prototype, t), r && gS(e, r), e;
}
function See(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && xv(e, t);
}
function xv(e, t) {
  return xv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, xv(e, t);
}
function Tee(e) {
  var t = $ee();
  return function() {
    var n = Mf(e), o;
    if (t) {
      var a = Mf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return Eee(this, o);
  };
}
function Eee(e, t) {
  return t && (hu(t) === "object" || typeof t == "function") ? t : _v(e);
}
function _v(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function $ee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Mf(e) {
  return Mf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Mf(e);
}
function bS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var Cee = /* @__PURE__ */ function(e) {
  See(r, e);
  var t = Tee(r);
  function r() {
    var n;
    Oee(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), bS(_v(n), "priority", 10), bS(_v(n), "incompatibleTokens", ["t", "T", "X"]), n;
  }
  return Pee(r, [{
    key: "parse",
    value: function(o, a) {
      switch (a) {
        case "x":
          return zn(Vn.basicOptionalMinutes, o);
        case "xx":
          return zn(Vn.basic, o);
        case "xxxx":
          return zn(Vn.basicOptionalSeconds, o);
        case "xxxxx":
          return zn(Vn.extendedOptionalSeconds, o);
        case "xxx":
        default:
          return zn(Vn.extended, o);
      }
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return a.timestampIsSet ? o : new Date(o.getTime() - i);
    }
  }]), r;
}(bt);
function yu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? yu = function(r) {
    return typeof r;
  } : yu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, yu(e);
}
function kee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wS(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function Ree(e, t, r) {
  return t && wS(e.prototype, t), r && wS(e, r), e;
}
function Dee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Ov(e, t);
}
function Ov(e, t) {
  return Ov = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Ov(e, t);
}
function Nee(e) {
  var t = Mee();
  return function() {
    var n = Af(e), o;
    if (t) {
      var a = Af(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return Iee(this, o);
  };
}
function Iee(e, t) {
  return t && (yu(t) === "object" || typeof t == "function") ? t : Pv(e);
}
function Pv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Mee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Af(e) {
  return Af = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Af(e);
}
function xS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var Aee = /* @__PURE__ */ function(e) {
  Dee(r, e);
  var t = Nee(r);
  function r() {
    var n;
    kee(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), xS(Pv(n), "priority", 40), xS(Pv(n), "incompatibleTokens", "*"), n;
  }
  return Ree(r, [{
    key: "parse",
    value: function(o) {
      return FD(o);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return [new Date(i * 1e3), {
        timestampIsSet: !0
      }];
    }
  }]), r;
}(bt);
function vu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? vu = function(r) {
    return typeof r;
  } : vu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, vu(e);
}
function jee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _S(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function Fee(e, t, r) {
  return t && _S(e.prototype, t), r && _S(e, r), e;
}
function Lee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && Sv(e, t);
}
function Sv(e, t) {
  return Sv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Sv(e, t);
}
function Vee(e) {
  var t = Bee();
  return function() {
    var n = jf(e), o;
    if (t) {
      var a = jf(this).constructor;
      o = Reflect.construct(n, arguments, a);
    } else
      o = n.apply(this, arguments);
    return zee(this, o);
  };
}
function zee(e, t) {
  return t && (vu(t) === "object" || typeof t == "function") ? t : Tv(e);
}
function Tv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Bee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function jf(e) {
  return jf = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, jf(e);
}
function OS(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
}
var Wee = /* @__PURE__ */ function(e) {
  Lee(r, e);
  var t = Vee(r);
  function r() {
    var n;
    jee(this, r);
    for (var o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = t.call.apply(t, [this].concat(a)), OS(Tv(n), "priority", 20), OS(Tv(n), "incompatibleTokens", "*"), n;
  }
  return Fee(r, [{
    key: "parse",
    value: function(o) {
      return FD(o);
    }
  }, {
    key: "set",
    value: function(o, a, i) {
      return [new Date(i), {
        timestampIsSet: !0
      }];
    }
  }]), r;
}(bt), Uee = {
  G: new UX(),
  y: new QX(),
  Y: new oQ(),
  R: new dQ(),
  u: new gQ(),
  Q: new SQ(),
  q: new DQ(),
  M: new LQ(),
  L: new YQ(),
  w: new eZ(),
  I: new lZ(),
  d: new vZ(),
  D: new PZ(),
  E: new RZ(),
  e: new FZ(),
  c: new HZ(),
  i: new JZ(),
  a: new iJ(),
  b: new pJ(),
  B: new wJ(),
  h: new EJ(),
  H: new IJ(),
  K: new zJ(),
  k: new GJ(),
  m: new tee(),
  s: new lee(),
  S: new hee(),
  X: new _ee(),
  x: new Cee(),
  t: new Aee(),
  T: new Wee()
};
function gu(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? gu = function(r) {
    return typeof r;
  } : gu = function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, gu(e);
}
function PS(e, t) {
  var r;
  if (typeof Symbol > "u" || e[Symbol.iterator] == null) {
    if (Array.isArray(e) || (r = Hee(e)) || t && e && typeof e.length == "number") {
      r && (e = r);
      var n = 0, o = function() {
      };
      return { s: o, n: function() {
        return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
      }, e: function(u) {
        throw u;
      }, f: o };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a = !0, i = !1, l;
  return { s: function() {
    r = e[Symbol.iterator]();
  }, n: function() {
    var u = r.next();
    return a = u.done, u;
  }, e: function(u) {
    i = !0, l = u;
  }, f: function() {
    try {
      !a && r.return != null && r.return();
    } finally {
      if (i)
        throw l;
    }
  } };
}
function Hee(e, t) {
  if (e) {
    if (typeof e == "string")
      return SS(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set")
      return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return SS(e, t);
  }
}
function SS(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
var Yee = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, qee = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Gee = /^'([^]*?)'?$/, Kee = /''/g, Xee = /\S/, Qee = /[a-zA-Z]/;
function Zee(e, t, r, n) {
  var o, a, i, l, c, u, d, f, p, m, y, h, v, g, b, x, O, w;
  $e(3, arguments);
  var S = String(e), E = String(t), C = ro(), N = (o = (a = n == null ? void 0 : n.locale) !== null && a !== void 0 ? a : C.locale) !== null && o !== void 0 ? o : Up;
  if (!N.match)
    throw new RangeError("locale must contain match property");
  var $ = ht((i = (l = (c = (u = n == null ? void 0 : n.firstWeekContainsDate) !== null && u !== void 0 ? u : n == null || (d = n.locale) === null || d === void 0 || (f = d.options) === null || f === void 0 ? void 0 : f.firstWeekContainsDate) !== null && c !== void 0 ? c : C.firstWeekContainsDate) !== null && l !== void 0 ? l : (p = C.locale) === null || p === void 0 || (m = p.options) === null || m === void 0 ? void 0 : m.firstWeekContainsDate) !== null && i !== void 0 ? i : 1);
  if (!($ >= 1 && $ <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var j = ht((y = (h = (v = (g = n == null ? void 0 : n.weekStartsOn) !== null && g !== void 0 ? g : n == null || (b = n.locale) === null || b === void 0 || (x = b.options) === null || x === void 0 ? void 0 : x.weekStartsOn) !== null && v !== void 0 ? v : C.weekStartsOn) !== null && h !== void 0 ? h : (O = C.locale) === null || O === void 0 || (w = O.options) === null || w === void 0 ? void 0 : w.weekStartsOn) !== null && y !== void 0 ? y : 0);
  if (!(j >= 0 && j <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (E === "")
    return S === "" ? ke(r) : /* @__PURE__ */ new Date(NaN);
  var A = {
    firstWeekContainsDate: $,
    weekStartsOn: j,
    locale: N
  }, k = [new MX()], R = E.match(qee).map(function(K) {
    var Q = K[0];
    if (Q in vy) {
      var ae = vy[Q];
      return ae(K, N.formatLong);
    }
    return K;
  }).join("").match(Yee), D = [], L = PS(R), B;
  try {
    var H = function() {
      var Q = B.value;
      !(n != null && n.useAdditionalWeekYearTokens) && ND(Q) && nf(Q, E, e), !(n != null && n.useAdditionalDayOfYearTokens) && DD(Q) && nf(Q, E, e);
      var ae = Q[0], ie = Uee[ae];
      if (ie) {
        var oe = ie.incompatibleTokens;
        if (Array.isArray(oe)) {
          var se = D.find(function(le) {
            return oe.includes(le.token) || le.token === ae;
          });
          if (se)
            throw new RangeError("The format string mustn't contain `".concat(se.fullToken, "` and `").concat(Q, "` at the same time"));
        } else if (ie.incompatibleTokens === "*" && D.length > 0)
          throw new RangeError("The format string mustn't contain `".concat(Q, "` and any other token at the same time"));
        D.push({
          token: ae,
          fullToken: Q
        });
        var re = ie.run(S, Q, N.match, A);
        if (!re)
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        k.push(re.setter), S = re.rest;
      } else {
        if (ae.match(Qee))
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + ae + "`");
        if (Q === "''" ? Q = "'" : ae === "'" && (Q = Jee(Q)), S.indexOf(Q) === 0)
          S = S.slice(Q.length);
        else
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
      }
    };
    for (L.s(); !(B = L.n()).done; ) {
      var U = H();
      if (gu(U) === "object")
        return U.v;
    }
  } catch (K) {
    L.e(K);
  } finally {
    L.f();
  }
  if (S.length > 0 && Xee.test(S))
    return /* @__PURE__ */ new Date(NaN);
  var I = k.map(function(K) {
    return K.priority;
  }).sort(function(K, Q) {
    return Q - K;
  }).filter(function(K, Q, ae) {
    return ae.indexOf(K) === Q;
  }).map(function(K) {
    return k.filter(function(Q) {
      return Q.priority === K;
    }).sort(function(Q, ae) {
      return ae.subPriority - Q.subPriority;
    });
  }).map(function(K) {
    return K[0];
  }), V = ke(r);
  if (isNaN(V.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var G = ED(V, rf(V)), q = {}, J = PS(I), ne;
  try {
    for (J.s(); !(ne = J.n()).done; ) {
      var te = ne.value;
      if (!te.validate(G, A))
        return /* @__PURE__ */ new Date(NaN);
      var ee = te.set(G, q, A);
      Array.isArray(ee) ? (G = ee[0], kX(q, ee[1])) : G = ee;
    }
  } catch (K) {
    J.e(K);
  } finally {
    J.f();
  }
  return G;
}
function Jee(e) {
  return e.match(Gee)[1].replace(Kee, "'");
}
function ete(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return r.setDate(n), r;
}
function tte(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return r.setHours(n), r;
}
function rte(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return r.setMinutes(n), r;
}
function nte(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t), o = r.getFullYear(), a = r.getDate(), i = /* @__PURE__ */ new Date(0);
  i.setFullYear(o, n, 15), i.setHours(0, 0, 0, 0);
  var l = ID(i);
  return r.setMonth(n, Math.min(a, l)), r;
}
function ote(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return r.setSeconds(n), r;
}
function ate(e, t) {
  $e(2, arguments);
  var r = ke(e), n = ht(t);
  return isNaN(r.getTime()) ? /* @__PURE__ */ new Date(NaN) : (r.setFullYear(n), r);
}
function TS(e) {
  $e(1, arguments);
  var t = ke(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function Sa(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ro(), f = ht((r = (n = (o = (a = t == null ? void 0 : t.weekStartsOn) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && o !== void 0 ? o : d.weekStartsOn) !== null && n !== void 0 ? n : (c = d.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
  if (!(f >= 0 && f <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var p = ke(e), m = p.getDay(), y = (m < f ? 7 : 0) + m - f;
  return p.setDate(p.getDate() - y), p.setHours(0, 0, 0, 0), p;
}
function nc(e) {
  $e(1, arguments);
  var t = ke(e), r = /* @__PURE__ */ new Date(0);
  return r.setFullYear(t.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r;
}
function ite(e, t) {
  var r;
  $e(1, arguments);
  var n = ht((r = t == null ? void 0 : t.additionalDigits) !== null && r !== void 0 ? r : 2);
  if (n !== 2 && n !== 1 && n !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var o = ute(e), a;
  if (o.date) {
    var i = dte(o.date, n);
    a = fte(i.restDateString, i.year);
  }
  if (!a || isNaN(a.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var l = a.getTime(), c = 0, u;
  if (o.time && (c = pte(o.time), isNaN(c)))
    return /* @__PURE__ */ new Date(NaN);
  if (o.timezone) {
    if (u = mte(o.timezone), isNaN(u))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    var d = new Date(l + c), f = /* @__PURE__ */ new Date(0);
    return f.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()), f.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()), f;
  }
  return new Date(l + c + u);
}
var oc = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, ste = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, lte = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, cte = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function ute(e) {
  var t = {}, r = e.split(oc.dateTimeDelimiter), n;
  if (r.length > 2)
    return t;
  if (/:/.test(r[0]) ? n = r[0] : (t.date = r[0], n = r[1], oc.timeZoneDelimiter.test(t.date) && (t.date = e.split(oc.timeZoneDelimiter)[0], n = e.substr(t.date.length, e.length))), n) {
    var o = oc.timezone.exec(n);
    o ? (t.time = n.replace(o[1], ""), t.timezone = o[1]) : t.time = n;
  }
  return t;
}
function dte(e, t) {
  var r = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + t) + "})|(\\d{2}|[+-]\\d{" + (2 + t) + "})$)"), n = e.match(r);
  if (!n)
    return {
      year: NaN,
      restDateString: ""
    };
  var o = n[1] ? parseInt(n[1]) : null, a = n[2] ? parseInt(n[2]) : null;
  return {
    year: a === null ? o : a * 100,
    restDateString: e.slice((n[1] || n[2]).length)
  };
}
function fte(e, t) {
  if (t === null)
    return /* @__PURE__ */ new Date(NaN);
  var r = e.match(ste);
  if (!r)
    return /* @__PURE__ */ new Date(NaN);
  var n = !!r[4], o = _s(r[1]), a = _s(r[2]) - 1, i = _s(r[3]), l = _s(r[4]), c = _s(r[5]) - 1;
  if (n)
    return bte(t, l, c) ? hte(t, l, c) : /* @__PURE__ */ new Date(NaN);
  var u = /* @__PURE__ */ new Date(0);
  return !vte(t, a, i) || !gte(t, o) ? /* @__PURE__ */ new Date(NaN) : (u.setUTCFullYear(t, a, Math.max(o, i)), u);
}
function _s(e) {
  return e ? parseInt(e) : 1;
}
function pte(e) {
  var t = e.match(lte);
  if (!t)
    return NaN;
  var r = lh(t[1]), n = lh(t[2]), o = lh(t[3]);
  return wte(r, n, o) ? r * Bp + n * zp + o * 1e3 : NaN;
}
function lh(e) {
  return e && parseFloat(e.replace(",", ".")) || 0;
}
function mte(e) {
  if (e === "Z")
    return 0;
  var t = e.match(cte);
  if (!t)
    return 0;
  var r = t[1] === "+" ? -1 : 1, n = parseInt(t[2]), o = t[3] && parseInt(t[3]) || 0;
  return xte(n, o) ? r * (n * Bp + o * zp) : NaN;
}
function hte(e, t, r) {
  var n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(e, 0, 4);
  var o = n.getUTCDay() || 7, a = (t - 1) * 7 + r + 1 - o;
  return n.setUTCDate(n.getUTCDate() + a), n;
}
var yte = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function zD(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function vte(e, t, r) {
  return t >= 0 && t <= 11 && r >= 1 && r <= (yte[t] || (zD(e) ? 29 : 28));
}
function gte(e, t) {
  return t >= 1 && t <= (zD(e) ? 366 : 365);
}
function bte(e, t, r) {
  return t >= 1 && t <= 53 && r >= 0 && r <= 6;
}
function wte(e, t, r) {
  return e === 24 ? t === 0 && r === 0 : r >= 0 && r < 60 && t >= 0 && t < 60 && e >= 0 && e < 25;
}
function xte(e, t) {
  return t >= 0 && t <= 59;
}
function _te(e, t) {
  var r, n;
  $e(1, arguments);
  var o = ke(e);
  if (isNaN(o.getTime()))
    throw new RangeError("Invalid time value");
  var a = String((r = t == null ? void 0 : t.format) !== null && r !== void 0 ? r : "extended"), i = String((n = t == null ? void 0 : t.representation) !== null && n !== void 0 ? n : "complete");
  if (a !== "extended" && a !== "basic")
    throw new RangeError("format must be 'extended' or 'basic'");
  if (i !== "date" && i !== "time" && i !== "complete")
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  var l = "", c = "", u = a === "extended" ? "-" : "", d = a === "extended" ? ":" : "";
  if (i !== "time") {
    var f = st(o.getDate(), 2), p = st(o.getMonth() + 1, 2), m = st(o.getFullYear(), 4);
    l = "".concat(m).concat(u).concat(p).concat(u).concat(f);
  }
  if (i !== "date") {
    var y = o.getTimezoneOffset();
    if (y !== 0) {
      var h = Math.abs(y), v = st(Math.floor(h / 60), 2), g = st(h % 60, 2), b = y < 0 ? "+" : "-";
      c = "".concat(b).concat(v, ":").concat(g);
    } else
      c = "Z";
    var x = st(o.getHours(), 2), O = st(o.getMinutes(), 2), w = st(o.getSeconds(), 2), S = l === "" ? "" : "T", E = [x, O, w].join(d);
    l = "".concat(l).concat(S).concat(E).concat(c);
  }
  return l;
}
function Ote(e, t) {
  $e(2, arguments);
  var r = ke(e).getTime(), n = ke(t.start).getTime(), o = ke(t.end).getTime();
  if (!(n <= o))
    throw new RangeError("Invalid interval");
  return r >= n && r <= o;
}
var Ev = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = void 0;
  var r = function(c, u) {
    switch (c) {
      case "P":
        return u.date({
          width: "short"
        });
      case "PP":
        return u.date({
          width: "medium"
        });
      case "PPP":
        return u.date({
          width: "long"
        });
      case "PPPP":
      default:
        return u.date({
          width: "full"
        });
    }
  }, n = function(c, u) {
    switch (c) {
      case "p":
        return u.time({
          width: "short"
        });
      case "pp":
        return u.time({
          width: "medium"
        });
      case "ppp":
        return u.time({
          width: "long"
        });
      case "pppp":
      default:
        return u.time({
          width: "full"
        });
    }
  }, o = function(c, u) {
    var d = c.match(/(P+)(p+)?/) || [], f = d[1], p = d[2];
    if (!p)
      return r(c, u);
    var m;
    switch (f) {
      case "P":
        m = u.dateTime({
          width: "short"
        });
        break;
      case "PP":
        m = u.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        m = u.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        m = u.dateTime({
          width: "full"
        });
        break;
    }
    return m.replace("{{date}}", r(f, u)).replace("{{time}}", n(p, u));
  }, a = {
    p: n,
    P: o
  }, i = a;
  t.default = i, e.exports = t.default;
})(Ev, Ev.exports);
var Pte = Ev.exports;
const BD = /* @__PURE__ */ qi(Pte);
var Ste = {
  dayOfMonth: "d",
  fullDate: "PP",
  fullDateWithWeekday: "PPPP",
  fullDateTime: "PP p",
  fullDateTime12h: "PP hh:mm aaa",
  fullDateTime24h: "PP HH:mm",
  fullTime: "p",
  fullTime12h: "hh:mm aaa",
  fullTime24h: "HH:mm",
  hours12h: "hh",
  hours24h: "HH",
  keyboardDate: "P",
  keyboardDateTime: "P p",
  keyboardDateTime12h: "P hh:mm aaa",
  keyboardDateTime24h: "P HH:mm",
  minutes: "mm",
  month: "LLLL",
  monthAndDate: "MMMM d",
  monthAndYear: "LLLL yyyy",
  monthShort: "MMM",
  weekday: "EEEE",
  weekdayShort: "EEE",
  normalDate: "d MMMM",
  normalDateWithWeekday: "EEE, MMM d",
  seconds: "ss",
  shortDate: "MMM d",
  year: "yyyy"
}, Tte = (
  /** @class */
  function() {
    function e(t) {
      var r = this, n = t === void 0 ? {} : t, o = n.locale, a = n.formats;
      this.lib = "date-fns", this.is12HourCycleInCurrentLocale = function() {
        return r.locale ? /a/.test(r.locale.formatLong.time()) : !0;
      }, this.getFormatHelperText = function(i) {
        var l = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, c = r.locale || Up;
        return i.match(l).map(function(u) {
          var d = u[0];
          if (d === "p" || d === "P") {
            var f = BD[d];
            return f(u, c.formatLong, {});
          }
          return u;
        }).join("").replace(/(aaa|aa|a)/g, "(a|p)m").toLocaleLowerCase();
      }, this.parseISO = function(i) {
        return ite(i);
      }, this.toISO = function(i) {
        return _te(i, { format: "extended" });
      }, this.getCurrentLocaleCode = function() {
        var i;
        return ((i = r.locale) === null || i === void 0 ? void 0 : i.code) || "en-US";
      }, this.addSeconds = function(i, l) {
        return YG(i, l);
      }, this.addMinutes = function(i, l) {
        return GG(i, l);
      }, this.addHours = function(i, l) {
        return XG(i, l);
      }, this.addDays = function(i, l) {
        return my(i, l);
      }, this.addWeeks = function(i, l) {
        return QG(i, l);
      }, this.addMonths = function(i, l) {
        return Ac(i, l);
      }, this.addYears = function(i, l) {
        return cP(i, l);
      }, this.isValid = function(i) {
        return TD(r.date(i));
      }, this.getDiff = function(i, l, c) {
        switch (c) {
          case "years":
            return JG(i, r.date(l));
          case "quarters":
            return nK(i, r.date(l));
          case "months":
            return PD(i, r.date(l));
          case "weeks":
            return iK(i, r.date(l));
          case "days":
            return SD(i, r.date(l));
          case "hours":
            return lK(i, r.date(l));
          case "minutes":
            return cK(i, r.date(l));
          case "seconds":
            return uK(i, r.date(l));
          default:
            return Wp(i, r.date(l));
        }
      }, this.isAfter = function(i, l) {
        return ah(i, l);
      }, this.isBefore = function(i, l) {
        return xs(i, l);
      }, this.startOfDay = function(i) {
        return Fi(i);
      }, this.endOfDay = function(i) {
        return hy(i);
      }, this.getHours = function(i) {
        return wX(i);
      }, this.setHours = function(i, l) {
        return tte(i, l);
      }, this.setMinutes = function(i, l) {
        return rte(i, l);
      }, this.getSeconds = function(i) {
        return OX(i);
      }, this.setSeconds = function(i, l) {
        return ote(i, l);
      }, this.isSameDay = function(i, l) {
        return TX(i, l);
      }, this.isSameMonth = function(i, l) {
        return $X(i, l);
      }, this.isSameYear = function(i, l) {
        return EX(i, l);
      }, this.isSameHour = function(i, l) {
        return CX(i, l);
      }, this.startOfYear = function(i) {
        return nc(i);
      }, this.endOfYear = function(i) {
        return nh(i);
      }, this.startOfMonth = function(i) {
        return TS(i);
      }, this.endOfMonth = function(i) {
        return yy(i);
      }, this.startOfWeek = function(i) {
        return Sa(i, { locale: r.locale });
      }, this.endOfWeek = function(i) {
        return rh(i, { locale: r.locale });
      }, this.getYear = function(i) {
        return PX(i);
      }, this.setYear = function(i, l) {
        return ate(i, l);
      }, this.date = function(i) {
        return typeof i > "u" ? /* @__PURE__ */ new Date() : i === null ? null : new Date(i);
      }, this.toJsDate = function(i) {
        return i;
      }, this.parse = function(i, l) {
        return i === "" ? null : Zee(i, l, /* @__PURE__ */ new Date(), { locale: r.locale });
      }, this.format = function(i, l) {
        return r.formatByString(i, r.formats[l]);
      }, this.formatByString = function(i, l) {
        return yX(i, l, { locale: r.locale });
      }, this.isEqual = function(i, l) {
        return i === null && l === null ? !0 : SX(i, l);
      }, this.isNull = function(i) {
        return i === null;
      }, this.isAfterDay = function(i, l) {
        return ah(i, hy(l));
      }, this.isBeforeDay = function(i, l) {
        return xs(i, Fi(l));
      }, this.isBeforeYear = function(i, l) {
        return xs(i, nc(l));
      }, this.isAfterYear = function(i, l) {
        return ah(i, nh(l));
      }, this.isWithinRange = function(i, l) {
        var c = l[0], u = l[1];
        return Ote(i, { start: c, end: u });
      }, this.formatNumber = function(i) {
        return i;
      }, this.getMinutes = function(i) {
        return xX(i);
      }, this.getDate = function(i) {
        return gX(i);
      }, this.setDate = function(i, l) {
        return ete(i, l);
      }, this.getMonth = function(i) {
        return _X(i);
      }, this.getDaysInMonth = function(i) {
        return ID(i);
      }, this.setMonth = function(i, l) {
        return nte(i, l);
      }, this.getMeridiemText = function(i) {
        return i === "am" ? "AM" : "PM";
      }, this.getNextMonth = function(i) {
        return Ac(i, 1);
      }, this.getPreviousMonth = function(i) {
        return Ac(i, -1);
      }, this.getMonthArray = function(i) {
        for (var l = nc(i), c = [l]; c.length < 12; ) {
          var u = c[c.length - 1];
          c.push(r.getNextMonth(u));
        }
        return c;
      }, this.mergeDateAndTime = function(i, l) {
        return r.setSeconds(r.setMinutes(r.setHours(i, r.getHours(l)), r.getMinutes(l)), r.getSeconds(l));
      }, this.getWeekdays = function() {
        var i = /* @__PURE__ */ new Date();
        return dK({
          start: Sa(i, { locale: r.locale }),
          end: rh(i, { locale: r.locale })
        }).map(function(l) {
          return r.formatByString(l, "EEEEEE");
        });
      }, this.getWeekArray = function(i) {
        for (var l = Sa(TS(i), { locale: r.locale }), c = rh(yy(i), { locale: r.locale }), u = 0, d = l, f = [], p = null; xs(d, c); ) {
          var m = Math.floor(u / 7);
          f[m] = f[m] || [];
          var y = bX(d);
          p !== y && (p = y, f[m].push(d), u += 1), d = my(d, 1);
        }
        return f;
      }, this.getYearRange = function(i, l) {
        for (var c = nc(i), u = nh(l), d = [], f = c; xs(f, u); )
          d.push(f), f = cP(f, 1);
        return d;
      }, this.locale = o, this.formats = Object.assign({}, Ste, a);
    }
    return e;
  }()
);
function Ete(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ke(e), f = d.getFullYear(), p = ro(), m = ht((r = (n = (o = (a = t == null ? void 0 : t.firstWeekContainsDate) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.firstWeekContainsDate) !== null && o !== void 0 ? o : p.firstWeekContainsDate) !== null && n !== void 0 ? n : (c = p.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1);
  if (!(m >= 1 && m <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var y = /* @__PURE__ */ new Date(0);
  y.setFullYear(f + 1, 0, m), y.setHours(0, 0, 0, 0);
  var h = Sa(y, t), v = /* @__PURE__ */ new Date(0);
  v.setFullYear(f, 0, m), v.setHours(0, 0, 0, 0);
  var g = Sa(v, t);
  return d.getTime() >= h.getTime() ? f + 1 : d.getTime() >= g.getTime() ? f : f - 1;
}
function $te(e, t) {
  var r, n, o, a, i, l, c, u;
  $e(1, arguments);
  var d = ro(), f = ht((r = (n = (o = (a = t == null ? void 0 : t.firstWeekContainsDate) !== null && a !== void 0 ? a : t == null || (i = t.locale) === null || i === void 0 || (l = i.options) === null || l === void 0 ? void 0 : l.firstWeekContainsDate) !== null && o !== void 0 ? o : d.firstWeekContainsDate) !== null && n !== void 0 ? n : (c = d.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1), p = Ete(e, t), m = /* @__PURE__ */ new Date(0);
  m.setFullYear(p, 0, f), m.setHours(0, 0, 0, 0);
  var y = Sa(m, t);
  return y;
}
var Cte = 6048e5;
function kte(e, t) {
  $e(1, arguments);
  var r = ke(e), n = Sa(r, t).getTime() - $te(r, t).getTime();
  return Math.round(n / Cte) + 1;
}
const Rte = {
  // Year
  y: "year",
  yy: "year",
  yyy: "year",
  yyyy: "year",
  // Month
  M: "month",
  MM: "month",
  MMMM: {
    sectionType: "month",
    contentType: "letter"
  },
  MMM: {
    sectionType: "month",
    contentType: "letter"
  },
  LLL: {
    sectionType: "month",
    contentType: "letter"
  },
  LLLL: {
    sectionType: "month",
    contentType: "letter"
  },
  // Day of the month
  d: "day",
  dd: "day",
  do: "day",
  // Day of the week
  E: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  EEEEE: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  i: "weekDay",
  ii: "weekDay",
  iii: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  iiii: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  e: "weekDay",
  ee: "weekDay",
  eee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  eeeeee: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  c: "weekDay",
  cc: "weekDay",
  ccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  cccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  ccccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  cccccc: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  // Meridiem
  a: "meridiem",
  aa: "meridiem",
  aaa: "meridiem",
  // Hours
  H: "hours",
  HH: "hours",
  h: "hours",
  hh: "hours",
  // Minutes
  mm: "minutes",
  // Seconds
  ss: "seconds"
};
class WD extends Tte {
  constructor(...t) {
    super(...t), this.isMUIAdapter = !0, this.formatTokenMap = Rte, this.escapedCharacters = {
      start: "'",
      end: "'"
    }, this.expandFormat = (r) => {
      const n = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      return r.match(n).map((o) => {
        const a = o[0];
        if (a === "p" || a === "P") {
          const i = BD[a], l = this.locale || Up;
          return i(o, l.formatLong, {});
        }
        return o;
      }).join("");
    }, this.getFormatHelperText = (r) => this.expandFormat(r).replace(/(aaa|aa|a)/g, "(a|p)m").toLocaleLowerCase(), this.getWeekNumber = (r) => kte(r, {
      locale: this.locale
    });
  }
}
const Dte = ["localeText"], Ff = /* @__PURE__ */ P.createContext(null);
process.env.NODE_ENV !== "production" && (Ff.displayName = "MuiPickersAdapterContext");
function Rl(e) {
  var t;
  const {
    localeText: r
  } = e, n = ge(e, Dte), {
    utils: o,
    localeText: a
  } = (t = P.useContext(Ff)) != null ? t : {
    utils: void 0,
    localeText: void 0
  }, i = Ae({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: n,
    name: "MuiLocalizationProvider"
  }), {
    children: l,
    dateAdapter: c,
    dateFormats: u,
    dateLibInstance: d,
    adapterLocale: f,
    localeText: p
  } = i, m = P.useMemo(() => T({}, p, a, r), [p, a, r]), y = P.useMemo(() => {
    if (!c)
      return o || null;
    const g = new c({
      locale: f,
      formats: u,
      instance: d
    });
    if (!g.isMUIAdapter)
      throw new Error(["MUI: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    return g;
  }, [c, f, u, d, o]), h = P.useMemo(() => y ? {
    minDate: y.date("1900-01-01T00:00:00.000"),
    maxDate: y.date("2099-12-31T00:00:00.000")
  } : null, [y]), v = P.useMemo(() => ({
    utils: y,
    defaultDates: h,
    localeText: m
  }), [h, y, m]);
  return /* @__PURE__ */ _.jsx(Ff.Provider, {
    value: v,
    children: l
  });
}
process.env.NODE_ENV !== "production" && (Rl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Locale for the date library you are using
   */
  adapterLocale: s.oneOfType([s.object, s.string]),
  children: s.node,
  /**
   * Date library adapter class function.
   * @see See the localization provider {@link https://mui.com/x/react-date-pickers/getting-started/#code-setup code setup section} for more details.
   */
  dateAdapter: s.func,
  /**
   * Formats that are used for any child pickers
   */
  dateFormats: s.shape({
    dayOfMonth: s.string,
    fullDate: s.string,
    fullDateTime: s.string,
    fullDateTime12h: s.string,
    fullDateTime24h: s.string,
    fullDateWithWeekday: s.string,
    fullTime: s.string,
    fullTime12h: s.string,
    fullTime24h: s.string,
    hours12h: s.string,
    hours24h: s.string,
    keyboardDate: s.string,
    keyboardDateTime: s.string,
    keyboardDateTime12h: s.string,
    keyboardDateTime24h: s.string,
    minutes: s.string,
    month: s.string,
    monthAndDate: s.string,
    monthAndYear: s.string,
    monthShort: s.string,
    normalDate: s.string,
    normalDateWithWeekday: s.string,
    seconds: s.string,
    shortDate: s.string,
    weekday: s.string,
    weekdayShort: s.string,
    year: s.string
  }),
  /**
   * Date library instance you are using, if it has some global overrides
   * ```jsx
   * dateLibInstance={momentTimeZone}
   * ```
   */
  dateLibInstance: s.any,
  /**
   * Locale for components texts
   */
  localeText: s.object
});
function Nte(e, t, r, n, o) {
  const [a, i] = P.useState(() => o && r ? r(e).matches : n ? n(e).matches : t);
  return wr(() => {
    let l = !0;
    if (!r)
      return;
    const c = r(e), u = () => {
      l && i(c.matches);
    };
    return u(), c.addListener(u), () => {
      l = !1, c.removeListener(u);
    };
  }, [e, r]), a;
}
const UD = P["useSyncExternalStore"];
function Ite(e, t, r, n, o) {
  const a = P.useCallback(() => t, [t]), i = P.useMemo(() => {
    if (o && r)
      return () => r(e).matches;
    if (n !== null) {
      const {
        matches: d
      } = n(e);
      return () => d;
    }
    return a;
  }, [a, e, n, o, r]), [l, c] = P.useMemo(() => {
    if (r === null)
      return [a, () => () => {
      }];
    const d = r(e);
    return [() => d.matches, (f) => (d.addListener(f), () => {
      d.removeListener(f);
    })];
  }, [a, r, e]);
  return UD(c, l, i);
}
function HD(e, t = {}) {
  const r = bp(), n = typeof window < "u" && typeof window.matchMedia < "u", {
    defaultMatches: o = !1,
    matchMedia: a = n ? window.matchMedia : null,
    ssrMatchMedia: i = null,
    noSsr: l = !1
  } = gE({
    name: "MuiUseMediaQuery",
    props: t,
    theme: r
  });
  process.env.NODE_ENV !== "production" && typeof e == "function" && r === null && console.error(["MUI: The `query` argument provided is invalid.", "You are providing a function without a theme in the context.", "One of the parent elements needs to use a ThemeProvider."].join(`
`));
  let c = typeof e == "function" ? e(r) : e;
  c = c.replace(/^@media( ?)/m, "");
  const d = (UD !== void 0 ? Ite : Nte)(c, o, a, i, l);
  return process.env.NODE_ENV !== "production" && P.useDebugValue({
    query: c,
    match: d
  }), d;
}
function Ia(e) {
  return typeof e == "string";
}
function Mte(e, t, r) {
  return e === void 0 || Ia(e) ? t : T({}, t, {
    ownerState: T({}, t.ownerState, r)
  });
}
const Ate = {
  disableDefaultClasses: !1
}, jte = /* @__PURE__ */ P.createContext(Ate);
function YD(e) {
  const {
    disableDefaultClasses: t
  } = P.useContext(jte);
  return (r) => t ? "" : e(r);
}
function Fte(e, t = []) {
  if (e === void 0)
    return {};
  const r = {};
  return Object.keys(e).filter((n) => n.match(/^on[A-Z]/) && typeof e[n] == "function" && !t.includes(n)).forEach((n) => {
    r[n] = e[n];
  }), r;
}
function Ma(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ES(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((r) => !(r.match(/^on[A-Z]/) && typeof e[r] == "function")).forEach((r) => {
    t[r] = e[r];
  }), t;
}
function Lte(e) {
  const {
    getSlotProps: t,
    additionalProps: r,
    externalSlotProps: n,
    externalForwardedProps: o,
    className: a
  } = e;
  if (!t) {
    const m = Pe(o == null ? void 0 : o.className, n == null ? void 0 : n.className, a, r == null ? void 0 : r.className), y = T({}, r == null ? void 0 : r.style, o == null ? void 0 : o.style, n == null ? void 0 : n.style), h = T({}, r, o, n);
    return m.length > 0 && (h.className = m), Object.keys(y).length > 0 && (h.style = y), {
      props: h,
      internalRef: void 0
    };
  }
  const i = Fte(T({}, o, n)), l = ES(n), c = ES(o), u = t(i), d = Pe(u == null ? void 0 : u.className, r == null ? void 0 : r.className, a, o == null ? void 0 : o.className, n == null ? void 0 : n.className), f = T({}, u == null ? void 0 : u.style, r == null ? void 0 : r.style, o == null ? void 0 : o.style, n == null ? void 0 : n.style), p = T({}, u, r, c, l);
  return d.length > 0 && (p.className = d), Object.keys(f).length > 0 && (p.style = f), {
    props: p,
    internalRef: u.ref
  };
}
const Vte = ["elementType", "externalSlotProps", "ownerState"];
function It(e) {
  var t;
  const {
    elementType: r,
    externalSlotProps: n,
    ownerState: o
  } = e, a = ge(e, Vte), i = Ma(n, o), {
    props: l,
    internalRef: c
  } = Lte(T({}, a, {
    externalSlotProps: i
  })), u = Lt(c, i == null ? void 0 : i.ref, (t = e.additionalProps) == null ? void 0 : t.ref);
  return Mte(r, T({}, l, {
    ref: u
  }), o);
}
const Ws = ({
  date: e,
  disableFuture: t,
  disablePast: r,
  maxDate: n,
  minDate: o,
  isDateDisabled: a,
  utils: i
}) => {
  const l = i.startOfDay(i.date());
  r && i.isBefore(o, l) && (o = l), t && i.isAfter(n, l) && (n = l);
  let c = e, u = e;
  for (i.isBefore(e, o) && (c = o, u = null), i.isAfter(e, n) && (u && (u = n), c = null); c || u; ) {
    if (c && i.isAfter(c, n) && (c = null), u && i.isBefore(u, o) && (u = null), c) {
      if (!a(c))
        return c;
      c = i.addDays(c, 1);
    }
    if (u) {
      if (!a(u))
        return u;
      u = i.addDays(u, -1);
    }
  }
  return null;
}, zte = (e, t, r, n) => e.isBefore(t, r) ? r : e.isAfter(t, n) ? n : t, Bte = (e, t) => t == null || !e.isValid(t) ? null : t, vr = (e, t, r) => t == null || !e.isValid(t) ? r : t, Wte = (e, t, r) => !e.isValid(t) && t != null && !e.isValid(r) && r != null ? !0 : e.isEqual(t, r), vb = (e, t) => {
  const r = e.formatTokenMap[t];
  if (r == null)
    throw new Error([`MUI: The token "${t}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join(`
`));
  return typeof r == "string" ? {
    type: r,
    contentType: r === "meridiem" ? "letter" : "digit"
  } : {
    type: r.sectionType,
    contentType: r.contentType
  };
}, Ute = (e) => {
  switch (e) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
}, Hp = (e, t) => {
  const r = [], n = e.date(), o = e.startOfWeek(n), a = e.endOfWeek(n);
  let i = o;
  for (; e.isBefore(i, a); )
    r.push(i), i = e.addDays(i, 1);
  return r.map((l) => e.formatByString(l, t));
}, qD = (e, t, r) => {
  switch (t) {
    case "month":
      return e.getMonthArray(e.date()).map((n) => e.formatByString(n, r));
    case "weekDay":
      return Hp(e, r);
    case "meridiem": {
      const n = e.date();
      return [e.startOfDay(n), e.endOfDay(n)].map((o) => e.formatByString(o, r));
    }
    default:
      return [];
  }
}, gb = (e, t, r, n, o, a) => {
  const i = () => {
    const c = e.startOfYear(e.date()), u = e.formatByString(c, n);
    return Number.isNaN(Number(u));
  };
  if (process.env.NODE_ENV !== "production" && r !== "day" && i())
    throw new Error([`MUI: The token "${n}" is a digit format with letter in it.'
             This type of format is only supported for 'day' sections`].join(`
`));
  if (r === "day" && i()) {
    const c = e.setDate(a.longestMonth, t);
    return e.formatByString(c, n);
  }
  const l = t.toString();
  if (o) {
    const c = e.formatByString(e.date(), n).length;
    let u = l;
    for (u = Number(u).toString(); u.length < c; )
      u = `0${u}`;
    return u;
  }
  return l;
}, Hte = (e, t, r, n, o) => {
  const a = Ute(r), i = r === "Home", l = r === "End", c = t.value === "" || i || l, u = () => {
    const f = n[t.type]({
      currentDate: o,
      format: t.format,
      contentType: t.contentType
    }), p = (h) => gb(e, h, t.type, t.format, t.hasLeadingZeros, f);
    if (c)
      return t.type === "year" && !l && !i ? e.formatByString(e.date(), t.format) : a > 0 || i ? p(f.minimum) : p(f.maximum);
    const y = parseInt(t.value, 10) + a;
    return y > f.maximum ? p(f.minimum) : y < f.minimum ? p(f.maximum) : p(y);
  }, d = () => {
    const f = qD(e, t.type, t.format);
    if (f.length === 0)
      return t.value;
    if (c)
      return a > 0 || i ? f[0] : f[f.length - 1];
    const m = (f.indexOf(t.value) + f.length + a) % f.length;
    return f[m];
  };
  return t.contentType === "digit" ? u() : d();
}, bb = (e, t) => {
  let r = e.value || e.placeholder;
  return ["input-rtl", "input-ltr"].includes(t) && e.contentType === "digit" && !e.hasLeadingZeros && r.length === 1 && (r = `${r}â€Ž`), t === "input-rtl" && (r = `â¨${r}â©`), r;
}, Us = (e) => e.replace(/[\u2066\u2067\u2068\u2069]/g, ""), GD = (e, t) => {
  let r = 0, n = t ? 1 : 0;
  const o = [];
  for (let a = 0; a < e.length; a += 1) {
    const i = e[a], l = bb(i, t ? "input-rtl" : "input-ltr"), c = `${i.startSeparator}${l}${i.endSeparator}`, u = Us(c).length, d = c.length, f = Us(l), p = n + l.indexOf(f[0]) + i.startSeparator.length, m = p + f.length;
    o.push(T({}, i, {
      start: r,
      end: r + u,
      startInInput: p,
      endInInput: m
    })), r += u, n += d;
  }
  return o;
}, Yte = (e, t, r, n) => {
  switch (r.type) {
    case "year":
      return t.fieldYearPlaceholder({
        digitAmount: e.formatByString(e.date(), n).length
      });
    case "month":
      return t.fieldMonthPlaceholder({
        contentType: r.contentType
      });
    case "day":
      return t.fieldDayPlaceholder();
    case "weekDay":
      return t.fieldWeekDayPlaceholder({
        contentType: r.contentType
      });
    case "hours":
      return t.fieldHoursPlaceholder();
    case "minutes":
      return t.fieldMinutesPlaceholder();
    case "seconds":
      return t.fieldSecondsPlaceholder();
    case "meridiem":
      return t.fieldMeridiemPlaceholder();
    default:
      return n;
  }
}, $S = (e, t, r, n) => {
  if (process.env.NODE_ENV !== "production" && vb(e, r).type === "weekDay")
    throw new Error("changeSectionValueFormat doesn't support week day formats");
  return e.formatByString(e.parse(t, r), n);
}, KD = (e, t) => e.formatByString(e.date(), t).length === 4, XD = (e, t, r, n) => {
  if (t !== "digit")
    return !1;
  switch (r) {
    case "year":
      return KD(e, n) ? e.formatByString(e.setYear(e.date(), 1), n) === "0001" : e.formatByString(e.setYear(e.date(), 2001), n) === "01";
    case "month":
      return e.formatByString(e.startOfYear(e.date()), n).length > 1;
    case "day":
      return e.formatByString(e.startOfMonth(e.date()), n).length > 1;
    case "weekDay":
      return e.formatByString(e.startOfWeek(e.date()), n).length > 1;
    case "hours":
      return e.formatByString(e.setHours(e.date(), 1), n).length > 1;
    case "minutes":
      return e.formatByString(e.setMinutes(e.date(), 1), n).length > 1;
    case "seconds":
      return e.formatByString(e.setMinutes(e.date(), 1), n).length > 1;
    default:
      throw new Error("Invalid section type");
  }
}, qte = (e, t) => {
  const r = [], {
    start: n,
    end: o
  } = e.escapedCharacters, a = new RegExp(`(\\${n}[^\\${o}]*\\${o})+`, "g");
  let i = null;
  for (; i = a.exec(t); )
    r.push({
      start: i.index,
      end: a.lastIndex - 1
    });
  return r;
}, CS = (e, t, r, n) => {
  let o = "";
  const a = [], i = (y) => {
    if (y === "")
      return null;
    const h = vb(e, y), v = n == null || !e.isValid(n) ? "" : e.formatByString(n, y), g = XD(e, h.contentType, h.type, y);
    return a.push(T({}, h, {
      format: y,
      value: v,
      placeholder: Yte(e, t, h, y),
      hasLeadingZeros: g,
      startSeparator: a.length === 0 ? o : "",
      endSeparator: "",
      modified: !1
    })), null;
  };
  let l = 10, c = r, u = e.expandFormat(r);
  for (; u !== c; )
    if (c = u, u = e.expandFormat(c), l -= 1, l < 0)
      throw new Error("MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component");
  const d = u, f = qte(e, d), p = new RegExp(`^(${Object.keys(e.formatTokenMap).join("|")})`);
  let m = "";
  for (let y = 0; y < d.length; y += 1) {
    const h = f.find((x) => x.start <= y && x.end >= y), v = d[y], g = h != null, b = `${m}${d.slice(y)}`;
    !g && v.match(/([A-Za-z]+)/) && p.test(b) ? m += v : g && (h == null ? void 0 : h.start) === y || (h == null ? void 0 : h.end) === y || (i(m), m = "", a.length === 0 ? o += v : a[a.length - 1].endSeparator += v);
  }
  return i(m), a.map((y) => {
    const h = (v) => {
      let g = v;
      return g !== null && g.includes(" ") && (g = `â©${g}â¦`), g === "/" && (g = " / "), g;
    };
    return y.startSeparator = h(y.startSeparator), y.endSeparator = h(y.endSeparator), y;
  });
}, $v = (e, t) => {
  const r = t.some((l) => l.type === "day"), n = [], o = [];
  for (let l = 0; l < t.length; l += 1) {
    const c = t[l];
    r && c.type === "weekDay" || (n.push(c.format), o.push(bb(c, "non-input")));
  }
  const a = n.join(" "), i = o.join(" ");
  return e.parse(i, a);
}, Gte = (e, t) => {
  const n = e.map((o) => `${o.startSeparator}${bb(o, t ? "input-rtl" : "input-ltr")}${o.endSeparator}`).join("");
  return t ? `â¦${n}â©` : n;
}, Kte = (e) => {
  const t = e.date(), r = e.endOfYear(t), {
    maxDaysInMonth: n,
    longestMonth: o
  } = e.getMonthArray(t).reduce((a, i) => {
    const l = e.getDaysInMonth(i);
    return l > a.maxDaysInMonth ? {
      maxDaysInMonth: l,
      longestMonth: i
    } : a;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format: a
    }) => ({
      minimum: 0,
      maximum: KD(e, a) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: e.getMonth(r) + 1
    }),
    day: ({
      currentDate: a
    }) => ({
      minimum: 1,
      maximum: a != null && e.isValid(a) ? e.getDaysInMonth(a) : n,
      longestMonth: o
    }),
    weekDay: ({
      format: a,
      contentType: i
    }) => {
      if (i === "digit") {
        const l = Hp(e, a).map(Number);
        return {
          minimum: Math.min(...l),
          maximum: Math.max(...l)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format: a
    }) => {
      const i = e.getHours(r);
      return e.formatByString(e.endOfDay(t), a) !== i.toString() ? {
        minimum: 1,
        maximum: Number(e.formatByString(e.startOfDay(t), a))
      } : {
        minimum: 0,
        maximum: i
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: e.getMinutes(r)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: e.getSeconds(r)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 0
    })
  };
};
let kS = !1;
const RS = (e, t) => {
  if (process.env.NODE_ENV !== "production" && !kS) {
    const r = [];
    ["date", "date-time"].includes(t) && r.push("weekDay", "day", "month", "year"), ["time", "date-time"].includes(t) && r.push("hours", "minutes", "seconds", "meridiem");
    const n = e.find((o) => !r.includes(o.type));
    n && (console.warn(`MUI: The field component you are using is not compatible with the "${n.type} date section.`, `The supported date sections are ["${r.join('", "')}"]\`.`), kS = !0);
  }
}, Xte = (e, t, r, n) => {
  switch (t.type) {
    case "year":
      return e.setYear(n, e.getYear(r));
    case "month":
      return e.setMonth(n, e.getMonth(r));
    case "weekDay": {
      const o = Hp(e, t.format), a = e.formatByString(r, t.format), i = o.indexOf(a), c = o.indexOf(t.value) - i;
      return e.addDays(r, c);
    }
    case "day":
      return e.setDate(n, e.getDate(r));
    case "meridiem": {
      const o = e.getHours(r) < 12, a = e.getHours(n);
      return o && a >= 12 ? e.addHours(n, -12) : !o && a < 12 ? e.addHours(n, 12) : n;
    }
    case "hours":
      return e.setHours(n, e.getHours(r));
    case "minutes":
      return e.setMinutes(n, e.getMinutes(r));
    case "seconds":
      return e.setSeconds(n, e.getSeconds(r));
    default:
      return n;
  }
}, DS = (e, t, r, n, o) => r.reduce((a, i) => !o || i.modified ? Xte(e, i, t, a) : a, n), Qte = () => navigator.userAgent.toLowerCase().indexOf("android") > -1, Zte = (e, t, r) => {
  if (!(t.every((i) => i.type === "weekDay" || i.value !== "") && t.some((i) => i.type === "day")))
    return null;
  const o = t.map((i) => {
    if (i.type !== "day")
      return i;
    const l = r.day({
      currentDate: null,
      format: i.format,
      contentType: i.contentType
    });
    return T({}, i, {
      value: gb(e, l.minimum, i.type, i.format, i.hasLeadingZeros, l)
    });
  }), a = $v(e, o);
  return a == null || !e.isValid(a) ? null : t.map((i) => {
    if (i.type !== "day")
      return i;
    const l = r.day({
      currentDate: a,
      format: i.format,
      contentType: i.contentType
    });
    return Number(i.value) <= l.maximum ? i : T({}, i, {
      value: l.maximum.toString()
    });
  });
}, Jte = (e, t) => {
  const r = {};
  if (!t)
    return e.forEach((c, u) => {
      const d = u === 0 ? null : u - 1, f = u === e.length - 1 ? null : u + 1;
      r[u] = {
        leftIndex: d,
        rightIndex: f
      };
    }), {
      neighbors: r,
      startIndex: 0,
      endIndex: e.length - 1
    };
  const n = {}, o = {};
  let a = 0, i = 0, l = e.length - 1;
  for (; l >= 0; ) {
    i = e.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (c, u) => {
        var d;
        return u >= a && ((d = c.endSeparator) == null ? void 0 : d.includes(" ")) && // Special case where the spaces were not there in the initial input
        c.endSeparator !== " / ";
      }
    ), i === -1 && (i = e.length - 1);
    for (let c = i; c >= a; c -= 1)
      o[c] = l, n[l] = c, l -= 1;
    a = i + 1;
  }
  return e.forEach((c, u) => {
    const d = o[u], f = d === 0 ? null : n[d - 1], p = d === e.length - 1 ? null : n[d + 1];
    r[u] = {
      leftIndex: f,
      rightIndex: p
    };
  }), {
    neighbors: r,
    startIndex: n[0],
    endIndex: n[e.length - 1]
  };
}, rs = {
  emptyValue: null,
  getTodayValue: (e) => e.date(),
  cleanValue: Bte,
  areValuesEqual: Wte,
  isSameError: (e, t) => e === t,
  hasError: (e) => e != null,
  defaultErrorState: null
}, QD = {
  updateReferenceValue: (e, t, r) => t == null || !e.isValid(t) ? r : t,
  getSectionsFromValue: (e, t, r, n, o) => !e.isValid(t) && !!r ? r : GD(o(t), n),
  getValueStrFromSections: Gte,
  getActiveDateManager: (e, t) => ({
    date: t.value,
    referenceDate: t.referenceValue,
    getSections: (r) => r,
    getNewValuesFromNewActiveDate: (r) => ({
      value: r,
      referenceValue: r == null || !e.isValid(r) ? t.referenceValue : r
    })
  }),
  parseValueStr: (e, t, r) => r(e.trim(), t)
}, ere = (e) => ({
  components: {
    MuiLocalizationProvider: {
      defaultProps: {
        localeText: T({}, e)
      }
    }
  }
}), ZD = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "open previous view",
  openNextView: "open next view",
  calendarViewSwitchingButtonAriaLabel: (e) => e === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange placeholders
  start: "Start",
  end: "End",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (e, t, r) => `Select ${e}. ${t === null ? "No time selected" : `Selected time is ${r.format(t, "fullTime")}`}`,
  hoursClockNumberText: (e) => `${e} hours`,
  minutesClockNumberText: (e) => `${e} minutes`,
  secondsClockNumberText: (e) => `${e} seconds`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (e) => `Week ${e}`,
  calendarWeekNumberText: (e) => `${e}`,
  // Open picker labels
  openDatePickerDialogue: (e, t) => e !== null && t.isValid(e) ? `Choose date, selected date is ${t.format(e, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (e, t) => e !== null && t.isValid(e) ? `Choose time, selected time is ${t.format(e, "fullTime")}` : "Choose time",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (e) => "Y".repeat(e.digitAmount),
  fieldMonthPlaceholder: (e) => e.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (e) => e.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa"
}, tre = ZD;
ere(ZD);
const Ha = () => {
  const e = P.useContext(Ff);
  if (e === null)
    throw new Error(["MUI: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join(`
`));
  if (e.utils === null)
    throw new Error(["MUI: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join(`
`));
  const t = P.useMemo(() => T({}, tre, e.localeText), [e.localeText]);
  return P.useMemo(() => T({}, e, {
    localeText: t
  }), [e, t]);
}, wt = () => Ha().utils, Ya = () => Ha().defaultDates, Yr = () => Ha().localeText, ns = () => {
  const e = wt();
  return P.useRef(e.date()).current;
}, JD = (e) => e.length === 1 && e[0] === "year", eN = (e) => e.length === 2 && e.indexOf("month") !== -1 && e.indexOf("year") !== -1, tN = ({
  openTo: e,
  defaultOpenTo: t,
  views: r,
  defaultViews: n
}) => {
  const o = r ?? n;
  let a;
  if (e != null)
    a = e;
  else if (o.includes(t))
    a = t;
  else if (o.length > 0)
    a = o[0];
  else
    throw new Error("MUI: The `views` prop must contain at least one view");
  return {
    views: o,
    openTo: a
  };
}, rre = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function nre(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function ore(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (n) => e.ownerDocument.querySelector(`input[type="radio"]${n}`);
  let r = t(`[name="${e.name}"]:checked`);
  return r || (r = t(`[name="${e.name}"]`)), r !== e;
}
function are(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || ore(e));
}
function ire(e) {
  const t = [], r = [];
  return Array.from(e.querySelectorAll(rre)).forEach((n, o) => {
    const a = nre(n);
    a === -1 || !are(n) || (a === 0 ? t.push(n) : r.push({
      documentOrder: o,
      tabIndex: a,
      node: n
    }));
  }), r.sort((n, o) => n.tabIndex === o.tabIndex ? n.documentOrder - o.documentOrder : n.tabIndex - o.tabIndex).map((n) => n.node).concat(t);
}
function sre() {
  return !0;
}
function sl(e) {
  const {
    children: t,
    disableAutoFocus: r = !1,
    disableEnforceFocus: n = !1,
    disableRestoreFocus: o = !1,
    getTabbable: a = ire,
    isEnabled: i = sre,
    open: l
  } = e, c = P.useRef(!1), u = P.useRef(null), d = P.useRef(null), f = P.useRef(null), p = P.useRef(null), m = P.useRef(!1), y = P.useRef(null), h = Lt(t.ref, y), v = P.useRef(null);
  P.useEffect(() => {
    !l || !y.current || (m.current = !r);
  }, [r, l]), P.useEffect(() => {
    if (!l || !y.current)
      return;
    const x = nr(y.current);
    return y.current.contains(x.activeElement) || (y.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), y.current.setAttribute("tabIndex", "-1")), m.current && y.current.focus()), () => {
      o || (f.current && f.current.focus && (c.current = !0, f.current.focus()), f.current = null);
    };
  }, [l]), P.useEffect(() => {
    if (!l || !y.current)
      return;
    const x = nr(y.current), O = (E) => {
      const {
        current: C
      } = y;
      if (C !== null) {
        if (!x.hasFocus() || n || !i() || c.current) {
          c.current = !1;
          return;
        }
        if (!C.contains(x.activeElement)) {
          if (E && p.current !== E.target || x.activeElement !== p.current)
            p.current = null;
          else if (p.current !== null)
            return;
          if (!m.current)
            return;
          let j = [];
          if ((x.activeElement === u.current || x.activeElement === d.current) && (j = a(y.current)), j.length > 0) {
            var N, $;
            const A = !!((N = v.current) != null && N.shiftKey && (($ = v.current) == null ? void 0 : $.key) === "Tab"), k = j[0], R = j[j.length - 1];
            typeof k != "string" && typeof R != "string" && (A ? R.focus() : k.focus());
          } else
            C.focus();
        }
      }
    }, w = (E) => {
      v.current = E, !(n || !i() || E.key !== "Tab") && x.activeElement === y.current && E.shiftKey && (c.current = !0, d.current && d.current.focus());
    };
    x.addEventListener("focusin", O), x.addEventListener("keydown", w, !0);
    const S = setInterval(() => {
      x.activeElement && x.activeElement.tagName === "BODY" && O(null);
    }, 50);
    return () => {
      clearInterval(S), x.removeEventListener("focusin", O), x.removeEventListener("keydown", w, !0);
    };
  }, [r, n, o, i, l, a]);
  const g = (x) => {
    f.current === null && (f.current = x.relatedTarget), m.current = !0, p.current = x.target;
    const O = t.props.onFocus;
    O && O(x);
  }, b = (x) => {
    f.current === null && (f.current = x.relatedTarget), m.current = !0;
  };
  return /* @__PURE__ */ _.jsxs(P.Fragment, {
    children: [/* @__PURE__ */ _.jsx("div", {
      tabIndex: l ? 0 : -1,
      onFocus: b,
      ref: u,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ P.cloneElement(t, {
      ref: h,
      onFocus: g
    }), /* @__PURE__ */ _.jsx("div", {
      tabIndex: l ? 0 : -1,
      onFocus: b,
      ref: d,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (sl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: yl,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: s.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: s.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: s.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: s.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: s.func,
  /**
   * If `true`, focus is locked.
   */
  open: s.bool.isRequired
});
process.env.NODE_ENV !== "production" && (sl["propTypes"] = tp(sl.propTypes));
var Cr = "top", mn = "bottom", hn = "right", kr = "left", wb = "auto", Dl = [Cr, mn, hn, kr], Vi = "start", ll = "end", lre = "clippingParents", rN = "viewport", Os = "popper", cre = "reference", NS = /* @__PURE__ */ Dl.reduce(function(e, t) {
  return e.concat([t + "-" + Vi, t + "-" + ll]);
}, []), nN = /* @__PURE__ */ [].concat(Dl, [wb]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Vi, t + "-" + ll]);
}, []), ure = "beforeRead", dre = "read", fre = "afterRead", pre = "beforeMain", mre = "main", hre = "afterMain", yre = "beforeWrite", vre = "write", gre = "afterWrite", bre = [ure, dre, fre, pre, mre, hre, yre, vre, gre];
function Qn(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Ur(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Aa(e) {
  var t = Ur(e).Element;
  return e instanceof t || e instanceof Element;
}
function un(e) {
  var t = Ur(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function xb(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Ur(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function wre(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(r) {
    var n = t.styles[r] || {}, o = t.attributes[r] || {}, a = t.elements[r];
    !un(a) || !Qn(a) || (Object.assign(a.style, n), Object.keys(o).forEach(function(i) {
      var l = o[i];
      l === !1 ? a.removeAttribute(i) : a.setAttribute(i, l === !0 ? "" : l);
    }));
  });
}
function xre(e) {
  var t = e.state, r = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow), function() {
    Object.keys(t.elements).forEach(function(n) {
      var o = t.elements[n], a = t.attributes[n] || {}, i = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]), l = i.reduce(function(c, u) {
        return c[u] = "", c;
      }, {});
      !un(o) || !Qn(o) || (Object.assign(o.style, l), Object.keys(a).forEach(function(c) {
        o.removeAttribute(c);
      }));
    });
  };
}
const _re = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: wre,
  effect: xre,
  requires: ["computeStyles"]
};
function Yn(e) {
  return e.split("-")[0];
}
var Ta = Math.max, Lf = Math.min, zi = Math.round;
function Cv() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function oN() {
  return !/^((?!chrome|android).)*safari/i.test(Cv());
}
function Bi(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var n = e.getBoundingClientRect(), o = 1, a = 1;
  t && un(e) && (o = e.offsetWidth > 0 && zi(n.width) / e.offsetWidth || 1, a = e.offsetHeight > 0 && zi(n.height) / e.offsetHeight || 1);
  var i = Aa(e) ? Ur(e) : window, l = i.visualViewport, c = !oN() && r, u = (n.left + (c && l ? l.offsetLeft : 0)) / o, d = (n.top + (c && l ? l.offsetTop : 0)) / a, f = n.width / o, p = n.height / a;
  return {
    width: f,
    height: p,
    top: d,
    right: u + f,
    bottom: d + p,
    left: u,
    x: u,
    y: d
  };
}
function _b(e) {
  var t = Bi(e), r = e.offsetWidth, n = e.offsetHeight;
  return Math.abs(t.width - r) <= 1 && (r = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: r,
    height: n
  };
}
function aN(e, t) {
  var r = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (r && xb(r)) {
    var n = t;
    do {
      if (n && e.isSameNode(n))
        return !0;
      n = n.parentNode || n.host;
    } while (n);
  }
  return !1;
}
function go(e) {
  return Ur(e).getComputedStyle(e);
}
function Ore(e) {
  return ["table", "td", "th"].indexOf(Qn(e)) >= 0;
}
function ra(e) {
  return ((Aa(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function Yp(e) {
  return Qn(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (xb(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ra(e)
  );
}
function IS(e) {
  return !un(e) || // https://github.com/popperjs/popper-core/issues/837
  go(e).position === "fixed" ? null : e.offsetParent;
}
function Pre(e) {
  var t = /firefox/i.test(Cv()), r = /Trident/i.test(Cv());
  if (r && un(e)) {
    var n = go(e);
    if (n.position === "fixed")
      return null;
  }
  var o = Yp(e);
  for (xb(o) && (o = o.host); un(o) && ["html", "body"].indexOf(Qn(o)) < 0; ) {
    var a = go(o);
    if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || t && a.willChange === "filter" || t && a.filter && a.filter !== "none")
      return o;
    o = o.parentNode;
  }
  return null;
}
function Nl(e) {
  for (var t = Ur(e), r = IS(e); r && Ore(r) && go(r).position === "static"; )
    r = IS(r);
  return r && (Qn(r) === "html" || Qn(r) === "body" && go(r).position === "static") ? t : r || Pre(e) || t;
}
function Ob(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Hs(e, t, r) {
  return Ta(e, Lf(t, r));
}
function Sre(e, t, r) {
  var n = Hs(e, t, r);
  return n > r ? r : n;
}
function iN() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function sN(e) {
  return Object.assign({}, iN(), e);
}
function lN(e, t) {
  return t.reduce(function(r, n) {
    return r[n] = e, r;
  }, {});
}
var Tre = function(t, r) {
  return t = typeof t == "function" ? t(Object.assign({}, r.rects, {
    placement: r.placement
  })) : t, sN(typeof t != "number" ? t : lN(t, Dl));
};
function Ere(e) {
  var t, r = e.state, n = e.name, o = e.options, a = r.elements.arrow, i = r.modifiersData.popperOffsets, l = Yn(r.placement), c = Ob(l), u = [kr, hn].indexOf(l) >= 0, d = u ? "height" : "width";
  if (!(!a || !i)) {
    var f = Tre(o.padding, r), p = _b(a), m = c === "y" ? Cr : kr, y = c === "y" ? mn : hn, h = r.rects.reference[d] + r.rects.reference[c] - i[c] - r.rects.popper[d], v = i[c] - r.rects.reference[c], g = Nl(a), b = g ? c === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, x = h / 2 - v / 2, O = f[m], w = b - p[d] - f[y], S = b / 2 - p[d] / 2 + x, E = Hs(O, S, w), C = c;
    r.modifiersData[n] = (t = {}, t[C] = E, t.centerOffset = E - S, t);
  }
}
function $re(e) {
  var t = e.state, r = e.options, n = r.element, o = n === void 0 ? "[data-popper-arrow]" : n;
  o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || aN(t.elements.popper, o) && (t.elements.arrow = o));
}
const Cre = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Ere,
  effect: $re,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Wi(e) {
  return e.split("-")[1];
}
var kre = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Rre(e, t) {
  var r = e.x, n = e.y, o = t.devicePixelRatio || 1;
  return {
    x: zi(r * o) / o || 0,
    y: zi(n * o) / o || 0
  };
}
function MS(e) {
  var t, r = e.popper, n = e.popperRect, o = e.placement, a = e.variation, i = e.offsets, l = e.position, c = e.gpuAcceleration, u = e.adaptive, d = e.roundOffsets, f = e.isFixed, p = i.x, m = p === void 0 ? 0 : p, y = i.y, h = y === void 0 ? 0 : y, v = typeof d == "function" ? d({
    x: m,
    y: h
  }) : {
    x: m,
    y: h
  };
  m = v.x, h = v.y;
  var g = i.hasOwnProperty("x"), b = i.hasOwnProperty("y"), x = kr, O = Cr, w = window;
  if (u) {
    var S = Nl(r), E = "clientHeight", C = "clientWidth";
    if (S === Ur(r) && (S = ra(r), go(S).position !== "static" && l === "absolute" && (E = "scrollHeight", C = "scrollWidth")), S = S, o === Cr || (o === kr || o === hn) && a === ll) {
      O = mn;
      var N = f && S === w && w.visualViewport ? w.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        S[E]
      );
      h -= N - n.height, h *= c ? 1 : -1;
    }
    if (o === kr || (o === Cr || o === mn) && a === ll) {
      x = hn;
      var $ = f && S === w && w.visualViewport ? w.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        S[C]
      );
      m -= $ - n.width, m *= c ? 1 : -1;
    }
  }
  var j = Object.assign({
    position: l
  }, u && kre), A = d === !0 ? Rre({
    x: m,
    y: h
  }, Ur(r)) : {
    x: m,
    y: h
  };
  if (m = A.x, h = A.y, c) {
    var k;
    return Object.assign({}, j, (k = {}, k[O] = b ? "0" : "", k[x] = g ? "0" : "", k.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + h + "px)" : "translate3d(" + m + "px, " + h + "px, 0)", k));
  }
  return Object.assign({}, j, (t = {}, t[O] = b ? h + "px" : "", t[x] = g ? m + "px" : "", t.transform = "", t));
}
function Dre(e) {
  var t = e.state, r = e.options, n = r.gpuAcceleration, o = n === void 0 ? !0 : n, a = r.adaptive, i = a === void 0 ? !0 : a, l = r.roundOffsets, c = l === void 0 ? !0 : l, u = {
    placement: Yn(t.placement),
    variation: Wi(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: o,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, MS(Object.assign({}, u, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: i,
    roundOffsets: c
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, MS(Object.assign({}, u, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const Nre = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Dre,
  data: {}
};
var ac = {
  passive: !0
};
function Ire(e) {
  var t = e.state, r = e.instance, n = e.options, o = n.scroll, a = o === void 0 ? !0 : o, i = n.resize, l = i === void 0 ? !0 : i, c = Ur(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return a && u.forEach(function(d) {
    d.addEventListener("scroll", r.update, ac);
  }), l && c.addEventListener("resize", r.update, ac), function() {
    a && u.forEach(function(d) {
      d.removeEventListener("scroll", r.update, ac);
    }), l && c.removeEventListener("resize", r.update, ac);
  };
}
const Mre = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Ire,
  data: {}
};
var Are = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function bu(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return Are[t];
  });
}
var jre = {
  start: "end",
  end: "start"
};
function AS(e) {
  return e.replace(/start|end/g, function(t) {
    return jre[t];
  });
}
function Pb(e) {
  var t = Ur(e), r = t.pageXOffset, n = t.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: n
  };
}
function Sb(e) {
  return Bi(ra(e)).left + Pb(e).scrollLeft;
}
function Fre(e, t) {
  var r = Ur(e), n = ra(e), o = r.visualViewport, a = n.clientWidth, i = n.clientHeight, l = 0, c = 0;
  if (o) {
    a = o.width, i = o.height;
    var u = oN();
    (u || !u && t === "fixed") && (l = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: a,
    height: i,
    x: l + Sb(e),
    y: c
  };
}
function Lre(e) {
  var t, r = ra(e), n = Pb(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, a = Ta(r.scrollWidth, r.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), i = Ta(r.scrollHeight, r.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), l = -n.scrollLeft + Sb(e), c = -n.scrollTop;
  return go(o || r).direction === "rtl" && (l += Ta(r.clientWidth, o ? o.clientWidth : 0) - a), {
    width: a,
    height: i,
    x: l,
    y: c
  };
}
function Tb(e) {
  var t = go(e), r = t.overflow, n = t.overflowX, o = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + o + n);
}
function cN(e) {
  return ["html", "body", "#document"].indexOf(Qn(e)) >= 0 ? e.ownerDocument.body : un(e) && Tb(e) ? e : cN(Yp(e));
}
function Ys(e, t) {
  var r;
  t === void 0 && (t = []);
  var n = cN(e), o = n === ((r = e.ownerDocument) == null ? void 0 : r.body), a = Ur(n), i = o ? [a].concat(a.visualViewport || [], Tb(n) ? n : []) : n, l = t.concat(i);
  return o ? l : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    l.concat(Ys(Yp(i)))
  );
}
function kv(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function Vre(e, t) {
  var r = Bi(e, !1, t === "fixed");
  return r.top = r.top + e.clientTop, r.left = r.left + e.clientLeft, r.bottom = r.top + e.clientHeight, r.right = r.left + e.clientWidth, r.width = e.clientWidth, r.height = e.clientHeight, r.x = r.left, r.y = r.top, r;
}
function jS(e, t, r) {
  return t === rN ? kv(Fre(e, r)) : Aa(t) ? Vre(t, r) : kv(Lre(ra(e)));
}
function zre(e) {
  var t = Ys(Yp(e)), r = ["absolute", "fixed"].indexOf(go(e).position) >= 0, n = r && un(e) ? Nl(e) : e;
  return Aa(n) ? t.filter(function(o) {
    return Aa(o) && aN(o, n) && Qn(o) !== "body";
  }) : [];
}
function Bre(e, t, r, n) {
  var o = t === "clippingParents" ? zre(e) : [].concat(t), a = [].concat(o, [r]), i = a[0], l = a.reduce(function(c, u) {
    var d = jS(e, u, n);
    return c.top = Ta(d.top, c.top), c.right = Lf(d.right, c.right), c.bottom = Lf(d.bottom, c.bottom), c.left = Ta(d.left, c.left), c;
  }, jS(e, i, n));
  return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l;
}
function uN(e) {
  var t = e.reference, r = e.element, n = e.placement, o = n ? Yn(n) : null, a = n ? Wi(n) : null, i = t.x + t.width / 2 - r.width / 2, l = t.y + t.height / 2 - r.height / 2, c;
  switch (o) {
    case Cr:
      c = {
        x: i,
        y: t.y - r.height
      };
      break;
    case mn:
      c = {
        x: i,
        y: t.y + t.height
      };
      break;
    case hn:
      c = {
        x: t.x + t.width,
        y: l
      };
      break;
    case kr:
      c = {
        x: t.x - r.width,
        y: l
      };
      break;
    default:
      c = {
        x: t.x,
        y: t.y
      };
  }
  var u = o ? Ob(o) : null;
  if (u != null) {
    var d = u === "y" ? "height" : "width";
    switch (a) {
      case Vi:
        c[u] = c[u] - (t[d] / 2 - r[d] / 2);
        break;
      case ll:
        c[u] = c[u] + (t[d] / 2 - r[d] / 2);
        break;
    }
  }
  return c;
}
function cl(e, t) {
  t === void 0 && (t = {});
  var r = t, n = r.placement, o = n === void 0 ? e.placement : n, a = r.strategy, i = a === void 0 ? e.strategy : a, l = r.boundary, c = l === void 0 ? lre : l, u = r.rootBoundary, d = u === void 0 ? rN : u, f = r.elementContext, p = f === void 0 ? Os : f, m = r.altBoundary, y = m === void 0 ? !1 : m, h = r.padding, v = h === void 0 ? 0 : h, g = sN(typeof v != "number" ? v : lN(v, Dl)), b = p === Os ? cre : Os, x = e.rects.popper, O = e.elements[y ? b : p], w = Bre(Aa(O) ? O : O.contextElement || ra(e.elements.popper), c, d, i), S = Bi(e.elements.reference), E = uN({
    reference: S,
    element: x,
    strategy: "absolute",
    placement: o
  }), C = kv(Object.assign({}, x, E)), N = p === Os ? C : S, $ = {
    top: w.top - N.top + g.top,
    bottom: N.bottom - w.bottom + g.bottom,
    left: w.left - N.left + g.left,
    right: N.right - w.right + g.right
  }, j = e.modifiersData.offset;
  if (p === Os && j) {
    var A = j[o];
    Object.keys($).forEach(function(k) {
      var R = [hn, mn].indexOf(k) >= 0 ? 1 : -1, D = [Cr, mn].indexOf(k) >= 0 ? "y" : "x";
      $[k] += A[D] * R;
    });
  }
  return $;
}
function Wre(e, t) {
  t === void 0 && (t = {});
  var r = t, n = r.placement, o = r.boundary, a = r.rootBoundary, i = r.padding, l = r.flipVariations, c = r.allowedAutoPlacements, u = c === void 0 ? nN : c, d = Wi(n), f = d ? l ? NS : NS.filter(function(y) {
    return Wi(y) === d;
  }) : Dl, p = f.filter(function(y) {
    return u.indexOf(y) >= 0;
  });
  p.length === 0 && (p = f);
  var m = p.reduce(function(y, h) {
    return y[h] = cl(e, {
      placement: h,
      boundary: o,
      rootBoundary: a,
      padding: i
    })[Yn(h)], y;
  }, {});
  return Object.keys(m).sort(function(y, h) {
    return m[y] - m[h];
  });
}
function Ure(e) {
  if (Yn(e) === wb)
    return [];
  var t = bu(e);
  return [AS(e), t, AS(t)];
}
function Hre(e) {
  var t = e.state, r = e.options, n = e.name;
  if (!t.modifiersData[n]._skip) {
    for (var o = r.mainAxis, a = o === void 0 ? !0 : o, i = r.altAxis, l = i === void 0 ? !0 : i, c = r.fallbackPlacements, u = r.padding, d = r.boundary, f = r.rootBoundary, p = r.altBoundary, m = r.flipVariations, y = m === void 0 ? !0 : m, h = r.allowedAutoPlacements, v = t.options.placement, g = Yn(v), b = g === v, x = c || (b || !y ? [bu(v)] : Ure(v)), O = [v].concat(x).reduce(function(J, ne) {
      return J.concat(Yn(ne) === wb ? Wre(t, {
        placement: ne,
        boundary: d,
        rootBoundary: f,
        padding: u,
        flipVariations: y,
        allowedAutoPlacements: h
      }) : ne);
    }, []), w = t.rects.reference, S = t.rects.popper, E = /* @__PURE__ */ new Map(), C = !0, N = O[0], $ = 0; $ < O.length; $++) {
      var j = O[$], A = Yn(j), k = Wi(j) === Vi, R = [Cr, mn].indexOf(A) >= 0, D = R ? "width" : "height", L = cl(t, {
        placement: j,
        boundary: d,
        rootBoundary: f,
        altBoundary: p,
        padding: u
      }), B = R ? k ? hn : kr : k ? mn : Cr;
      w[D] > S[D] && (B = bu(B));
      var H = bu(B), U = [];
      if (a && U.push(L[A] <= 0), l && U.push(L[B] <= 0, L[H] <= 0), U.every(function(J) {
        return J;
      })) {
        N = j, C = !1;
        break;
      }
      E.set(j, U);
    }
    if (C)
      for (var I = y ? 3 : 1, V = function(ne) {
        var te = O.find(function(ee) {
          var K = E.get(ee);
          if (K)
            return K.slice(0, ne).every(function(Q) {
              return Q;
            });
        });
        if (te)
          return N = te, "break";
      }, G = I; G > 0; G--) {
        var q = V(G);
        if (q === "break")
          break;
      }
    t.placement !== N && (t.modifiersData[n]._skip = !0, t.placement = N, t.reset = !0);
  }
}
const Yre = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Hre,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function FS(e, t, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - r.y,
    right: e.right - t.width + r.x,
    bottom: e.bottom - t.height + r.y,
    left: e.left - t.width - r.x
  };
}
function LS(e) {
  return [Cr, hn, mn, kr].some(function(t) {
    return e[t] >= 0;
  });
}
function qre(e) {
  var t = e.state, r = e.name, n = t.rects.reference, o = t.rects.popper, a = t.modifiersData.preventOverflow, i = cl(t, {
    elementContext: "reference"
  }), l = cl(t, {
    altBoundary: !0
  }), c = FS(i, n), u = FS(l, o, a), d = LS(c), f = LS(u);
  t.modifiersData[r] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: u,
    isReferenceHidden: d,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": f
  });
}
const Gre = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: qre
};
function Kre(e, t, r) {
  var n = Yn(e), o = [kr, Cr].indexOf(n) >= 0 ? -1 : 1, a = typeof r == "function" ? r(Object.assign({}, t, {
    placement: e
  })) : r, i = a[0], l = a[1];
  return i = i || 0, l = (l || 0) * o, [kr, hn].indexOf(n) >= 0 ? {
    x: l,
    y: i
  } : {
    x: i,
    y: l
  };
}
function Xre(e) {
  var t = e.state, r = e.options, n = e.name, o = r.offset, a = o === void 0 ? [0, 0] : o, i = nN.reduce(function(d, f) {
    return d[f] = Kre(f, t.rects, a), d;
  }, {}), l = i[t.placement], c = l.x, u = l.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += u), t.modifiersData[n] = i;
}
const Qre = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Xre
};
function Zre(e) {
  var t = e.state, r = e.name;
  t.modifiersData[r] = uN({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const Jre = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Zre,
  data: {}
};
function ene(e) {
  return e === "x" ? "y" : "x";
}
function tne(e) {
  var t = e.state, r = e.options, n = e.name, o = r.mainAxis, a = o === void 0 ? !0 : o, i = r.altAxis, l = i === void 0 ? !1 : i, c = r.boundary, u = r.rootBoundary, d = r.altBoundary, f = r.padding, p = r.tether, m = p === void 0 ? !0 : p, y = r.tetherOffset, h = y === void 0 ? 0 : y, v = cl(t, {
    boundary: c,
    rootBoundary: u,
    padding: f,
    altBoundary: d
  }), g = Yn(t.placement), b = Wi(t.placement), x = !b, O = Ob(g), w = ene(O), S = t.modifiersData.popperOffsets, E = t.rects.reference, C = t.rects.popper, N = typeof h == "function" ? h(Object.assign({}, t.rects, {
    placement: t.placement
  })) : h, $ = typeof N == "number" ? {
    mainAxis: N,
    altAxis: N
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, N), j = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, A = {
    x: 0,
    y: 0
  };
  if (S) {
    if (a) {
      var k, R = O === "y" ? Cr : kr, D = O === "y" ? mn : hn, L = O === "y" ? "height" : "width", B = S[O], H = B + v[R], U = B - v[D], I = m ? -C[L] / 2 : 0, V = b === Vi ? E[L] : C[L], G = b === Vi ? -C[L] : -E[L], q = t.elements.arrow, J = m && q ? _b(q) : {
        width: 0,
        height: 0
      }, ne = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : iN(), te = ne[R], ee = ne[D], K = Hs(0, E[L], J[L]), Q = x ? E[L] / 2 - I - K - te - $.mainAxis : V - K - te - $.mainAxis, ae = x ? -E[L] / 2 + I + K + ee + $.mainAxis : G + K + ee + $.mainAxis, ie = t.elements.arrow && Nl(t.elements.arrow), oe = ie ? O === "y" ? ie.clientTop || 0 : ie.clientLeft || 0 : 0, se = (k = j == null ? void 0 : j[O]) != null ? k : 0, re = B + Q - se - oe, le = B + ae - se, M = Hs(m ? Lf(H, re) : H, B, m ? Ta(U, le) : U);
      S[O] = M, A[O] = M - B;
    }
    if (l) {
      var W, Z = O === "x" ? Cr : kr, he = O === "x" ? mn : hn, me = S[w], de = w === "y" ? "height" : "width", ue = me + v[Z], Oe = me - v[he], Se = [Cr, kr].indexOf(g) !== -1, De = (W = j == null ? void 0 : j[w]) != null ? W : 0, nt = Se ? ue : me - E[de] - C[de] - De + $.altAxis, rt = Se ? me + E[de] + C[de] - De - $.altAxis : Oe, Be = m && Se ? Sre(nt, me, rt) : Hs(m ? nt : ue, me, m ? rt : Oe);
      S[w] = Be, A[w] = Be - me;
    }
    t.modifiersData[n] = A;
  }
}
const rne = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: tne,
  requiresIfExists: ["offset"]
};
function nne(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function one(e) {
  return e === Ur(e) || !un(e) ? Pb(e) : nne(e);
}
function ane(e) {
  var t = e.getBoundingClientRect(), r = zi(t.width) / e.offsetWidth || 1, n = zi(t.height) / e.offsetHeight || 1;
  return r !== 1 || n !== 1;
}
function ine(e, t, r) {
  r === void 0 && (r = !1);
  var n = un(t), o = un(t) && ane(t), a = ra(t), i = Bi(e, o, r), l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (n || !n && !r) && ((Qn(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Tb(a)) && (l = one(t)), un(t) ? (c = Bi(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : a && (c.x = Sb(a))), {
    x: i.left + l.scrollLeft - c.x,
    y: i.top + l.scrollTop - c.y,
    width: i.width,
    height: i.height
  };
}
function sne(e) {
  var t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
  e.forEach(function(a) {
    t.set(a.name, a);
  });
  function o(a) {
    r.add(a.name);
    var i = [].concat(a.requires || [], a.requiresIfExists || []);
    i.forEach(function(l) {
      if (!r.has(l)) {
        var c = t.get(l);
        c && o(c);
      }
    }), n.push(a);
  }
  return e.forEach(function(a) {
    r.has(a.name) || o(a);
  }), n;
}
function lne(e) {
  var t = sne(e);
  return bre.reduce(function(r, n) {
    return r.concat(t.filter(function(o) {
      return o.phase === n;
    }));
  }, []);
}
function cne(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(r) {
      Promise.resolve().then(function() {
        t = void 0, r(e());
      });
    })), t;
  };
}
function une(e) {
  var t = e.reduce(function(r, n) {
    var o = r[n.name];
    return r[n.name] = o ? Object.assign({}, o, n, {
      options: Object.assign({}, o.options, n.options),
      data: Object.assign({}, o.data, n.data)
    }) : n, r;
  }, {});
  return Object.keys(t).map(function(r) {
    return t[r];
  });
}
var VS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function zS() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return !t.some(function(n) {
    return !(n && typeof n.getBoundingClientRect == "function");
  });
}
function dne(e) {
  e === void 0 && (e = {});
  var t = e, r = t.defaultModifiers, n = r === void 0 ? [] : r, o = t.defaultOptions, a = o === void 0 ? VS : o;
  return function(l, c, u) {
    u === void 0 && (u = a);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, VS, a),
      modifiersData: {},
      elements: {
        reference: l,
        popper: c
      },
      attributes: {},
      styles: {}
    }, f = [], p = !1, m = {
      state: d,
      setOptions: function(g) {
        var b = typeof g == "function" ? g(d.options) : g;
        h(), d.options = Object.assign({}, a, d.options, b), d.scrollParents = {
          reference: Aa(l) ? Ys(l) : l.contextElement ? Ys(l.contextElement) : [],
          popper: Ys(c)
        };
        var x = lne(une([].concat(n, d.options.modifiers)));
        return d.orderedModifiers = x.filter(function(O) {
          return O.enabled;
        }), y(), m.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!p) {
          var g = d.elements, b = g.reference, x = g.popper;
          if (zS(b, x)) {
            d.rects = {
              reference: ine(b, Nl(x), d.options.strategy === "fixed"),
              popper: _b(x)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function($) {
              return d.modifiersData[$.name] = Object.assign({}, $.data);
            });
            for (var O = 0; O < d.orderedModifiers.length; O++) {
              if (d.reset === !0) {
                d.reset = !1, O = -1;
                continue;
              }
              var w = d.orderedModifiers[O], S = w.fn, E = w.options, C = E === void 0 ? {} : E, N = w.name;
              typeof S == "function" && (d = S({
                state: d,
                options: C,
                name: N,
                instance: m
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: cne(function() {
        return new Promise(function(v) {
          m.forceUpdate(), v(d);
        });
      }),
      destroy: function() {
        h(), p = !0;
      }
    };
    if (!zS(l, c))
      return m;
    m.setOptions(u).then(function(v) {
      !p && u.onFirstUpdate && u.onFirstUpdate(v);
    });
    function y() {
      d.orderedModifiers.forEach(function(v) {
        var g = v.name, b = v.options, x = b === void 0 ? {} : b, O = v.effect;
        if (typeof O == "function") {
          var w = O({
            state: d,
            name: g,
            instance: m,
            options: x
          }), S = function() {
          };
          f.push(w || S);
        }
      });
    }
    function h() {
      f.forEach(function(v) {
        return v();
      }), f = [];
    }
    return m;
  };
}
var fne = [Mre, Jre, Nre, _re, Qre, Yre, rne, Cre, Gre], pne = /* @__PURE__ */ dne({
  defaultModifiers: fne
});
function mne(e) {
  return typeof e == "function" ? e() : e;
}
const Vf = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    children: n,
    container: o,
    disablePortal: a = !1
  } = t, [i, l] = P.useState(null), c = Lt(/* @__PURE__ */ P.isValidElement(n) ? n.ref : null, r);
  if (wr(() => {
    a || l(mne(o) || document.body);
  }, [o, a]), wr(() => {
    if (i && !a)
      return zh(r, i), () => {
        zh(r, null);
      };
  }, [r, i, a]), a) {
    if (/* @__PURE__ */ P.isValidElement(n)) {
      const u = {
        ref: c
      };
      return /* @__PURE__ */ P.cloneElement(n, u);
    }
    return /* @__PURE__ */ _.jsx(P.Fragment, {
      children: n
    });
  }
  return /* @__PURE__ */ _.jsx(P.Fragment, {
    children: i && /* @__PURE__ */ rg.createPortal(n, i)
  });
});
process.env.NODE_ENV !== "production" && (Vf.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The children to render into the `container`.
   */
  children: s.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: s.bool
});
process.env.NODE_ENV !== "production" && (Vf["propTypes"] = tp(Vf.propTypes));
const dN = Vf;
function hne(e) {
  return ze("MuiPopper", e);
}
Le("MuiPopper", ["root"]);
const yne = ["anchorEl", "children", "component", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps"], vne = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function gne(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function zf(e) {
  return typeof e == "function" ? e() : e;
}
function qp(e) {
  return e.nodeType !== void 0;
}
function bne(e) {
  return !qp(e);
}
const wne = () => Ve({
  root: ["root"]
}, YD(hne)), xne = {}, _ne = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n;
  const {
    anchorEl: o,
    children: a,
    component: i,
    direction: l,
    disablePortal: c,
    modifiers: u,
    open: d,
    ownerState: f,
    placement: p,
    popperOptions: m,
    popperRef: y,
    slotProps: h = {},
    slots: v = {},
    TransitionProps: g
  } = t, b = ge(t, yne), x = P.useRef(null), O = Lt(x, r), w = P.useRef(null), S = Lt(w, y), E = P.useRef(S);
  wr(() => {
    E.current = S;
  }, [S]), P.useImperativeHandle(y, () => w.current, []);
  const C = gne(p, l), [N, $] = P.useState(C), [j, A] = P.useState(zf(o));
  P.useEffect(() => {
    w.current && w.current.forceUpdate();
  }), P.useEffect(() => {
    o && A(zf(o));
  }, [o]), wr(() => {
    if (!j || !d)
      return;
    const B = (I) => {
      $(I.placement);
    };
    if (process.env.NODE_ENV !== "production" && j && qp(j) && j.nodeType === 1) {
      const I = j.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && I.top === 0 && I.left === 0 && I.right === 0 && I.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    let H = [{
      name: "preventOverflow",
      options: {
        altBoundary: c
      }
    }, {
      name: "flip",
      options: {
        altBoundary: c
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: I
      }) => {
        B(I);
      }
    }];
    u != null && (H = H.concat(u)), m && m.modifiers != null && (H = H.concat(m.modifiers));
    const U = pne(j, x.current, T({
      placement: C
    }, m, {
      modifiers: H
    }));
    return E.current(U), () => {
      U.destroy(), E.current(null);
    };
  }, [j, c, u, d, m, C]);
  const k = {
    placement: N
  };
  g !== null && (k.TransitionProps = g);
  const R = wne(), D = (n = i ?? v.root) != null ? n : "div", L = It({
    elementType: D,
    externalSlotProps: h.root,
    externalForwardedProps: b,
    additionalProps: {
      role: "tooltip",
      ref: O
    },
    ownerState: T({}, t, f),
    className: R.root
  });
  return /* @__PURE__ */ _.jsx(D, T({}, L, {
    children: typeof a == "function" ? a(k) : a
  }));
}), fN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    anchorEl: n,
    children: o,
    container: a,
    direction: i = "ltr",
    disablePortal: l = !1,
    keepMounted: c = !1,
    modifiers: u,
    open: d,
    placement: f = "bottom",
    popperOptions: p = xne,
    popperRef: m,
    style: y,
    transition: h = !1,
    slotProps: v = {},
    slots: g = {}
  } = t, b = ge(t, vne), [x, O] = P.useState(!0), w = () => {
    O(!1);
  }, S = () => {
    O(!0);
  };
  if (!c && !d && (!h || x))
    return null;
  let E;
  if (a)
    E = a;
  else if (n) {
    const $ = zf(n);
    E = $ && qp($) ? nr($).body : nr(null).body;
  }
  const C = !d && c && (!h || x) ? "none" : void 0, N = h ? {
    in: d,
    onEnter: w,
    onExited: S
  } : void 0;
  return /* @__PURE__ */ _.jsx(dN, {
    disablePortal: l,
    container: E,
    children: /* @__PURE__ */ _.jsx(_ne, T({
      anchorEl: n,
      direction: i,
      disablePortal: l,
      modifiers: u,
      ref: r,
      open: h ? !x : d,
      placement: f,
      popperOptions: p,
      popperRef: m,
      slotProps: v,
      slots: g
    }, b, {
      style: T({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: C
      }, y),
      TransitionProps: N,
      children: o
    }))
  });
});
process.env.NODE_ENV !== "production" && (fN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: xo(s.oneOfType([Gn, s.object, s.func]), (e) => {
    if (e.open) {
      const t = zf(e.anchorEl);
      if (t && qp(t) && t.nodeType === 1) {
        const r = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!t || typeof t.getBoundingClientRect != "function" || bne(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join(`
`));
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: s.oneOfType([s.node, s.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: s.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: s.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: s.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: s.arrayOf(s.shape({
    data: s.object,
    effect: s.func,
    enabled: s.bool,
    fn: s.func,
    name: s.any,
    options: s.object,
    phase: s.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: s.arrayOf(s.string),
    requiresIfExists: s.arrayOf(s.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: s.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: s.shape({
    modifiers: s.array,
    onFirstUpdate: s.func,
    placement: s.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: s.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: vn,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: s.shape({
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: s.shape({
    root: s.elementType
  }),
  /**
   * @ignore
   */
  style: s.object,
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: s.bool
});
const One = fN;
function Pne(e) {
  const t = nr(e);
  return t.body === e ? ho(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function qs(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function BS(e) {
  return parseInt(ho(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function Sne(e) {
  const r = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName) !== -1, n = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return r || n;
}
function WS(e, t, r, n, o) {
  const a = [t, r, ...n];
  [].forEach.call(e.children, (i) => {
    const l = a.indexOf(i) === -1, c = !Sne(i);
    l && c && qs(i, o);
  });
}
function ch(e, t) {
  let r = -1;
  return e.some((n, o) => t(n) ? (r = o, !0) : !1), r;
}
function Tne(e, t) {
  const r = [], n = e.container;
  if (!t.disableScrollLock) {
    if (Pne(n)) {
      const i = HT(nr(n));
      r.push({
        value: n.style.paddingRight,
        property: "padding-right",
        el: n
      }), n.style.paddingRight = `${BS(n) + i}px`;
      const l = nr(n).querySelectorAll(".mui-fixed");
      [].forEach.call(l, (c) => {
        r.push({
          value: c.style.paddingRight,
          property: "padding-right",
          el: c
        }), c.style.paddingRight = `${BS(c) + i}px`;
      });
    }
    let a;
    if (n.parentNode instanceof DocumentFragment)
      a = nr(n).body;
    else {
      const i = n.parentElement, l = ho(n);
      a = (i == null ? void 0 : i.nodeName) === "HTML" && l.getComputedStyle(i).overflowY === "scroll" ? i : n;
    }
    r.push({
      value: a.style.overflow,
      property: "overflow",
      el: a
    }, {
      value: a.style.overflowX,
      property: "overflow-x",
      el: a
    }, {
      value: a.style.overflowY,
      property: "overflow-y",
      el: a
    }), a.style.overflow = "hidden";
  }
  return () => {
    r.forEach(({
      value: a,
      el: i,
      property: l
    }) => {
      a ? i.style.setProperty(l, a) : i.style.removeProperty(l);
    });
  };
}
function Ene(e) {
  const t = [];
  return [].forEach.call(e.children, (r) => {
    r.getAttribute("aria-hidden") === "true" && t.push(r);
  }), t;
}
class $ne {
  constructor() {
    this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = [];
  }
  add(t, r) {
    let n = this.modals.indexOf(t);
    if (n !== -1)
      return n;
    n = this.modals.length, this.modals.push(t), t.modalRef && qs(t.modalRef, !1);
    const o = Ene(r);
    WS(r, t.mount, t.modalRef, o, !0);
    const a = ch(this.containers, (i) => i.container === r);
    return a !== -1 ? (this.containers[a].modals.push(t), n) : (this.containers.push({
      modals: [t],
      container: r,
      restore: null,
      hiddenSiblings: o
    }), n);
  }
  mount(t, r) {
    const n = ch(this.containers, (a) => a.modals.indexOf(t) !== -1), o = this.containers[n];
    o.restore || (o.restore = Tne(o, r));
  }
  remove(t, r = !0) {
    const n = this.modals.indexOf(t);
    if (n === -1)
      return n;
    const o = ch(this.containers, (i) => i.modals.indexOf(t) !== -1), a = this.containers[o];
    if (a.modals.splice(a.modals.indexOf(t), 1), this.modals.splice(n, 1), a.modals.length === 0)
      a.restore && a.restore(), t.modalRef && qs(t.modalRef, r), WS(a.container, t.mount, t.modalRef, a.hiddenSiblings, !1), this.containers.splice(o, 1);
    else {
      const i = a.modals[a.modals.length - 1];
      i.modalRef && qs(i.modalRef, !1);
    }
    return n;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
function Cne(e) {
  return ze("MuiModal", e);
}
Le("MuiModal", ["root", "hidden", "backdrop"]);
const kne = ["children", "closeAfterTransition", "component", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"], Rne = (e) => {
  const {
    open: t,
    exited: r
  } = e;
  return Ve({
    root: ["root", !t && r && "hidden"],
    backdrop: ["backdrop"]
  }, YD(Cne));
};
function Dne(e) {
  return typeof e == "function" ? e() : e;
}
function Nne(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const Ine = new $ne(), pN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o;
  const {
    children: a,
    closeAfterTransition: i = !1,
    component: l,
    container: c,
    disableAutoFocus: u = !1,
    disableEnforceFocus: d = !1,
    disableEscapeKeyDown: f = !1,
    disablePortal: p = !1,
    disableRestoreFocus: m = !1,
    disableScrollLock: y = !1,
    hideBackdrop: h = !1,
    keepMounted: v = !1,
    // private
    manager: g = Ine,
    onBackdropClick: b,
    onClose: x,
    onKeyDown: O,
    open: w,
    onTransitionEnter: S,
    onTransitionExited: E,
    slotProps: C = {},
    slots: N = {}
  } = t, $ = ge(t, kne), [j, A] = P.useState(!w), k = P.useRef({}), R = P.useRef(null), D = P.useRef(null), L = Lt(D, r), B = Nne(a), H = (n = t["aria-hidden"]) != null ? n : !0, U = () => nr(R.current), I = () => (k.current.modalRef = D.current, k.current.mountNode = R.current, k.current), V = () => {
    g.mount(I(), {
      disableScrollLock: y
    }), D.current && (D.current.scrollTop = 0);
  }, G = $t(() => {
    const W = Dne(c) || U().body;
    g.add(I(), W), D.current && V();
  }), q = P.useCallback(() => g.isTopModal(I()), [g]), J = $t((W) => {
    R.current = W, !(!W || !D.current) && (w && q() ? V() : qs(D.current, H));
  }), ne = P.useCallback(() => {
    g.remove(I(), H);
  }, [g, H]);
  P.useEffect(() => () => {
    ne();
  }, [ne]), P.useEffect(() => {
    w ? G() : (!B || !i) && ne();
  }, [w, ne, B, i, G]);
  const te = T({}, t, {
    closeAfterTransition: i,
    disableAutoFocus: u,
    disableEnforceFocus: d,
    disableEscapeKeyDown: f,
    disablePortal: p,
    disableRestoreFocus: m,
    disableScrollLock: y,
    exited: j,
    hideBackdrop: h,
    keepMounted: v
  }), ee = Rne(te), K = () => {
    A(!1), S && S();
  }, Q = () => {
    A(!0), E && E(), i && ne();
  }, ae = (W) => {
    W.target === W.currentTarget && (b && b(W), x && x(W, "backdropClick"));
  }, ie = (W) => {
    O && O(W), !(W.key !== "Escape" || !q()) && (f || (W.stopPropagation(), x && x(W, "escapeKeyDown")));
  }, oe = {};
  a.props.tabIndex === void 0 && (oe.tabIndex = "-1"), B && (oe.onEnter = A0(K, a.props.onEnter), oe.onExited = A0(Q, a.props.onExited));
  const se = (o = l ?? N.root) != null ? o : "div", re = It({
    elementType: se,
    externalSlotProps: C.root,
    externalForwardedProps: $,
    additionalProps: {
      ref: L,
      role: "presentation",
      onKeyDown: ie
    },
    className: ee.root,
    ownerState: te
  }), le = N.backdrop, M = It({
    elementType: le,
    externalSlotProps: C.backdrop,
    additionalProps: {
      "aria-hidden": !0,
      onClick: ae,
      open: w
    },
    className: ee.backdrop,
    ownerState: te
  });
  return !v && !w && (!B || j) ? null : /* @__PURE__ */ _.jsx(
    dN,
    {
      ref: J,
      container: c,
      disablePortal: p,
      children: /* @__PURE__ */ _.jsxs(se, T({}, re, {
        children: [!h && le ? /* @__PURE__ */ _.jsx(le, T({}, M)) : null, /* @__PURE__ */ _.jsx(sl, {
          disableEnforceFocus: d,
          disableAutoFocus: u,
          disableRestoreFocus: m,
          isEnabled: q,
          open: w,
          children: /* @__PURE__ */ P.cloneElement(a, oe)
        })]
      }))
    }
  );
});
process.env.NODE_ENV !== "production" && (pN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: yl.isRequired,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: s.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: s.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: s.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: s.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: s.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: s.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: s.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: s.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: s.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: s.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: s.func,
  /**
   * @ignore
   */
  onKeyDown: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: s.shape({
    backdrop: s.oneOfType([s.func, s.object]),
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: s.shape({
    backdrop: s.elementType,
    root: s.elementType
  })
});
const Mne = pN, Ane = ["onChange", "maxRows", "minRows", "style", "value"];
function ic(e) {
  return parseInt(e, 10) || 0;
}
const jne = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function US(e) {
  return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflow;
}
const mN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    onChange: n,
    maxRows: o,
    minRows: a = 1,
    style: i,
    value: l
  } = t, c = ge(t, Ane), {
    current: u
  } = P.useRef(l != null), d = P.useRef(null), f = Lt(r, d), p = P.useRef(null), m = P.useRef(0), [y, h] = P.useState({
    outerHeightStyle: 0
  }), v = P.useCallback(() => {
    const w = d.current, E = ho(w).getComputedStyle(w);
    if (E.width === "0px")
      return {
        outerHeightStyle: 0
      };
    const C = p.current;
    C.style.width = E.width, C.value = w.value || t.placeholder || "x", C.value.slice(-1) === `
` && (C.value += " ");
    const N = E.boxSizing, $ = ic(E.paddingBottom) + ic(E.paddingTop), j = ic(E.borderBottomWidth) + ic(E.borderTopWidth), A = C.scrollHeight;
    C.value = "x";
    const k = C.scrollHeight;
    let R = A;
    a && (R = Math.max(Number(a) * k, R)), o && (R = Math.min(Number(o) * k, R)), R = Math.max(R, k);
    const D = R + (N === "border-box" ? $ + j : 0), L = Math.abs(R - A) <= 1;
    return {
      outerHeightStyle: D,
      overflow: L
    };
  }, [o, a, t.placeholder]), g = (w, S) => {
    const {
      outerHeightStyle: E,
      overflow: C
    } = S;
    return m.current < 20 && (E > 0 && Math.abs((w.outerHeightStyle || 0) - E) > 1 || w.overflow !== C) ? (m.current += 1, {
      overflow: C,
      outerHeightStyle: E
    }) : (process.env.NODE_ENV !== "production" && m.current === 20 && console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join(`
`)), w);
  }, b = P.useCallback(() => {
    const w = v();
    US(w) || h((S) => g(S, w));
  }, [v]), x = () => {
    const w = v();
    US(w) || rg.flushSync(() => {
      h((S) => g(S, w));
    });
  };
  P.useEffect(() => {
    const w = ki(() => {
      m.current = 0, d.current && x();
    });
    let S;
    const E = d.current, C = ho(E);
    return C.addEventListener("resize", w), typeof ResizeObserver < "u" && (S = new ResizeObserver(w), S.observe(E)), () => {
      w.clear(), C.removeEventListener("resize", w), S && S.disconnect();
    };
  }), wr(() => {
    b();
  }), P.useEffect(() => {
    m.current = 0;
  }, [l]);
  const O = (w) => {
    m.current = 0, u || b(), n && n(w);
  };
  return /* @__PURE__ */ _.jsxs(P.Fragment, {
    children: [/* @__PURE__ */ _.jsx("textarea", T({
      value: l,
      onChange: O,
      ref: f,
      rows: a,
      style: T({
        height: y.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: y.overflow ? "hidden" : void 0
      }, i)
    }, c)), /* @__PURE__ */ _.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: p,
      tabIndex: -1,
      style: T({}, jne.shadow, i, {
        padding: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (mN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  className: s.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * @ignore
   */
  onChange: s.func,
  /**
   * @ignore
   */
  placeholder: s.string,
  /**
   * @ignore
   */
  style: s.object,
  /**
   * @ignore
   */
  value: s.oneOfType([s.arrayOf(s.string), s.number, s.string])
});
const Fne = mN;
function Lne(e) {
  return ze("MuiTypography", e);
}
Le("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const Vne = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"], zne = (e) => {
  const {
    align: t,
    gutterBottom: r,
    noWrap: n,
    paragraph: o,
    variant: a,
    classes: i
  } = e, l = {
    root: ["root", a, e.align !== "inherit" && `align${Te(t)}`, r && "gutterBottom", n && "noWrap", o && "paragraph"]
  };
  return Ve(l, Lne, i);
}, Bne = ce("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.variant && t[r.variant], r.align !== "inherit" && t[`align${Te(r.align)}`], r.noWrap && t.noWrap, r.gutterBottom && t.gutterBottom, r.paragraph && t.paragraph];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  margin: 0
}, t.variant && e.typography[t.variant], t.align !== "inherit" && {
  textAlign: t.align
}, t.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, t.gutterBottom && {
  marginBottom: "0.35em"
}, t.paragraph && {
  marginBottom: 16
})), HS = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Wne = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
}, Une = (e) => Wne[e] || e, hN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTypography"
  }), o = Une(n.color), a = hE(T({}, n, {
    color: o
  })), {
    align: i = "inherit",
    className: l,
    component: c,
    gutterBottom: u = !1,
    noWrap: d = !1,
    paragraph: f = !1,
    variant: p = "body1",
    variantMapping: m = HS
  } = a, y = ge(a, Vne), h = T({}, a, {
    align: i,
    color: o,
    className: l,
    component: c,
    gutterBottom: u,
    noWrap: d,
    paragraph: f,
    variant: p,
    variantMapping: m
  }), v = c || (f ? "p" : m[p] || HS[p]) || "span", g = zne(h);
  return /* @__PURE__ */ _.jsx(Bne, T({
    as: v,
    ref: r,
    ownerState: h,
    className: Pe(g.root, l)
  }, y));
});
process.env.NODE_ENV !== "production" && (hN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: s.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: s.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: s.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   */
  paragraph: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: s.oneOfType([s.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), s.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: s.object
});
const Zn = hN, yN = /* @__PURE__ */ P.createContext();
process.env.NODE_ENV !== "production" && (yN.displayName = "GridContext");
const YS = yN;
function Hne(e) {
  return ze("MuiGrid", e);
}
const Yne = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], qne = ["column-reverse", "column", "row-reverse", "row"], Gne = ["nowrap", "wrap-reverse", "wrap"], Ps = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], Kne = Le("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...Yne.map((e) => `spacing-xs-${e}`),
  // direction values
  ...qne.map((e) => `direction-xs-${e}`),
  // wrap values
  ...Gne.map((e) => `wrap-xs-${e}`),
  // grid sizes for all breakpoints
  ...Ps.map((e) => `grid-xs-${e}`),
  ...Ps.map((e) => `grid-sm-${e}`),
  ...Ps.map((e) => `grid-md-${e}`),
  ...Ps.map((e) => `grid-lg-${e}`),
  ...Ps.map((e) => `grid-xl-${e}`)
]), ul = Kne, Xne = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function Ti(e) {
  const t = parseFloat(e);
  return `${t}${String(e).replace(String(t), "") || "px"}`;
}
function Qne({
  theme: e,
  ownerState: t
}) {
  let r;
  return e.breakpoints.keys.reduce((n, o) => {
    let a = {};
    if (t[o] && (r = t[o]), !r)
      return n;
    if (r === !0)
      a = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    else if (r === "auto")
      a = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    else {
      const i = cp({
        values: t.columns,
        breakpoints: e.breakpoints.values
      }), l = typeof i == "object" ? i[o] : i;
      if (l == null)
        return n;
      const c = `${Math.round(r / l * 1e8) / 1e6}%`;
      let u = {};
      if (t.container && t.item && t.columnSpacing !== 0) {
        const d = e.spacing(t.columnSpacing);
        if (d !== "0px") {
          const f = `calc(${c} + ${Ti(d)})`;
          u = {
            flexBasis: f,
            maxWidth: f
          };
        }
      }
      a = T({
        flexBasis: c,
        flexGrow: 0,
        maxWidth: c
      }, u);
    }
    return e.breakpoints.values[o] === 0 ? Object.assign(n, a) : n[e.breakpoints.up(o)] = a, n;
  }, {});
}
function Zne({
  theme: e,
  ownerState: t
}) {
  const r = cp({
    values: t.direction,
    breakpoints: e.breakpoints.values
  });
  return pn({
    theme: e
  }, r, (n) => {
    const o = {
      flexDirection: n
    };
    return n.indexOf("column") === 0 && (o[`& > .${ul.item}`] = {
      maxWidth: "none"
    }), o;
  });
}
function vN({
  breakpoints: e,
  values: t
}) {
  let r = "";
  Object.keys(t).forEach((o) => {
    r === "" && t[o] !== 0 && (r = o);
  });
  const n = Object.keys(e).sort((o, a) => e[o] - e[a]);
  return n.slice(0, n.indexOf(r));
}
function Jne({
  theme: e,
  ownerState: t
}) {
  const {
    container: r,
    rowSpacing: n
  } = t;
  let o = {};
  if (r && n !== 0) {
    const a = cp({
      values: n,
      breakpoints: e.breakpoints.values
    });
    let i;
    typeof a == "object" && (i = vN({
      breakpoints: e.breakpoints.values,
      values: a
    })), o = pn({
      theme: e
    }, a, (l, c) => {
      var u;
      const d = e.spacing(l);
      return d !== "0px" ? {
        marginTop: `-${Ti(d)}`,
        [`& > .${ul.item}`]: {
          paddingTop: Ti(d)
        }
      } : (u = i) != null && u.includes(c) ? {} : {
        marginTop: 0,
        [`& > .${ul.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return o;
}
function eoe({
  theme: e,
  ownerState: t
}) {
  const {
    container: r,
    columnSpacing: n
  } = t;
  let o = {};
  if (r && n !== 0) {
    const a = cp({
      values: n,
      breakpoints: e.breakpoints.values
    });
    let i;
    typeof a == "object" && (i = vN({
      breakpoints: e.breakpoints.values,
      values: a
    })), o = pn({
      theme: e
    }, a, (l, c) => {
      var u;
      const d = e.spacing(l);
      return d !== "0px" ? {
        width: `calc(100% + ${Ti(d)})`,
        marginLeft: `-${Ti(d)}`,
        [`& > .${ul.item}`]: {
          paddingLeft: Ti(d)
        }
      } : (u = i) != null && u.includes(c) ? {} : {
        width: "100%",
        marginLeft: 0,
        [`& > .${ul.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return o;
}
function toe(e, t, r = {}) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [r[`spacing-xs-${String(e)}`]];
  const n = [];
  return t.forEach((o) => {
    const a = e[o];
    Number(a) > 0 && n.push(r[`spacing-${o}-${String(a)}`]);
  }), n;
}
const roe = ce("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e, {
      container: n,
      direction: o,
      item: a,
      spacing: i,
      wrap: l,
      zeroMinWidth: c,
      breakpoints: u
    } = r;
    let d = [];
    n && (d = toe(i, u, t));
    const f = [];
    return u.forEach((p) => {
      const m = r[p];
      m && f.push(t[`grid-${p}-${String(m)}`]);
    }), [t.root, n && t.container, a && t.item, c && t.zeroMinWidth, ...d, o !== "row" && t[`direction-xs-${String(o)}`], l !== "wrap" && t[`wrap-xs-${String(l)}`], ...f];
  }
})(({
  ownerState: e
}) => T({
  boxSizing: "border-box"
}, e.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, e.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, e.zeroMinWidth && {
  minWidth: 0
}, e.wrap !== "wrap" && {
  flexWrap: e.wrap
}), Zne, Jne, eoe, Qne);
function noe(e, t) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [`spacing-xs-${String(e)}`];
  const r = [];
  return t.forEach((n) => {
    const o = e[n];
    if (Number(o) > 0) {
      const a = `spacing-${n}-${String(o)}`;
      r.push(a);
    }
  }), r;
}
const ooe = (e) => {
  const {
    classes: t,
    container: r,
    direction: n,
    item: o,
    spacing: a,
    wrap: i,
    zeroMinWidth: l,
    breakpoints: c
  } = e;
  let u = [];
  r && (u = noe(a, c));
  const d = [];
  c.forEach((p) => {
    const m = e[p];
    m && d.push(`grid-${p}-${String(m)}`);
  });
  const f = {
    root: ["root", r && "container", o && "item", l && "zeroMinWidth", ...u, n !== "row" && `direction-xs-${String(n)}`, i !== "wrap" && `wrap-xs-${String(i)}`, ...d]
  };
  return Ve(f, Hne, t);
}, Gs = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiGrid"
  }), {
    breakpoints: o
  } = Nr(), a = hE(n), {
    className: i,
    columns: l,
    columnSpacing: c,
    component: u = "div",
    container: d = !1,
    direction: f = "row",
    item: p = !1,
    rowSpacing: m,
    spacing: y = 0,
    wrap: h = "wrap",
    zeroMinWidth: v = !1
  } = a, g = ge(a, Xne), b = m || y, x = c || y, O = P.useContext(YS), w = d ? l || 12 : O, S = {}, E = T({}, g);
  o.keys.forEach(($) => {
    g[$] != null && (S[$] = g[$], delete E[$]);
  });
  const C = T({}, a, {
    columns: w,
    container: d,
    direction: f,
    item: p,
    rowSpacing: b,
    columnSpacing: x,
    wrap: h,
    zeroMinWidth: v,
    spacing: y
  }, S, {
    breakpoints: o.keys
  }), N = ooe(C);
  return /* @__PURE__ */ _.jsx(YS.Provider, {
    value: w,
    children: /* @__PURE__ */ _.jsx(roe, T({
      ownerState: C,
      className: Pe(N.root, i),
      as: u,
      ref: r
    }, E))
  });
});
process.env.NODE_ENV !== "production" && (Gs.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The number of columns.
   * @default 12
   */
  columns: s.oneOfType([s.arrayOf(s.number), s.number, s.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: s.oneOfType([s.arrayOf(s.oneOfType([s.number, s.string])), s.number, s.object, s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: s.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: s.oneOfType([s.oneOf(["column-reverse", "column", "row-reverse", "row"]), s.arrayOf(s.oneOf(["column-reverse", "column", "row-reverse", "row"])), s.object]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: s.bool,
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: s.oneOfType([s.oneOf(["auto"]), s.number, s.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: s.oneOfType([s.oneOf(["auto"]), s.number, s.bool]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: s.oneOfType([s.arrayOf(s.oneOfType([s.number, s.string])), s.number, s.object, s.string]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: s.oneOfType([s.oneOf(["auto"]), s.number, s.bool]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: s.oneOfType([s.arrayOf(s.oneOfType([s.number, s.string])), s.number, s.object, s.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: s.oneOf(["nowrap", "wrap-reverse", "wrap"]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: s.oneOfType([s.oneOf(["auto"]), s.number, s.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: s.oneOfType([s.oneOf(["auto"]), s.number, s.bool]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: s.bool
});
if (process.env.NODE_ENV !== "production") {
  const e = fA("Grid", Gs);
  Gs["propTypes"] = T({}, Gs.propTypes, {
    direction: e("container"),
    lg: e("item"),
    md: e("item"),
    sm: e("item"),
    spacing: e("container"),
    wrap: e("container"),
    xs: e("item"),
    zeroMinWidth: e("item")
  });
}
const aoe = Gs;
function gN(e) {
  return ze("MuiPickersToolbar", e);
}
const ioe = Le("MuiPickersToolbar", ["root", "content", "penIconButton", "penIconButtonLandscape"]), soe = (e) => {
  const {
    classes: t,
    isLandscape: r
  } = e;
  return Ve({
    root: ["root"],
    content: ["content"],
    penIconButton: ["penIconButton", r && "penIconButtonLandscape"]
  }, gN, t);
}, loe = ce("div", {
  name: "MuiPickersToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => T({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "space-between",
  padding: e.spacing(2, 3)
}, t.isLandscape && {
  height: "auto",
  maxWidth: 160,
  padding: 16,
  justifyContent: "flex-start",
  flexWrap: "wrap"
})), coe = ce(aoe, {
  name: "MuiPickersToolbar",
  slot: "Content",
  overridesResolver: (e, t) => t.content
})(({
  ownerState: e
}) => T({
  flex: 1
}, !e.isLandscape && {
  alignItems: "center"
})), bN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPickersToolbar"
  }), {
    children: o,
    className: a,
    isLandscape: i,
    landscapeDirection: l = "column",
    toolbarTitle: c,
    hidden: u,
    titleId: d
  } = n, f = n, p = soe(f);
  return u ? null : /* @__PURE__ */ _.jsxs(loe, {
    ref: r,
    className: Pe(p.root, a),
    ownerState: f,
    children: [/* @__PURE__ */ _.jsx(Zn, {
      color: "text.secondary",
      variant: "overline",
      id: d,
      children: c
    }), /* @__PURE__ */ _.jsx(coe, {
      container: !0,
      justifyContent: i ? "flex-start" : "space-between",
      className: p.content,
      ownerState: f,
      direction: i ? l : "row",
      alignItems: i ? "flex-start" : "flex-end",
      children: o
    })]
  });
});
function uoe(e) {
  return ze("MuiDatePickerToolbar", e);
}
Le("MuiDatePickerToolbar", ["root", "title"]);
const doe = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views"], foe = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    title: ["title"]
  }, uoe, t);
}, poe = ce(bN, {
  name: "MuiDatePickerToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), moe = ce(Zn, {
  name: "MuiDatePickerToolbar",
  slot: "Title",
  overridesResolver: (e, t) => t.title
})(({
  ownerState: e
}) => T({}, e.isLandscape && {
  margin: "auto 16px auto auto"
})), wN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDatePickerToolbar"
  }), {
    value: o,
    isLandscape: a,
    toolbarFormat: i,
    toolbarPlaceholder: l = "â€“â€“",
    views: c
  } = n, u = ge(n, doe), d = wt(), f = Yr(), p = foe(n), m = P.useMemo(() => o ? i ? d.formatByString(o, i) : JD(c) ? d.format(o, "year") : eN(c) ? d.format(o, "month") : /en/.test(d.getCurrentLocaleCode()) ? d.format(o, "normalDateWithWeekday") : d.format(o, "normalDate") : l, [o, i, l, d, c]), y = n;
  return /* @__PURE__ */ _.jsx(poe, T({
    ref: r,
    toolbarTitle: f.datePickerToolbarTitle,
    isLandscape: a,
    className: p.root
  }, u, {
    children: /* @__PURE__ */ _.jsx(moe, {
      variant: "h4",
      align: a ? "left" : "center",
      ownerState: y,
      className: p.title,
      children: m
    })
  }));
});
process.env.NODE_ENV !== "production" && (wN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  classes: s.object,
  /**
   * className applied to the root component.
   */
  className: s.string,
  disabled: s.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: s.bool,
  isLandscape: s.bool.isRequired,
  onChange: s.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: s.func.isRequired,
  readOnly: s.bool,
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  titleId: s.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: s.string,
  /**
   * Toolbar value placeholderâ€”it is displayed when the value is empty.
   * @default "â€“â€“"
   */
  toolbarPlaceholder: s.node,
  value: s.any,
  /**
   * Currently visible picker view.
   */
  view: s.oneOf(["day", "month", "year"]).isRequired,
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired).isRequired
});
const Gp = (e) => {
  if (e !== void 0)
    return Object.keys(e).reduce((t, r) => T({}, t, {
      [`${r.slice(0, 1).toLowerCase()}${r.slice(1)}`]: e[r]
    }), {});
}, xN = (e, {
  format: t,
  views: r
}) => {
  if (t != null)
    return t;
  if (JD(r))
    return e.formats.year;
  if (eN(r))
    return e.formats.monthAndYear;
};
function _N(e, t) {
  var r, n, o, a;
  const i = wt(), l = Ya(), c = Ae({
    props: e,
    name: t
  }), u = P.useMemo(() => {
    var f;
    return ((f = c.localeText) == null ? void 0 : f.toolbarTitle) == null ? c.localeText : T({}, c.localeText, {
      datePickerToolbarTitle: c.localeText.toolbarTitle
    });
  }, [c.localeText]), d = (r = c.slots) != null ? r : Gp(c.components);
  return T({}, c, {
    localeText: u
  }, tN({
    views: c.views,
    openTo: c.openTo,
    defaultViews: ["year", "day"],
    defaultOpenTo: "day"
  }), {
    disableFuture: (n = c.disableFuture) != null ? n : !1,
    disablePast: (o = c.disablePast) != null ? o : !1,
    minDate: vr(i, c.minDate, l.minDate),
    maxDate: vr(i, c.maxDate, l.maxDate),
    slots: T({
      toolbar: wN
    }, d),
    slotProps: (a = c.slotProps) != null ? a : c.componentsProps
  });
}
function Rv(e, t) {
  return Rv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, o) {
    return n.__proto__ = o, n;
  }, Rv(e, t);
}
function Eb(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Rv(e, t);
}
function hoe(e, t) {
  return e.classList ? !!t && e.classList.contains(t) : (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") !== -1;
}
function yoe(e, t) {
  e.classList ? e.classList.add(t) : hoe(e, t) || (typeof e.className == "string" ? e.className = e.className + " " + t : e.setAttribute("class", (e.className && e.className.baseVal || "") + " " + t));
}
function qS(e, t) {
  return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function voe(e, t) {
  e.classList ? e.classList.remove(t) : typeof e.className == "string" ? e.className = qS(e.className, t) : e.setAttribute("class", qS(e.className && e.className.baseVal || "", t));
}
const GS = {
  disabled: !1
};
var goe = process.env.NODE_ENV !== "production" ? s.oneOfType([s.number, s.shape({
  enter: s.number,
  exit: s.number,
  appear: s.number
}).isRequired]) : null, boe = process.env.NODE_ENV !== "production" ? s.oneOfType([s.string, s.shape({
  enter: s.string,
  exit: s.string,
  active: s.string
}), s.shape({
  enter: s.string,
  enterDone: s.string,
  enterActive: s.string,
  exit: s.string,
  exitDone: s.string,
  exitActive: s.string
})]) : null;
const Bf = F.createContext(null);
var ON = function(t) {
  return t.scrollTop;
}, Ns = "unmounted", ma = "exited", ha = "entering", ui = "entered", Dv = "exiting", To = /* @__PURE__ */ function(e) {
  Eb(t, e);
  function t(n, o) {
    var a;
    a = e.call(this, n, o) || this;
    var i = o, l = i && !i.isMounting ? n.enter : n.appear, c;
    return a.appearStatus = null, n.in ? l ? (c = ma, a.appearStatus = ha) : c = ui : n.unmountOnExit || n.mountOnEnter ? c = Ns : c = ma, a.state = {
      status: c
    }, a.nextCallback = null, a;
  }
  t.getDerivedStateFromProps = function(o, a) {
    var i = o.in;
    return i && a.status === Ns ? {
      status: ma
    } : null;
  };
  var r = t.prototype;
  return r.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, r.componentDidUpdate = function(o) {
    var a = null;
    if (o !== this.props) {
      var i = this.state.status;
      this.props.in ? i !== ha && i !== ui && (a = ha) : (i === ha || i === ui) && (a = Dv);
    }
    this.updateStatus(!1, a);
  }, r.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, r.getTimeouts = function() {
    var o = this.props.timeout, a, i, l;
    return a = i = l = o, o != null && typeof o != "number" && (a = o.exit, i = o.enter, l = o.appear !== void 0 ? o.appear : i), {
      exit: a,
      enter: i,
      appear: l
    };
  }, r.updateStatus = function(o, a) {
    if (o === void 0 && (o = !1), a !== null)
      if (this.cancelNextCallback(), a === ha) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var i = this.props.nodeRef ? this.props.nodeRef.current : zl.findDOMNode(this);
          i && ON(i);
        }
        this.performEnter(o);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === ma && this.setState({
        status: Ns
      });
  }, r.performEnter = function(o) {
    var a = this, i = this.props.enter, l = this.context ? this.context.isMounting : o, c = this.props.nodeRef ? [l] : [zl.findDOMNode(this), l], u = c[0], d = c[1], f = this.getTimeouts(), p = l ? f.appear : f.enter;
    if (!o && !i || GS.disabled) {
      this.safeSetState({
        status: ui
      }, function() {
        a.props.onEntered(u);
      });
      return;
    }
    this.props.onEnter(u, d), this.safeSetState({
      status: ha
    }, function() {
      a.props.onEntering(u, d), a.onTransitionEnd(p, function() {
        a.safeSetState({
          status: ui
        }, function() {
          a.props.onEntered(u, d);
        });
      });
    });
  }, r.performExit = function() {
    var o = this, a = this.props.exit, i = this.getTimeouts(), l = this.props.nodeRef ? void 0 : zl.findDOMNode(this);
    if (!a || GS.disabled) {
      this.safeSetState({
        status: ma
      }, function() {
        o.props.onExited(l);
      });
      return;
    }
    this.props.onExit(l), this.safeSetState({
      status: Dv
    }, function() {
      o.props.onExiting(l), o.onTransitionEnd(i.exit, function() {
        o.safeSetState({
          status: ma
        }, function() {
          o.props.onExited(l);
        });
      });
    });
  }, r.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, r.safeSetState = function(o, a) {
    a = this.setNextCallback(a), this.setState(o, a);
  }, r.setNextCallback = function(o) {
    var a = this, i = !0;
    return this.nextCallback = function(l) {
      i && (i = !1, a.nextCallback = null, o(l));
    }, this.nextCallback.cancel = function() {
      i = !1;
    }, this.nextCallback;
  }, r.onTransitionEnd = function(o, a) {
    this.setNextCallback(a);
    var i = this.props.nodeRef ? this.props.nodeRef.current : zl.findDOMNode(this), l = o == null && !this.props.addEndListener;
    if (!i || l) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var c = this.props.nodeRef ? [this.nextCallback] : [i, this.nextCallback], u = c[0], d = c[1];
      this.props.addEndListener(u, d);
    }
    o != null && setTimeout(this.nextCallback, o);
  }, r.render = function() {
    var o = this.state.status;
    if (o === Ns)
      return null;
    var a = this.props, i = a.children;
    a.in, a.mountOnEnter, a.unmountOnExit, a.appear, a.enter, a.exit, a.timeout, a.addEndListener, a.onEnter, a.onEntering, a.onEntered, a.onExit, a.onExiting, a.onExited, a.nodeRef;
    var l = ge(a, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ F.createElement(Bf.Provider, {
        value: null
      }, typeof i == "function" ? i(o, l) : F.cloneElement(F.Children.only(i), l))
    );
  }, t;
}(F.Component);
To.contextType = Bf;
To.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: s.shape({
    current: typeof Element > "u" ? s.any : function(e, t, r, n, o, a) {
      var i = e[t];
      return s.instanceOf(i && "ownerDocument" in i ? i.ownerDocument.defaultView.Element : Element)(e, t, r, n, o, a);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: s.oneOfType([s.func.isRequired, s.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: s.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: s.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: s.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: s.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: s.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: s.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function(t) {
    var r = goe;
    t.addEndListener || (r = r.isRequired);
    for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
      o[a - 1] = arguments[a];
    return r.apply(void 0, [t].concat(o));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: s.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: s.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: s.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: s.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: s.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: s.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: s.func
} : {};
function ai() {
}
To.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: ai,
  onEntering: ai,
  onEntered: ai,
  onExit: ai,
  onExiting: ai,
  onExited: ai
};
To.UNMOUNTED = Ns;
To.EXITED = ma;
To.ENTERING = ha;
To.ENTERED = ui;
To.EXITING = Dv;
const Kp = To;
var woe = function(t, r) {
  return t && r && r.split(" ").forEach(function(n) {
    return yoe(t, n);
  });
}, uh = function(t, r) {
  return t && r && r.split(" ").forEach(function(n) {
    return voe(t, n);
  });
}, $b = /* @__PURE__ */ function(e) {
  Eb(t, e);
  function t() {
    for (var n, o = arguments.length, a = new Array(o), i = 0; i < o; i++)
      a[i] = arguments[i];
    return n = e.call.apply(e, [this].concat(a)) || this, n.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, n.onEnter = function(l, c) {
      var u = n.resolveArguments(l, c), d = u[0], f = u[1];
      n.removeClasses(d, "exit"), n.addClass(d, f ? "appear" : "enter", "base"), n.props.onEnter && n.props.onEnter(l, c);
    }, n.onEntering = function(l, c) {
      var u = n.resolveArguments(l, c), d = u[0], f = u[1], p = f ? "appear" : "enter";
      n.addClass(d, p, "active"), n.props.onEntering && n.props.onEntering(l, c);
    }, n.onEntered = function(l, c) {
      var u = n.resolveArguments(l, c), d = u[0], f = u[1], p = f ? "appear" : "enter";
      n.removeClasses(d, p), n.addClass(d, p, "done"), n.props.onEntered && n.props.onEntered(l, c);
    }, n.onExit = function(l) {
      var c = n.resolveArguments(l), u = c[0];
      n.removeClasses(u, "appear"), n.removeClasses(u, "enter"), n.addClass(u, "exit", "base"), n.props.onExit && n.props.onExit(l);
    }, n.onExiting = function(l) {
      var c = n.resolveArguments(l), u = c[0];
      n.addClass(u, "exit", "active"), n.props.onExiting && n.props.onExiting(l);
    }, n.onExited = function(l) {
      var c = n.resolveArguments(l), u = c[0];
      n.removeClasses(u, "exit"), n.addClass(u, "exit", "done"), n.props.onExited && n.props.onExited(l);
    }, n.resolveArguments = function(l, c) {
      return n.props.nodeRef ? [n.props.nodeRef.current, l] : [l, c];
    }, n.getClassNames = function(l) {
      var c = n.props.classNames, u = typeof c == "string", d = u && c ? c + "-" : "", f = u ? "" + d + l : c[l], p = u ? f + "-active" : c[l + "Active"], m = u ? f + "-done" : c[l + "Done"];
      return {
        baseClassName: f,
        activeClassName: p,
        doneClassName: m
      };
    }, n;
  }
  var r = t.prototype;
  return r.addClass = function(o, a, i) {
    var l = this.getClassNames(a)[i + "ClassName"], c = this.getClassNames("enter"), u = c.doneClassName;
    a === "appear" && i === "done" && u && (l += " " + u), i === "active" && o && ON(o), l && (this.appliedClasses[a][i] = l, woe(o, l));
  }, r.removeClasses = function(o, a) {
    var i = this.appliedClasses[a], l = i.base, c = i.active, u = i.done;
    this.appliedClasses[a] = {}, l && uh(o, l), c && uh(o, c), u && uh(o, u);
  }, r.render = function() {
    var o = this.props;
    o.classNames;
    var a = ge(o, ["classNames"]);
    return /* @__PURE__ */ F.createElement(Kp, T({}, a, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, t;
}(F.Component);
$b.defaultProps = {
  classNames: ""
};
$b.propTypes = process.env.NODE_ENV !== "production" ? T({}, Kp.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: boe,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: s.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: s.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: s.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: s.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: s.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: s.func
}) : {};
const xoe = $b;
function _oe(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Cb(e, t) {
  var r = function(a) {
    return t && Wo(a) ? t(a) : a;
  }, n = /* @__PURE__ */ Object.create(null);
  return e && Bo.map(e, function(o) {
    return o;
  }).forEach(function(o) {
    n[o.key] = r(o);
  }), n;
}
function Ooe(e, t) {
  e = e || {}, t = t || {};
  function r(d) {
    return d in t ? t[d] : e[d];
  }
  var n = /* @__PURE__ */ Object.create(null), o = [];
  for (var a in e)
    a in t ? o.length && (n[a] = o, o = []) : o.push(a);
  var i, l = {};
  for (var c in t) {
    if (n[c])
      for (i = 0; i < n[c].length; i++) {
        var u = n[c][i];
        l[n[c][i]] = r(u);
      }
    l[c] = r(c);
  }
  for (i = 0; i < o.length; i++)
    l[o[i]] = r(o[i]);
  return l;
}
function xa(e, t, r) {
  return r[t] != null ? r[t] : e.props[t];
}
function Poe(e, t) {
  return Cb(e.children, function(r) {
    return on(r, {
      onExited: t.bind(null, r),
      in: !0,
      appear: xa(r, "appear", e),
      enter: xa(r, "enter", e),
      exit: xa(r, "exit", e)
    });
  });
}
function Soe(e, t, r) {
  var n = Cb(e.children), o = Ooe(t, n);
  return Object.keys(o).forEach(function(a) {
    var i = o[a];
    if (Wo(i)) {
      var l = a in t, c = a in n, u = t[a], d = Wo(u) && !u.props.in;
      c && (!l || d) ? o[a] = on(i, {
        onExited: r.bind(null, i),
        in: !0,
        exit: xa(i, "exit", e),
        enter: xa(i, "enter", e)
      }) : !c && l && !d ? o[a] = on(i, {
        in: !1
      }) : c && l && Wo(u) && (o[a] = on(i, {
        onExited: r.bind(null, i),
        in: u.props.in,
        exit: xa(i, "exit", e),
        enter: xa(i, "enter", e)
      }));
    }
  }), o;
}
var Toe = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, Eoe = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, kb = /* @__PURE__ */ function(e) {
  Eb(t, e);
  function t(n, o) {
    var a;
    a = e.call(this, n, o) || this;
    var i = a.handleExited.bind(_oe(a));
    return a.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: i,
      firstRender: !0
    }, a;
  }
  var r = t.prototype;
  return r.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, r.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(o, a) {
    var i = a.children, l = a.handleExited, c = a.firstRender;
    return {
      children: c ? Poe(o, l) : Soe(o, i, l),
      firstRender: !1
    };
  }, r.handleExited = function(o, a) {
    var i = Cb(this.props.children);
    o.key in i || (o.props.onExited && o.props.onExited(a), this.mounted && this.setState(function(l) {
      var c = T({}, l.children);
      return delete c[o.key], {
        children: c
      };
    }));
  }, r.render = function() {
    var o = this.props, a = o.component, i = o.childFactory, l = ge(o, ["component", "childFactory"]), c = this.state.contextValue, u = Toe(this.state.children).map(i);
    return delete l.appear, delete l.enter, delete l.exit, a === null ? /* @__PURE__ */ F.createElement(Bf.Provider, {
      value: c
    }, u) : /* @__PURE__ */ F.createElement(Bf.Provider, {
      value: c
    }, /* @__PURE__ */ F.createElement(a, l, u));
  }, t;
}(F.Component);
kb.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: s.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: s.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: s.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: s.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: s.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: s.func
} : {};
kb.defaultProps = Eoe;
const Rb = kb;
function PN(e) {
  const {
    className: t,
    classes: r,
    pulsate: n = !1,
    rippleX: o,
    rippleY: a,
    rippleSize: i,
    in: l,
    onExited: c,
    timeout: u
  } = e, [d, f] = P.useState(!1), p = Pe(t, r.ripple, r.rippleVisible, n && r.ripplePulsate), m = {
    width: i,
    height: i,
    top: -(i / 2) + a,
    left: -(i / 2) + o
  }, y = Pe(r.child, d && r.childLeaving, n && r.childPulsate);
  return !l && !d && f(!0), P.useEffect(() => {
    if (!l && c != null) {
      const h = setTimeout(c, u);
      return () => {
        clearTimeout(h);
      };
    }
  }, [c, l, u]), /* @__PURE__ */ _.jsx("span", {
    className: p,
    style: m,
    children: /* @__PURE__ */ _.jsx("span", {
      className: y
    })
  });
}
process.env.NODE_ENV !== "production" && (PN.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: s.object.isRequired,
  className: s.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: s.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: s.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: s.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: s.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: s.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: s.number,
  /**
   * exit delay
   */
  timeout: s.number.isRequired
});
const $oe = Le("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Qr = $oe, Coe = ["center", "classes", "className"];
let Xp = (e) => e, KS, XS, QS, ZS;
const Nv = 550, koe = 80, Roe = _o(KS || (KS = Xp`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), Doe = _o(XS || (XS = Xp`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), Noe = _o(QS || (QS = Xp`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), Ioe = ce("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), Moe = ce(PN, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(ZS || (ZS = Xp`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Qr.rippleVisible, Roe, Nv, ({
  theme: e
}) => e.transitions.easing.easeInOut, Qr.ripplePulsate, ({
  theme: e
}) => e.transitions.duration.shorter, Qr.child, Qr.childLeaving, Doe, Nv, ({
  theme: e
}) => e.transitions.easing.easeInOut, Qr.childPulsate, Noe, ({
  theme: e
}) => e.transitions.easing.easeInOut), SN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: o = !1,
    classes: a = {},
    className: i
  } = n, l = ge(n, Coe), [c, u] = P.useState([]), d = P.useRef(0), f = P.useRef(null);
  P.useEffect(() => {
    f.current && (f.current(), f.current = null);
  }, [c]);
  const p = P.useRef(!1), m = P.useRef(null), y = P.useRef(null), h = P.useRef(null);
  P.useEffect(() => () => {
    clearTimeout(m.current);
  }, []);
  const v = P.useCallback((O) => {
    const {
      pulsate: w,
      rippleX: S,
      rippleY: E,
      rippleSize: C,
      cb: N
    } = O;
    u(($) => [...$, /* @__PURE__ */ _.jsx(Moe, {
      classes: {
        ripple: Pe(a.ripple, Qr.ripple),
        rippleVisible: Pe(a.rippleVisible, Qr.rippleVisible),
        ripplePulsate: Pe(a.ripplePulsate, Qr.ripplePulsate),
        child: Pe(a.child, Qr.child),
        childLeaving: Pe(a.childLeaving, Qr.childLeaving),
        childPulsate: Pe(a.childPulsate, Qr.childPulsate)
      },
      timeout: Nv,
      pulsate: w,
      rippleX: S,
      rippleY: E,
      rippleSize: C
    }, d.current)]), d.current += 1, f.current = N;
  }, [a]), g = P.useCallback((O = {}, w = {}, S = () => {
  }) => {
    const {
      pulsate: E = !1,
      center: C = o || w.pulsate,
      fakeElement: N = !1
      // For test purposes
    } = w;
    if ((O == null ? void 0 : O.type) === "mousedown" && p.current) {
      p.current = !1;
      return;
    }
    (O == null ? void 0 : O.type) === "touchstart" && (p.current = !0);
    const $ = N ? null : h.current, j = $ ? $.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let A, k, R;
    if (C || O === void 0 || O.clientX === 0 && O.clientY === 0 || !O.clientX && !O.touches)
      A = Math.round(j.width / 2), k = Math.round(j.height / 2);
    else {
      const {
        clientX: D,
        clientY: L
      } = O.touches && O.touches.length > 0 ? O.touches[0] : O;
      A = Math.round(D - j.left), k = Math.round(L - j.top);
    }
    if (C)
      R = Math.sqrt((2 * j.width ** 2 + j.height ** 2) / 3), R % 2 === 0 && (R += 1);
    else {
      const D = Math.max(Math.abs(($ ? $.clientWidth : 0) - A), A) * 2 + 2, L = Math.max(Math.abs(($ ? $.clientHeight : 0) - k), k) * 2 + 2;
      R = Math.sqrt(D ** 2 + L ** 2);
    }
    O != null && O.touches ? y.current === null && (y.current = () => {
      v({
        pulsate: E,
        rippleX: A,
        rippleY: k,
        rippleSize: R,
        cb: S
      });
    }, m.current = setTimeout(() => {
      y.current && (y.current(), y.current = null);
    }, koe)) : v({
      pulsate: E,
      rippleX: A,
      rippleY: k,
      rippleSize: R,
      cb: S
    });
  }, [o, v]), b = P.useCallback(() => {
    g({}, {
      pulsate: !0
    });
  }, [g]), x = P.useCallback((O, w) => {
    if (clearTimeout(m.current), (O == null ? void 0 : O.type) === "touchend" && y.current) {
      y.current(), y.current = null, m.current = setTimeout(() => {
        x(O, w);
      });
      return;
    }
    y.current = null, u((S) => S.length > 0 ? S.slice(1) : S), f.current = w;
  }, []);
  return P.useImperativeHandle(r, () => ({
    pulsate: b,
    start: g,
    stop: x
  }), [b, g, x]), /* @__PURE__ */ _.jsx(Ioe, T({
    className: Pe(Qr.root, a.root, i),
    ref: h
  }, l, {
    children: /* @__PURE__ */ _.jsx(Rb, {
      component: null,
      exit: !0,
      children: c
    })
  }));
});
process.env.NODE_ENV !== "production" && (SN.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: s.bool,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string
});
const Aoe = SN;
function joe(e) {
  return ze("MuiButtonBase", e);
}
const Foe = Le("MuiButtonBase", ["root", "disabled", "focusVisible"]), Loe = Foe, Voe = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], zoe = (e) => {
  const {
    disabled: t,
    focusVisible: r,
    focusVisibleClassName: n,
    classes: o
  } = e, i = Ve({
    root: ["root", t && "disabled", r && "focusVisible"]
  }, joe, o);
  return r && n && (i.root += ` ${n}`), i;
}, Boe = ce("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${Loe.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), TN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: o,
    centerRipple: a = !1,
    children: i,
    className: l,
    component: c = "button",
    disabled: u = !1,
    disableRipple: d = !1,
    disableTouchRipple: f = !1,
    focusRipple: p = !1,
    LinkComponent: m = "a",
    onBlur: y,
    onClick: h,
    onContextMenu: v,
    onDragLeave: g,
    onFocus: b,
    onFocusVisible: x,
    onKeyDown: O,
    onKeyUp: w,
    onMouseDown: S,
    onMouseLeave: E,
    onMouseUp: C,
    onTouchEnd: N,
    onTouchMove: $,
    onTouchStart: j,
    tabIndex: A = 0,
    TouchRippleProps: k,
    touchRippleRef: R,
    type: D
  } = n, L = ge(n, Voe), B = P.useRef(null), H = P.useRef(null), U = Lt(H, R), {
    isFocusVisibleRef: I,
    onFocus: V,
    onBlur: G,
    ref: q
  } = xA(), [J, ne] = P.useState(!1);
  u && J && ne(!1), P.useImperativeHandle(o, () => ({
    focusVisible: () => {
      ne(!0), B.current.focus();
    }
  }), []);
  const [te, ee] = P.useState(!1);
  P.useEffect(() => {
    ee(!0);
  }, []);
  const K = te && !d && !u;
  P.useEffect(() => {
    J && p && !d && te && H.current.pulsate();
  }, [d, p, J, te]);
  function Q(Ie, it, we = f) {
    return $t((ye) => (it && it(ye), !we && H.current && H.current[Ie](ye), !0));
  }
  const ae = Q("start", S), ie = Q("stop", v), oe = Q("stop", g), se = Q("stop", C), re = Q("stop", (Ie) => {
    J && Ie.preventDefault(), E && E(Ie);
  }), le = Q("start", j), M = Q("stop", N), W = Q("stop", $), Z = Q("stop", (Ie) => {
    G(Ie), I.current === !1 && ne(!1), y && y(Ie);
  }, !1), he = $t((Ie) => {
    B.current || (B.current = Ie.currentTarget), V(Ie), I.current === !0 && (ne(!0), x && x(Ie)), b && b(Ie);
  }), me = () => {
    const Ie = B.current;
    return c && c !== "button" && !(Ie.tagName === "A" && Ie.href);
  }, de = P.useRef(!1), ue = $t((Ie) => {
    p && !de.current && J && H.current && Ie.key === " " && (de.current = !0, H.current.stop(Ie, () => {
      H.current.start(Ie);
    })), Ie.target === Ie.currentTarget && me() && Ie.key === " " && Ie.preventDefault(), O && O(Ie), Ie.target === Ie.currentTarget && me() && Ie.key === "Enter" && !u && (Ie.preventDefault(), h && h(Ie));
  }), Oe = $t((Ie) => {
    p && Ie.key === " " && H.current && J && !Ie.defaultPrevented && (de.current = !1, H.current.stop(Ie, () => {
      H.current.pulsate(Ie);
    })), w && w(Ie), h && Ie.target === Ie.currentTarget && me() && Ie.key === " " && !Ie.defaultPrevented && h(Ie);
  });
  let Se = c;
  Se === "button" && (L.href || L.to) && (Se = m);
  const De = {};
  Se === "button" ? (De.type = D === void 0 ? "button" : D, De.disabled = u) : (!L.href && !L.to && (De.role = "button"), u && (De["aria-disabled"] = u));
  const nt = Lt(r, q, B);
  process.env.NODE_ENV !== "production" && P.useEffect(() => {
    K && !H.current && console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join(`
`));
  }, [K]);
  const rt = T({}, n, {
    centerRipple: a,
    component: c,
    disabled: u,
    disableRipple: d,
    disableTouchRipple: f,
    focusRipple: p,
    tabIndex: A,
    focusVisible: J
  }), Be = zoe(rt);
  return /* @__PURE__ */ _.jsxs(Boe, T({
    as: Se,
    className: Pe(Be.root, l),
    ownerState: rt,
    onBlur: Z,
    onClick: h,
    onContextMenu: ie,
    onFocus: he,
    onKeyDown: ue,
    onKeyUp: Oe,
    onMouseDown: ae,
    onMouseLeave: re,
    onMouseUp: se,
    onDragLeave: oe,
    onTouchEnd: M,
    onTouchMove: W,
    onTouchStart: le,
    ref: nt,
    tabIndex: u ? -1 : A,
    type: D
  }, De, L, {
    children: [i, K ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ _.jsx(Aoe, T({
        ref: U,
        center: a
      }, k))
    ) : null]
  }));
});
process.env.NODE_ENV !== "production" && (TN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: vn,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: s.bool,
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: ep,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * âš ï¸ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: s.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: s.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: s.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: s.string,
  /**
   * @ignore
   */
  href: s.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: s.elementType,
  /**
   * @ignore
   */
  onBlur: s.func,
  /**
   * @ignore
   */
  onClick: s.func,
  /**
   * @ignore
   */
  onContextMenu: s.func,
  /**
   * @ignore
   */
  onDragLeave: s.func,
  /**
   * @ignore
   */
  onFocus: s.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: s.func,
  /**
   * @ignore
   */
  onKeyDown: s.func,
  /**
   * @ignore
   */
  onKeyUp: s.func,
  /**
   * @ignore
   */
  onMouseDown: s.func,
  /**
   * @ignore
   */
  onMouseLeave: s.func,
  /**
   * @ignore
   */
  onMouseUp: s.func,
  /**
   * @ignore
   */
  onTouchEnd: s.func,
  /**
   * @ignore
   */
  onTouchMove: s.func,
  /**
   * @ignore
   */
  onTouchStart: s.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * @default 0
   */
  tabIndex: s.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: s.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: s.oneOfType([s.func, s.shape({
    current: s.shape({
      pulsate: s.func.isRequired,
      start: s.func.isRequired,
      stop: s.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: s.oneOfType([s.oneOf(["button", "reset", "submit"]), s.string])
});
const bo = TN;
function Woe(e) {
  return ze("MuiIconButton", e);
}
const Uoe = Le("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), Hoe = Uoe, Yoe = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"], qoe = (e) => {
  const {
    classes: t,
    disabled: r,
    color: n,
    edge: o,
    size: a
  } = e, i = {
    root: ["root", r && "disabled", n !== "default" && `color${Te(n)}`, o && `edge${Te(o)}`, `size${Te(a)}`]
  };
  return Ve(i, Woe, t);
}, Goe = ce(bo, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.color !== "default" && t[`color${Te(r.color)}`], r.edge && t[`edge${Te(r.edge)}`], t[`size${Te(r.size)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  })
}, !t.disableRipple && {
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.action.active, e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, t.edge === "start" && {
  marginLeft: t.size === "small" ? -3 : -12
}, t.edge === "end" && {
  marginRight: t.size === "small" ? -3 : -12
}), ({
  theme: e,
  ownerState: t
}) => {
  var r;
  const n = (r = (e.vars || e).palette) == null ? void 0 : r[t.color];
  return T({}, t.color === "inherit" && {
    color: "inherit"
  }, t.color !== "inherit" && t.color !== "default" && T({
    color: n == null ? void 0 : n.main
  }, !t.disableRipple && {
    "&:hover": T({}, n && {
      backgroundColor: e.vars ? `rgba(${n.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(n.main, e.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), t.size === "small" && {
    padding: 5,
    fontSize: e.typography.pxToRem(18)
  }, t.size === "large" && {
    padding: 12,
    fontSize: e.typography.pxToRem(28)
  }, {
    [`&.${Hoe.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    }
  });
}), EN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: o = !1,
    children: a,
    className: i,
    color: l = "default",
    disabled: c = !1,
    disableFocusRipple: u = !1,
    size: d = "medium"
  } = n, f = ge(n, Yoe), p = T({}, n, {
    edge: o,
    color: l,
    disabled: c,
    disableFocusRipple: u,
    size: d
  }), m = qoe(p);
  return /* @__PURE__ */ _.jsx(Goe, T({
    className: Pe(m.root, i),
    centerRipple: !0,
    focusRipple: !u,
    disabled: c,
    ref: r,
    ownerState: p
  }, f, {
    children: a
  }));
});
process.env.NODE_ENV !== "production" && (EN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The icon to display.
   */
  children: xo(s.node, (e) => P.Children.toArray(e.children).some((r) => /* @__PURE__ */ P.isValidElement(r) && r.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
`)) : null),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: s.oneOfType([s.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: s.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * âš ï¸ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: s.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: s.oneOf(["end", "start", !1]),
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: s.oneOfType([s.oneOf(["small", "medium", "large"]), s.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const co = EN;
function Koe(e) {
  return ze("MuiSvgIcon", e);
}
Le("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const Xoe = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], Qoe = (e) => {
  const {
    color: t,
    fontSize: r,
    classes: n
  } = e, o = {
    root: ["root", t !== "inherit" && `color${Te(t)}`, `fontSize${Te(r)}`]
  };
  return Ve(o, Koe, n);
}, Zoe = ce("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.color !== "inherit" && t[`color${Te(r.color)}`], t[`fontSize${Te(r.fontSize)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var r, n, o, a, i, l, c, u, d, f, p, m, y, h, v, g, b;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    fill: "currentColor",
    flexShrink: 0,
    transition: (r = e.transitions) == null || (n = r.create) == null ? void 0 : n.call(r, "fill", {
      duration: (o = e.transitions) == null || (a = o.duration) == null ? void 0 : a.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((i = e.typography) == null || (l = i.pxToRem) == null ? void 0 : l.call(i, 20)) || "1.25rem",
      medium: ((c = e.typography) == null || (u = c.pxToRem) == null ? void 0 : u.call(c, 24)) || "1.5rem",
      large: ((d = e.typography) == null || (f = d.pxToRem) == null ? void 0 : f.call(d, 35)) || "2.1875rem"
    }[t.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (p = (m = (e.vars || e).palette) == null || (y = m[t.color]) == null ? void 0 : y.main) != null ? p : {
      action: (h = (e.vars || e).palette) == null || (v = h.action) == null ? void 0 : v.active,
      disabled: (g = (e.vars || e).palette) == null || (b = g.action) == null ? void 0 : b.disabled,
      inherit: void 0
    }[t.color]
  };
}), Db = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: o,
    className: a,
    color: i = "inherit",
    component: l = "svg",
    fontSize: c = "medium",
    htmlColor: u,
    inheritViewBox: d = !1,
    titleAccess: f,
    viewBox: p = "0 0 24 24"
  } = n, m = ge(n, Xoe), y = T({}, n, {
    color: i,
    component: l,
    fontSize: c,
    instanceFontSize: t.fontSize,
    inheritViewBox: d,
    viewBox: p
  }), h = {};
  d || (h.viewBox = p);
  const v = Qoe(y);
  return /* @__PURE__ */ _.jsxs(Zoe, T({
    as: l,
    className: Pe(v.root, a),
    focusable: "false",
    color: u,
    "aria-hidden": f ? void 0 : !0,
    role: f ? "img" : void 0,
    ref: r
  }, h, m, {
    ownerState: y,
    children: [o, f ? /* @__PURE__ */ _.jsx("title", {
      children: f
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (Db.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Node passed into the SVG element.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: s.oneOfType([s.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: s.oneOfType([s.oneOf(["inherit", "large", "medium", "small"]), s.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: s.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: s.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: s.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: s.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: s.string
});
Db.muiName = "SvgIcon";
const JS = Db;
function qr(e, t) {
  function r(n, o) {
    return /* @__PURE__ */ _.jsx(JS, T({
      "data-testid": `${t}Icon`,
      ref: o
    }, n, {
      children: e
    }));
  }
  return process.env.NODE_ENV !== "production" && (r.displayName = `${t}Icon`), r.muiName = JS.muiName, /* @__PURE__ */ P.memo(/* @__PURE__ */ P.forwardRef(r));
}
const Joe = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), eae = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft"), tae = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight"), $N = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
qr(/* @__PURE__ */ _.jsxs(P.Fragment, {
  children: [/* @__PURE__ */ _.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ _.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
const rae = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange"), nae = qr(/* @__PURE__ */ _.jsxs(P.Fragment, {
  children: [/* @__PURE__ */ _.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ _.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
function oae(e) {
  return ze("MuiPickersArrowSwitcher", e);
}
Le("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
const aae = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"], iae = ["ownerState"], sae = ["ownerState"], lae = ce("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex"
}), cae = ce("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Spacer",
  overridesResolver: (e, t) => t.spacer
})(({
  theme: e
}) => ({
  width: e.spacing(3)
})), e1 = ce(co, {
  name: "MuiPickersArrowSwitcher",
  slot: "Button",
  overridesResolver: (e, t) => t.button
})(({
  ownerState: e
}) => T({}, e.hidden && {
  visibility: "hidden"
})), uae = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    spacer: ["spacer"],
    button: ["button"]
  }, oae, t);
}, CN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i;
  const c = Nr().direction === "rtl", u = Ae({
    props: t,
    name: "MuiPickersArrowSwitcher"
  }), {
    children: d,
    className: f,
    slots: p,
    slotProps: m,
    isNextDisabled: y,
    isNextHidden: h,
    onGoToNext: v,
    nextLabel: g,
    isPreviousDisabled: b,
    isPreviousHidden: x,
    onGoToPrevious: O,
    previousLabel: w
  } = u, S = ge(u, aae), E = u, C = uae(E), N = {
    isDisabled: y,
    isHidden: h,
    goTo: v,
    label: g
  }, $ = {
    isDisabled: b,
    isHidden: x,
    goTo: O,
    label: w
  }, [j, A] = c ? [N, $] : [$, N], k = (n = p == null ? void 0 : p.previousIconButton) != null ? n : e1, R = It({
    elementType: k,
    externalSlotProps: m == null ? void 0 : m.previousIconButton,
    additionalProps: {
      size: "medium",
      title: j.label,
      "aria-label": j.label,
      disabled: j.isDisabled,
      edge: "end",
      onClick: j.goTo
    },
    ownerState: T({}, E, {
      hidden: j.isHidden
    }),
    className: C.button
  }), D = (o = p == null ? void 0 : p.nextIconButton) != null ? o : e1, L = It({
    elementType: D,
    externalSlotProps: m == null ? void 0 : m.nextIconButton,
    additionalProps: {
      size: "medium",
      title: A.label,
      "aria-label": A.label,
      disabled: A.isDisabled,
      edge: "start",
      onClick: A.goTo
    },
    ownerState: T({}, E, {
      hidden: A.isHidden
    }),
    className: C.button
  }), B = (a = p == null ? void 0 : p.leftArrowIcon) != null ? a : eae, H = It({
    elementType: B,
    externalSlotProps: m == null ? void 0 : m.leftArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), U = ge(H, iae), I = (i = p == null ? void 0 : p.rightArrowIcon) != null ? i : tae, V = It({
    elementType: I,
    externalSlotProps: m == null ? void 0 : m.rightArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), G = ge(V, sae);
  return /* @__PURE__ */ _.jsxs(lae, T({
    ref: r,
    className: Pe(C.root, f),
    ownerState: E
  }, S, {
    children: [/* @__PURE__ */ _.jsx(k, T({}, R, {
      children: c ? /* @__PURE__ */ _.jsx(I, T({}, G)) : /* @__PURE__ */ _.jsx(B, T({}, U))
    })), d ? /* @__PURE__ */ _.jsx(Zn, {
      variant: "subtitle1",
      component: "span",
      children: d
    }) : /* @__PURE__ */ _.jsx(cae, {
      className: C.spacer,
      ownerState: E
    }), /* @__PURE__ */ _.jsx(D, T({}, L, {
      children: c ? /* @__PURE__ */ _.jsx(B, T({}, U)) : /* @__PURE__ */ _.jsx(I, T({}, G))
    }))]
  }));
});
function dae(e) {
  return ze("MuiDialogContent", e);
}
Le("MuiDialogContent", ["root", "dividers"]);
const fae = Le("MuiDialogTitle", ["root"]), pae = fae, mae = ["className", "dividers"], hae = (e) => {
  const {
    classes: t,
    dividers: r
  } = e;
  return Ve({
    root: ["root", r && "dividers"]
  }, dae, t);
}, yae = ce("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.dividers && t.dividers];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, t.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(e.vars || e).palette.divider}`,
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`
} : {
  [`.${pae.root} + &`]: {
    paddingTop: 0
  }
})), kN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDialogContent"
  }), {
    className: o,
    dividers: a = !1
  } = n, i = ge(n, mae), l = T({}, n, {
    dividers: a
  }), c = hae(l);
  return /* @__PURE__ */ _.jsx(yae, T({
    className: Pe(c.root, o),
    ownerState: l,
    ref: r
  }, i));
});
process.env.NODE_ENV !== "production" && (kN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * Display the top and bottom dividers.
   * @default false
   */
  dividers: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const vae = kN, RN = (e) => e.scrollTop;
function Wf(e, t) {
  var r, n;
  const {
    timeout: o,
    easing: a,
    style: i = {}
  } = e;
  return {
    duration: (r = i.transitionDuration) != null ? r : typeof o == "number" ? o : o[t.mode] || 0,
    easing: (n = i.transitionTimingFunction) != null ? n : typeof a == "object" ? a[t.mode] : a,
    delay: i.transitionDelay
  };
}
const gae = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"], bae = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, DN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Nr(), o = {
    enter: n.transitions.duration.enteringScreen,
    exit: n.transitions.duration.leavingScreen
  }, {
    addEndListener: a,
    appear: i = !0,
    children: l,
    easing: c,
    in: u,
    onEnter: d,
    onEntered: f,
    onEntering: p,
    onExit: m,
    onExited: y,
    onExiting: h,
    style: v,
    timeout: g = o,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: b = Kp
  } = t, x = ge(t, gae), O = P.useRef(null), w = Lt(O, l.ref, r), S = (R) => (D) => {
    if (R) {
      const L = O.current;
      D === void 0 ? R(L) : R(L, D);
    }
  }, E = S(p), C = S((R, D) => {
    RN(R);
    const L = Wf({
      style: v,
      timeout: g,
      easing: c
    }, {
      mode: "enter"
    });
    R.style.webkitTransition = n.transitions.create("opacity", L), R.style.transition = n.transitions.create("opacity", L), d && d(R, D);
  }), N = S(f), $ = S(h), j = S((R) => {
    const D = Wf({
      style: v,
      timeout: g,
      easing: c
    }, {
      mode: "exit"
    });
    R.style.webkitTransition = n.transitions.create("opacity", D), R.style.transition = n.transitions.create("opacity", D), m && m(R);
  }), A = S(y), k = (R) => {
    a && a(O.current, R);
  };
  return /* @__PURE__ */ _.jsx(b, T({
    appear: i,
    in: u,
    nodeRef: O,
    onEnter: C,
    onEntered: N,
    onEntering: E,
    onExit: j,
    onExited: A,
    onExiting: $,
    addEndListener: k,
    timeout: g
  }, x, {
    children: (R, D) => /* @__PURE__ */ P.cloneElement(l, T({
      style: T({
        opacity: 0,
        visibility: R === "exited" && !u ? "hidden" : void 0
      }, bae[R], v, l.props.style),
      ref: w
    }, D))
  }));
});
process.env.NODE_ENV !== "production" && (DN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: s.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: s.bool,
  /**
   * A single child content element.
   */
  children: yl.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: s.oneOfType([s.shape({
    enter: s.string,
    exit: s.string
  }), s.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: s.bool,
  /**
   * @ignore
   */
  onEnter: s.func,
  /**
   * @ignore
   */
  onEntered: s.func,
  /**
   * @ignore
   */
  onEntering: s.func,
  /**
   * @ignore
   */
  onExit: s.func,
  /**
   * @ignore
   */
  onExited: s.func,
  /**
   * @ignore
   */
  onExiting: s.func,
  /**
   * @ignore
   */
  style: s.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: s.oneOfType([s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })])
});
const Il = DN;
function wae(e) {
  return ze("MuiBackdrop", e);
}
Le("MuiBackdrop", ["root", "invisible"]);
const xae = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"], _ae = (e) => {
  const {
    classes: t,
    invisible: r
  } = e;
  return Ve({
    root: ["root", r && "invisible"]
  }, wae, t);
}, Oae = ce("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.invisible && t.invisible];
  }
})(({
  ownerState: e
}) => T({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, e.invisible && {
  backgroundColor: "transparent"
})), NN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a;
  const i = Ae({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: l,
    className: c,
    component: u = "div",
    components: d = {},
    componentsProps: f = {},
    invisible: p = !1,
    open: m,
    slotProps: y = {},
    slots: h = {},
    TransitionComponent: v = Il,
    transitionDuration: g
  } = i, b = ge(i, xae), x = T({}, i, {
    component: u,
    invisible: p
  }), O = _ae(x), w = (n = y.root) != null ? n : f.root;
  return /* @__PURE__ */ _.jsx(v, T({
    in: m,
    timeout: g
  }, b, {
    children: /* @__PURE__ */ _.jsx(Oae, T({
      "aria-hidden": !0
    }, w, {
      as: (o = (a = h.root) != null ? a : d.Root) != null ? o : u,
      className: Pe(O.root, c, w == null ? void 0 : w.className),
      ownerState: T({}, x, w == null ? void 0 : w.ownerState),
      classes: O,
      ref: r,
      children: l
    }))
  }));
});
process.env.NODE_ENV !== "production" && (NN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    root: s.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: s.bool,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: s.shape({
    root: s.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    root: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: s.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: s.oneOfType([s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })])
});
const IN = NN, Pae = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "slotProps", "slots", "theme"], Sae = ce("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.open && r.exited && t.hidden];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !t.open && t.exited && {
  visibility: "hidden"
})), Tae = ce(IN, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), MN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i, l, c;
  const u = Ae({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: d = Tae,
    BackdropProps: f,
    classes: p,
    className: m,
    closeAfterTransition: y = !1,
    children: h,
    component: v,
    components: g = {},
    componentsProps: b = {},
    disableAutoFocus: x = !1,
    disableEnforceFocus: O = !1,
    disableEscapeKeyDown: w = !1,
    disablePortal: S = !1,
    disableRestoreFocus: E = !1,
    disableScrollLock: C = !1,
    hideBackdrop: N = !1,
    keepMounted: $ = !1,
    slotProps: j,
    slots: A,
    // eslint-disable-next-line react/prop-types
    theme: k
  } = u, R = ge(u, Pae), [D, L] = P.useState(!0), B = {
    closeAfterTransition: y,
    disableAutoFocus: x,
    disableEnforceFocus: O,
    disableEscapeKeyDown: w,
    disablePortal: S,
    disableRestoreFocus: E,
    disableScrollLock: C,
    hideBackdrop: N,
    keepMounted: $
  }, H = T({}, u, B, {
    exited: D
  }), U = (n = (o = A == null ? void 0 : A.root) != null ? o : g.Root) != null ? n : Sae, I = (a = (i = A == null ? void 0 : A.backdrop) != null ? i : g.Backdrop) != null ? a : d, V = (l = j == null ? void 0 : j.root) != null ? l : b.root, G = (c = j == null ? void 0 : j.backdrop) != null ? c : b.backdrop;
  return /* @__PURE__ */ _.jsx(Mne, T({
    slots: {
      root: U,
      backdrop: I
    },
    slotProps: {
      root: () => T({}, Ma(V, H), !Ia(U) && {
        as: v,
        theme: k
      }, {
        className: Pe(m, V == null ? void 0 : V.className, p == null ? void 0 : p.root, !H.open && H.exited && (p == null ? void 0 : p.hidden))
      }),
      backdrop: () => T({}, f, Ma(G, H), {
        className: Pe(G == null ? void 0 : G.className, p == null ? void 0 : p.backdrop)
      })
    },
    onTransitionEnter: () => L(!1),
    onTransitionExited: () => L(!0),
    ref: r
  }, R, B, {
    children: h
  }));
});
process.env.NODE_ENV !== "production" && (MN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: s.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: s.object,
  /**
   * A single child content element.
   */
  children: yl.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: s.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Backdrop: s.elementType,
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    backdrop: s.oneOfType([s.func, s.object]),
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: s.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: s.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: s.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: s.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: s.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: s.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: s.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: s.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: s.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: s.shape({
    backdrop: s.oneOfType([s.func, s.object]),
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: s.shape({
    backdrop: s.elementType,
    root: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const AN = MN;
function Eae(e) {
  return ze("MuiPaper", e);
}
Le("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const $ae = ["className", "component", "elevation", "square", "variant"], Cae = (e) => {
  const {
    square: t,
    elevation: r,
    variant: n,
    classes: o
  } = e, a = {
    root: ["root", n, !t && "rounded", n === "elevation" && `elevation${r}`]
  };
  return Ve(a, Eae, o);
}, kae = ce("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, t[r.variant], !r.square && t.rounded, r.variant === "elevation" && t[`elevation${r.elevation}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var r;
  return T({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow")
  }, !t.square && {
    borderRadius: e.shape.borderRadius
  }, t.variant === "outlined" && {
    border: `1px solid ${(e.vars || e).palette.divider}`
  }, t.variant === "elevation" && T({
    boxShadow: (e.vars || e).shadows[t.elevation]
  }, !e.vars && e.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${dt("#fff", bw(t.elevation))}, ${dt("#fff", bw(t.elevation))})`
  }, e.vars && {
    backgroundImage: (r = e.vars.overlays) == null ? void 0 : r[t.elevation]
  }));
}), jN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPaper"
  }), {
    className: o,
    component: a = "div",
    elevation: i = 1,
    square: l = !1,
    variant: c = "elevation"
  } = n, u = ge(n, $ae), d = T({}, n, {
    component: a,
    elevation: i,
    square: l,
    variant: c
  }), f = Cae(d);
  return process.env.NODE_ENV !== "production" && Nr().shadows[i] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${i}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${i}]\` is defined.`].join(`
`)), /* @__PURE__ */ _.jsx(kae, T({
    as: a,
    ownerState: d,
    className: Pe(f.root, o),
    ref: r
  }, u));
});
process.env.NODE_ENV !== "production" && (jN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: xo(js, (e) => {
    const {
      elevation: t,
      variant: r
    } = e;
    return t > 0 && r === "outlined" ? new Error(`MUI: Combining \`elevation={${t}}\` with \`variant="${r}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: s.oneOfType([s.oneOf(["elevation", "outlined"]), s.string])
});
const Ml = jN;
function Rae(e) {
  return ze("MuiDialog", e);
}
const Dae = Le("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]), Ks = Dae, FN = /* @__PURE__ */ P.createContext({});
process.env.NODE_ENV !== "production" && (FN.displayName = "DialogContext");
const Nae = FN, Iae = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"], Mae = ce(IN, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (e, t) => t.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
}), Aae = (e) => {
  const {
    classes: t,
    scroll: r,
    maxWidth: n,
    fullWidth: o,
    fullScreen: a
  } = e, i = {
    root: ["root"],
    container: ["container", `scroll${Te(r)}`],
    paper: ["paper", `paperScroll${Te(r)}`, `paperWidth${Te(String(n))}`, o && "paperFullWidth", a && "paperFullScreen"]
  };
  return Ve(i, Rae, t);
}, jae = ce(AN, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
}), Fae = ce("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.container, t[`scroll${Te(r.scroll)}`]];
  }
})(({
  ownerState: e
}) => T({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, e.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, e.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&:after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
})), Lae = ce(Ml, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.paper, t[`scrollPaper${Te(r.scroll)}`], t[`paperWidth${Te(String(r.maxWidth))}`], r.fullWidth && t.paperFullWidth, r.fullScreen && t.paperFullScreen];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, t.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, t.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !t.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, t.maxWidth === "xs" && {
  maxWidth: e.breakpoints.unit === "px" ? Math.max(e.breakpoints.values.xs, 444) : `${e.breakpoints.values.xs}${e.breakpoints.unit}`,
  [`&.${Ks.paperScrollBody}`]: {
    [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, t.maxWidth && t.maxWidth !== "xs" && {
  maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`,
  [`&.${Ks.paperScrollBody}`]: {
    [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, t.fullWidth && {
  width: "calc(100% - 64px)"
}, t.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${Ks.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
})), LN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDialog"
  }), o = Nr(), a = {
    enter: o.transitions.duration.enteringScreen,
    exit: o.transitions.duration.leavingScreen
  }, {
    "aria-describedby": i,
    "aria-labelledby": l,
    BackdropComponent: c,
    BackdropProps: u,
    children: d,
    className: f,
    disableEscapeKeyDown: p = !1,
    fullScreen: m = !1,
    fullWidth: y = !1,
    maxWidth: h = "sm",
    onBackdropClick: v,
    onClose: g,
    open: b,
    PaperComponent: x = Ml,
    PaperProps: O = {},
    scroll: w = "paper",
    TransitionComponent: S = Il,
    transitionDuration: E = a,
    TransitionProps: C
  } = n, N = ge(n, Iae), $ = T({}, n, {
    disableEscapeKeyDown: p,
    fullScreen: m,
    fullWidth: y,
    maxWidth: h,
    scroll: w
  }), j = Aae($), A = P.useRef(), k = (B) => {
    A.current = B.target === B.currentTarget;
  }, R = (B) => {
    A.current && (A.current = null, v && v(B), g && g(B, "backdropClick"));
  }, D = Ri(l), L = P.useMemo(() => ({
    titleId: D
  }), [D]);
  return /* @__PURE__ */ _.jsx(jae, T({
    className: Pe(j.root, f),
    closeAfterTransition: !0,
    components: {
      Backdrop: Mae
    },
    componentsProps: {
      backdrop: T({
        transitionDuration: E,
        as: c
      }, u)
    },
    disableEscapeKeyDown: p,
    onClose: g,
    open: b,
    ref: r,
    onClick: R,
    ownerState: $
  }, N, {
    children: /* @__PURE__ */ _.jsx(S, T({
      appear: !0,
      in: b,
      timeout: E,
      role: "presentation"
    }, C, {
      children: /* @__PURE__ */ _.jsx(Fae, {
        className: Pe(j.container),
        onMouseDown: k,
        ownerState: $,
        children: /* @__PURE__ */ _.jsx(Lae, T({
          as: x,
          elevation: 24,
          role: "dialog",
          "aria-describedby": i,
          "aria-labelledby": D
        }, O, {
          className: Pe(j.paper, O.className),
          ownerState: $,
          children: /* @__PURE__ */ _.jsx(Nae.Provider, {
            value: L,
            children: d
          })
        }))
      })
    }))
  }));
});
process.env.NODE_ENV !== "production" && (LN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The id(s) of the element(s) that describe the dialog.
   */
  "aria-describedby": s.string,
  /**
   * The id(s) of the element(s) that label the dialog.
   */
  "aria-labelledby": s.string,
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: s.elementType,
  /**
   * @ignore
   */
  BackdropProps: s.object,
  /**
   * Dialog children, usually the included sub-components.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: s.bool,
  /**
   * If `true`, the dialog is full-screen.
   * @default false
   */
  fullScreen: s.bool,
  /**
   * If `true`, the dialog stretches to `maxWidth`.
   *
   * Notice that the dialog width grow is limited by the default margin.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * Determine the max-width of the dialog.
   * The dialog width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'sm'
   */
  maxWidth: s.oneOfType([s.oneOf(["xs", "sm", "md", "lg", "xl", !1]), s.string]),
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: s.func,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * The component used to render the body of the dialog.
   * @default Paper
   */
  PaperComponent: s.elementType,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: s.object,
  /**
   * Determine the container for scrolling the dialog.
   * @default 'paper'
   */
  scroll: s.oneOf(["body", "paper"]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: s.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: s.oneOfType([s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: s.object
});
const Vae = LN, dl = 36, Qp = 2, VN = 320, zN = 358, zae = ce(Vae)({
  [`& .${Ks.container}`]: {
    outline: 0
  },
  [`& .${Ks.paper}`]: {
    outline: 0,
    minWidth: VN
  }
}), Bae = ce(vae)({
  "&:first-of-type": {
    padding: 0
  }
});
function Wae(e) {
  var t, r;
  const {
    children: n,
    onDismiss: o,
    open: a,
    slots: i,
    slotProps: l
  } = e, c = (t = i == null ? void 0 : i.dialog) != null ? t : zae, u = (r = i == null ? void 0 : i.mobileTransition) != null ? r : Il;
  return /* @__PURE__ */ _.jsx(c, T({
    open: a,
    onClose: o
  }, l == null ? void 0 : l.dialog, {
    TransitionComponent: u,
    TransitionProps: l == null ? void 0 : l.mobileTransition,
    PaperComponent: i == null ? void 0 : i.mobilePaper,
    PaperProps: l == null ? void 0 : l.mobilePaper,
    children: /* @__PURE__ */ _.jsx(Bae, {
      children: n
    })
  }));
}
const Uae = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function Iv(e) {
  return `scale(${e}, ${e ** 2})`;
}
const Hae = {
  entering: {
    opacity: 1,
    transform: Iv(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, dh = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), Nb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    addEndListener: n,
    appear: o = !0,
    children: a,
    easing: i,
    in: l,
    onEnter: c,
    onEntered: u,
    onEntering: d,
    onExit: f,
    onExited: p,
    onExiting: m,
    style: y,
    timeout: h = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: v = Kp
  } = t, g = ge(t, Uae), b = P.useRef(), x = P.useRef(), O = Nr(), w = P.useRef(null), S = Lt(w, a.ref, r), E = (D) => (L) => {
    if (D) {
      const B = w.current;
      L === void 0 ? D(B) : D(B, L);
    }
  }, C = E(d), N = E((D, L) => {
    RN(D);
    const {
      duration: B,
      delay: H,
      easing: U
    } = Wf({
      style: y,
      timeout: h,
      easing: i
    }, {
      mode: "enter"
    });
    let I;
    h === "auto" ? (I = O.transitions.getAutoHeightDuration(D.clientHeight), x.current = I) : I = B, D.style.transition = [O.transitions.create("opacity", {
      duration: I,
      delay: H
    }), O.transitions.create("transform", {
      duration: dh ? I : I * 0.666,
      delay: H,
      easing: U
    })].join(","), c && c(D, L);
  }), $ = E(u), j = E(m), A = E((D) => {
    const {
      duration: L,
      delay: B,
      easing: H
    } = Wf({
      style: y,
      timeout: h,
      easing: i
    }, {
      mode: "exit"
    });
    let U;
    h === "auto" ? (U = O.transitions.getAutoHeightDuration(D.clientHeight), x.current = U) : U = L, D.style.transition = [O.transitions.create("opacity", {
      duration: U,
      delay: B
    }), O.transitions.create("transform", {
      duration: dh ? U : U * 0.666,
      delay: dh ? B : B || U * 0.333,
      easing: H
    })].join(","), D.style.opacity = 0, D.style.transform = Iv(0.75), f && f(D);
  }), k = E(p), R = (D) => {
    h === "auto" && (b.current = setTimeout(D, x.current || 0)), n && n(w.current, D);
  };
  return P.useEffect(() => () => {
    clearTimeout(b.current);
  }, []), /* @__PURE__ */ _.jsx(v, T({
    appear: o,
    in: l,
    nodeRef: w,
    onEnter: N,
    onEntered: $,
    onEntering: C,
    onExit: A,
    onExited: k,
    onExiting: j,
    addEndListener: R,
    timeout: h === "auto" ? null : h
  }, g, {
    children: (D, L) => /* @__PURE__ */ P.cloneElement(a, T({
      style: T({
        opacity: 0,
        transform: Iv(0.75),
        visibility: D === "exited" && !l ? "hidden" : void 0
      }, Hae[D], y, a.props.style),
      ref: S
    }, L))
  }));
});
process.env.NODE_ENV !== "production" && (Nb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: s.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: s.bool,
  /**
   * A single child content element.
   */
  children: yl.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: s.oneOfType([s.shape({
    enter: s.string,
    exit: s.string
  }), s.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: s.bool,
  /**
   * @ignore
   */
  onEnter: s.func,
  /**
   * @ignore
   */
  onEntered: s.func,
  /**
   * @ignore
   */
  onEntering: s.func,
  /**
   * @ignore
   */
  onExit: s.func,
  /**
   * @ignore
   */
  onExited: s.func,
  /**
   * @ignore
   */
  onExiting: s.func,
  /**
   * @ignore
   */
  style: s.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: s.oneOfType([s.oneOf(["auto"]), s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })])
});
Nb.muiSupportAuto = !0;
const BN = Nb, Yae = ["components", "componentsProps", "slots", "slotProps"], qae = ce(One, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), WN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n;
  const o = bp(), a = Ae({
    props: t,
    name: "MuiPopper"
  }), {
    components: i,
    componentsProps: l,
    slots: c,
    slotProps: u
  } = a, d = ge(a, Yae), f = (n = c == null ? void 0 : c.root) != null ? n : i == null ? void 0 : i.Root;
  return /* @__PURE__ */ _.jsx(qae, T({
    direction: o == null ? void 0 : o.direction,
    slots: {
      root: f
    },
    slotProps: u ?? l
  }, d, {
    ref: r
  }));
});
process.env.NODE_ENV !== "production" && (WN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: s.oneOfType([Gn, s.object, s.func]),
  /**
   * Popper render function or node.
   */
  children: s.oneOfType([s.node, s.func]),
  /**
   * @ignore
   */
  component: s.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: s.shape({
    Root: s.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  componentsProps: s.shape({
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: s.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: s.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: s.arrayOf(s.shape({
    data: s.object,
    effect: s.func,
    enabled: s.bool,
    fn: s.func,
    name: s.any,
    options: s.object,
    phase: s.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: s.arrayOf(s.string),
    requiresIfExists: s.arrayOf(s.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * @ignore
   */
  ownerState: s.any,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: s.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: s.shape({
    modifiers: s.array,
    onFirstUpdate: s.func,
    placement: s.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: s.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: vn,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: s.shape({
    root: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: s.shape({
    root: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: s.bool
});
const Gae = WN;
function Kae(e) {
  return ze("MuiPickersPopper", e);
}
Le("MuiPickersPopper", ["root", "paper"]);
function Xae(e, t) {
  return Array.isArray(t) ? t.every((r) => e.indexOf(r) !== -1) : e.indexOf(t) !== -1;
}
const Qae = (e, t) => (r) => {
  (r.key === "Enter" || r.key === " ") && (e(r), r.preventDefault(), r.stopPropagation()), t && t(r);
}, Ib = (e = document) => {
  const t = e.activeElement;
  return t ? t.shadowRoot ? Ib(t.shadowRoot) : t : null;
}, UN = "@media (pointer: fine)", Zae = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    paper: ["paper"]
  }, Kae, t);
}, Jae = ce(Gae, {
  name: "MuiPickersPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  zIndex: e.zIndex.modal
})), eie = ce(Ml, {
  name: "MuiPickersPopper",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})(({
  ownerState: e
}) => T({
  transformOrigin: "top center",
  outline: 0
}, e.placement === "top" && {
  transformOrigin: "bottom center"
}));
function tie(e, t) {
  return t.documentElement.clientWidth < e.clientX || t.documentElement.clientHeight < e.clientY;
}
function rie(e, t) {
  const r = P.useRef(!1), n = P.useRef(!1), o = P.useRef(null), a = P.useRef(!1);
  P.useEffect(() => {
    if (!e)
      return;
    function c() {
      a.current = !0;
    }
    return document.addEventListener("mousedown", c, !0), document.addEventListener("touchstart", c, !0), () => {
      document.removeEventListener("mousedown", c, !0), document.removeEventListener("touchstart", c, !0), a.current = !1;
    };
  }, [e]);
  const i = $t((c) => {
    if (!a.current)
      return;
    const u = n.current;
    n.current = !1;
    const d = nr(o.current);
    if (!o.current || // is a TouchEvent?
    "clientX" in c && tie(c, d))
      return;
    if (r.current) {
      r.current = !1;
      return;
    }
    let f;
    c.composedPath ? f = c.composedPath().indexOf(o.current) > -1 : f = !d.documentElement.contains(c.target) || o.current.contains(c.target), !f && !u && t(c);
  }), l = () => {
    n.current = !0;
  };
  return P.useEffect(() => {
    if (e) {
      const c = nr(o.current), u = () => {
        r.current = !0;
      };
      return c.addEventListener("touchstart", i), c.addEventListener("touchmove", u), () => {
        c.removeEventListener("touchstart", i), c.removeEventListener("touchmove", u);
      };
    }
  }, [e, i]), P.useEffect(() => {
    if (e) {
      const c = nr(o.current);
      return c.addEventListener("click", i), () => {
        c.removeEventListener("click", i), n.current = !1;
      };
    }
  }, [e, i]), [o, l, l];
}
function nie(e) {
  var t, r, n, o;
  const a = Ae({
    props: e,
    name: "MuiPickersPopper"
  }), {
    anchorEl: i,
    children: l,
    containerRef: c = null,
    shouldRestoreFocus: u,
    onBlur: d,
    onDismiss: f,
    open: p,
    role: m,
    placement: y,
    slots: h,
    slotProps: v
  } = a;
  P.useEffect(() => {
    function B(H) {
      p && (H.key === "Escape" || H.key === "Esc") && f();
    }
    return document.addEventListener("keydown", B), () => {
      document.removeEventListener("keydown", B);
    };
  }, [f, p]);
  const g = P.useRef(null);
  P.useEffect(() => {
    m === "tooltip" || u && !u() || (p ? g.current = Ib(document) : g.current && g.current instanceof HTMLElement && setTimeout(() => {
      g.current instanceof HTMLElement && g.current.focus();
    }));
  }, [p, m, u]);
  const [b, x, O] = rie(p, d ?? f), w = P.useRef(null), S = Lt(w, c), E = Lt(S, b), C = a, N = Zae(C), $ = (B) => {
    B.key === "Escape" && (B.stopPropagation(), f());
  }, j = (t = h == null ? void 0 : h.desktopTransition) != null ? t : BN, A = (r = h == null ? void 0 : h.desktopTrapFocus) != null ? r : sl, k = (n = h == null ? void 0 : h.desktopPaper) != null ? n : eie, R = It({
    elementType: k,
    externalSlotProps: v == null ? void 0 : v.desktopPaper,
    additionalProps: {
      tabIndex: -1,
      elevation: 8,
      ref: E
    },
    className: N.paper,
    ownerState: {}
    // Is overridden below to use `placement
  }), D = (o = h == null ? void 0 : h.popper) != null ? o : Jae, L = It({
    elementType: D,
    externalSlotProps: v == null ? void 0 : v.popper,
    additionalProps: {
      transition: !0,
      role: m,
      open: p,
      anchorEl: i,
      placement: y,
      onKeyDown: $
    },
    className: N.root,
    ownerState: a
  });
  return /* @__PURE__ */ _.jsx(D, T({}, L, {
    children: ({
      TransitionProps: B,
      placement: H
    }) => /* @__PURE__ */ _.jsx(A, T({
      open: p,
      disableAutoFocus: !0,
      disableRestoreFocus: !0,
      disableEnforceFocus: m === "tooltip",
      isEnabled: () => !0
    }, v == null ? void 0 : v.desktopTrapFocus, {
      children: /* @__PURE__ */ _.jsx(j, T({}, B, v == null ? void 0 : v.desktopTransition, {
        children: /* @__PURE__ */ _.jsx(k, T({}, R, {
          onClick: (U) => {
            var I;
            x(U), (I = R.onClick) == null || I.call(R, U);
          },
          onTouchStart: (U) => {
            var I;
            O(U), (I = R.onTouchStart) == null || I.call(R, U);
          },
          ownerState: T({}, C, {
            placement: H
          }),
          children: l
        }))
      }))
    }))
  }));
}
function oie(e) {
  return ze("MuiPickersToolbarText", e);
}
const t1 = Le("MuiPickersToolbarText", ["root", "selected"]);
function aie(e) {
  return ze("MuiButton", e);
}
const iie = Le("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), sc = iie, HN = /* @__PURE__ */ P.createContext({});
process.env.NODE_ENV !== "production" && (HN.displayName = "ButtonGroupContext");
const sie = HN, lie = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"], cie = (e) => {
  const {
    color: t,
    disableElevation: r,
    fullWidth: n,
    size: o,
    variant: a,
    classes: i
  } = e, l = {
    root: ["root", a, `${a}${Te(t)}`, `size${Te(o)}`, `${a}Size${Te(o)}`, t === "inherit" && "colorInherit", r && "disableElevation", n && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${Te(o)}`],
    endIcon: ["endIcon", `iconSize${Te(o)}`]
  }, c = Ve(l, aie, i);
  return T({}, i, c);
}, YN = (e) => T({}, e.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, e.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, e.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), uie = ce(bo, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, t[r.variant], t[`${r.variant}${Te(r.color)}`], t[`size${Te(r.size)}`], t[`${r.variant}Size${Te(r.size)}`], r.color === "inherit" && t.colorInherit, r.disableElevation && t.disableElevation, r.fullWidth && t.fullWidth];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var r, n;
  return T({}, e.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": T({
      textDecoration: "none",
      backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.text.primary, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "text" && t.color !== "inherit" && {
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "outlined" && t.color !== "inherit" && {
      border: `1px solid ${(e.vars || e).palette[t.color].main}`,
      backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette[t.color].main, e.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, t.variant === "contained" && {
      backgroundColor: (e.vars || e).palette.grey.A100,
      boxShadow: (e.vars || e).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (e.vars || e).shadows[2],
        backgroundColor: (e.vars || e).palette.grey[300]
      }
    }, t.variant === "contained" && t.color !== "inherit" && {
      backgroundColor: (e.vars || e).palette[t.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (e.vars || e).palette[t.color].main
      }
    }),
    "&:active": T({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[8]
    }),
    [`&.${sc.focusVisible}`]: T({}, t.variant === "contained" && {
      boxShadow: (e.vars || e).shadows[6]
    }),
    [`&.${sc.disabled}`]: T({
      color: (e.vars || e).palette.action.disabled
    }, t.variant === "outlined" && {
      border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
    }, t.variant === "contained" && {
      color: (e.vars || e).palette.action.disabled,
      boxShadow: (e.vars || e).shadows[0],
      backgroundColor: (e.vars || e).palette.action.disabledBackground
    })
  }, t.variant === "text" && {
    padding: "6px 8px"
  }, t.variant === "text" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main
  }, t.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, t.variant === "outlined" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].main,
    border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${dt(e.palette[t.color].main, 0.5)}`
  }, t.variant === "contained" && {
    color: e.vars ? (
      // this is safe because grey does not change between default light/dark mode
      e.vars.palette.text.primary
    ) : (r = (n = e.palette).getContrastText) == null ? void 0 : r.call(n, e.palette.grey[300]),
    backgroundColor: (e.vars || e).palette.grey[300],
    boxShadow: (e.vars || e).shadows[2]
  }, t.variant === "contained" && t.color !== "inherit" && {
    color: (e.vars || e).palette[t.color].contrastText,
    backgroundColor: (e.vars || e).palette[t.color].main
  }, t.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, t.size === "small" && t.variant === "text" && {
    padding: "4px 5px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "text" && {
    padding: "8px 11px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: e.typography.pxToRem(15)
  }, t.size === "small" && t.variant === "contained" && {
    padding: "4px 10px",
    fontSize: e.typography.pxToRem(13)
  }, t.size === "large" && t.variant === "contained" && {
    padding: "8px 22px",
    fontSize: e.typography.pxToRem(15)
  }, t.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState: e
}) => e.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${sc.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${sc.disabled}`]: {
    boxShadow: "none"
  }
}), die = ce("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.startIcon, t[`iconSize${Te(r.size)}`]];
  }
})(({
  ownerState: e
}) => T({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, e.size === "small" && {
  marginLeft: -2
}, YN(e))), fie = ce("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.endIcon, t[`iconSize${Te(r.size)}`]];
  }
})(({
  ownerState: e
}) => T({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, e.size === "small" && {
  marginRight: -2
}, YN(e))), qN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = P.useContext(sie), o = ag(n, t), a = Ae({
    props: o,
    name: "MuiButton"
  }), {
    children: i,
    color: l = "primary",
    component: c = "button",
    className: u,
    disabled: d = !1,
    disableElevation: f = !1,
    disableFocusRipple: p = !1,
    endIcon: m,
    focusVisibleClassName: y,
    fullWidth: h = !1,
    size: v = "medium",
    startIcon: g,
    type: b,
    variant: x = "text"
  } = a, O = ge(a, lie), w = T({}, a, {
    color: l,
    component: c,
    disabled: d,
    disableElevation: f,
    disableFocusRipple: p,
    fullWidth: h,
    size: v,
    type: b,
    variant: x
  }), S = cie(w), E = g && /* @__PURE__ */ _.jsx(die, {
    className: S.startIcon,
    ownerState: w,
    children: g
  }), C = m && /* @__PURE__ */ _.jsx(fie, {
    className: S.endIcon,
    ownerState: w,
    children: m
  });
  return /* @__PURE__ */ _.jsxs(uie, T({
    ownerState: w,
    className: Pe(n.className, S.root, u),
    component: c,
    disabled: d,
    focusRipple: !p,
    focusVisibleClassName: Pe(S.focusVisible, y),
    ref: r,
    type: b
  }, O, {
    classes: S,
    children: [E, i, C]
  }));
});
process.env.NODE_ENV !== "production" && (qN.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: s.oneOfType([s.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, no elevation is used.
   * @default false
   */
  disableElevation: s.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: s.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * âš ï¸ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: s.bool,
  /**
   * Element placed after the children.
   */
  endIcon: s.node,
  /**
   * @ignore
   */
  focusVisibleClassName: s.string,
  /**
   * If `true`, the button will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: s.string,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: s.oneOfType([s.oneOf(["small", "medium", "large"]), s.string]),
  /**
   * Element placed before the children.
   */
  startIcon: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * @ignore
   */
  type: s.oneOfType([s.oneOf(["button", "reset", "submit"]), s.string]),
  /**
   * The variant to use.
   * @default 'text'
   */
  variant: s.oneOfType([s.oneOf(["contained", "outlined", "text"]), s.string])
});
const Is = qN, pie = ["className", "selected", "value"], mie = (e) => {
  const {
    classes: t,
    selected: r
  } = e;
  return Ve({
    root: ["root", r && "selected"]
  }, oie, t);
}, hie = ce(Zn, {
  name: "MuiPickersToolbarText",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`&.${t1.selected}`]: t.selected
  }]
})(({
  theme: e
}) => ({
  transition: e.transitions.create("color"),
  color: (e.vars || e).palette.text.secondary,
  [`&.${t1.selected}`]: {
    color: (e.vars || e).palette.text.primary
  }
})), GN = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPickersToolbarText"
  }), {
    className: o,
    value: a
  } = n, i = ge(n, pie), l = mie(n);
  return /* @__PURE__ */ _.jsx(hie, T({
    ref: r,
    className: Pe(o, l.root),
    component: "span"
  }, i, {
    children: a
  }));
}), yie = ["align", "className", "selected", "typographyClassName", "value", "variant"], vie = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, gN, t);
}, gie = ce(Is, {
  name: "MuiPickersToolbarButton",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  padding: 0,
  minWidth: 16,
  textTransform: "none"
}), ua = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPickersToolbarButton"
  }), {
    align: o,
    className: a,
    selected: i,
    typographyClassName: l,
    value: c,
    variant: u
  } = n, d = ge(n, yie), f = vie(n);
  return /* @__PURE__ */ _.jsx(gie, T({
    variant: "text",
    ref: r,
    className: Pe(a, f.root)
  }, d, {
    children: /* @__PURE__ */ _.jsx(GN, {
      align: o,
      className: l,
      variant: u,
      value: c,
      selected: i
    })
  }));
});
var Ss = {}, r1;
function KN() {
  if (r1)
    return Ss;
  r1 = 1, Object.defineProperty(Ss, "__esModule", {
    value: !0
  }), Ss.default = void 0;
  var e = r(F);
  function t(a) {
    if (typeof WeakMap != "function")
      return null;
    var i = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
    return (t = function(c) {
      return c ? l : i;
    })(a);
  }
  function r(a, i) {
    if (!i && a && a.__esModule)
      return a;
    if (a === null || typeof a != "object" && typeof a != "function")
      return { default: a };
    var l = t(i);
    if (l && l.has(a))
      return l.get(a);
    var c = {}, u = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var d in a)
      if (d !== "default" && Object.prototype.hasOwnProperty.call(a, d)) {
        var f = u ? Object.getOwnPropertyDescriptor(a, d) : null;
        f && (f.get || f.set) ? Object.defineProperty(c, d, f) : c[d] = a[d];
      }
    return c.default = a, l && l.set(a, c), c;
  }
  var o = typeof window < "u" ? e.useLayoutEffect : e.useEffect;
  return Ss.default = o, Ss;
}
var bie = KN();
const Mv = /* @__PURE__ */ qi(bie);
var XN = {}, QN = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(QN);
var ZN = QN.exports, wie = ZN;
Object.defineProperty(XN, "__esModule", {
  value: !0
});
var gt = XN.default = Oie, n1 = _ie(F), xie = wie(KN());
function JN(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (JN = function(n) {
    return n ? r : t;
  })(e);
}
function _ie(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = JN(t);
  if (r && r.has(e))
    return r.get(e);
  var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in e)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var i = o ? Object.getOwnPropertyDescriptor(e, a) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, a, i) : n[a] = e[a];
    }
  return n.default = e, r && r.set(e, n), n;
}
function Oie(e) {
  const t = n1.useRef(e);
  return (0, xie.default)(() => {
    t.current = e;
  }), n1.useCallback((...r) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, t.current)(...r)
  ), []);
}
var eI = {}, lc = {}, o1;
function Pie() {
  if (o1)
    return lc;
  o1 = 1, Object.defineProperty(lc, "__esModule", {
    value: !0
  }), lc.default = e;
  function e(t, r) {
    typeof t == "function" ? t(r) : t && (t.current = r);
  }
  return lc;
}
var Sie = ZN;
Object.defineProperty(eI, "__esModule", {
  value: !0
});
var Mb = eI.default = Cie, Tie = $ie(F), Eie = Sie(Pie());
function tI(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (tI = function(n) {
    return n ? r : t;
  })(e);
}
function $ie(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = tI(t);
  if (r && r.has(e))
    return r.get(e);
  var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in e)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var i = o ? Object.getOwnPropertyDescriptor(e, a) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, a, i) : n[a] = e[a];
    }
  return n.default = e, r && r.set(e, n), n;
}
function Cie(...e) {
  return Tie.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((r) => {
      (0, Eie.default)(r, t);
    });
  }, e);
}
function rI(e, t, r, n) {
  const {
    value: o,
    onError: a
  } = e, i = Ha(), l = P.useRef(n), c = t({
    adapter: i,
    value: o,
    props: e
  });
  return P.useEffect(() => {
    a && !r(c, l.current) && a(c, o), l.current = c;
  }, [r, a, l, c, o]), c;
}
var nI = {};
Object.defineProperty(nI, "__esModule", {
  value: !0
});
var kie = nI.default = Die, ii = Rie(F);
function oI(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (oI = function(n) {
    return n ? r : t;
  })(e);
}
function Rie(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = oI(t);
  if (r && r.has(e))
    return r.get(e);
  var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in e)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var i = o ? Object.getOwnPropertyDescriptor(e, a) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, a, i) : n[a] = e[a];
    }
  return n.default = e, r && r.set(e, n), n;
}
function Die({
  controlled: e,
  default: t,
  name: r,
  state: n = "value"
}) {
  const {
    current: o
  } = ii.useRef(e !== void 0), [a, i] = ii.useState(t), l = o ? e : a;
  if (process.env.NODE_ENV !== "production") {
    ii.useEffect(() => {
      o !== (e !== void 0) && console.error([`MUI: A component is changing the ${o ? "" : "un"}controlled ${n} state of ${r} to be ${o ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [n, r, e]);
    const {
      current: u
    } = ii.useRef(t);
    ii.useEffect(() => {
      !o && u !== t && console.error([`MUI: A component is changing the default ${n} state of an uncontrolled ${r} after being initialized. To suppress this warning opt to use a controlled ${r}.`].join(`
`));
    }, [JSON.stringify(t)]);
  }
  const c = ii.useCallback((u) => {
    o || i(u);
  }, []);
  return [l, c];
}
const Nie = (e) => {
  var t;
  const r = wt(), n = Yr(), o = Ha(), i = Nr().direction === "rtl", {
    valueManager: l,
    fieldValueManager: c,
    valueType: u,
    validator: d,
    internalProps: f,
    internalProps: {
      value: p,
      defaultValue: m,
      onChange: y,
      format: h,
      selectedSections: v,
      onSelectedSectionsChange: g
    }
  } = e, b = P.useRef(m), x = (t = p ?? b.current) != null ? t : l.emptyValue, O = P.useMemo(() => Kte(r), [r]), w = P.useCallback((I, V = null) => c.getSectionsFromValue(r, I, V, i, (G) => CS(r, n, h, G)), [c, h, n, i, r]), S = P.useMemo(() => c.getValueStrFromSections(w(l.emptyValue), i), [c, w, l.emptyValue, i]), [E, C] = P.useState(() => {
    const I = w(x);
    return RS(I, u), {
      sections: I,
      value: x,
      referenceValue: c.updateReferenceValue(r, x, l.getTodayValue(r)),
      tempValueStrAndroid: null
    };
  }), [N, $] = kie({
    controlled: v,
    default: null,
    name: "useField",
    state: "selectedSectionIndexes"
  }), j = (I) => {
    $(I), g == null || g(I), C((V) => T({}, V, {
      selectedSectionQuery: null
    }));
  }, A = P.useMemo(() => {
    if (N == null)
      return null;
    if (N === "all")
      return {
        startIndex: 0,
        endIndex: E.sections.length - 1,
        shouldSelectBoundarySelectors: !0
      };
    if (typeof N == "number")
      return {
        startIndex: N,
        endIndex: N
      };
    if (typeof N == "string") {
      const I = E.sections.findIndex((V) => V.type === N);
      return {
        startIndex: I,
        endIndex: I
      };
    }
    return N;
  }, [N, E.sections]), k = ({
    value: I,
    referenceValue: V,
    sections: G
  }) => {
    if (C((q) => T({}, q, {
      sections: G,
      value: I,
      referenceValue: V,
      tempValueStrAndroid: null
    })), y) {
      const q = {
        validationError: d({
          adapter: o,
          value: I,
          props: T({}, f, {
            value: I
          })
        })
      };
      y(I, q);
    }
  }, R = (I, V) => {
    const G = [...E.sections];
    return G[I] = T({}, G[I], {
      value: V,
      modified: !0
    }), GD(G, i);
  }, D = () => {
    l.areValuesEqual(r, E.value, l.emptyValue) || k({
      value: l.emptyValue,
      referenceValue: E.referenceValue,
      sections: w(l.emptyValue)
    });
  }, L = () => {
    if (A == null)
      return;
    const I = E.sections[A.startIndex];
    if (I.value === "")
      return;
    const V = c.getActiveDateManager(r, E, I), q = V.getSections(E.sections).filter((ee) => ee.value !== "").length === 1, J = R(A.startIndex, ""), ne = q ? null : r.date(/* @__PURE__ */ new Date("")), te = V.getNewValuesFromNewActiveDate(ne);
    (ne != null && !r.isValid(ne)) != (V.date != null && !r.isValid(V.date)) ? k(T({}, te, {
      sections: J
    })) : C((ee) => T({}, ee, te, {
      sections: J,
      tempValueStrAndroid: null
    }));
  }, B = (I) => {
    const V = (J, ne) => {
      const te = r.parse(J, h);
      if (te == null || !r.isValid(te))
        return null;
      const ee = CS(r, n, h, te);
      return DS(r, te, ee, ne, !1);
    }, G = c.parseValueStr(I, E.referenceValue, V), q = c.updateReferenceValue(r, G, E.referenceValue);
    k({
      value: G,
      referenceValue: q,
      sections: w(G, E.sections)
    });
  }, H = ({
    activeSection: I,
    newSectionValue: V,
    shouldGoToNextSection: G
  }) => {
    G && A && A.startIndex < E.sections.length - 1 ? j(A.startIndex + 1) : A && A.startIndex !== A.endIndex && j(A.startIndex);
    const q = c.getActiveDateManager(r, E, I), J = R(A.startIndex, V), ne = q.getSections(J);
    let te = $v(r, ne), ee = !1;
    if (!r.isValid(te)) {
      const ie = Zte(r, ne, O);
      ie != null && (ee = !0, te = $v(r, ie));
    }
    let K, Q;
    if (te != null && r.isValid(te)) {
      const ie = DS(r, te, ne, q.referenceDate, !0);
      K = q.getNewValuesFromNewActiveDate(ie), Q = !0;
    } else
      K = q.getNewValuesFromNewActiveDate(te), Q = (te != null && !r.isValid(te)) != (q.date != null && !r.isValid(q.date));
    const ae = ee ? w(K.value, E.sections) : J;
    return Q ? k(T({}, K, {
      sections: ae
    })) : C((ie) => T({}, ie, K, {
      sections: ae,
      tempValueStrAndroid: null
    }));
  }, U = (I) => C((V) => T({}, V, {
    tempValueStrAndroid: I
  }));
  return P.useEffect(() => {
    l.areValuesEqual(r, E.value, x) || C((I) => T({}, I, {
      value: x,
      referenceValue: c.updateReferenceValue(r, x, I.referenceValue),
      sections: w(x)
    }));
  }, [x]), P.useEffect(() => {
    const I = w(E.value);
    RS(I, u), C((V) => T({}, V, {
      sections: I
    }));
  }, [h, r.locale]), {
    state: E,
    selectedSectionIndexes: A,
    setSelectedSections: j,
    clearValue: D,
    clearActiveSection: L,
    updateSectionValue: H,
    updateValueFromValueStr: B,
    setTempAndroidValueStr: U,
    sectionsValueBoundaries: O,
    placeholder: S
  };
}, Iie = 5e3, si = (e) => e.saveQuery != null, Mie = ({
  sections: e,
  updateSectionValue: t,
  sectionsValueBoundaries: r,
  setTempAndroidValueStr: n
}) => {
  const o = wt(), [a, i] = P.useState(null), l = gt(() => i(null));
  P.useEffect(() => {
    var p;
    a != null && ((p = e[a.sectionIndex]) == null ? void 0 : p.type) !== a.sectionType && l();
  }, [e, a, l]), P.useEffect(() => {
    if (a != null) {
      const p = setTimeout(() => l(), Iie);
      return () => {
        window.clearTimeout(p);
      };
    }
    return () => {
    };
  }, [a, l]);
  const c = ({
    keyPressed: p,
    sectionIndex: m
  }, y, h) => {
    const v = p.toLowerCase(), g = e[m];
    if (a != null && (!h || h(a.value)) && a.sectionIndex === m) {
      const x = `${a.value}${v}`, O = y(x, g);
      if (!si(O))
        return i({
          sectionIndex: m,
          value: x,
          sectionType: g.type
        }), O;
    }
    const b = y(v, g);
    return si(b) && !b.saveQuery ? (l(), null) : (i({
      sectionIndex: m,
      value: v,
      sectionType: g.type
    }), si(b) ? null : b);
  }, u = (p) => {
    const m = (v, g, b) => {
      const x = g.filter((O) => O.toLowerCase().startsWith(b));
      return x.length === 0 ? {
        saveQuery: !1
      } : {
        sectionValue: x[0],
        shouldGoToNextSection: x.length === 1
      };
    }, y = (v, g, b, x) => {
      const O = (w) => qD(o, g.type, w);
      if (g.contentType === "letter")
        return m(g.format, O(g.format), v);
      if (b && x != null && vb(o, b).contentType === "letter") {
        const w = O(b), S = m(b, w, v);
        return si(S) ? {
          saveQuery: !1
        } : T({}, S, {
          sectionValue: x(S.sectionValue, w)
        });
      }
      return {
        saveQuery: !1
      };
    };
    return c(p, (v, g) => {
      switch (g.type) {
        case "month": {
          const b = (x) => $S(o, x, o.formats.month, g.format);
          return y(v, g, o.formats.month, b);
        }
        case "weekDay": {
          const b = (x, O) => O.indexOf(x).toString();
          return y(v, g, o.formats.weekday, b);
        }
        case "meridiem":
          return y(v, g);
        default:
          return {
            saveQuery: !1
          };
      }
    });
  }, d = (p) => {
    const m = (h, v, g, b, x) => {
      const O = +`${h}`, w = r[v]({
        currentDate: null,
        format: g,
        contentType: x
      });
      if (O > w.maximum)
        return {
          saveQuery: !1
        };
      if (O < w.minimum)
        return {
          saveQuery: !0
        };
      const S = +`${h}0` > w.maximum || h.length === w.maximum.toString().length;
      return {
        sectionValue: gb(o, O, v, g, b, w),
        shouldGoToNextSection: S
      };
    };
    return c(p, (h, v) => {
      if (v.contentType === "digit")
        return m(h, v.type, v.format, v.hasLeadingZeros, v.contentType);
      if (v.type === "month") {
        const g = m(h, v.type, "MM", XD(o, "digit", "month", "MM"), "digit");
        if (si(g))
          return g;
        const b = $S(o, g.sectionValue, "MM", v.format);
        return T({}, g, {
          sectionValue: b
        });
      }
      if (v.type === "weekDay") {
        const g = m(h, v.type, v.format, v.hasLeadingZeros, v.contentType);
        if (si(g))
          return g;
        const b = Hp(o, v.format)[Number(g.sectionValue) - 1];
        return T({}, g, {
          sectionValue: b
        });
      }
      return {
        saveQuery: !1
      };
    }, (h) => !Number.isNaN(Number(h)));
  };
  return {
    applyCharacterEditing: gt((p) => {
      const m = e[p.sectionIndex], h = !Number.isNaN(Number(p.keyPressed)) ? d(p) : u(p);
      h == null ? n(null) : t({
        activeSection: m,
        newSectionValue: h.sectionValue,
        shouldGoToNextSection: h.shouldGoToNextSection
      });
    }),
    resetCharacterQuery: l
  };
}, Aie = ["onClick", "onKeyDown", "onFocus", "onBlur", "onMouseUp", "onPaste", "error"], aI = (e) => {
  const t = wt(), {
    state: r,
    selectedSectionIndexes: n,
    setSelectedSections: o,
    clearValue: a,
    clearActiveSection: i,
    updateSectionValue: l,
    updateValueFromValueStr: c,
    setTempAndroidValueStr: u,
    sectionsValueBoundaries: d,
    placeholder: f
  } = Nie(e), {
    applyCharacterEditing: p,
    resetCharacterQuery: m
  } = Mie({
    sections: r.sections,
    updateSectionValue: l,
    sectionsValueBoundaries: d,
    setTempAndroidValueStr: u
  }), {
    inputRef: y,
    internalProps: h,
    internalProps: {
      readOnly: v = !1,
      unstableFieldRef: g
    },
    forwardedProps: {
      onClick: b,
      onKeyDown: x,
      onFocus: O,
      onBlur: w,
      onMouseUp: S,
      onPaste: E,
      error: C
    },
    fieldValueManager: N,
    valueManager: $,
    validator: j
  } = e, A = ge(e.forwardedProps, Aie), k = P.useRef(null), R = Mb(y, k), D = P.useRef(void 0), B = Nr().direction === "rtl", H = P.useMemo(() => Jte(r.sections, B), [r.sections, B]), U = () => {
    var se;
    if (v) {
      o(null);
      return;
    }
    const re = (se = k.current.selectionStart) != null ? se : 0, le = re <= r.sections[0].startInInput ? 1 : r.sections.findIndex((W) => W.startInInput - W.startSeparator.length > re), M = le === -1 ? r.sections.length - 1 : le - 1;
    o(M);
  }, I = gt((...se) => {
    b == null || b(...se), U();
  }), V = gt((se) => {
    S == null || S(se), se.preventDefault();
  }), G = gt((...se) => {
    O == null || O(...se);
    const re = k.current;
    clearTimeout(D.current), D.current = setTimeout(() => {
      !re || re !== k.current || n != null || v || (// avoid selecting all sections when focusing empty field without value
      re.value.length && Number(re.selectionEnd) - Number(re.selectionStart) === re.value.length ? o("all") : U());
    });
  }), q = gt((...se) => {
    w == null || w(...se), o(null);
  }), J = gt((se) => {
    if (E == null || E(se), v) {
      se.preventDefault();
      return;
    }
    const re = se.clipboardData.getData("text");
    if (n && n.startIndex === n.endIndex) {
      const le = r.sections[n.startIndex], M = /^[a-zA-Z]+$/.test(re), W = /^[0-9]+$/.test(re);
      if (le.contentType === "letter" && M || le.contentType === "digit" && W)
        return;
      if (M || W) {
        se.preventDefault();
        return;
      }
    }
    se.preventDefault(), c(re);
  }), ne = gt((se) => {
    if (v)
      return;
    const re = se.target.value, le = Us(re);
    if (n == null) {
      c(le);
      return;
    }
    let M;
    if (n.startIndex === 0 && n.endIndex === r.sections.length - 1)
      M = le;
    else {
      const W = Us(N.getValueStrFromSections(r.sections, B));
      let Z = -1, he = -1;
      for (let Oe = 0; Oe < W.length; Oe += 1)
        Z === -1 && W[Oe] !== le[Oe] && (Z = Oe), he === -1 && W[W.length - Oe - 1] !== le[le.length - Oe - 1] && (he = Oe);
      const me = r.sections[n.startIndex];
      if (Z < me.start || W.length - he - 1 > me.end)
        return;
      const ue = le.length - W.length + me.end - Us(me.endSeparator || "").length;
      M = le.slice(me.start, ue);
    }
    if (Qte() && M.length === 0) {
      u(re);
      return;
    }
    p({
      keyPressed: M,
      sectionIndex: n.startIndex
    });
  }), te = gt((se) => {
    switch (x == null || x(se), !0) {
      case (se.key === "a" && (se.ctrlKey || se.metaKey)): {
        se.preventDefault(), o("all");
        break;
      }
      case se.key === "ArrowRight": {
        if (se.preventDefault(), n == null)
          o(H.startIndex);
        else if (n.startIndex !== n.endIndex)
          o(n.endIndex);
        else {
          const re = H.neighbors[n.startIndex].rightIndex;
          re !== null && o(re);
        }
        break;
      }
      case se.key === "ArrowLeft": {
        if (se.preventDefault(), n == null)
          o(H.endIndex);
        else if (n.startIndex !== n.endIndex)
          o(n.startIndex);
        else {
          const re = H.neighbors[n.startIndex].leftIndex;
          re !== null && o(re);
        }
        break;
      }
      case ["Backspace", "Delete"].includes(se.key): {
        if (se.preventDefault(), v)
          break;
        n == null || n.startIndex === 0 && n.endIndex === r.sections.length - 1 ? a() : i(), m();
        break;
      }
      case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(se.key): {
        if (se.preventDefault(), v || n == null)
          break;
        const re = r.sections[n.startIndex], le = N.getActiveDateManager(t, r, re), M = Hte(t, re, se.key, d, le.date);
        l({
          activeSection: re,
          newSectionValue: M,
          shouldGoToNextSection: !1
        });
        break;
      }
    }
  });
  Mv(() => {
    if (n == null) {
      k.current.scrollLeft && (k.current.scrollLeft = 0);
      return;
    }
    const se = r.sections[n.startIndex], re = r.sections[n.endIndex];
    let le = se.startInInput, M = re.endInInput;
    if (n.shouldSelectBoundarySelectors && (le -= se.startSeparator.length, M += re.endSeparator.length), le !== k.current.selectionStart || M !== k.current.selectionEnd) {
      const W = k.current.scrollTop;
      k.current.setSelectionRange(le, M), k.current.scrollTop = W;
    }
  });
  const ee = rI(T({}, h, {
    value: r.value
  }), j, $.isSameError, $.defaultErrorState), K = P.useMemo(() => C !== void 0 ? C : $.hasError(ee), [$, ee, C]);
  P.useEffect(() => (k.current && k.current === document.activeElement && o("all"), () => window.clearTimeout(D.current)), []), P.useEffect(() => {
    r.tempValueStrAndroid != null && n != null && (m(), i());
  }, [r.tempValueStrAndroid]);
  const Q = P.useMemo(() => {
    var se;
    return (se = r.tempValueStrAndroid) != null ? se : N.getValueStrFromSections(r.sections, B);
  }, [r.sections, N, r.tempValueStrAndroid, B]), ae = P.useMemo(() => n == null || r.sections[n.startIndex].contentType === "letter" ? "text" : "tel", [n, r.sections]), oe = !(k.current && k.current === Ib(document)) && $.areValuesEqual(t, r.value, $.emptyValue);
  return P.useImperativeHandle(g, () => ({
    getSections: () => r.sections,
    getActiveSectionIndex: () => {
      var se, re;
      const le = (se = k.current.selectionStart) != null ? se : 0, M = (re = k.current.selectionEnd) != null ? re : 0;
      if (le === 0 && M === 0)
        return null;
      const W = le <= r.sections[0].startInInput ? 1 : r.sections.findIndex((Z) => Z.startInInput - Z.startSeparator.length > le);
      return W === -1 ? r.sections.length - 1 : W - 1;
    },
    setSelectedSections: (se) => o(se)
  })), T({
    placeholder: f,
    autoComplete: "off"
  }, A, {
    value: oe ? "" : Q,
    inputMode: ae,
    readOnly: v,
    onClick: I,
    onFocus: G,
    onBlur: q,
    onPaste: J,
    onChange: ne,
    onKeyDown: te,
    onMouseUp: V,
    error: K,
    ref: R
  });
}, jie = ({
  open: e,
  onOpen: t,
  onClose: r
}) => {
  const n = P.useRef(typeof e == "boolean").current, [o, a] = P.useState(!1);
  P.useEffect(() => {
    if (n) {
      if (typeof e != "boolean")
        throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
      a(e);
    }
  }, [n, e]);
  const i = P.useCallback((l) => {
    n || a(l), l && t && t(), !l && r && r();
  }, [n, t, r]);
  return {
    isOpen: o,
    setIsOpen: i
  };
}, Fie = ({
  props: e,
  valueManager: t,
  wrapperVariant: r,
  validator: n
}) => {
  const {
    onAccept: o,
    onChange: a,
    value: i,
    defaultValue: l,
    closeOnSelect: c = r === "desktop",
    selectedSections: u,
    onSelectedSectionsChange: d
  } = e, f = wt(), p = Ha(), [m, y] = Wr({
    controlled: i,
    default: l ?? t.emptyValue,
    name: "usePickerValue",
    state: "value"
  }), [h, v] = Wr({
    controlled: u,
    default: null,
    name: "usePickerValue",
    state: "selectedSections"
  }), {
    isOpen: g,
    setIsOpen: b
  } = jie(e), [x, O] = P.useState(() => ({
    committed: m,
    draft: m,
    resetFallback: m
  }));
  rI(T({}, e, {
    value: m
  }), n, t.isSameError, t.defaultErrorState);
  const w = gt((G) => {
    if (O((q) => {
      switch (G.action) {
        case "setAll":
        case "acceptAndClose":
          return {
            draft: G.value,
            committed: G.value,
            resetFallback: G.value
          };
        case "setCommitted":
          return T({}, q, {
            draft: G.value,
            committed: G.value
          });
        case "setDraft":
          return T({}, q, {
            draft: G.value
          });
        default:
          return q;
      }
    }), !G.skipOnChangeCall && !t.areValuesEqual(f, x.committed, G.value) && (y(G.value), a)) {
      const q = {
        validationError: G.contextFromField == null ? n({
          adapter: p,
          value: G.value,
          props: T({}, e, {
            value: G.value
          })
        }) : G.contextFromField.validationError
      };
      a(G.value, q);
    }
    G.action === "acceptAndClose" && (b(!1), o && !t.areValuesEqual(f, x.resetFallback, G.value) && o(G.value));
  });
  P.useEffect(() => {
    g && w({
      action: "setAll",
      value: m,
      skipOnChangeCall: !0
    });
  }, [g]), t.areValuesEqual(f, x.committed, m) || w({
    action: "setCommitted",
    value: m,
    skipOnChangeCall: !0
  });
  const S = gt(() => {
    w({
      value: t.emptyValue,
      action: "acceptAndClose"
    });
  }), E = gt(() => {
    w({
      value: x.draft,
      action: "acceptAndClose"
    });
  }), C = gt(() => {
    w({
      value: x.committed,
      action: "acceptAndClose"
    });
  }), N = gt(() => {
    w({
      value: x.resetFallback,
      action: "acceptAndClose"
    });
  }), $ = gt(() => {
    w({
      value: t.getTodayValue(f),
      action: "acceptAndClose"
    });
  }), j = gt(() => b(!0)), A = gt(() => b(!1)), k = gt((G, q = "partial") => {
    switch (q) {
      case "shallow":
        return w({
          action: "setDraft",
          value: G,
          skipOnChangeCall: !0
        });
      case "partial":
        return w({
          action: "setDraft",
          value: G
        });
      case "finish":
        return w(c ? {
          value: G,
          action: "acceptAndClose"
        } : {
          value: G,
          action: "setCommitted"
        });
      default:
        throw new Error("MUI: Invalid selectionState passed to `onDateChange`");
    }
  }), R = gt((G, q) => w({
    action: "setCommitted",
    value: G,
    contextFromField: q
  })), D = gt((G) => {
    v(G), d == null || d(G);
  }), L = {
    onClear: S,
    onAccept: E,
    onDismiss: C,
    onCancel: N,
    onSetToday: $,
    onOpen: j,
    onClose: A
  }, B = {
    value: x.draft,
    onChange: R,
    selectedSections: h,
    onSelectedSectionsChange: D
  }, H = P.useMemo(() => t.cleanValue(f, x.draft), [f, t, x.draft]), U = {
    value: H,
    onChange: k,
    onClose: A,
    open: g,
    onSelectedSectionsChange: D
  }, V = T({}, L, {
    value: H,
    onChange: R,
    isValid: (G) => {
      const q = n({
        adapter: p,
        value: G,
        props: T({}, e, {
          value: G
        })
      });
      return !t.hasError(q);
    }
  });
  return {
    open: g,
    fieldProps: B,
    viewProps: U,
    layoutProps: V,
    actions: L
  };
};
let fh = !1;
function Ab({
  onChange: e,
  onViewChange: t,
  openTo: r,
  view: n,
  views: o,
  autoFocus: a,
  focusedView: i,
  onFocusedViewChange: l
}) {
  var c, u;
  process.env.NODE_ENV !== "production" && (fh || (n != null && !o.includes(n) && (console.warn(`MUI: \`view="${n}"\` is not a valid prop.`, `It must be an element of \`views=["${o.join('", "')}"]\`.`), fh = !0), n == null && r != null && !o.includes(r) && (console.warn(`MUI: \`openTo="${r}"\` is not a valid prop.`, `It must be an element of \`views=["${o.join('", "')}"]\`.`), fh = !0)));
  const d = P.useRef(r), f = P.useRef(o), p = P.useRef(o.includes(r) ? r : o[0]), [m, y] = Wr({
    name: "useViews",
    state: "view",
    controlled: n,
    default: p.current
  }), h = P.useRef(a ? m : null), [v, g] = Wr({
    name: "useViews",
    state: "focusedView",
    controlled: i,
    default: h.current
  });
  P.useEffect(() => {
    (d.current && d.current !== r || f.current && f.current.some((N) => !o.includes(N))) && y(o.includes(r) ? r : o[0]);
  }, [r, y, m, o]);
  const b = o.indexOf(m), x = (c = o[b - 1]) != null ? c : null, O = (u = o[b + 1]) != null ? u : null, w = gt((N) => {
    y(N), t && t(N);
  }), S = gt(() => {
    O && w(O);
  }), E = gt((N, $) => {
    const j = $ === "finish";
    e(N, j && O ? "partial" : $), j && S();
  }), C = gt((N, $) => {
    g($ ? N : (j) => N === j ? null : j), l == null || l(N, $);
  });
  return {
    view: m,
    setView: w,
    focusedView: v,
    setFocusedView: C,
    nextView: O,
    previousView: x,
    defaultView: p.current,
    goToNextView: S,
    setValueAndGoToNextView: E
  };
}
const Lie = (e) => ["hours", "minutes", "seconds"].includes(e), Vie = (e, t) => e ? t.getHours(e) >= 12 ? "pm" : "am" : null, Av = (e, t, r) => r && (e >= 12 ? "pm" : "am") !== t ? t === "am" ? e - 12 : e + 12 : e, zie = (e, t, r, n) => {
  const o = Av(n.getHours(e), t, r);
  return n.setHours(e, o);
}, a1 = (e, t) => t.getHours(e) * 3600 + t.getMinutes(e) * 60 + t.getSeconds(e), iI = (e, t) => (r, n) => e ? t.isAfter(r, n) : a1(r, t) > a1(n, t), Bie = ["className", "sx"], Wie = ({
  props: e,
  propsFromPickerValue: t,
  additionalViewProps: r,
  inputRef: n,
  autoFocusView: o
}) => {
  const {
    onChange: a,
    open: i,
    onSelectedSectionsChange: l,
    onClose: c
  } = t, {
    views: u,
    openTo: d,
    onViewChange: f,
    disableOpenPicker: p,
    viewRenderers: m
  } = e, y = ge(e, Bie), {
    view: h,
    setView: v,
    defaultView: g,
    focusedView: b,
    setFocusedView: x,
    setValueAndGoToNextView: O
  } = Ab({
    view: void 0,
    views: u,
    openTo: d,
    onChange: a,
    onViewChange: f,
    autoFocus: o
  }), {
    hasUIView: w,
    viewModeLookup: S
  } = P.useMemo(() => u.reduce((k, R) => {
    let D;
    return p ? D = "field" : m[R] != null ? D = "UI" : D = "field", k.viewModeLookup[R] = D, D === "UI" && (k.hasUIView = !0), k;
  }, {
    hasUIView: !1,
    viewModeLookup: {}
  }), [p, m, u]), E = P.useMemo(() => u.reduce((R, D) => m[D] != null && Lie(D) ? R + 1 : R, 0) > 1, [m, u]), C = S[h], N = gt(() => C === "UI"), [$, j] = P.useState(C === "UI" ? h : null);
  return $ !== h && S[h] === "UI" && j(h), Mv(() => {
    C === "field" && i && (c(), l("hours"), setTimeout(() => {
      n == null || n.current.focus();
    }));
  }, [h]), Mv(() => {
    if (!i)
      return;
    let k = h;
    C === "field" && $ != null && (k = $), k !== g && S[k] === "UI" && S[g] === "UI" && (k = g), k !== h && v(k), x(k, !0);
  }, [i]), {
    hasUIView: w,
    shouldRestoreFocus: N,
    layoutProps: {
      views: u,
      view: $,
      onViewChange: v
    },
    renderCurrentView: () => {
      if ($ == null)
        return null;
      const k = m[$];
      return k == null ? null : k(T({}, y, r, t, {
        views: u,
        onChange: O,
        view: $,
        onViewChange: v,
        focusedView: b,
        onFocusedViewChange: x,
        showViewSwitcher: E
      }));
    }
  };
};
function i1() {
  return typeof window > "u" ? "portrait" : window.screen && window.screen.orientation && window.screen.orientation.angle ? Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait" : window.orientation && Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
}
const Uie = (e, t) => {
  const [r, n] = P.useState(i1);
  return wr(() => {
    const a = () => {
      n(i1());
    };
    return window.addEventListener("orientationchange", a), () => {
      window.removeEventListener("orientationchange", a);
    };
  }, []), Xae(e, ["hours", "minutes", "seconds"]) ? !1 : (t || r) === "landscape";
}, Hie = ({
  props: e,
  propsFromPickerValue: t,
  propsFromPickerViews: r,
  wrapperVariant: n
}) => {
  const {
    orientation: o
  } = e, a = Uie(r.views, o);
  return {
    layoutProps: T({}, r, t, {
      isLandscape: a,
      wrapperVariant: n,
      disabled: e.disabled,
      readOnly: e.readOnly
    })
  };
}, Yie = (e, t = "warning") => {
  let r = !1;
  const n = Array.isArray(e) ? e.join(`
`) : e;
  return () => {
    r || (r = !0, t === "error" ? console.error(n) : console.warn(n));
  };
}, qie = Yie(["The `renderInput` prop has been removed in version 6.0 of the Date and Time Pickers.", "You can replace it with the `textField` component slot in most cases.", "For more information, please have a look at the migration guide (https://mui.com/x/migration/migration-pickers-v5/#input-renderer-required-in-v5)."]), sI = ({
  props: e,
  valueManager: t,
  wrapperVariant: r,
  inputRef: n,
  additionalViewProps: o,
  validator: a,
  autoFocusView: i
}) => {
  process.env.NODE_ENV !== "production" && e.renderInput != null && qie();
  const l = Fie({
    props: e,
    valueManager: t,
    wrapperVariant: r,
    validator: a
  }), c = Wie({
    props: e,
    inputRef: n,
    additionalViewProps: o,
    autoFocusView: i,
    propsFromPickerValue: l.viewProps
  }), u = Hie({
    props: e,
    wrapperVariant: r,
    propsFromPickerValue: l.layoutProps,
    propsFromPickerViews: c.layoutProps
  });
  return {
    // Picker value
    open: l.open,
    actions: l.actions,
    fieldProps: l.fieldProps,
    // Picker views
    renderCurrentView: c.renderCurrentView,
    hasUIView: c.hasUIView,
    shouldRestoreFocus: c.shouldRestoreFocus,
    // Picker layout
    layoutProps: u.layoutProps
  };
};
function lI(e) {
  return ze("MuiPickersLayout", e);
}
const ph = Le("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "shortcuts"]);
function Gie(e) {
  return ze("MuiDialogActions", e);
}
Le("MuiDialogActions", ["root", "spacing"]);
const Kie = ["className", "disableSpacing"], Xie = (e) => {
  const {
    classes: t,
    disableSpacing: r
  } = e;
  return Ve({
    root: ["root", !r && "spacing"]
  }, Gie, t);
}, Qie = ce("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.disableSpacing && t.spacing];
  }
})(({
  ownerState: e
}) => T({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !e.disableSpacing && {
  "& > :not(:first-of-type)": {
    marginLeft: 8
  }
})), cI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDialogActions"
  }), {
    className: o,
    disableSpacing: a = !1
  } = n, i = ge(n, Kie), l = T({}, n, {
    disableSpacing: a
  }), c = Xie(l);
  return /* @__PURE__ */ _.jsx(Qie, T({
    className: Pe(c.root, o),
    ownerState: l,
    ref: r
  }, i));
});
process.env.NODE_ENV !== "production" && (cI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, the actions do not have additional margin.
   * @default false
   */
  disableSpacing: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const Zie = cI, Jie = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
function uI(e) {
  const {
    onAccept: t,
    onClear: r,
    onCancel: n,
    onSetToday: o,
    actions: a
  } = e, i = ge(e, Jie), l = Yr();
  if (a == null || a.length === 0)
    return null;
  const c = a == null ? void 0 : a.map((u) => {
    switch (u) {
      case "clear":
        return /* @__PURE__ */ _.jsx(Is, {
          onClick: r,
          children: l.clearButtonLabel
        }, u);
      case "cancel":
        return /* @__PURE__ */ _.jsx(Is, {
          onClick: n,
          children: l.cancelButtonLabel
        }, u);
      case "accept":
        return /* @__PURE__ */ _.jsx(Is, {
          onClick: t,
          children: l.okButtonLabel
        }, u);
      case "today":
        return /* @__PURE__ */ _.jsx(Is, {
          onClick: o,
          children: l.todayButtonLabel
        }, u);
      default:
        return null;
    }
  });
  return /* @__PURE__ */ _.jsx(Zie, T({}, i, {
    children: c
  }));
}
process.env.NODE_ENV !== "production" && (uI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Ordered array of actions to display.
   * If empty, does not display that action bar.
   * @default `['cancel', 'accept']` for mobile and `[]` for desktop
   */
  actions: s.arrayOf(s.oneOf(["accept", "cancel", "clear", "today"]).isRequired),
  /**
   * If `true`, the actions do not have additional margin.
   * @default false
   */
  disableSpacing: s.bool,
  onAccept: s.func.isRequired,
  onCancel: s.func.isRequired,
  onClear: s.func.isRequired,
  onSetToday: s.func.isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const dI = /* @__PURE__ */ P.createContext({});
process.env.NODE_ENV !== "production" && (dI.displayName = "ListContext");
const Ea = dI;
function ese(e) {
  return ze("MuiList", e);
}
Le("MuiList", ["root", "padding", "dense", "subheader"]);
const tse = ["children", "className", "component", "dense", "disablePadding", "subheader"], rse = (e) => {
  const {
    classes: t,
    disablePadding: r,
    dense: n,
    subheader: o
  } = e;
  return Ve({
    root: ["root", !r && "padding", n && "dense", o && "subheader"]
  }, ese, t);
}, nse = ce("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.disablePadding && t.padding, r.dense && t.dense, r.subheader && t.subheader];
  }
})(({
  ownerState: e
}) => T({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !e.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, e.subheader && {
  paddingTop: 0
})), fI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiList"
  }), {
    children: o,
    className: a,
    component: i = "ul",
    dense: l = !1,
    disablePadding: c = !1,
    subheader: u
  } = n, d = ge(n, tse), f = P.useMemo(() => ({
    dense: l
  }), [l]), p = T({}, n, {
    component: i,
    dense: l,
    disablePadding: c
  }), m = rse(p);
  return /* @__PURE__ */ _.jsx(Ea.Provider, {
    value: f,
    children: /* @__PURE__ */ _.jsxs(nse, T({
      as: i,
      className: Pe(m.root, a),
      ref: r,
      ownerState: p
    }, d, {
      children: [u, o]
    }))
  });
});
process.env.NODE_ENV !== "production" && (fI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: s.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: s.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const pI = fI;
function ose(e) {
  return ze("MuiListItem", e);
}
const ase = Le("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]), di = ase, ise = Le("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]), sse = ise;
function lse(e) {
  return ze("MuiListItemSecondaryAction", e);
}
Le("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const cse = ["className"], use = (e) => {
  const {
    disableGutters: t,
    classes: r
  } = e;
  return Ve({
    root: ["root", t && "disableGutters"]
  }, lse, r);
}, dse = ce("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.disableGutters && t.disableGutters];
  }
})(({
  ownerState: e
}) => T({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)"
}, e.disableGutters && {
  right: 0
})), jb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiListItemSecondaryAction"
  }), {
    className: o
  } = n, a = ge(n, cse), i = P.useContext(Ea), l = T({}, n, {
    disableGutters: i.disableGutters
  }), c = use(l);
  return /* @__PURE__ */ _.jsx(dse, T({
    className: Pe(c.root, o),
    ownerState: l,
    ref: r
  }, a));
});
process.env.NODE_ENV !== "production" && (jb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally an `IconButton` or selection control.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
jb.muiName = "ListItemSecondaryAction";
const fse = jb, pse = ["className"], mse = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"], hse = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.dense && t.dense, r.alignItems === "flex-start" && t.alignItemsFlexStart, r.divider && t.divider, !r.disableGutters && t.gutters, !r.disablePadding && t.padding, r.button && t.button, r.hasSecondaryAction && t.secondaryAction];
}, yse = (e) => {
  const {
    alignItems: t,
    button: r,
    classes: n,
    dense: o,
    disabled: a,
    disableGutters: i,
    disablePadding: l,
    divider: c,
    hasSecondaryAction: u,
    selected: d
  } = e;
  return Ve({
    root: ["root", o && "dense", !i && "gutters", !l && "padding", c && "divider", a && "disabled", r && "button", t === "flex-start" && "alignItemsFlexStart", u && "secondaryAction", d && "selected"],
    container: ["container"]
  }, ose, n);
}, vse = ce("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: hse
})(({
  theme: e,
  ownerState: t
}) => T({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left"
}, !t.disablePadding && T({
  paddingTop: 8,
  paddingBottom: 8
}, t.dense && {
  paddingTop: 4,
  paddingBottom: 4
}, !t.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, !!t.secondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}), !!t.secondaryAction && {
  [`& > .${sse.root}`]: {
    paddingRight: 48
  }
}, {
  [`&.${di.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${di.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : dt(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${di.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : dt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${di.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  }
}, t.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, t.divider && {
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
  backgroundClip: "padding-box"
}, t.button && {
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${di.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : dt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : dt(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  }
}, t.hasSecondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
})), gse = ce("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (e, t) => t.container
})({
  position: "relative"
}), mI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiListItem"
  }), {
    alignItems: o = "center",
    autoFocus: a = !1,
    button: i = !1,
    children: l,
    className: c,
    component: u,
    components: d = {},
    componentsProps: f = {},
    ContainerComponent: p = "li",
    ContainerProps: {
      className: m
    } = {},
    dense: y = !1,
    disabled: h = !1,
    disableGutters: v = !1,
    disablePadding: g = !1,
    divider: b = !1,
    focusVisibleClassName: x,
    secondaryAction: O,
    selected: w = !1,
    slotProps: S = {},
    slots: E = {}
  } = n, C = ge(n.ContainerProps, pse), N = ge(n, mse), $ = P.useContext(Ea), j = P.useMemo(() => ({
    dense: y || $.dense || !1,
    alignItems: o,
    disableGutters: v
  }), [o, $.dense, y, v]), A = P.useRef(null);
  wr(() => {
    a && (A.current ? A.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a ListItem whose component has not been rendered."));
  }, [a]);
  const k = P.Children.toArray(l), R = k.length && As(k[k.length - 1], ["ListItemSecondaryAction"]), D = T({}, n, {
    alignItems: o,
    autoFocus: a,
    button: i,
    dense: j.dense,
    disabled: h,
    disableGutters: v,
    disablePadding: g,
    divider: b,
    hasSecondaryAction: R,
    selected: w
  }), L = yse(D), B = Lt(A, r), H = E.root || d.Root || vse, U = S.root || f.root || {}, I = T({
    className: Pe(L.root, U.className, c),
    disabled: h
  }, N);
  let V = u || "li";
  return i && (I.component = u || "div", I.focusVisibleClassName = Pe(di.focusVisible, x), V = bo), R ? (V = !I.component && !u ? "div" : V, p === "li" && (V === "li" ? V = "div" : I.component === "li" && (I.component = "div")), /* @__PURE__ */ _.jsx(Ea.Provider, {
    value: j,
    children: /* @__PURE__ */ _.jsxs(gse, T({
      as: p,
      className: Pe(L.container, m),
      ref: B,
      ownerState: D
    }, C, {
      children: [/* @__PURE__ */ _.jsx(H, T({}, U, !Ia(H) && {
        as: V,
        ownerState: T({}, D, U.ownerState)
      }, I, {
        children: k
      })), k.pop()]
    }))
  })) : /* @__PURE__ */ _.jsx(Ea.Provider, {
    value: j,
    children: /* @__PURE__ */ _.jsxs(H, T({}, U, {
      as: V,
      ref: B
    }, !Ia(H) && {
      ownerState: T({}, D, U.ownerState)
    }, I, {
      children: [k, O && /* @__PURE__ */ _.jsx(fse, {
        children: O
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" && (mI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Defines the `align-items` style property.
   * @default 'center'
   */
  alignItems: s.oneOf(["center", "flex-start"]),
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  autoFocus: s.bool,
  /**
   * If `true`, the list item is a button (using `ButtonBase`). Props intended
   * for `ButtonBase` can then be applied to `ListItem`.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  button: s.bool,
  /**
   * The content of the component if a `ListItemSecondaryAction` is used it must
   * be the last child.
   */
  children: xo(s.node, (e) => {
    const t = P.Children.toArray(e.children);
    let r = -1;
    for (let n = t.length - 1; n >= 0; n -= 1) {
      const o = t[n];
      if (As(o, ["ListItemSecondaryAction"])) {
        r = n;
        break;
      }
    }
    return r !== -1 && r !== t.length - 1 ? new Error("MUI: You used an element after ListItemSecondaryAction. For ListItem to detect that it has a secondary action you must pass it as the last child to ListItem.") : null;
  }),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    root: s.object
  }),
  /**
   * The container component used when a `ListItemSecondaryAction` is the last child.
   * @default 'li'
   * @deprecated
   */
  ContainerComponent: ep,
  /**
   * Props applied to the container component if used.
   * @default {}
   * @deprecated
   */
  ContainerProps: s.object,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent List component.
   * @default false
   */
  dense: s.bool,
  /**
   * If `true`, the component is disabled.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  disabled: s.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: s.bool,
  /**
   * If `true`, all padding is removed.
   * @default false
   */
  disablePadding: s.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the list item.
   * @default false
   */
  divider: s.bool,
  /**
   * @ignore
   */
  focusVisibleClassName: s.string,
  /**
   * The element to display at the end of ListItem.
   */
  secondaryAction: s.node,
  /**
   * Use to apply selected styling.
   * @default false
   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead
   */
  selected: s.bool,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: s.shape({
    root: s.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    root: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const bse = mI, wse = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function xse(e) {
  return ze("MuiChip", e);
}
const _se = Le("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]), pt = _se, Ose = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"], Pse = (e) => {
  const {
    classes: t,
    disabled: r,
    size: n,
    color: o,
    iconColor: a,
    onDelete: i,
    clickable: l,
    variant: c
  } = e, u = {
    root: ["root", c, r && "disabled", `size${Te(n)}`, `color${Te(o)}`, l && "clickable", l && `clickableColor${Te(o)}`, i && "deletable", i && `deletableColor${Te(o)}`, `${c}${Te(o)}`],
    label: ["label", `label${Te(n)}`],
    avatar: ["avatar", `avatar${Te(n)}`, `avatarColor${Te(o)}`],
    icon: ["icon", `icon${Te(n)}`, `iconColor${Te(a)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${Te(n)}`, `deleteIconColor${Te(o)}`, `deleteIcon${Te(c)}Color${Te(o)}`]
  };
  return Ve(u, xse, t);
}, Sse = ce("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e, {
      color: n,
      iconColor: o,
      clickable: a,
      onDelete: i,
      size: l,
      variant: c
    } = r;
    return [{
      [`& .${pt.avatar}`]: t.avatar
    }, {
      [`& .${pt.avatar}`]: t[`avatar${Te(l)}`]
    }, {
      [`& .${pt.avatar}`]: t[`avatarColor${Te(n)}`]
    }, {
      [`& .${pt.icon}`]: t.icon
    }, {
      [`& .${pt.icon}`]: t[`icon${Te(l)}`]
    }, {
      [`& .${pt.icon}`]: t[`iconColor${Te(o)}`]
    }, {
      [`& .${pt.deleteIcon}`]: t.deleteIcon
    }, {
      [`& .${pt.deleteIcon}`]: t[`deleteIcon${Te(l)}`]
    }, {
      [`& .${pt.deleteIcon}`]: t[`deleteIconColor${Te(n)}`]
    }, {
      [`& .${pt.deleteIcon}`]: t[`deleteIcon${Te(c)}Color${Te(n)}`]
    }, t.root, t[`size${Te(l)}`], t[`color${Te(n)}`], a && t.clickable, a && n !== "default" && t[`clickableColor${Te(n)})`], i && t.deletable, i && n !== "default" && t[`deletableColor${Te(n)}`], t[c], t[`${c}${Te(n)}`]];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  const r = e.palette.mode === "light" ? e.palette.grey[700] : e.palette.grey[300];
  return T({
    maxWidth: "100%",
    fontFamily: e.typography.fontFamily,
    fontSize: e.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (e.vars || e).palette.text.primary,
    backgroundColor: (e.vars || e).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: e.transitions.create(["background-color", "box-shadow"]),
    // label will inherit this from root, then `clickable` class overrides this for both
    cursor: "default",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${pt.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${pt.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: e.vars ? e.vars.palette.Chip.defaultAvatarColor : r,
      fontSize: e.typography.pxToRem(12)
    },
    [`& .${pt.avatarColorPrimary}`]: {
      color: (e.vars || e).palette.primary.contrastText,
      backgroundColor: (e.vars || e).palette.primary.dark
    },
    [`& .${pt.avatarColorSecondary}`]: {
      color: (e.vars || e).palette.secondary.contrastText,
      backgroundColor: (e.vars || e).palette.secondary.dark
    },
    [`& .${pt.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: e.typography.pxToRem(10)
    },
    [`& .${pt.icon}`]: T({
      marginLeft: 5,
      marginRight: -6
    }, t.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, t.iconColor === t.color && T({
      color: e.vars ? e.vars.palette.Chip.defaultIconColor : r
    }, t.color !== "default" && {
      color: "inherit"
    })),
    [`& .${pt.deleteIcon}`]: T({
      WebkitTapHighlightColor: "transparent",
      color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : dt(e.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : dt(e.palette.text.primary, 0.4)
      }
    }, t.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, t.color !== "default" && {
      color: e.vars ? `rgba(${e.vars.palette[t.color].contrastTextChannel} / 0.7)` : dt(e.palette[t.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (e.vars || e).palette[t.color].contrastText
      }
    })
  }, t.size === "small" && {
    height: 24
  }, t.color !== "default" && {
    backgroundColor: (e.vars || e).palette[t.color].main,
    color: (e.vars || e).palette[t.color].contrastText
  }, t.onDelete && {
    [`&.${pt.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : dt(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  }, t.onDelete && t.color !== "default" && {
    [`&.${pt.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette[t.color].dark
    }
  });
}, ({
  theme: e,
  ownerState: t
}) => T({}, t.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : dt(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
  },
  [`&.${pt.focusVisible}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : dt(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (e.vars || e).shadows[1]
  }
}, t.clickable && t.color !== "default" && {
  [`&:hover, &.${pt.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette[t.color].dark
  }
}), ({
  theme: e,
  ownerState: t
}) => T({}, t.variant === "outlined" && {
  backgroundColor: "transparent",
  border: e.vars ? `1px solid ${e.vars.palette.Chip.defaultBorder}` : `1px solid ${e.palette.mode === "light" ? e.palette.grey[400] : e.palette.grey[700]}`,
  [`&.${pt.clickable}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${pt.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`& .${pt.avatar}`]: {
    marginLeft: 4
  },
  [`& .${pt.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${pt.icon}`]: {
    marginLeft: 4
  },
  [`& .${pt.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${pt.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${pt.deleteIconSmall}`]: {
    marginRight: 3
  }
}, t.variant === "outlined" && t.color !== "default" && {
  color: (e.vars || e).palette[t.color].main,
  border: `1px solid ${e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : dt(e.palette[t.color].main, 0.7)}`,
  [`&.${pt.clickable}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette[t.color].main, e.palette.action.hoverOpacity)
  },
  [`&.${pt.focusVisible}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.focusOpacity})` : dt(e.palette[t.color].main, e.palette.action.focusOpacity)
  },
  [`& .${pt.deleteIcon}`]: {
    color: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / 0.7)` : dt(e.palette[t.color].main, 0.7),
    "&:hover, &:active": {
      color: (e.vars || e).palette[t.color].main
    }
  }
})), Tse = ce("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e, {
      size: n
    } = r;
    return [t.label, t[`label${Te(n)}`]];
  }
})(({
  ownerState: e
}) => T({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, e.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}));
function s1(e) {
  return e.key === "Backspace" || e.key === "Delete";
}
const hI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiChip"
  }), {
    avatar: o,
    className: a,
    clickable: i,
    color: l = "default",
    component: c,
    deleteIcon: u,
    disabled: d = !1,
    icon: f,
    label: p,
    onClick: m,
    onDelete: y,
    onKeyDown: h,
    onKeyUp: v,
    size: g = "medium",
    variant: b = "filled",
    tabIndex: x,
    skipFocusWhenDisabled: O = !1
  } = n, w = ge(n, Ose), S = P.useRef(null), E = Lt(S, r), C = (U) => {
    U.stopPropagation(), y && y(U);
  }, N = (U) => {
    U.currentTarget === U.target && s1(U) && U.preventDefault(), h && h(U);
  }, $ = (U) => {
    U.currentTarget === U.target && (y && s1(U) ? y(U) : U.key === "Escape" && S.current && S.current.blur()), v && v(U);
  }, j = i !== !1 && m ? !0 : i, A = j || y ? bo : c || "div", k = T({}, n, {
    component: A,
    disabled: d,
    size: g,
    color: l,
    iconColor: /* @__PURE__ */ P.isValidElement(f) && f.props.color || l,
    onDelete: !!y,
    clickable: j,
    variant: b
  }), R = Pse(k), D = A === bo ? T({
    component: c || "div",
    focusVisibleClassName: R.focusVisible
  }, y && {
    disableRipple: !0
  }) : {};
  let L = null;
  y && (L = u && /* @__PURE__ */ P.isValidElement(u) ? /* @__PURE__ */ P.cloneElement(u, {
    className: Pe(u.props.className, R.deleteIcon),
    onClick: C
  }) : /* @__PURE__ */ _.jsx(wse, {
    className: Pe(R.deleteIcon),
    onClick: C
  }));
  let B = null;
  o && /* @__PURE__ */ P.isValidElement(o) && (B = /* @__PURE__ */ P.cloneElement(o, {
    className: Pe(R.avatar, o.props.className)
  }));
  let H = null;
  return f && /* @__PURE__ */ P.isValidElement(f) && (H = /* @__PURE__ */ P.cloneElement(f, {
    className: Pe(R.icon, f.props.className)
  })), process.env.NODE_ENV !== "production" && B && H && console.error("MUI: The Chip component can not handle the avatar and the icon prop at the same time. Pick one."), /* @__PURE__ */ _.jsxs(Sse, T({
    as: A,
    className: Pe(R.root, a),
    disabled: j && d ? !0 : void 0,
    onClick: m,
    onKeyDown: N,
    onKeyUp: $,
    ref: E,
    tabIndex: O && d ? -1 : x,
    ownerState: k
  }, D, w, {
    children: [B || H, /* @__PURE__ */ _.jsx(Tse, {
      className: Pe(R.label),
      ownerState: k,
      children: p
    }), L]
  }));
});
process.env.NODE_ENV !== "production" && (hI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The Avatar element to display.
   */
  avatar: s.element,
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: UT,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, the chip will appear clickable, and will raise when pressed,
   * even if the onClick prop is not defined.
   * If `false`, the chip will not appear clickable, even if onClick prop is defined.
   * This can be used, for example,
   * along with the component prop to indicate an anchor Chip is clickable.
   * Note: this controls the UI and does not affect the onClick event.
   */
  clickable: s.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: s.oneOfType([s.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * Override the default delete icon element. Shown only if `onDelete` is set.
   */
  deleteIcon: s.element,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * Icon element.
   */
  icon: s.element,
  /**
   * The content of the component.
   */
  label: s.node,
  /**
   * @ignore
   */
  onClick: s.func,
  /**
   * Callback fired when the delete icon is clicked.
   * If set, the delete icon will be shown.
   */
  onDelete: s.func,
  /**
   * @ignore
   */
  onKeyDown: s.func,
  /**
   * @ignore
   */
  onKeyUp: s.func,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: s.oneOfType([s.oneOf(["medium", "small"]), s.string]),
  /**
   * If `true`, allows the disabled chip to escape focus.
   * If `false`, allows the disabled chip to receive focus.
   * @default false
   */
  skipFocusWhenDisabled: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * @ignore
   */
  tabIndex: s.number,
  /**
   * The variant to use.
   * @default 'filled'
   */
  variant: s.oneOfType([s.oneOf(["filled", "outlined"]), s.string])
});
const Ese = hI, $se = ["items", "isLandscape", "onChange", "isValid"];
function yI(e) {
  const {
    items: t,
    onChange: r,
    isValid: n
  } = e, o = ge(e, $se);
  if (t == null || t.length === 0)
    return null;
  const a = t.map((i) => {
    const l = i.getValue({
      isValid: n
    });
    return {
      label: i.label,
      onClick: () => {
        r(l);
      },
      disabled: !n(l)
    };
  });
  return /* @__PURE__ */ _.jsx(pI, T({
    dense: !0,
    sx: [{
      maxHeight: zN,
      maxWidth: 200,
      overflow: "auto"
    }, ...Array.isArray(o.sx) ? o.sx : [o.sx]]
  }, o, {
    children: a.map((i) => /* @__PURE__ */ _.jsx(bse, {
      children: /* @__PURE__ */ _.jsx(Ese, T({}, i))
    }, i.label))
  }));
}
process.env.NODE_ENV !== "production" && (yI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  className: s.string,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: s.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: s.bool,
  isLandscape: s.bool.isRequired,
  isValid: s.func.isRequired,
  /**
   * Ordered array of shortcuts to display.
   * If empty, does not display the shortcuts.
   * @default `[]`
   */
  items: s.arrayOf(s.shape({
    getValue: s.func.isRequired,
    label: s.string.isRequired
  })),
  onChange: s.func.isRequired,
  style: s.object,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
function Cse(e) {
  return e.view !== null;
}
const kse = (e) => {
  const {
    classes: t,
    isLandscape: r
  } = e;
  return Ve({
    root: ["root", r && "landscape"],
    contentWrapper: ["contentWrapper"],
    toolbar: ["toolbar"],
    actionBar: ["actionBar"],
    tabs: ["tabs"],
    landscape: ["landscape"],
    shortcuts: ["shortcuts"]
  }, lI, t);
}, Rse = (e) => {
  var t, r;
  const {
    wrapperVariant: n,
    onAccept: o,
    onClear: a,
    onCancel: i,
    onSetToday: l,
    view: c,
    views: u,
    onViewChange: d,
    value: f,
    onChange: p,
    isValid: m,
    isLandscape: y,
    disabled: h,
    readOnly: v,
    children: g,
    components: b,
    componentsProps: x,
    slots: O,
    slotProps: w
    // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
    // The true type should be
    // - For pickers value: TDate | null
    // - For rangepickers value: [TDate | null, TDate | null]
  } = e, S = O ?? Gp(b), E = w ?? x, C = kse(e), N = (t = S == null ? void 0 : S.actionBar) != null ? t : uI, $ = It({
    elementType: N,
    externalSlotProps: E == null ? void 0 : E.actionBar,
    additionalProps: {
      onAccept: o,
      onClear: a,
      onCancel: i,
      onSetToday: l,
      actions: n === "desktop" ? [] : ["cancel", "accept"],
      className: C.actionBar
    },
    ownerState: T({}, e, {
      wrapperVariant: n
    })
  }), j = /* @__PURE__ */ _.jsx(N, T({}, $)), A = S == null ? void 0 : S.toolbar, k = It({
    elementType: A,
    externalSlotProps: E == null ? void 0 : E.toolbar,
    additionalProps: {
      isLandscape: y,
      onChange: p,
      value: f,
      view: c,
      onViewChange: d,
      views: u,
      disabled: h,
      readOnly: v,
      className: C.toolbar
    },
    ownerState: T({}, e, {
      wrapperVariant: n
    })
  }), R = Cse(k) && A ? /* @__PURE__ */ _.jsx(A, T({}, k)) : null, D = g, L = S == null ? void 0 : S.tabs, B = c && L ? /* @__PURE__ */ _.jsx(L, T({
    view: c,
    onViewChange: d
  }, E == null ? void 0 : E.tabs)) : null, H = (r = S == null ? void 0 : S.shortcuts) != null ? r : yI, U = It({
    elementType: H,
    externalSlotProps: E == null ? void 0 : E.shortcuts,
    additionalProps: {
      isValid: m,
      isLandscape: y,
      onChange: p,
      className: C.shortcuts
    },
    ownerState: {
      isValid: m,
      isLandscape: y,
      onChange: p,
      className: C.shortcuts,
      wrapperVariant: n
    }
  }), I = c && H ? /* @__PURE__ */ _.jsx(H, T({}, U)) : null;
  return {
    toolbar: R,
    content: D,
    tabs: B,
    actionBar: j,
    shortcuts: I
  };
}, Dse = Rse, Nse = (e) => {
  const {
    isLandscape: t,
    classes: r
  } = e;
  return Ve({
    root: ["root", t && "landscape"],
    contentWrapper: ["contentWrapper"]
  }, lI, r);
}, vI = ce("div", {
  name: "MuiPickersLayout",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => ({
  display: "grid",
  gridAutoColumns: "max-content auto max-content",
  gridAutoRows: "max-content auto max-content",
  [`& .${ph.toolbar}`]: t.isLandscape ? {
    gridColumn: e.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  } : {
    gridColumn: "2 / 4",
    gridRow: 1
  },
  [`.${ph.shortcuts}`]: t.isLandscape ? {
    gridColumn: "2 / 4",
    gridRow: 1
  } : {
    gridColumn: e.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  },
  [`& .${ph.actionBar}`]: {
    gridColumn: "1 / 4",
    gridRow: 3
  }
}));
vI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: s.elementType,
  ownerState: s.shape({
    isLandscape: s.bool.isRequired
  }).isRequired,
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
};
const Ise = ce("div", {
  name: "MuiPickersLayout",
  slot: "ContentWrapper",
  overridesResolver: (e, t) => t.contentWrapper
})({
  gridColumn: 2,
  gridRow: 2,
  display: "flex",
  flexDirection: "column"
}), Fb = function(t) {
  const r = Ae({
    props: t,
    name: "MuiPickersLayout"
  }), {
    toolbar: n,
    content: o,
    tabs: a,
    actionBar: i,
    shortcuts: l
  } = Dse(r), {
    sx: c,
    className: u,
    isLandscape: d,
    ref: f,
    wrapperVariant: p
  } = r, m = r, y = Nse(m);
  return /* @__PURE__ */ _.jsxs(vI, {
    ref: f,
    sx: c,
    className: Pe(u, y.root),
    ownerState: m,
    children: [d ? l : n, d ? n : l, /* @__PURE__ */ _.jsx(Ise, {
      className: y.contentWrapper,
      children: p === "desktop" ? /* @__PURE__ */ _.jsxs(P.Fragment, {
        children: [o, a]
      }) : /* @__PURE__ */ _.jsxs(P.Fragment, {
        children: [a, o]
      })
    }), i]
  });
};
process.env.NODE_ENV !== "production" && (Fb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  children: s.node,
  classes: s.object,
  className: s.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  disabled: s.bool,
  isLandscape: s.bool.isRequired,
  isValid: s.func.isRequired,
  onAccept: s.func.isRequired,
  onCancel: s.func.isRequired,
  onChange: s.func.isRequired,
  onClear: s.func.isRequired,
  onClose: s.func.isRequired,
  onDismiss: s.func.isRequired,
  onOpen: s.func.isRequired,
  onSetToday: s.func.isRequired,
  onViewChange: s.func.isRequired,
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  value: s.any,
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired).isRequired,
  wrapperVariant: s.oneOf(["desktop", "mobile"])
});
const Al = ({
  props: e,
  value: t,
  adapter: r
}) => {
  if (t === null)
    return null;
  const n = r.utils.date(), o = vr(r.utils, e.minDate, r.defaultDates.minDate), a = vr(r.utils, e.maxDate, r.defaultDates.maxDate);
  switch (!0) {
    case !r.utils.isValid(t):
      return "invalidDate";
    case !!(e.shouldDisableDate && e.shouldDisableDate(t)):
      return "shouldDisableDate";
    case !!(e.shouldDisableMonth && e.shouldDisableMonth(t)):
      return "shouldDisableMonth";
    case !!(e.shouldDisableYear && e.shouldDisableYear(t)):
      return "shouldDisableYear";
    case !!(e.disableFuture && r.utils.isAfterDay(t, n)):
      return "disableFuture";
    case !!(e.disablePast && r.utils.isBeforeDay(t, n)):
      return "disablePast";
    case !!(o && r.utils.isBeforeDay(t, o)):
      return "minDate";
    case !!(a && r.utils.isAfterDay(t, a)):
      return "maxDate";
    default:
      return null;
  }
}, gI = ({
  shouldDisableDate: e,
  shouldDisableMonth: t,
  shouldDisableYear: r,
  minDate: n,
  maxDate: o,
  disableFuture: a,
  disablePast: i
}) => {
  const l = Ha();
  return P.useCallback((c) => Al({
    adapter: l,
    value: c,
    props: {
      shouldDisableDate: e,
      shouldDisableMonth: t,
      shouldDisableYear: r,
      minDate: n,
      maxDate: o,
      disableFuture: a,
      disablePast: i
    }
  }) !== null, [l, e, t, r, n, o, a, i]);
}, Mse = ({
  adapter: e,
  value: t,
  props: r
}) => {
  const {
    minTime: n,
    maxTime: o,
    minutesStep: a,
    shouldDisableClock: i,
    shouldDisableTime: l,
    disableIgnoringDatePartForTimeValidation: c = !1,
    disablePast: u,
    disableFuture: d
  } = r, f = e.utils.date(), p = e.utils.date(t), m = iI(c, e.utils);
  if (t === null)
    return null;
  switch (!0) {
    case !e.utils.isValid(t):
      return "invalidDate";
    case !!(n && m(n, t)):
      return "minTime";
    case !!(o && m(t, o)):
      return "maxTime";
    case !!(d && e.utils.isAfter(p, f)):
      return "disableFuture";
    case !!(u && e.utils.isBefore(p, f)):
      return "disablePast";
    case !!(l && l(t, "hours")):
      return "shouldDisableTime-hours";
    case !!(l && l(t, "minutes")):
      return "shouldDisableTime-minutes";
    case !!(l && l(t, "seconds")):
      return "shouldDisableTime-seconds";
    case !!(i && i(e.utils.getHours(t), "hours")):
      return "shouldDisableClock-hours";
    case !!(i && i(e.utils.getMinutes(t), "minutes")):
      return "shouldDisableClock-minutes";
    case !!(i && i(e.utils.getSeconds(t), "seconds")):
      return "shouldDisableClock-seconds";
    case !!(a && e.utils.getMinutes(t) % a !== 0):
      return "minutesStep";
    default:
      return null;
  }
}, Lb = ({
  props: e,
  value: t,
  adapter: r
}) => {
  const n = Al({
    adapter: r,
    value: t,
    props: e
  });
  return n !== null ? n : Mse({
    adapter: r,
    value: t,
    props: e
  });
};
function Ase(e, {
  disableFuture: t,
  maxDate: r
}) {
  const n = wt();
  return P.useMemo(() => {
    const o = n.date(), a = n.startOfMonth(t && n.isBefore(o, r) ? o : r);
    return !n.isAfter(a, e);
  }, [t, r, e, n]);
}
function jse(e, {
  disablePast: t,
  minDate: r
}) {
  const n = wt();
  return P.useMemo(() => {
    const o = n.date(), a = n.startOfMonth(t && n.isAfter(o, r) ? o : r);
    return !n.isBefore(a, e);
  }, [t, r, e, n]);
}
function bI(e, t, r) {
  const n = wt(), o = Vie(e, n), a = P.useCallback((i) => {
    const l = e == null ? null : zie(e, i, !!t, n);
    r(l, "partial");
  }, [t, e, r, n]);
  return {
    meridiemMode: o,
    handleMeridiemChange: a
  };
}
const Fse = typeof navigator < "u" && /(android)/i.test(navigator.userAgent), Lse = ["disablePast", "disableFuture", "minDate", "maxDate", "minTime", "maxTime", "minDateTime", "maxDateTime", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "shouldDisableClock", "shouldDisableTime", "minuteStep"], Zp = (e) => Lse.reduce((t, r) => (e.hasOwnProperty(r) && (t[r] = e[r]), t), {}), Vse = (e) => ze("MuiPickersFadeTransitionGroup", e);
Le("MuiPickersFadeTransitionGroup", ["root"]);
const zse = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, Vse, t);
}, l1 = 500, Bse = ce(Rb, {
  name: "MuiPickersFadeTransitionGroup",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "block",
  position: "relative"
});
function wI(e) {
  const t = Ae({
    props: e,
    name: "MuiPickersFadeTransitionGroup"
  }), {
    children: r,
    className: n,
    reduceAnimations: o,
    transKey: a
  } = t, i = zse(t);
  return o ? r : /* @__PURE__ */ _.jsx(Bse, {
    className: Pe(i.root, n),
    children: /* @__PURE__ */ _.jsx(Il, {
      appear: !1,
      mountOnEnter: !0,
      unmountOnExit: !0,
      timeout: {
        appear: l1,
        enter: l1 / 2,
        exit: 0
      },
      children: r
    }, a)
  });
}
const Wse = (e) => ze("MuiPickersCalendarHeader", e), Use = Le("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]), Hse = ["ownerState"], Yse = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  }, Wse, t);
}, qse = ce("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 16,
  marginBottom: 8,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 30,
  minHeight: 30
}), Gse = ce("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (e, t) => t.labelContainer
})(({
  theme: e
}) => T({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, e.typography.body1, {
  fontWeight: e.typography.fontWeightMedium
})), Kse = ce("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (e, t) => t.label
})({
  marginRight: 6
}), Xse = ce(co, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (e, t) => t.switchViewButton
})(({
  ownerState: e
}) => T({
  marginRight: "auto"
}, e.view === "year" && {
  [`.${Use.switchViewIcon}`]: {
    transform: "rotate(180deg)"
  }
})), Qse = ce(Joe, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (e, t) => t.switchViewIcon
})(({
  theme: e
}) => ({
  willChange: "transform",
  transition: e.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
function Zse(e) {
  var t, r;
  const n = Yr(), o = wt(), a = Ae({
    props: e,
    name: "MuiPickersCalendarHeader"
  }), {
    slots: i,
    slotProps: l,
    currentMonth: c,
    disabled: u,
    disableFuture: d,
    disablePast: f,
    maxDate: p,
    minDate: m,
    onMonthChange: y,
    onViewChange: h,
    view: v,
    reduceAnimations: g,
    views: b,
    labelId: x
  } = a, O = a, w = Yse(a), S = (t = i == null ? void 0 : i.switchViewButton) != null ? t : Xse, E = It({
    elementType: S,
    externalSlotProps: l == null ? void 0 : l.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": n.calendarViewSwitchingButtonAriaLabel(v)
    },
    ownerState: O,
    className: w.switchViewButton
  }), C = (r = i == null ? void 0 : i.switchViewIcon) != null ? r : Qse, N = It({
    elementType: C,
    externalSlotProps: l == null ? void 0 : l.switchViewIcon,
    ownerState: void 0,
    className: w.switchViewIcon
  }), $ = ge(N, Hse), j = () => y(o.getNextMonth(c), "left"), A = () => y(o.getPreviousMonth(c), "right"), k = Ase(c, {
    disableFuture: d,
    maxDate: p
  }), R = jse(c, {
    disablePast: f,
    minDate: m
  }), D = () => {
    if (!(b.length === 1 || !h || u))
      if (b.length === 2)
        h(b.find((L) => L !== v) || b[0]);
      else {
        const L = b.indexOf(v) !== 0 ? 0 : 1;
        h(b[L]);
      }
  };
  return b.length === 1 && b[0] === "year" ? null : /* @__PURE__ */ _.jsxs(qse, {
    ownerState: O,
    className: w.root,
    children: [/* @__PURE__ */ _.jsxs(Gse, {
      role: "presentation",
      onClick: D,
      ownerState: O,
      "aria-live": "polite",
      className: w.labelContainer,
      children: [/* @__PURE__ */ _.jsx(wI, {
        reduceAnimations: g,
        transKey: o.format(c, "monthAndYear"),
        children: /* @__PURE__ */ _.jsx(Kse, {
          id: x,
          ownerState: O,
          className: w.label,
          children: o.format(c, "monthAndYear")
        })
      }), b.length > 1 && !u && /* @__PURE__ */ _.jsx(S, T({}, E, {
        children: /* @__PURE__ */ _.jsx(C, T({}, $))
      }))]
    }), /* @__PURE__ */ _.jsx(Il, {
      in: v === "day",
      children: /* @__PURE__ */ _.jsx(CN, {
        slots: i,
        slotProps: l,
        onGoToPrevious: A,
        isPreviousDisabled: R,
        previousLabel: n.previousMonth,
        onGoToNext: j,
        isNextDisabled: k,
        nextLabel: n.nextMonth
      })
    })]
  });
}
function Jse(e) {
  return ze("MuiPickersDay", e);
}
const cc = Le("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]), ele = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"], tle = (e) => {
  const {
    selected: t,
    disableMargin: r,
    disableHighlightToday: n,
    today: o,
    disabled: a,
    outsideCurrentMonth: i,
    showDaysOutsideCurrentMonth: l,
    classes: c
  } = e;
  return Ve({
    root: ["root", t && "selected", a && "disabled", !r && "dayWithMargin", !n && o && "today", i && l && "dayOutsideMonth", i && !l && "hiddenDaySpacingFiller"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  }, Jse, c);
}, xI = ({
  theme: e,
  ownerState: t
}) => T({}, e.typography.caption, {
  width: dl,
  height: dl,
  borderRadius: "50%",
  padding: 0,
  // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
  backgroundColor: "transparent",
  color: (e.vars || e).palette.text.primary,
  "@media (pointer: fine)": {
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.primary.main, e.palette.action.hoverOpacity)
    }
  },
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.focusOpacity})` : dt(e.palette.primary.main, e.palette.action.focusOpacity),
    [`&.${cc.selected}`]: {
      willChange: "background-color",
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  },
  [`&.${cc.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    fontWeight: e.typography.fontWeightMedium,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      willChange: "background-color",
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  },
  [`&.${cc.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  }
}, !t.disableMargin && {
  margin: `0 ${Qp}px`
}, t.outsideCurrentMonth && t.showDaysOutsideCurrentMonth && {
  color: (e.vars || e).palette.text.secondary
}, !t.disableHighlightToday && t.today && {
  [`&:not(.${cc.selected})`]: {
    border: `1px solid ${(e.vars || e).palette.text.secondary}`
  }
}), _I = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, !r.disableMargin && t.dayWithMargin, !r.disableHighlightToday && r.today && t.today, !r.outsideCurrentMonth && r.showDaysOutsideCurrentMonth && t.dayOutsideMonth, r.outsideCurrentMonth && !r.showDaysOutsideCurrentMonth && t.hiddenDaySpacingFiller];
}, rle = ce(bo, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: _I
})(xI), nle = ce("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: _I
})(({
  theme: e,
  ownerState: t
}) => T({}, xI({
  theme: e,
  ownerState: t
}), {
  // visibility: 'hidden' does not work here as it hides the element from screen readers as well
  opacity: 0,
  pointerEvents: "none"
})), Ts = () => {
}, OI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPickersDay"
  }), {
    autoFocus: o = !1,
    className: a,
    day: i,
    disabled: l = !1,
    disableHighlightToday: c = !1,
    disableMargin: u = !1,
    isAnimating: d,
    onClick: f,
    onDaySelect: p,
    onFocus: m = Ts,
    onBlur: y = Ts,
    onKeyDown: h = Ts,
    onMouseDown: v = Ts,
    onMouseEnter: g = Ts,
    outsideCurrentMonth: b,
    selected: x = !1,
    showDaysOutsideCurrentMonth: O = !1,
    children: w,
    today: S = !1
  } = n, E = ge(n, ele), C = T({}, n, {
    autoFocus: o,
    disabled: l,
    disableHighlightToday: c,
    disableMargin: u,
    selected: x,
    showDaysOutsideCurrentMonth: O,
    today: S
  }), N = tle(C), $ = wt(), j = P.useRef(null), A = Lt(j, r);
  wr(() => {
    o && !l && !d && !b && j.current.focus();
  }, [o, l, d, b]);
  const k = (D) => {
    v(D), b && D.preventDefault();
  }, R = (D) => {
    l || p(i), b && D.currentTarget.focus(), f && f(D);
  };
  return b && !O ? /* @__PURE__ */ _.jsx(nle, {
    className: Pe(N.root, N.hiddenDaySpacingFiller, a),
    ownerState: C,
    role: E.role
  }) : /* @__PURE__ */ _.jsx(rle, T({
    className: Pe(N.root, a),
    ref: A,
    centerRipple: !0,
    disabled: l,
    tabIndex: x ? 0 : -1,
    onKeyDown: (D) => h(D, i),
    onFocus: (D) => m(D, i),
    onBlur: (D) => y(D, i),
    onMouseEnter: (D) => g(D, i),
    onClick: R,
    onMouseDown: k
  }, E, {
    ownerState: C,
    children: w || $.format(i, "dayOfMonth")
  }));
});
process.env.NODE_ENV !== "production" && (OI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: s.oneOfType([s.func, s.shape({
    current: s.shape({
      focusVisible: s.func.isRequired
    })
  })]),
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  className: s.string,
  /**
   * The date to show.
   */
  day: s.any.isRequired,
  /**
   * If `true`, renders as disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, days are rendering without margin. Useful for displaying linked range of days.
   * @default false
   */
  disableMargin: s.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * âš ï¸ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: s.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: s.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: s.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: s.string,
  isAnimating: s.bool,
  /**
   * If `true`, day is the first visible cell of the month.
   * Either the first day of the month or the first day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isFirstVisibleCell: s.bool.isRequired,
  /**
   * If `true`, day is the last visible cell of the month.
   * Either the last day of the month or the last day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isLastVisibleCell: s.bool.isRequired,
  onBlur: s.func,
  onDaySelect: s.func.isRequired,
  onFocus: s.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: s.func,
  onKeyDown: s.func,
  onMouseEnter: s.func,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: s.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: s.bool,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  style: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * @default 0
   */
  tabIndex: s.number,
  /**
   * If `true`, renders as today date.
   * @default false
   */
  today: s.bool,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: s.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: s.oneOfType([s.func, s.shape({
    current: s.shape({
      pulsate: s.func.isRequired,
      start: s.func.isRequired,
      stop: s.func.isRequired
    })
  })])
});
const ole = /* @__PURE__ */ P.memo(OI), ale = (e) => ze("MuiPickersSlideTransition", e), Xr = Le("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]), ile = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"], sle = (e) => {
  const {
    classes: t,
    slideDirection: r
  } = e, n = {
    root: ["root"],
    exit: ["slideExit"],
    enterActive: ["slideEnterActive"],
    enter: [`slideEnter-${r}`],
    exitActive: [`slideExitActiveLeft-${r}`]
  };
  return Ve(n, ale, t);
}, PI = 350, lle = ce(Rb, {
  name: "MuiPickersSlideTransition",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`.${Xr["slideEnter-left"]}`]: t["slideEnter-left"]
  }, {
    [`.${Xr["slideEnter-right"]}`]: t["slideEnter-right"]
  }, {
    [`.${Xr.slideEnterActive}`]: t.slideEnterActive
  }, {
    [`.${Xr.slideExit}`]: t.slideExit
  }, {
    [`.${Xr["slideExitActiveLeft-left"]}`]: t["slideExitActiveLeft-left"]
  }, {
    [`.${Xr["slideExitActiveLeft-right"]}`]: t["slideExitActiveLeft-right"]
  }]
})(({
  theme: e
}) => {
  const t = e.transitions.create("transform", {
    duration: PI,
    easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
  });
  return {
    display: "block",
    position: "relative",
    overflowX: "hidden",
    "& > *": {
      position: "absolute",
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${Xr["slideEnter-left"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      zIndex: 1
    },
    [`& .${Xr["slideEnter-right"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      zIndex: 1
    },
    [`& .${Xr.slideEnterActive}`]: {
      transform: "translate(0%)",
      transition: t
    },
    [`& .${Xr.slideExit}`]: {
      transform: "translate(0%)"
    },
    [`& .${Xr["slideExitActiveLeft-left"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      transition: t,
      zIndex: 0
    },
    [`& .${Xr["slideExitActiveLeft-right"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      transition: t,
      zIndex: 0
    }
  };
});
function cle(e) {
  const t = Ae({
    props: e,
    name: "MuiPickersSlideTransition"
  }), {
    children: r,
    className: n,
    reduceAnimations: o,
    transKey: a
    // extracting `classes` from `other`
  } = t, i = ge(t, ile), l = sle(t);
  if (o)
    return /* @__PURE__ */ _.jsx("div", {
      className: Pe(l.root, n),
      children: r
    });
  const c = {
    exit: l.exit,
    enterActive: l.enterActive,
    enter: l.enter,
    exitActive: l.exitActive
  };
  return /* @__PURE__ */ _.jsx(lle, {
    className: Pe(l.root, n),
    childFactory: (u) => /* @__PURE__ */ P.cloneElement(u, {
      classNames: c
    }),
    role: "presentation",
    children: /* @__PURE__ */ _.jsx(xoe, T({
      mountOnEnter: !0,
      unmountOnExit: !0,
      timeout: PI,
      classNames: c
    }, i, {
      children: r
    }), a)
  });
}
const ule = (e) => ze("MuiDayCalendar", e);
Le("MuiDayCalendar", ["header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
const dle = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], fle = ["ownerState"], ple = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    header: ["header"],
    weekDayLabel: ["weekDayLabel"],
    loadingContainer: ["loadingContainer"],
    slideTransition: ["slideTransition"],
    monthContainer: ["monthContainer"],
    weekContainer: ["weekContainer"],
    weekNumberLabel: ["weekNumberLabel"],
    weekNumber: ["weekNumber"]
  }, ule, t);
}, mle = (e) => e.charAt(0).toUpperCase(), SI = (dl + Qp * 2) * 6, hle = ce("div", {
  name: "MuiDayCalendar",
  slot: "Header",
  overridesResolver: (e, t) => t.header
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}), yle = ce(Zn, {
  name: "MuiDayCalendar",
  slot: "WeekDayLabel",
  overridesResolver: (e, t) => t.weekDayLabel
})(({
  theme: e
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: (e.vars || e).palette.text.secondary
})), vle = ce(Zn, {
  name: "MuiDayPicker",
  slot: "WeekNumberLabel",
  overridesResolver: (e, t) => t.weekNumberLabel
})(({
  theme: e
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: e.palette.text.disabled
})), gle = ce(Zn, {
  name: "MuiDayPicker",
  slot: "WeekNumber",
  overridesResolver: (e, t) => t.weekNumber
})(({
  theme: e
}) => T({}, e.typography.caption, {
  width: dl,
  height: dl,
  padding: 0,
  margin: `0 ${Qp}px`,
  color: e.palette.text.disabled,
  fontSize: "0.75rem",
  alignItems: "center",
  justifyContent: "center",
  display: "inline-flex"
})), ble = ce("div", {
  name: "MuiDayCalendar",
  slot: "LoadingContainer",
  overridesResolver: (e, t) => t.loadingContainer
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  minHeight: SI
}), wle = ce(cle, {
  name: "MuiDayCalendar",
  slot: "SlideTransition",
  overridesResolver: (e, t) => t.slideTransition
})({
  minHeight: SI
}), xle = ce("div", {
  name: "MuiDayCalendar",
  slot: "MonthContainer",
  overridesResolver: (e, t) => t.monthContainer
})({
  overflow: "hidden"
}), _le = ce("div", {
  name: "MuiDayCalendar",
  slot: "WeekContainer",
  overridesResolver: (e, t) => t.weekContainer
})({
  margin: `${Qp}px 0`,
  display: "flex",
  justifyContent: "center"
});
function Ole(e) {
  var t, r, n;
  let {
    parentProps: o,
    day: a,
    focusableDay: i,
    selectedDays: l,
    isDateDisabled: c,
    currentMonthNumber: u,
    isViewFocused: d
  } = e, f = ge(e, dle);
  const p = wt(), m = ns(), {
    disabled: y,
    disableHighlightToday: h,
    isMonthSwitchingAnimating: v,
    showDaysOutsideCurrentMonth: g,
    components: b,
    componentsProps: x,
    slots: O,
    slotProps: w
  } = o, S = i !== null && p.isSameDay(a, i), E = l.some((L) => p.isSameDay(L, a)), C = p.isSameDay(a, m), N = (t = (r = O == null ? void 0 : O.day) != null ? r : b == null ? void 0 : b.Day) != null ? t : ole, $ = It({
    elementType: N,
    externalSlotProps: (n = w == null ? void 0 : w.day) != null ? n : x == null ? void 0 : x.day,
    additionalProps: T({
      disableHighlightToday: h,
      showDaysOutsideCurrentMonth: g,
      role: "gridcell",
      isAnimating: v,
      // it is used in date range dragging logic by accessing `dataset.timestamp`
      "data-timestamp": p.toJsDate(a).valueOf()
    }, f),
    ownerState: T({}, o, {
      day: a,
      selected: E
    })
  }), j = ge($, fle), A = P.useMemo(() => y || c(a), [y, c, a]), k = P.useMemo(() => p.getMonth(a) !== u, [p, a, u]), R = P.useMemo(() => {
    const L = p.startOfMonth(p.setMonth(a, u));
    return g ? p.isSameDay(a, p.startOfWeek(L)) : p.isSameDay(a, L);
  }, [u, a, g, p]), D = P.useMemo(() => {
    const L = p.endOfMonth(p.setMonth(a, u));
    return g ? p.isSameDay(a, p.endOfWeek(L)) : p.isSameDay(a, L);
  }, [u, a, g, p]);
  return /* @__PURE__ */ _.jsx(N, T({}, j, {
    day: a,
    disabled: A,
    autoFocus: d && S,
    today: C,
    outsideCurrentMonth: k,
    isFirstVisibleCell: R,
    isLastVisibleCell: D,
    selected: E,
    tabIndex: S ? 0 : -1,
    "aria-selected": E,
    "aria-current": C ? "date" : void 0
  }));
}
function Ple(e) {
  const t = ns(), r = wt(), n = Ae({
    props: e,
    name: "MuiDayCalendar"
  }), o = ple(n), a = Nr(), {
    onFocusedDayChange: i,
    className: l,
    currentMonth: c,
    selectedDays: u,
    focusedDay: d,
    loading: f,
    onSelectedDaysChange: p,
    onMonthSwitchingAnimationEnd: m,
    readOnly: y,
    reduceAnimations: h,
    renderLoading: v = () => /* @__PURE__ */ _.jsx("span", {
      children: "..."
    }),
    slideDirection: g,
    TransitionProps: b,
    disablePast: x,
    disableFuture: O,
    minDate: w,
    maxDate: S,
    shouldDisableDate: E,
    shouldDisableMonth: C,
    shouldDisableYear: N,
    dayOfWeekFormatter: $ = mle,
    hasFocus: j,
    onFocusedViewChange: A,
    gridLabelId: k,
    displayWeekNumber: R,
    fixedWeekNumber: D,
    autoFocus: L
  } = n, B = gI({
    shouldDisableDate: E,
    shouldDisableMonth: C,
    shouldDisableYear: N,
    minDate: w,
    maxDate: S,
    disablePast: x,
    disableFuture: O
  }), H = Yr(), [U, I] = Wr({
    name: "DayCalendar",
    state: "hasFocus",
    controlled: j,
    default: L ?? !1
  }), [V, G] = P.useState(() => d || t), q = gt((le) => {
    y || p(le);
  }), J = (le) => {
    B(le) || (i(le), G(le), A == null || A(!0), I(!0));
  }, ne = gt((le, M) => {
    switch (le.key) {
      case "ArrowUp":
        J(r.addDays(M, -7)), le.preventDefault();
        break;
      case "ArrowDown":
        J(r.addDays(M, 7)), le.preventDefault();
        break;
      case "ArrowLeft": {
        const W = r.addDays(M, a.direction === "ltr" ? -1 : 1), Z = a.direction === "ltr" ? r.getPreviousMonth(M) : r.getNextMonth(M), he = Ws({
          utils: r,
          date: W,
          minDate: a.direction === "ltr" ? r.startOfMonth(Z) : W,
          maxDate: a.direction === "ltr" ? W : r.endOfMonth(Z),
          isDateDisabled: B
        });
        J(he || W), le.preventDefault();
        break;
      }
      case "ArrowRight": {
        const W = r.addDays(M, a.direction === "ltr" ? 1 : -1), Z = a.direction === "ltr" ? r.getNextMonth(M) : r.getPreviousMonth(M), he = Ws({
          utils: r,
          date: W,
          minDate: a.direction === "ltr" ? W : r.startOfMonth(Z),
          maxDate: a.direction === "ltr" ? r.endOfMonth(Z) : W,
          isDateDisabled: B
        });
        J(he || W), le.preventDefault();
        break;
      }
      case "Home":
        J(r.startOfWeek(M)), le.preventDefault();
        break;
      case "End":
        J(r.endOfWeek(M)), le.preventDefault();
        break;
      case "PageUp":
        J(r.getNextMonth(M)), le.preventDefault();
        break;
      case "PageDown":
        J(r.getPreviousMonth(M)), le.preventDefault();
        break;
    }
  }), te = gt((le, M) => J(M)), ee = gt((le, M) => {
    U && r.isSameDay(V, M) && (A == null || A(!1));
  }), K = r.getMonth(c), Q = P.useMemo(() => u.filter((le) => !!le).map((le) => r.startOfDay(le)), [r, u]), ae = K, ie = P.useMemo(() => /* @__PURE__ */ P.createRef(), [ae]), oe = r.startOfWeek(t), se = P.useMemo(() => {
    const le = r.startOfMonth(c), M = r.endOfMonth(c);
    return B(V) || r.isAfterDay(V, M) || r.isBeforeDay(V, le) ? Ws({
      utils: r,
      date: V,
      minDate: le,
      maxDate: M,
      disablePast: x,
      disableFuture: O,
      isDateDisabled: B
    }) : V;
  }, [c, O, x, V, B, r]), re = P.useMemo(() => {
    const le = r.getWeekArray(c);
    let M = r.addMonths(c, 1);
    for (; D && le.length < D; ) {
      const W = r.getWeekArray(M), Z = r.isSameDay(le[le.length - 1][0], W[0][0]);
      W.slice(Z ? 1 : 0).forEach((he) => {
        le.length < D && le.push(he);
      }), M = r.addMonths(M, 1);
    }
    return le;
  }, [c, D, r]);
  return /* @__PURE__ */ _.jsxs("div", {
    role: "grid",
    "aria-labelledby": k,
    children: [/* @__PURE__ */ _.jsxs(hle, {
      role: "row",
      className: o.header,
      children: [R && /* @__PURE__ */ _.jsx(vle, {
        variant: "caption",
        role: "columnheader",
        "aria-label": H.calendarWeekNumberHeaderLabel,
        className: o.weekNumberLabel,
        children: H.calendarWeekNumberHeaderText
      }), r.getWeekdays().map((le, M) => {
        var W;
        return /* @__PURE__ */ _.jsx(yle, {
          variant: "caption",
          role: "columnheader",
          "aria-label": r.format(r.addDays(oe, M), "weekday"),
          className: o.weekDayLabel,
          children: (W = $ == null ? void 0 : $(le)) != null ? W : le
        }, le + M.toString());
      })]
    }), f ? /* @__PURE__ */ _.jsx(ble, {
      className: o.loadingContainer,
      children: v()
    }) : /* @__PURE__ */ _.jsx(wle, T({
      transKey: ae,
      onExited: m,
      reduceAnimations: h,
      slideDirection: g,
      className: Pe(l, o.slideTransition)
    }, b, {
      nodeRef: ie,
      children: /* @__PURE__ */ _.jsx(xle, {
        ref: ie,
        role: "rowgroup",
        className: o.monthContainer,
        children: re.map((le, M) => /* @__PURE__ */ _.jsxs(_le, {
          role: "row",
          className: o.weekContainer,
          "aria-rowindex": M + 1,
          children: [R && /* @__PURE__ */ _.jsx(gle, {
            className: o.weekNumber,
            role: "rowheader",
            "aria-label": H.calendarWeekNumberAriaLabelText(r.getWeekNumber(le[0])),
            children: H.calendarWeekNumberText(r.getWeekNumber(le[0]))
          }), le.map((W, Z) => /* @__PURE__ */ _.jsx(Ole, {
            parentProps: n,
            day: W,
            selectedDays: Q,
            focusableDay: se,
            onKeyDown: ne,
            onFocus: te,
            onBlur: ee,
            onDaySelect: q,
            isDateDisabled: B,
            currentMonthNumber: K,
            isViewFocused: U,
            "aria-colindex": Z + 1
          }, W.toString()))]
        }, `week-${le[0]}`))
      })
    }))]
  });
}
const Sle = (e, t, r) => (n, o) => {
  switch (o.type) {
    case "changeMonth":
      return T({}, n, {
        slideDirection: o.direction,
        currentMonth: o.newMonth,
        isMonthSwitchingAnimating: !e
      });
    case "finishMonthSwitchingAnimation":
      return T({}, n, {
        isMonthSwitchingAnimating: !1
      });
    case "changeFocusedDay": {
      if (n.focusedDay != null && o.focusedDay != null && r.isSameDay(o.focusedDay, n.focusedDay))
        return n;
      const a = o.focusedDay != null && !t && !r.isSameMonth(n.currentMonth, o.focusedDay);
      return T({}, n, {
        focusedDay: o.focusedDay,
        isMonthSwitchingAnimating: a && !e && !o.withoutMonthSwitchingAnimation,
        currentMonth: a ? r.startOfMonth(o.focusedDay) : n.currentMonth,
        slideDirection: o.focusedDay != null && r.isAfterDay(o.focusedDay, n.currentMonth) ? "left" : "right"
      });
    }
    default:
      throw new Error("missing support");
  }
}, Tle = ({
  value: e,
  defaultCalendarMonth: t,
  disableFuture: r,
  disablePast: n,
  disableSwitchToMonthOnDayFocus: o = !1,
  maxDate: a,
  minDate: i,
  onMonthChange: l,
  reduceAnimations: c,
  shouldDisableDate: u
}) => {
  var d;
  const f = ns(), p = wt(), m = P.useRef(Sle(!!c, o, p)).current, [y, h] = P.useReducer(m, {
    isMonthSwitchingAnimating: !1,
    focusedDay: e || f,
    currentMonth: p.startOfMonth((d = e ?? t) != null ? d : zte(p, f, i, a)),
    slideDirection: "left"
  }), v = P.useCallback((w) => {
    h(T({
      type: "changeMonth"
    }, w)), l && l(w.newMonth);
  }, [l]), g = P.useCallback((w) => {
    const S = w;
    p.isSameMonth(S, y.currentMonth) || v({
      newMonth: p.startOfMonth(S),
      direction: p.isAfterDay(S, y.currentMonth) ? "left" : "right"
    });
  }, [y.currentMonth, v, p]), b = gI({
    shouldDisableDate: u,
    minDate: i,
    maxDate: a,
    disableFuture: r,
    disablePast: n
  }), x = P.useCallback(() => {
    h({
      type: "finishMonthSwitchingAnimation"
    });
  }, []), O = gt((w, S) => {
    b(w) || h({
      type: "changeFocusedDay",
      focusedDay: w,
      withoutMonthSwitchingAnimation: S
    });
  });
  return {
    calendarState: y,
    changeMonth: g,
    changeFocusedDay: O,
    isDateDisabled: b,
    onMonthSwitchingAnimationEnd: x,
    handleChangeMonth: v
  };
}, TI = /* @__PURE__ */ P.createContext(void 0);
process.env.NODE_ENV !== "production" && (TI.displayName = "FormControlContext");
const Jp = TI;
function qa() {
  return P.useContext(Jp);
}
function Ele(e) {
  return ze("MuiInputAdornment", e);
}
const $le = Le("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]), c1 = $le;
var u1;
const Cle = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"], kle = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, t[`position${Te(r.position)}`], r.disablePointerEvents === !0 && t.disablePointerEvents, t[r.variant]];
}, Rle = (e) => {
  const {
    classes: t,
    disablePointerEvents: r,
    hiddenLabel: n,
    position: o,
    size: a,
    variant: i
  } = e, l = {
    root: ["root", r && "disablePointerEvents", o && `position${Te(o)}`, i, n && "hiddenLabel", a && `size${Te(a)}`]
  };
  return Ve(l, Ele, t);
}, Dle = ce("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: kle
})(({
  theme: e,
  ownerState: t
}) => T({
  display: "flex",
  height: "0.01em",
  // Fix IE11 flexbox alignment. To remove at some point.
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (e.vars || e).palette.action.active
}, t.variant === "filled" && {
  // Styles applied to the root element if `variant="filled"`.
  [`&.${c1.positionStart}&:not(.${c1.hiddenLabel})`]: {
    marginTop: 16
  }
}, t.position === "start" && {
  // Styles applied to the root element if `position="start"`.
  marginRight: 8
}, t.position === "end" && {
  // Styles applied to the root element if `position="end"`.
  marginLeft: 8
}, t.disablePointerEvents === !0 && {
  // Styles applied to the root element if `disablePointerEvents={true}`.
  pointerEvents: "none"
})), EI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiInputAdornment"
  }), {
    children: o,
    className: a,
    component: i = "div",
    disablePointerEvents: l = !1,
    disableTypography: c = !1,
    position: u,
    variant: d
  } = n, f = ge(n, Cle), p = qa() || {};
  let m = d;
  d && p.variant && process.env.NODE_ENV !== "production" && d === p.variant && console.error("MUI: The `InputAdornment` variant infers the variant prop you do not have to provide one."), p && !m && (m = p.variant);
  const y = T({}, n, {
    hiddenLabel: p.hiddenLabel,
    size: p.size,
    disablePointerEvents: l,
    position: u,
    variant: m
  }), h = Rle(y);
  return /* @__PURE__ */ _.jsx(Jp.Provider, {
    value: null,
    children: /* @__PURE__ */ _.jsx(Dle, T({
      as: i,
      ownerState: y,
      className: Pe(h.root, a),
      ref: r
    }, f, {
      children: typeof o == "string" && !c ? /* @__PURE__ */ _.jsx(Zn, {
        color: "text.secondary",
        children: o
      }) : /* @__PURE__ */ _.jsxs(P.Fragment, {
        children: [u === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          u1 || (u1 = /* @__PURE__ */ _.jsx("span", {
            className: "notranslate",
            children: "â€‹"
          }))
        ) : null, o]
      })
    }))
  });
});
process.env.NODE_ENV !== "production" && (EI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally an `IconButton` or string.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * Disable pointer events on the root.
   * This allows for the content of the adornment to focus the `input` on click.
   * @default false
   */
  disablePointerEvents: s.bool,
  /**
   * If children is a string then disable wrapping in a Typography component.
   * @default false
   */
  disableTypography: s.bool,
  /**
   * The position this adornment should appear relative to the `Input`.
   */
  position: s.oneOf(["end", "start"]).isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   * Note: If you are using the `TextField` component or the `FormControl` component
   * you do not have to set this manually.
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
const Nle = EI;
var $I = {};
Object.defineProperty($I, "__esModule", {
  value: !0
});
var CI = $I.default = Ale, jv = Ile(F);
function kI(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (kI = function(n) {
    return n ? r : t;
  })(e);
}
function Ile(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var r = kI(t);
  if (r && r.has(e))
    return r.get(e);
  var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var a in e)
    if (a !== "default" && Object.prototype.hasOwnProperty.call(e, a)) {
      var i = o ? Object.getOwnPropertyDescriptor(e, a) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, a, i) : n[a] = e[a];
    }
  return n.default = e, r && r.set(e, n), n;
}
let d1 = 0;
function Mle(e) {
  const [t, r] = jv.useState(e), n = e || t;
  return jv.useEffect(() => {
    t == null && (d1 += 1, r(`mui-${d1}`));
  }, [t]), n;
}
const f1 = jv["useId".toString()];
function Ale(e) {
  if (f1 !== void 0) {
    const t = f1();
    return e ?? t;
  }
  return Mle(e);
}
const jle = ["ownerState"], Fle = ["ownerState"], RI = ({
  props: e,
  valueManager: t,
  getOpenDialogAriaText: r,
  validator: n
}) => {
  var o, a, i, l, c;
  const {
    slots: u,
    slotProps: d,
    className: f,
    sx: p,
    format: m,
    label: y,
    inputRef: h,
    readOnly: v,
    disabled: g,
    autoFocus: b,
    localeText: x
  } = e, O = wt(), w = P.useRef(null), S = P.useRef(null), E = CI(), C = (o = d == null || (a = d.toolbar) == null ? void 0 : a.hidden) != null ? o : !1, {
    open: N,
    actions: $,
    hasUIView: j,
    layoutProps: A,
    renderCurrentView: k,
    shouldRestoreFocus: R,
    fieldProps: D
  } = sI({
    props: e,
    inputRef: w,
    valueManager: t,
    validator: n,
    autoFocusView: !0,
    additionalViewProps: {},
    wrapperVariant: "desktop"
  }), L = (i = u.inputAdornment) != null ? i : Nle, B = It({
    elementType: L,
    externalSlotProps: d == null ? void 0 : d.inputAdornment,
    additionalProps: {
      position: "end"
    },
    ownerState: e
  }), H = ge(B, jle), U = (l = u.openPickerButton) != null ? l : co, I = It({
    elementType: U,
    externalSlotProps: d == null ? void 0 : d.openPickerButton,
    additionalProps: {
      disabled: g || v,
      onClick: $.onOpen,
      "aria-label": r(D.value, O),
      edge: H.position
    },
    ownerState: e
  }), V = ge(I, Fle), G = u.openPickerIcon, q = u.field, J = It({
    elementType: q,
    externalSlotProps: d == null ? void 0 : d.field,
    additionalProps: T({}, D, C && {
      id: E
    }, {
      readOnly: v,
      disabled: g,
      className: f,
      sx: p,
      format: m,
      label: y,
      autoFocus: b && !e.open
    }),
    ownerState: e
  });
  j && (J.InputProps = T({}, J.InputProps, {
    ref: S,
    [`${H.position}Adornment`]: /* @__PURE__ */ _.jsx(L, T({}, H, {
      children: /* @__PURE__ */ _.jsx(U, T({}, V, {
        children: /* @__PURE__ */ _.jsx(G, T({}, d == null ? void 0 : d.openPickerIcon))
      }))
    }))
  }));
  const ne = T({
    textField: u.textField
  }, J.slots), te = (c = u.layout) != null ? c : Fb, ee = Mb(w, J.inputRef, h);
  let K = E;
  C && (y ? K = `${E}-label` : K = void 0);
  const Q = T({}, d, {
    toolbar: T({}, d == null ? void 0 : d.toolbar, {
      titleId: E
    }),
    popper: T({
      "aria-labelledby": K
    }, d == null ? void 0 : d.popper)
  });
  return {
    renderPicker: () => /* @__PURE__ */ _.jsxs(Rl, {
      localeText: x,
      children: [/* @__PURE__ */ _.jsx(q, T({}, J, {
        slots: ne,
        slotProps: Q,
        inputRef: ee
      })), /* @__PURE__ */ _.jsx(nie, T({
        role: "dialog",
        placement: "bottom-start",
        anchorEl: S.current
      }, $, {
        open: N,
        slots: u,
        slotProps: Q,
        shouldRestoreFocus: R,
        children: /* @__PURE__ */ _.jsx(te, T({}, A, Q == null ? void 0 : Q.layout, {
          slots: u,
          slotProps: Q,
          children: k()
        }))
      }))]
    })
  };
};
function os({
  props: e,
  states: t,
  muiFormControl: r
}) {
  return t.reduce((n, o) => (n[o] = e[o], r && typeof e[o] > "u" && (n[o] = r[o]), n), {});
}
function DI(e) {
  return /* @__PURE__ */ _.jsx(mE, T({}, e, {
    defaultTheme: xp
  }));
}
process.env.NODE_ENV !== "production" && (DI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The styles you want to apply globally.
   */
  styles: s.oneOfType([s.func, s.number, s.object, s.shape({
    __emotion_styles: s.any.isRequired
  }), s.string, s.bool])
});
function p1(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function Vb(e, t = !1) {
  return e && (p1(e.value) && e.value !== "" || t && p1(e.defaultValue) && e.defaultValue !== "");
}
function Lle(e) {
  return e.startAdornment;
}
function Vle(e) {
  return ze("MuiInputBase", e);
}
const zle = Le("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]), Ui = zle, Ble = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"], em = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.formControl && t.formControl, r.startAdornment && t.adornedStart, r.endAdornment && t.adornedEnd, r.error && t.error, r.size === "small" && t.sizeSmall, r.multiline && t.multiline, r.color && t[`color${Te(r.color)}`], r.fullWidth && t.fullWidth, r.hiddenLabel && t.hiddenLabel];
}, tm = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.input, r.size === "small" && t.inputSizeSmall, r.multiline && t.inputMultiline, r.type === "search" && t.inputTypeSearch, r.startAdornment && t.inputAdornedStart, r.endAdornment && t.inputAdornedEnd, r.hiddenLabel && t.inputHiddenLabel];
}, Wle = (e) => {
  const {
    classes: t,
    color: r,
    disabled: n,
    error: o,
    endAdornment: a,
    focused: i,
    formControl: l,
    fullWidth: c,
    hiddenLabel: u,
    multiline: d,
    readOnly: f,
    size: p,
    startAdornment: m,
    type: y
  } = e, h = {
    root: ["root", `color${Te(r)}`, n && "disabled", o && "error", c && "fullWidth", i && "focused", l && "formControl", p === "small" && "sizeSmall", d && "multiline", m && "adornedStart", a && "adornedEnd", u && "hiddenLabel", f && "readOnly"],
    input: ["input", n && "disabled", y === "search" && "inputTypeSearch", d && "inputMultiline", p === "small" && "inputSizeSmall", u && "inputHiddenLabel", m && "inputAdornedStart", a && "inputAdornedEnd", f && "readOnly"]
  };
  return Ve(h, Vle, t);
}, rm = ce("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: em
})(({
  theme: e,
  ownerState: t
}) => T({}, e.typography.body1, {
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Ui.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  }
}, t.multiline && T({
  padding: "4px 0 5px"
}, t.size === "small" && {
  paddingTop: 1
}), t.fullWidth && {
  width: "100%"
})), nm = ce("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: tm
})(({
  theme: e,
  ownerState: t
}) => {
  const r = e.palette.mode === "light", n = T({
    color: "currentColor"
  }, e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: r ? 0.42 : 0.5
  }, {
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }), o = {
    opacity: "0 !important"
  }, a = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: r ? 0.42 : 0.5
  };
  return T({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&:-ms-input-placeholder": n,
    // IE11
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Ui.formControl} &`]: {
      "&::-webkit-input-placeholder": o,
      "&::-moz-placeholder": o,
      // Firefox 19+
      "&:-ms-input-placeholder": o,
      // IE11
      "&::-ms-input-placeholder": o,
      // Edge
      "&:focus::-webkit-input-placeholder": a,
      "&:focus::-moz-placeholder": a,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": a,
      // IE11
      "&:focus::-ms-input-placeholder": a
      // Edge
    },
    [`&.${Ui.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, t.size === "small" && {
    paddingTop: 1
  }, t.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, t.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
}), Ule = /* @__PURE__ */ _.jsx(DI, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
}), NI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n;
  const o = Ae({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": a,
    autoComplete: i,
    autoFocus: l,
    className: c,
    components: u = {},
    componentsProps: d = {},
    defaultValue: f,
    disabled: p,
    disableInjectingGlobalStyles: m,
    endAdornment: y,
    fullWidth: h = !1,
    id: v,
    inputComponent: g = "input",
    inputProps: b = {},
    inputRef: x,
    maxRows: O,
    minRows: w,
    multiline: S = !1,
    name: E,
    onBlur: C,
    onChange: N,
    onClick: $,
    onFocus: j,
    onKeyDown: A,
    onKeyUp: k,
    placeholder: R,
    readOnly: D,
    renderSuffix: L,
    rows: B,
    slotProps: H = {},
    slots: U = {},
    startAdornment: I,
    type: V = "text",
    value: G
  } = o, q = ge(o, Ble), J = b.value != null ? b.value : G, {
    current: ne
  } = P.useRef(J != null), te = P.useRef(), ee = P.useCallback((Be) => {
    process.env.NODE_ENV !== "production" && Be && Be.nodeName !== "INPUT" && !Be.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), K = Lt(te, x, b.ref, ee), [Q, ae] = P.useState(!1), ie = qa();
  process.env.NODE_ENV !== "production" && P.useEffect(() => {
    if (ie)
      return ie.registerEffect();
  }, [ie]);
  const oe = os({
    props: o,
    muiFormControl: ie,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  oe.focused = ie ? ie.focused : Q, P.useEffect(() => {
    !ie && p && Q && (ae(!1), C && C());
  }, [ie, p, Q, C]);
  const se = ie && ie.onFilled, re = ie && ie.onEmpty, le = P.useCallback((Be) => {
    Vb(Be) ? se && se() : re && re();
  }, [se, re]);
  wr(() => {
    ne && le({
      value: J
    });
  }, [J, le, ne]);
  const M = (Be) => {
    if (oe.disabled) {
      Be.stopPropagation();
      return;
    }
    j && j(Be), b.onFocus && b.onFocus(Be), ie && ie.onFocus ? ie.onFocus(Be) : ae(!0);
  }, W = (Be) => {
    C && C(Be), b.onBlur && b.onBlur(Be), ie && ie.onBlur ? ie.onBlur(Be) : ae(!1);
  }, Z = (Be, ...Ie) => {
    if (!ne) {
      const it = Be.target || te.current;
      if (it == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : Go(1));
      le({
        value: it.value
      });
    }
    b.onChange && b.onChange(Be, ...Ie), N && N(Be, ...Ie);
  };
  P.useEffect(() => {
    le(te.current);
  }, []);
  const he = (Be) => {
    te.current && Be.currentTarget === Be.target && te.current.focus(), $ && $(Be);
  };
  let me = g, de = b;
  S && me === "input" && (B ? (process.env.NODE_ENV !== "production" && (w || O) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), de = T({
    type: void 0,
    minRows: B,
    maxRows: B
  }, de)) : de = T({
    type: void 0,
    maxRows: O,
    minRows: w
  }, de), me = Fne);
  const ue = (Be) => {
    le(Be.animationName === "mui-auto-fill-cancel" ? te.current : {
      value: "x"
    });
  };
  P.useEffect(() => {
    ie && ie.setAdornedStart(!!I);
  }, [ie, I]);
  const Oe = T({}, o, {
    color: oe.color || "primary",
    disabled: oe.disabled,
    endAdornment: y,
    error: oe.error,
    focused: oe.focused,
    formControl: ie,
    fullWidth: h,
    hiddenLabel: oe.hiddenLabel,
    multiline: S,
    size: oe.size,
    startAdornment: I,
    type: V
  }), Se = Wle(Oe), De = U.root || u.Root || rm, nt = H.root || d.root || {}, rt = U.input || u.Input || nm;
  return de = T({}, de, (n = H.input) != null ? n : d.input), /* @__PURE__ */ _.jsxs(P.Fragment, {
    children: [!m && Ule, /* @__PURE__ */ _.jsxs(De, T({}, nt, !Ia(De) && {
      ownerState: T({}, Oe, nt.ownerState)
    }, {
      ref: r,
      onClick: he
    }, q, {
      className: Pe(Se.root, nt.className, c, D && "MuiInputBase-readOnly"),
      children: [I, /* @__PURE__ */ _.jsx(Jp.Provider, {
        value: null,
        children: /* @__PURE__ */ _.jsx(rt, T({
          ownerState: Oe,
          "aria-invalid": oe.error,
          "aria-describedby": a,
          autoComplete: i,
          autoFocus: l,
          defaultValue: f,
          disabled: oe.disabled,
          id: v,
          onAnimationStart: ue,
          name: E,
          placeholder: R,
          readOnly: D,
          required: oe.required,
          rows: B,
          value: J,
          onKeyDown: A,
          onKeyUp: k,
          type: V
        }, de, !Ia(rt) && {
          as: me,
          ownerState: T({}, Oe, de.ownerState)
        }, {
          ref: K,
          className: Pe(Se.input, de.className, D && "MuiInputBase-readOnly"),
          onBlur: W,
          onChange: Z,
          onFocus: M
        }))
      }), y, L ? L(T({}, oe, {
        startAdornment: I
      })) : null]
    }))]
  });
});
process.env.NODE_ENV !== "production" && (NI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  "aria-describedby": s.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: s.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Input: s.elementType,
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: s.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: s.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: s.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: s.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The id of the `input` element.
   */
  id: s.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: ep,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: vn,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: s.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: s.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: s.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * @ignore
   */
  onClick: s.func,
  /**
   * @ignore
   */
  onFocus: s.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: s.func,
  /**
   * @ignore
   */
  onKeyDown: s.func,
  /**
   * @ignore
   */
  onKeyUp: s.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: s.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: s.bool,
  /**
   * @ignore
   */
  renderSuffix: s.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: s.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: s.oneOfType([s.number, s.string]),
  /**
   * The size of the component.
   */
  size: s.oneOfType([s.oneOf(["medium", "small"]), s.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    input: s.elementType,
    root: s.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: s.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: s.any
});
const om = NI;
function Hle(e) {
  return ze("MuiInput", e);
}
const Yle = T({}, Ui, Le("MuiInput", ["root", "underline", "input"])), Es = Yle, qle = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"], Gle = (e) => {
  const {
    classes: t,
    disableUnderline: r
  } = e, o = Ve({
    root: ["root", !r && "underline"],
    input: ["input"]
  }, Hle, t);
  return T({}, t, o);
}, Kle = ce(rm, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [...em(e, t), !r.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (n = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), T({
    position: "relative"
  }, t.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(e.vars || e).palette[t.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${Es.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${Es.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${n}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${Es.disabled}, .${Es.error}):before`]: {
      borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${n}`
      }
    },
    [`&.${Es.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
}), Xle = ce(nm, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: tm
})({}), zb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i;
  const l = Ae({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: c,
    components: u = {},
    componentsProps: d,
    fullWidth: f = !1,
    inputComponent: p = "input",
    multiline: m = !1,
    slotProps: y,
    slots: h = {},
    type: v = "text"
  } = l, g = ge(l, qle), b = Gle(l), O = {
    root: {
      ownerState: {
        disableUnderline: c
      }
    }
  }, w = y ?? d ? an(y ?? d, O) : O, S = (n = (o = h.root) != null ? o : u.Root) != null ? n : Kle, E = (a = (i = h.input) != null ? i : u.Input) != null ? a : Xle;
  return /* @__PURE__ */ _.jsx(om, T({
    slots: {
      root: S,
      input: E
    },
    slotProps: w,
    fullWidth: f,
    inputComponent: p,
    multiline: m,
    ref: r,
    type: v
  }, g, {
    classes: b
  }));
});
process.env.NODE_ENV !== "production" && (zb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: s.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary"]), s.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Input: s.elementType,
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: s.bool,
  /**
   * If `true`, the `input` will not have an underline.
   */
  disableUnderline: s.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: s.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: s.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The id of the `input` element.
   */
  id: s.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: s.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: vn,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: s.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: s.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: s.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: s.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: s.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: s.oneOfType([s.number, s.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    input: s.elementType,
    root: s.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: s.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: s.any
});
zb.muiName = "Input";
const II = zb;
function Qle(e) {
  return ze("MuiFilledInput", e);
}
const Zle = T({}, Ui, Le("MuiFilledInput", ["root", "underline", "input"])), da = Zle, Jle = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"], ece = (e) => {
  const {
    classes: t,
    disableUnderline: r
  } = e, o = Ve({
    root: ["root", !r && "underline"],
    input: ["input"]
  }, Qle, t);
  return T({}, t, o);
}, tce = ce(rm, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [...em(e, t), !r.disableUnderline && t.underline];
  }
})(({
  theme: e,
  ownerState: t
}) => {
  var r;
  const n = e.palette.mode === "light", o = n ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", a = n ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", i = n ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", l = n ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return T({
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : a,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : a
      }
    },
    [`&.${da.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : a
    },
    [`&.${da.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : l
    }
  }, !t.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(r = (e.vars || e).palette[t.color || "primary"]) == null ? void 0 : r.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: e.transitions.create("transform", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${da.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${da.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (e.vars || e).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : o}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: e.transitions.create("border-bottom-color", {
        duration: e.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${da.disabled}, .${da.error}):before`]: {
      borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
    },
    [`&.${da.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, t.startAdornment && {
    paddingLeft: 12
  }, t.endAdornment && {
    paddingRight: 12
  }, t.multiline && T({
    padding: "25px 12px 8px"
  }, t.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, t.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
}), rce = ce(nm, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: tm
})(({
  theme: e,
  ownerState: t
}) => T({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, t.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, t.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
}, t.hiddenLabel && t.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
})), Bb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i;
  const l = Ae({
    props: t,
    name: "MuiFilledInput"
  }), {
    components: c = {},
    componentsProps: u,
    fullWidth: d = !1,
    // declare here to prevent spreading to DOM
    inputComponent: f = "input",
    multiline: p = !1,
    slotProps: m,
    slots: y = {},
    type: h = "text"
  } = l, v = ge(l, Jle), g = T({}, l, {
    fullWidth: d,
    inputComponent: f,
    multiline: p,
    type: h
  }), b = ece(l), x = {
    root: {
      ownerState: g
    },
    input: {
      ownerState: g
    }
  }, O = m ?? u ? an(m ?? u, x) : x, w = (n = (o = y.root) != null ? o : c.Root) != null ? n : tce, S = (a = (i = y.input) != null ? i : c.Input) != null ? a : rce;
  return /* @__PURE__ */ _.jsx(om, T({
    slots: {
      root: w,
      input: S
    },
    componentsProps: O,
    fullWidth: d,
    inputComponent: f,
    multiline: p,
    ref: r,
    type: h
  }, v, {
    classes: b
  }));
});
process.env.NODE_ENV !== "production" && (Bb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: s.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary"]), s.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Input: s.elementType,
    Root: s.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: s.bool,
  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: s.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: s.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: s.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: s.bool,
  /**
   * The id of the `input` element.
   */
  id: s.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: s.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: vn,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: s.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: s.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: s.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: s.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: s.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: s.oneOfType([s.number, s.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: s.shape({
    input: s.object,
    root: s.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    input: s.elementType,
    root: s.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: s.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: s.any
});
Bb.muiName = "Input";
const MI = Bb;
var m1;
const nce = ["children", "classes", "className", "label", "notched"], oce = ce("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), ace = ce("legend")(({
  ownerState: e,
  theme: t
}) => T({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !e.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: t.transitions.create("width", {
    duration: 150,
    easing: t.transitions.easing.easeOut
  })
}, e.withLabel && T({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: t.transitions.create("max-width", {
    duration: 50,
    easing: t.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, e.notched && {
  maxWidth: "100%",
  transition: t.transitions.create("max-width", {
    duration: 100,
    easing: t.transitions.easing.easeOut,
    delay: 50
  })
})));
function AI(e) {
  const {
    className: t,
    label: r,
    notched: n
  } = e, o = ge(e, nce), a = r != null && r !== "", i = T({}, e, {
    notched: n,
    withLabel: a
  });
  return /* @__PURE__ */ _.jsx(oce, T({
    "aria-hidden": !0,
    className: t,
    ownerState: i
  }, o, {
    children: /* @__PURE__ */ _.jsx(ace, {
      ownerState: i,
      children: a ? /* @__PURE__ */ _.jsx("span", {
        children: r
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        m1 || (m1 = /* @__PURE__ */ _.jsx("span", {
          className: "notranslate",
          children: "â€‹"
        }))
      )
    })
  }));
}
process.env.NODE_ENV !== "production" && (AI.propTypes = {
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The label.
   */
  label: s.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: s.bool.isRequired,
  /**
   * @ignore
   */
  style: s.object
});
function ice(e) {
  return ze("MuiOutlinedInput", e);
}
const sce = T({}, Ui, Le("MuiOutlinedInput", ["root", "notchedOutline", "input"])), Io = sce, lce = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"], cce = (e) => {
  const {
    classes: t
  } = e, n = Ve({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, ice, t);
  return T({}, t, n);
}, uce = ce(rm, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: em
})(({
  theme: e,
  ownerState: t
}) => {
  const r = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return T({
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${Io.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Io.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : r
      }
    },
    [`&.${Io.focused} .${Io.notchedOutline}`]: {
      borderColor: (e.vars || e).palette[t.color].main,
      borderWidth: 2
    },
    [`&.${Io.error} .${Io.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.error.main
    },
    [`&.${Io.disabled} .${Io.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.action.disabled
    }
  }, t.startAdornment && {
    paddingLeft: 14
  }, t.endAdornment && {
    paddingRight: 14
  }, t.multiline && T({
    padding: "16.5px 14px"
  }, t.size === "small" && {
    padding: "8.5px 14px"
  }));
}), dce = ce(AI, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
}), fce = ce(nm, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: tm
})(({
  theme: e,
  ownerState: t
}) => T({
  padding: "16.5px 14px"
}, !e.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
    caretColor: e.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, e.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [e.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, t.size === "small" && {
  padding: "8.5px 14px"
}, t.multiline && {
  padding: 0
}, t.startAdornment && {
  paddingLeft: 0
}, t.endAdornment && {
  paddingRight: 0
})), Wb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i, l;
  const c = Ae({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: u = {},
    fullWidth: d = !1,
    inputComponent: f = "input",
    label: p,
    multiline: m = !1,
    notched: y,
    slots: h = {},
    type: v = "text"
  } = c, g = ge(c, lce), b = cce(c), x = qa(), O = os({
    props: c,
    muiFormControl: x,
    states: ["required"]
  }), w = T({}, c, {
    color: O.color || "primary",
    disabled: O.disabled,
    error: O.error,
    focused: O.focused,
    formControl: x,
    fullWidth: d,
    hiddenLabel: O.hiddenLabel,
    multiline: m,
    size: O.size,
    type: v
  }), S = (n = (o = h.root) != null ? o : u.Root) != null ? n : uce, E = (a = (i = h.input) != null ? i : u.Input) != null ? a : fce;
  return /* @__PURE__ */ _.jsx(om, T({
    slots: {
      root: S,
      input: E
    },
    renderSuffix: (C) => /* @__PURE__ */ _.jsx(dce, {
      ownerState: w,
      className: b.notchedOutline,
      label: p != null && p !== "" && O.required ? l || (l = /* @__PURE__ */ _.jsxs(P.Fragment, {
        children: [p, "â€‰", "*"]
      })) : p,
      notched: typeof y < "u" ? y : !!(C.startAdornment || C.filled || C.focused)
    }),
    fullWidth: d,
    inputComponent: f,
    multiline: m,
    ref: r,
    type: v
  }, g, {
    classes: T({}, b, {
      notchedOutline: null
    })
  }));
});
process.env.NODE_ENV !== "production" && (Wb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: s.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary"]), s.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: s.shape({
    Input: s.elementType,
    Root: s.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: s.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: s.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: s.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The id of the `input` element.
   */
  id: s.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: s.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: vn,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: s.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: s.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: s.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: s.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: s.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: s.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: s.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: s.oneOfType([s.number, s.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: s.shape({
    input: s.elementType,
    root: s.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: s.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: s.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: s.any
});
Wb.muiName = "Input";
const jI = Wb;
function pce(e) {
  return ze("MuiFormLabel", e);
}
const mce = Le("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), Xs = mce, hce = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"], yce = (e) => {
  const {
    classes: t,
    color: r,
    focused: n,
    disabled: o,
    error: a,
    filled: i,
    required: l
  } = e, c = {
    root: ["root", `color${Te(r)}`, o && "disabled", a && "error", i && "filled", n && "focused", l && "required"],
    asterisk: ["asterisk", a && "error"]
  };
  return Ve(c, pce, t);
}, vce = ce("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => T({}, t.root, e.color === "secondary" && t.colorSecondary, e.filled && t.filled)
})(({
  theme: e,
  ownerState: t
}) => T({
  color: (e.vars || e).palette.text.secondary
}, e.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${Xs.focused}`]: {
    color: (e.vars || e).palette[t.color].main
  },
  [`&.${Xs.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${Xs.error}`]: {
    color: (e.vars || e).palette.error.main
  }
})), gce = ce("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (e, t) => t.asterisk
})(({
  theme: e
}) => ({
  [`&.${Xs.error}`]: {
    color: (e.vars || e).palette.error.main
  }
})), FI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: o,
    className: a,
    component: i = "label"
  } = n, l = ge(n, hce), c = qa(), u = os({
    props: n,
    muiFormControl: c,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), d = T({}, n, {
    color: u.color || "primary",
    component: i,
    disabled: u.disabled,
    error: u.error,
    filled: u.filled,
    focused: u.focused,
    required: u.required
  }), f = yce(d);
  return /* @__PURE__ */ _.jsxs(vce, T({
    as: i,
    ownerState: d,
    className: Pe(f.root, a),
    ref: r
  }, l, {
    children: [o, u.required && /* @__PURE__ */ _.jsxs(gce, {
      ownerState: d,
      "aria-hidden": !0,
      className: f.asterisk,
      children: ["â€‰", "*"]
    })]
  }));
});
process.env.NODE_ENV !== "production" && (FI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: s.oneOfType([s.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: s.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: s.bool,
  /**
   * If `true`, the label should use filled classes key.
   */
  filled: s.bool,
  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: s.bool,
  /**
   * If `true`, the label will indicate that the `input` is required.
   */
  required: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const bce = FI;
function wce(e) {
  return ze("MuiInputLabel", e);
}
Le("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const xce = ["disableAnimation", "margin", "shrink", "variant", "className"], _ce = (e) => {
  const {
    classes: t,
    formControl: r,
    size: n,
    shrink: o,
    disableAnimation: a,
    variant: i,
    required: l
  } = e, u = Ve({
    root: ["root", r && "formControl", !a && "animated", o && "shrink", n === "small" && "sizeSmall", i],
    asterisk: [l && "asterisk"]
  }, wce, t);
  return T({}, t, u);
}, Oce = ce(bce, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [{
      [`& .${Xs.asterisk}`]: t.asterisk
    }, t.root, r.formControl && t.formControl, r.size === "small" && t.sizeSmall, r.shrink && t.shrink, !r.disableAnimation && t.animated, t[r.variant]];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, t.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, t.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, t.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !t.disableAnimation && {
  transition: e.transitions.create(["color", "transform", "max-width"], {
    duration: e.transitions.duration.shorter,
    easing: e.transitions.easing.easeOut
  })
}, t.variant === "filled" && T({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, t.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, t.shrink && T({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, t.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), t.variant === "outlined" && T({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, t.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, t.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  // Theoretically, we should have (8+5)*2/0.75 = 34px
  // but it feels a better when it bleeds a bit on the left, so 32px.
  maxWidth: "calc(133% - 32px)",
  transform: "translate(14px, -9px) scale(0.75)"
}))), LI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: o = !1,
    shrink: a,
    className: i
  } = n, l = ge(n, xce), c = qa();
  let u = a;
  typeof u > "u" && c && (u = c.filled || c.focused || c.adornedStart);
  const d = os({
    props: n,
    muiFormControl: c,
    states: ["size", "variant", "required"]
  }), f = T({}, n, {
    disableAnimation: o,
    formControl: c,
    shrink: u,
    size: d.size,
    variant: d.variant,
    required: d.required
  }), p = _ce(f);
  return /* @__PURE__ */ _.jsx(Oce, T({
    "data-shrink": u,
    ownerState: f,
    ref: r,
    className: Pe(p.root, i)
  }, l, {
    classes: p
  }));
});
process.env.NODE_ENV !== "production" && (LI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: s.oneOfType([s.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), s.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: s.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: s.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: s.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: s.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: s.oneOf(["dense"]),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: s.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: s.bool,
  /**
   * The size of the component.
   * @default 'normal'
   */
  size: s.oneOfType([s.oneOf(["normal", "small"]), s.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
const Pce = LI;
function Sce(e) {
  return ze("MuiFormControl", e);
}
Le("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const Tce = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"], Ece = (e) => {
  const {
    classes: t,
    margin: r,
    fullWidth: n
  } = e, o = {
    root: ["root", r !== "none" && `margin${Te(r)}`, n && "fullWidth"]
  };
  return Ve(o, Sce, t);
}, $ce = ce("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState: e
  }, t) => T({}, t.root, t[`margin${Te(e.margin)}`], e.fullWidth && t.fullWidth)
})(({
  ownerState: e
}) => T({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, e.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, e.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, e.fullWidth && {
  width: "100%"
})), VI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiFormControl"
  }), {
    children: o,
    className: a,
    color: i = "primary",
    component: l = "div",
    disabled: c = !1,
    error: u = !1,
    focused: d,
    fullWidth: f = !1,
    hiddenLabel: p = !1,
    margin: m = "none",
    required: y = !1,
    size: h = "medium",
    variant: v = "outlined"
  } = n, g = ge(n, Tce), b = T({}, n, {
    color: i,
    component: l,
    disabled: c,
    error: u,
    fullWidth: f,
    hiddenLabel: p,
    margin: m,
    required: y,
    size: h,
    variant: v
  }), x = Ece(b), [O, w] = P.useState(() => {
    let k = !1;
    return o && P.Children.forEach(o, (R) => {
      if (!As(R, ["Input", "Select"]))
        return;
      const D = As(R, ["Select"]) ? R.props.input : R;
      D && Lle(D.props) && (k = !0);
    }), k;
  }), [S, E] = P.useState(() => {
    let k = !1;
    return o && P.Children.forEach(o, (R) => {
      As(R, ["Input", "Select"]) && Vb(R.props, !0) && (k = !0);
    }), k;
  }), [C, N] = P.useState(!1);
  c && C && N(!1);
  const $ = d !== void 0 && !c ? d : C;
  let j;
  if (process.env.NODE_ENV !== "production") {
    const k = P.useRef(!1);
    j = () => (k.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), k.current = !0, () => {
      k.current = !1;
    });
  }
  const A = P.useMemo(() => ({
    adornedStart: O,
    setAdornedStart: w,
    color: i,
    disabled: c,
    error: u,
    filled: S,
    focused: $,
    fullWidth: f,
    hiddenLabel: p,
    size: h,
    onBlur: () => {
      N(!1);
    },
    onEmpty: () => {
      E(!1);
    },
    onFilled: () => {
      E(!0);
    },
    onFocus: () => {
      N(!0);
    },
    registerEffect: j,
    required: y,
    variant: v
  }), [O, i, c, u, S, $, f, p, j, y, h, v]);
  return /* @__PURE__ */ _.jsx(Jp.Provider, {
    value: A,
    children: /* @__PURE__ */ _.jsx($ce, T({
      as: l,
      ownerState: b,
      className: Pe(x.root, a),
      ref: r
    }, g, {
      children: o
    }))
  });
});
process.env.NODE_ENV !== "production" && (VI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: s.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: s.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: s.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: s.oneOf(["dense", "none", "normal"]),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: s.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: s.oneOfType([s.oneOf(["medium", "small"]), s.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
const Cce = VI;
function kce(e) {
  return ze("MuiFormHelperText", e);
}
const Rce = Le("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]), h1 = Rce;
var y1;
const Dce = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"], Nce = (e) => {
  const {
    classes: t,
    contained: r,
    size: n,
    disabled: o,
    error: a,
    filled: i,
    focused: l,
    required: c
  } = e, u = {
    root: ["root", o && "disabled", a && "error", n && `size${Te(n)}`, r && "contained", l && "focused", i && "filled", c && "required"]
  };
  return Ve(u, kce, t);
}, Ice = ce("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.size && t[`size${Te(r.size)}`], r.contained && t.contained, r.filled && t.filled];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  color: (e.vars || e).palette.text.secondary
}, e.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${h1.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${h1.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}, t.size === "small" && {
  marginTop: 4
}, t.contained && {
  marginLeft: 14,
  marginRight: 14
})), zI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: o,
    className: a,
    component: i = "p"
  } = n, l = ge(n, Dce), c = qa(), u = os({
    props: n,
    muiFormControl: c,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), d = T({}, n, {
    component: i,
    contained: u.variant === "filled" || u.variant === "outlined",
    variant: u.variant,
    size: u.size,
    disabled: u.disabled,
    error: u.error,
    filled: u.filled,
    focused: u.focused,
    required: u.required
  }), f = Nce(d);
  return /* @__PURE__ */ _.jsx(Ice, T({
    as: i,
    ownerState: d,
    className: Pe(f.root, a),
    ref: r
  }, l, {
    children: o === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      y1 || (y1 = /* @__PURE__ */ _.jsx("span", {
        className: "notranslate",
        children: "â€‹"
      }))
    ) : o
  }));
});
process.env.NODE_ENV !== "production" && (zI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: s.bool,
  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: s.bool,
  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: s.bool,
  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: s.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: s.oneOf(["dense"]),
  /**
   * If `true`, the helper text should use required classes key.
   */
  required: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   */
  variant: s.oneOfType([s.oneOf(["filled", "outlined", "standard"]), s.string])
});
const Mce = zI, Ace = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function mh(e, t, r) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : r ? null : e.firstChild;
}
function v1(e, t, r) {
  return e === t ? r ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : r ? null : e.lastChild;
}
function BI(e, t) {
  if (t === void 0)
    return !0;
  let r = e.innerText;
  return r === void 0 && (r = e.textContent), r = r.trim().toLowerCase(), r.length === 0 ? !1 : t.repeating ? r[0] === t.keys[0] : r.indexOf(t.keys.join("")) === 0;
}
function $s(e, t, r, n, o, a) {
  let i = !1, l = o(e, t, t ? r : !1);
  for (; l; ) {
    if (l === e.firstChild) {
      if (i)
        return !1;
      i = !0;
    }
    const c = n ? !1 : l.disabled || l.getAttribute("aria-disabled") === "true";
    if (!l.hasAttribute("tabindex") || !BI(l, a) || c)
      l = o(e, l, r);
    else
      return l.focus(), !0;
  }
  return !1;
}
const WI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: n,
    autoFocus: o = !1,
    autoFocusItem: a = !1,
    children: i,
    className: l,
    disabledItemsFocusable: c = !1,
    disableListWrap: u = !1,
    onKeyDown: d,
    variant: f = "selectedMenu"
  } = t, p = ge(t, Ace), m = P.useRef(null), y = P.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  wr(() => {
    o && m.current.focus();
  }, [o]), P.useImperativeHandle(n, () => ({
    adjustStyleForScrollbar: (x, O) => {
      const w = !m.current.style.width;
      if (x.clientHeight < m.current.clientHeight && w) {
        const S = `${HT(nr(x))}px`;
        m.current.style[O.direction === "rtl" ? "paddingLeft" : "paddingRight"] = S, m.current.style.width = `calc(100% + ${S})`;
      }
      return m.current;
    }
  }), []);
  const h = (x) => {
    const O = m.current, w = x.key, S = nr(O).activeElement;
    if (w === "ArrowDown")
      x.preventDefault(), $s(O, S, u, c, mh);
    else if (w === "ArrowUp")
      x.preventDefault(), $s(O, S, u, c, v1);
    else if (w === "Home")
      x.preventDefault(), $s(O, null, u, c, mh);
    else if (w === "End")
      x.preventDefault(), $s(O, null, u, c, v1);
    else if (w.length === 1) {
      const E = y.current, C = w.toLowerCase(), N = performance.now();
      E.keys.length > 0 && (N - E.lastTime > 500 ? (E.keys = [], E.repeating = !0, E.previousKeyMatched = !0) : E.repeating && C !== E.keys[0] && (E.repeating = !1)), E.lastTime = N, E.keys.push(C);
      const $ = S && !E.repeating && BI(S, E);
      E.previousKeyMatched && ($ || $s(O, S, !1, c, mh, E)) ? x.preventDefault() : E.previousKeyMatched = !1;
    }
    d && d(x);
  }, v = Lt(m, r);
  let g = -1;
  P.Children.forEach(i, (x, O) => {
    /* @__PURE__ */ P.isValidElement(x) && (process.env.NODE_ENV !== "production" && Ci.isFragment(x) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), x.props.disabled || (f === "selectedMenu" && x.props.selected || g === -1) && (g = O), g === O && (x.props.disabled || x.props.muiSkipListHighlight || x.type.muiSkipListHighlight) && (g += 1, g >= i.length && (g = -1)));
  });
  const b = P.Children.map(i, (x, O) => {
    if (O === g) {
      const w = {};
      return a && (w.autoFocus = !0), x.props.tabIndex === void 0 && f === "selectedMenu" && (w.tabIndex = 0), /* @__PURE__ */ P.cloneElement(x, w);
    }
    return x;
  });
  return /* @__PURE__ */ _.jsx(pI, T({
    role: "menu",
    ref: v,
    className: l,
    onKeyDown: h,
    tabIndex: o ? 0 : -1
  }, p, {
    children: b
  }));
});
process.env.NODE_ENV !== "production" && (WI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: s.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: s.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: s.node,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: s.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: s.bool,
  /**
   * @ignore
   */
  onKeyDown: s.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: s.oneOf(["menu", "selectedMenu"])
});
const jce = WI;
function Fce(e) {
  return ze("MuiPopover", e);
}
Le("MuiPopover", ["root", "paper"]);
const Lce = ["onEntering"], Vce = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
function g1(e, t) {
  let r = 0;
  return typeof t == "number" ? r = t : t === "center" ? r = e.height / 2 : t === "bottom" && (r = e.height), r;
}
function b1(e, t) {
  let r = 0;
  return typeof t == "number" ? r = t : t === "center" ? r = e.width / 2 : t === "right" && (r = e.width), r;
}
function w1(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function wu(e) {
  return typeof e == "function" ? e() : e;
}
const zce = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    paper: ["paper"]
  }, Fce, t);
}, Bce = ce(AN, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), Wce = ce(Ml, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), UI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiPopover"
  }), {
    action: o,
    anchorEl: a,
    anchorOrigin: i = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: l,
    anchorReference: c = "anchorEl",
    children: u,
    className: d,
    container: f,
    elevation: p = 8,
    marginThreshold: m = 16,
    open: y,
    PaperProps: h = {},
    transformOrigin: v = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: g = BN,
    transitionDuration: b = "auto",
    TransitionProps: {
      onEntering: x
    } = {}
  } = n, O = ge(n.TransitionProps, Lce), w = ge(n, Vce), S = P.useRef(), E = Lt(S, h.ref), C = T({}, n, {
    anchorOrigin: i,
    anchorReference: c,
    elevation: p,
    marginThreshold: m,
    PaperProps: h,
    transformOrigin: v,
    TransitionComponent: g,
    transitionDuration: b,
    TransitionProps: O
  }), N = zce(C), $ = P.useCallback(() => {
    if (c === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (l || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), l;
    const I = wu(a), V = I && I.nodeType === 1 ? I : nr(S.current).body, G = V.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const q = V.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && q.top === 0 && q.left === 0 && q.right === 0 && q.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: G.top + g1(G, i.vertical),
      left: G.left + b1(G, i.horizontal)
    };
  }, [a, i.horizontal, i.vertical, l, c]), j = P.useCallback((I) => ({
    vertical: g1(I, v.vertical),
    horizontal: b1(I, v.horizontal)
  }), [v.horizontal, v.vertical]), A = P.useCallback((I) => {
    const V = {
      width: I.offsetWidth,
      height: I.offsetHeight
    }, G = j(V);
    if (c === "none")
      return {
        top: null,
        left: null,
        transformOrigin: w1(G)
      };
    const q = $();
    let J = q.top - G.vertical, ne = q.left - G.horizontal;
    const te = J + V.height, ee = ne + V.width, K = ho(wu(a)), Q = K.innerHeight - m, ae = K.innerWidth - m;
    if (J < m) {
      const ie = J - m;
      J -= ie, G.vertical += ie;
    } else if (te > Q) {
      const ie = te - Q;
      J -= ie, G.vertical += ie;
    }
    if (process.env.NODE_ENV !== "production" && V.height > Q && V.height && Q && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${V.height - Q}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), ne < m) {
      const ie = ne - m;
      ne -= ie, G.horizontal += ie;
    } else if (ee > ae) {
      const ie = ee - ae;
      ne -= ie, G.horizontal += ie;
    }
    return {
      top: `${Math.round(J)}px`,
      left: `${Math.round(ne)}px`,
      transformOrigin: w1(G)
    };
  }, [a, c, $, j, m]), [k, R] = P.useState(y), D = P.useCallback(() => {
    const I = S.current;
    if (!I)
      return;
    const V = A(I);
    V.top !== null && (I.style.top = V.top), V.left !== null && (I.style.left = V.left), I.style.transformOrigin = V.transformOrigin, R(!0);
  }, [A]), L = (I, V) => {
    x && x(I, V), D();
  }, B = () => {
    R(!1);
  };
  P.useEffect(() => {
    y && D();
  }), P.useImperativeHandle(o, () => y ? {
    updatePosition: () => {
      D();
    }
  } : null, [y, D]), P.useEffect(() => {
    if (!y)
      return;
    const I = ki(() => {
      D();
    }), V = ho(a);
    return V.addEventListener("resize", I), () => {
      I.clear(), V.removeEventListener("resize", I);
    };
  }, [a, y, D]);
  let H = b;
  b === "auto" && !g.muiSupportAuto && (H = void 0);
  const U = f || (a ? nr(wu(a)).body : void 0);
  return /* @__PURE__ */ _.jsx(Bce, T({
    BackdropProps: {
      invisible: !0
    },
    className: Pe(N.root, d),
    container: U,
    open: y,
    ref: r,
    ownerState: C
  }, w, {
    children: /* @__PURE__ */ _.jsx(g, T({
      appear: !0,
      in: y,
      onEntering: L,
      onExited: B,
      timeout: H
    }, O, {
      children: /* @__PURE__ */ _.jsx(Wce, T({
        elevation: p
      }, h, {
        ref: E,
        className: Pe(N.paper, h.className)
      }, k ? void 0 : {
        style: T({}, h.style, {
          opacity: 0
        })
      }, {
        ownerState: C,
        children: u
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" && (UI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: vn,
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the popover.
   */
  anchorEl: xo(s.oneOfType([Gn, s.func]), (e) => {
    if (e.open && (!e.anchorReference || e.anchorReference === "anchorEl")) {
      const t = wu(e.anchorEl);
      if (t && t.nodeType === 1) {
        const r = t.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && r.top === 0 && r.left === 0 && r.right === 0 && r.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element instance but it's \`${t}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: s.shape({
    horizontal: s.oneOfType([s.oneOf(["center", "left", "right"]), s.number]).isRequired,
    vertical: s.oneOfType([s.oneOf(["bottom", "center", "top"]), s.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: s.shape({
    left: s.number.isRequired,
    top: s.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: s.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: s.oneOfType([Gn, s.func]),
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: js,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * @default 16
   */
  marginThreshold: s.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: s.shape({
    component: ep
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: s.shape({
    horizontal: s.oneOfType([s.oneOf(["center", "left", "right"]), s.number]).isRequired,
    vertical: s.oneOfType([s.oneOf(["bottom", "center", "top"]), s.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: s.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: s.oneOfType([s.oneOf(["auto"]), s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: s.object
});
const Uce = UI;
function Hce(e) {
  return ze("MuiMenu", e);
}
Le("MuiMenu", ["root", "paper", "list"]);
const Yce = ["onEntering"], qce = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"], Gce = {
  vertical: "top",
  horizontal: "right"
}, Kce = {
  vertical: "top",
  horizontal: "left"
}, Xce = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, Hce, t);
}, Qce = ce(Uce, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), Zce = ce(Ml, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tapable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), Jce = ce(jce, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), HI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: o = !0,
    children: a,
    disableAutoFocusItem: i = !1,
    MenuListProps: l = {},
    onClose: c,
    open: u,
    PaperProps: d = {},
    PopoverClasses: f,
    transitionDuration: p = "auto",
    TransitionProps: {
      onEntering: m
    } = {},
    variant: y = "selectedMenu"
  } = n, h = ge(n.TransitionProps, Yce), v = ge(n, qce), g = Nr(), b = g.direction === "rtl", x = T({}, n, {
    autoFocus: o,
    disableAutoFocusItem: i,
    MenuListProps: l,
    onEntering: m,
    PaperProps: d,
    transitionDuration: p,
    TransitionProps: h,
    variant: y
  }), O = Xce(x), w = o && !i && u, S = P.useRef(null), E = ($, j) => {
    S.current && S.current.adjustStyleForScrollbar($, g), m && m($, j);
  }, C = ($) => {
    $.key === "Tab" && ($.preventDefault(), c && c($, "tabKeyDown"));
  };
  let N = -1;
  return P.Children.map(a, ($, j) => {
    /* @__PURE__ */ P.isValidElement($) && (process.env.NODE_ENV !== "production" && Ci.isFragment($) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), $.props.disabled || (y === "selectedMenu" && $.props.selected || N === -1) && (N = j));
  }), /* @__PURE__ */ _.jsx(Qce, T({
    onClose: c,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: b ? "right" : "left"
    },
    transformOrigin: b ? Gce : Kce,
    PaperProps: T({
      as: Zce
    }, d, {
      classes: T({}, d.classes, {
        root: O.paper
      })
    }),
    className: O.root,
    open: u,
    ref: r,
    transitionDuration: p,
    TransitionProps: T({
      onEntering: E
    }, h),
    ownerState: x
  }, v, {
    classes: f,
    children: /* @__PURE__ */ _.jsx(Jce, T({
      onKeyDown: C,
      actions: S,
      autoFocus: o && (N === -1 || i),
      autoFocusItem: w,
      variant: y
    }, l, {
      className: Pe(O.list, l.className),
      children: a
    }))
  }));
});
process.env.NODE_ENV !== "production" && (HI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: s.oneOfType([Gn, s.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: s.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: s.bool,
  /**
   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: s.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: s.object,
  /**
   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.
   */
  PopoverClasses: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: s.oneOfType([s.oneOf(["auto"]), s.number, s.shape({
    appear: s.number,
    enter: s.number,
    exit: s.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: s.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: s.oneOf(["menu", "selectedMenu"])
});
const eue = HI;
function tue(e) {
  return ze("MuiNativeSelect", e);
}
const rue = Le("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), Ub = rue, nue = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"], oue = (e) => {
  const {
    classes: t,
    variant: r,
    disabled: n,
    multiple: o,
    open: a,
    error: i
  } = e, l = {
    select: ["select", r, n && "disabled", o && "multiple", i && "error"],
    icon: ["icon", `icon${Te(r)}`, a && "iconOpen", n && "disabled"]
  };
  return Ve(l, tue, t);
}, YI = ({
  ownerState: e,
  theme: t
}) => T({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": T({}, t.vars ? {
    backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: t.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${Ub.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (t.vars || t).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, e.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, e.variant === "outlined" && {
  borderRadius: (t.vars || t).shape.borderRadius,
  "&:focus": {
    borderRadius: (t.vars || t).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
}), aue = ce("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: to,
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.select, t[r.variant], r.error && t.error, {
      [`&.${Ub.multiple}`]: t.multiple
    }];
  }
})(YI), qI = ({
  ownerState: e,
  theme: t
}) => T({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (t.vars || t).palette.action.active,
  [`&.${Ub.disabled}`]: {
    color: (t.vars || t).palette.action.disabled
  }
}, e.open && {
  transform: "rotate(180deg)"
}, e.variant === "filled" && {
  right: 7
}, e.variant === "outlined" && {
  right: 7
}), iue = ce("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.icon, r.variant && t[`icon${Te(r.variant)}`], r.open && t.iconOpen];
  }
})(qI), GI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    className: n,
    disabled: o,
    error: a,
    IconComponent: i,
    inputRef: l,
    variant: c = "standard"
  } = t, u = ge(t, nue), d = T({}, t, {
    disabled: o,
    variant: c,
    error: a
  }), f = oue(d);
  return /* @__PURE__ */ _.jsxs(P.Fragment, {
    children: [/* @__PURE__ */ _.jsx(aue, T({
      ownerState: d,
      className: Pe(f.select, n),
      disabled: o,
      ref: l || r
    }, u)), t.multiple ? null : /* @__PURE__ */ _.jsx(iue, {
      as: i,
      ownerState: d,
      className: f.icon
    })]
  });
});
process.env.NODE_ENV !== "production" && (GI.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: s.object,
  /**
   * The CSS class name of the select element.
   */
  className: s.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: s.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: s.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: s.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: vn,
  /**
   * @ignore
   */
  multiple: s.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: s.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * The input value.
   */
  value: s.any,
  /**
   * The variant to use.
   */
  variant: s.oneOf(["standard", "outlined", "filled"])
});
const sue = GI;
function lue(e) {
  return ze("MuiSelect", e);
}
const cue = Le("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), Cs = cue;
var x1;
const uue = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"], due = ce("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${Cs.select}`]: t.select
      },
      {
        [`&.${Cs.select}`]: t[r.variant]
      },
      {
        [`&.${Cs.error}`]: t.error
      },
      {
        [`&.${Cs.multiple}`]: t.multiple
      }
    ];
  }
})(YI, {
  // Win specificity over the input base
  [`&.${Cs.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), fue = ce("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.icon, r.variant && t[`icon${Te(r.variant)}`], r.open && t.iconOpen];
  }
})(qI), pue = ce("input", {
  shouldForwardProp: (e) => UL(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function _1(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function mue(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const hue = (e) => {
  const {
    classes: t,
    variant: r,
    disabled: n,
    multiple: o,
    open: a,
    error: i
  } = e, l = {
    select: ["select", r, n && "disabled", o && "multiple", i && "error"],
    icon: ["icon", `icon${Te(r)}`, a && "iconOpen", n && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return Ve(l, lue, t);
}, KI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    "aria-describedby": n,
    "aria-label": o,
    autoFocus: a,
    autoWidth: i,
    children: l,
    className: c,
    defaultOpen: u,
    defaultValue: d,
    disabled: f,
    displayEmpty: p,
    error: m = !1,
    IconComponent: y,
    inputRef: h,
    labelId: v,
    MenuProps: g = {},
    multiple: b,
    name: x,
    onBlur: O,
    onChange: w,
    onClose: S,
    onFocus: E,
    onOpen: C,
    open: N,
    readOnly: $,
    renderValue: j,
    SelectDisplayProps: A = {},
    tabIndex: k,
    value: R,
    variant: D = "standard"
  } = t, L = ge(t, uue), [B, H] = Wr({
    controlled: R,
    default: d,
    name: "Select"
  }), [U, I] = Wr({
    controlled: N,
    default: u,
    name: "Select"
  }), V = P.useRef(null), G = P.useRef(null), [q, J] = P.useState(null), {
    current: ne
  } = P.useRef(N != null), [te, ee] = P.useState(), K = Lt(r, h), Q = P.useCallback((we) => {
    G.current = we, we && J(we);
  }, []), ae = q == null ? void 0 : q.parentNode;
  P.useImperativeHandle(K, () => ({
    focus: () => {
      G.current.focus();
    },
    node: V.current,
    value: B
  }), [B]), P.useEffect(() => {
    u && U && q && !ne && (ee(i ? null : ae.clientWidth), G.current.focus());
  }, [q, i]), P.useEffect(() => {
    a && G.current.focus();
  }, [a]), P.useEffect(() => {
    if (!v)
      return;
    const we = nr(G.current).getElementById(v);
    if (we) {
      const ye = () => {
        getSelection().isCollapsed && G.current.focus();
      };
      return we.addEventListener("click", ye), () => {
        we.removeEventListener("click", ye);
      };
    }
  }, [v]);
  const ie = (we, ye) => {
    we ? C && C(ye) : S && S(ye), ne || (ee(i ? null : ae.clientWidth), I(we));
  }, oe = (we) => {
    we.button === 0 && (we.preventDefault(), G.current.focus(), ie(!0, we));
  }, se = (we) => {
    ie(!1, we);
  }, re = P.Children.toArray(l), le = (we) => {
    const ye = re.map((Re) => Re.props.value).indexOf(we.target.value);
    if (ye === -1)
      return;
    const _e = re[ye];
    H(_e.props.value), w && w(we, _e);
  }, M = (we) => (ye) => {
    let _e;
    if (ye.currentTarget.hasAttribute("tabindex")) {
      if (b) {
        _e = Array.isArray(B) ? B.slice() : [];
        const Re = B.indexOf(we.props.value);
        Re === -1 ? _e.push(we.props.value) : _e.splice(Re, 1);
      } else
        _e = we.props.value;
      if (we.props.onClick && we.props.onClick(ye), B !== _e && (H(_e), w)) {
        const Re = ye.nativeEvent || ye, je = new Re.constructor(Re.type, Re);
        Object.defineProperty(je, "target", {
          writable: !0,
          value: {
            value: _e,
            name: x
          }
        }), w(je, we);
      }
      b || ie(!1, ye);
    }
  }, W = (we) => {
    $ || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].indexOf(we.key) !== -1 && (we.preventDefault(), ie(!0, we));
  }, Z = q !== null && U, he = (we) => {
    !Z && O && (Object.defineProperty(we, "target", {
      writable: !0,
      value: {
        value: B,
        name: x
      }
    }), O(we));
  };
  delete L["aria-invalid"];
  let me, de;
  const ue = [];
  let Oe = !1, Se = !1;
  (Vb({
    value: B
  }) || p) && (j ? me = j(B) : Oe = !0);
  const De = re.map((we) => {
    if (!/* @__PURE__ */ P.isValidElement(we))
      return null;
    process.env.NODE_ENV !== "production" && Ci.isFragment(we) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let ye;
    if (b) {
      if (!Array.isArray(B))
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : Go(2));
      ye = B.some((_e) => _1(_e, we.props.value)), ye && Oe && ue.push(we.props.children);
    } else
      ye = _1(B, we.props.value), ye && Oe && (de = we.props.children);
    return ye && (Se = !0), /* @__PURE__ */ P.cloneElement(we, {
      "aria-selected": ye ? "true" : "false",
      onClick: M(we),
      onKeyUp: (_e) => {
        _e.key === " " && _e.preventDefault(), we.props.onKeyUp && we.props.onKeyUp(_e);
      },
      role: "option",
      selected: ye,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": we.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  process.env.NODE_ENV !== "production" && P.useEffect(() => {
    if (!Se && !b && B !== "") {
      const we = re.map((ye) => ye.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${B}\` for the select ${x ? `(name="${x}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${we.filter((ye) => ye != null).map((ye) => `\`${ye}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [Se, re, b, x, B]), Oe && (b ? ue.length === 0 ? me = null : me = ue.reduce((we, ye, _e) => (we.push(ye), _e < ue.length - 1 && we.push(", "), we), []) : me = de);
  let nt = te;
  !i && ne && q && (nt = ae.clientWidth);
  let rt;
  typeof k < "u" ? rt = k : rt = f ? null : 0;
  const Be = A.id || (x ? `mui-component-select-${x}` : void 0), Ie = T({}, t, {
    variant: D,
    value: B,
    open: Z,
    error: m
  }), it = hue(Ie);
  return /* @__PURE__ */ _.jsxs(P.Fragment, {
    children: [/* @__PURE__ */ _.jsx(due, T({
      ref: Q,
      tabIndex: rt,
      role: "button",
      "aria-disabled": f ? "true" : void 0,
      "aria-expanded": Z ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": o,
      "aria-labelledby": [v, Be].filter(Boolean).join(" ") || void 0,
      "aria-describedby": n,
      onKeyDown: W,
      onMouseDown: f || $ ? null : oe,
      onBlur: he,
      onFocus: E
    }, A, {
      ownerState: Ie,
      className: Pe(A.className, it.select, c),
      id: Be,
      children: mue(me) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        x1 || (x1 = /* @__PURE__ */ _.jsx("span", {
          className: "notranslate",
          children: "â€‹"
        }))
      ) : me
    })), /* @__PURE__ */ _.jsx(pue, T({
      "aria-invalid": m,
      value: Array.isArray(B) ? B.join(",") : B,
      name: x,
      ref: V,
      "aria-hidden": !0,
      onChange: le,
      tabIndex: -1,
      disabled: f,
      className: it.nativeInput,
      autoFocus: a,
      ownerState: Ie
    }, L)), /* @__PURE__ */ _.jsx(fue, {
      as: y,
      className: it.icon,
      ownerState: Ie
    }), /* @__PURE__ */ _.jsx(eue, T({
      id: `menu-${x || ""}`,
      anchorEl: ae,
      open: Z,
      onClose: se,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, g, {
      MenuListProps: T({
        "aria-labelledby": v,
        role: "listbox",
        disableListWrap: !0
      }, g.MenuListProps),
      PaperProps: T({}, g.PaperProps, {
        style: T({
          minWidth: nt
        }, g.PaperProps != null ? g.PaperProps.style : null)
      }),
      children: De
    }))]
  });
});
process.env.NODE_ENV !== "production" && (KI.propTypes = {
  /**
   * @ignore
   */
  "aria-describedby": s.string,
  /**
   * @ignore
   */
  "aria-label": s.string,
  /**
   * @ignore
   */
  autoFocus: s.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: s.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: s.object,
  /**
   * The CSS class name of the select element.
   */
  className: s.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: s.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: s.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: s.bool,
  /**
   * If `true`, the `select input` will indicate an error.
   */
  error: s.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: s.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: vn,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: s.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: s.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: s.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: s.string,
  /**
   * @ignore
   */
  onBlur: s.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: s.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: s.func,
  /**
   * @ignore
   */
  onFocus: s.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: s.func,
  /**
   * If `true`, the component is shown.
   */
  open: s.bool,
  /**
   * @ignore
   */
  readOnly: s.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: s.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: s.object,
  /**
   * @ignore
   */
  tabIndex: s.oneOfType([s.number, s.string]),
  /**
   * @ignore
   */
  type: s.any,
  /**
   * The input value.
   */
  value: s.any,
  /**
   * The variant to use.
   */
  variant: s.oneOf(["standard", "outlined", "filled"])
});
const yue = KI, vue = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), gue = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], bue = (e) => {
  const {
    classes: t
  } = e;
  return t;
}, Hb = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => to(e) && e !== "variant",
  slot: "Root"
}, wue = ce(II, Hb)(""), xue = ce(jI, Hb)(""), _ue = ce(MI, Hb)(""), Yb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: o = !1,
    children: a,
    classes: i = {},
    className: l,
    defaultOpen: c = !1,
    displayEmpty: u = !1,
    IconComponent: d = vue,
    id: f,
    input: p,
    inputProps: m,
    label: y,
    labelId: h,
    MenuProps: v,
    multiple: g = !1,
    native: b = !1,
    onClose: x,
    onOpen: O,
    open: w,
    renderValue: S,
    SelectDisplayProps: E,
    variant: C = "outlined"
  } = n, N = ge(n, gue), $ = b ? sue : yue, j = qa(), A = os({
    props: n,
    muiFormControl: j,
    states: ["variant", "error"]
  }), k = A.variant || C, R = T({}, n, {
    variant: k,
    classes: i
  }), D = bue(R), L = p || {
    standard: /* @__PURE__ */ _.jsx(wue, {
      ownerState: R
    }),
    outlined: /* @__PURE__ */ _.jsx(xue, {
      label: y,
      ownerState: R
    }),
    filled: /* @__PURE__ */ _.jsx(_ue, {
      ownerState: R
    })
  }[k], B = Lt(r, L.ref);
  return /* @__PURE__ */ _.jsx(P.Fragment, {
    children: /* @__PURE__ */ P.cloneElement(L, T({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: $,
      inputProps: T({
        children: a,
        error: A.error,
        IconComponent: d,
        variant: k,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: g
      }, b ? {
        id: f
      } : {
        autoWidth: o,
        defaultOpen: c,
        displayEmpty: u,
        labelId: h,
        MenuProps: v,
        onClose: x,
        onOpen: O,
        open: w,
        renderValue: S,
        SelectDisplayProps: T({
          id: f
        }, E)
      }, m, {
        classes: m ? an(D, m.classes) : D
      }, p ? p.props.inputProps : {})
    }, g && b && k === "outlined" ? {
      notched: !0
    } : {}, {
      ref: B,
      className: Pe(L.props.className, l)
    }, !p && {
      variant: k
    }, N))
  });
});
process.env.NODE_ENV !== "production" && (Yb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: s.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * âš ï¸The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: s.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   * âš ï¸ When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: s.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: s.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: s.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: s.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: s.object,
  /**
   * See [OutlinedInput#label](/material-ui/api/outlined-input/#props)
   */
  label: s.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: s.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: s.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: s.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: s.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<T>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: s.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapes).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: s.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: s.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: s.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: s.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: s.oneOfType([s.oneOf([""]), s.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
Yb.muiName = "Select";
const XI = Yb;
function Oue(e) {
  return ze("MuiTextField", e);
}
Le("MuiTextField", ["root"]);
const Pue = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"], Sue = {
  standard: II,
  filled: MI,
  outlined: jI
}, Tue = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, Oue, t);
}, Eue = ce(Cce, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), QI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: o,
    autoFocus: a = !1,
    children: i,
    className: l,
    color: c = "primary",
    defaultValue: u,
    disabled: d = !1,
    error: f = !1,
    FormHelperTextProps: p,
    fullWidth: m = !1,
    helperText: y,
    id: h,
    InputLabelProps: v,
    inputProps: g,
    InputProps: b,
    inputRef: x,
    label: O,
    maxRows: w,
    minRows: S,
    multiline: E = !1,
    name: C,
    onBlur: N,
    onChange: $,
    onFocus: j,
    placeholder: A,
    required: k = !1,
    rows: R,
    select: D = !1,
    SelectProps: L,
    type: B,
    value: H,
    variant: U = "outlined"
  } = n, I = ge(n, Pue), V = T({}, n, {
    autoFocus: a,
    color: c,
    disabled: d,
    error: f,
    fullWidth: m,
    multiline: E,
    required: k,
    select: D,
    variant: U
  }), G = Tue(V);
  process.env.NODE_ENV !== "production" && D && !i && console.error("MUI: `children` must be passed when using the `TextField` component with `select`.");
  const q = {};
  U === "outlined" && (v && typeof v.shrink < "u" && (q.notched = v.shrink), q.label = O), D && ((!L || !L.native) && (q.id = void 0), q["aria-describedby"] = void 0);
  const J = Ri(h), ne = y && J ? `${J}-helper-text` : void 0, te = O && J ? `${J}-label` : void 0, ee = Sue[U], K = /* @__PURE__ */ _.jsx(ee, T({
    "aria-describedby": ne,
    autoComplete: o,
    autoFocus: a,
    defaultValue: u,
    fullWidth: m,
    multiline: E,
    name: C,
    rows: R,
    maxRows: w,
    minRows: S,
    type: B,
    value: H,
    id: J,
    inputRef: x,
    onBlur: N,
    onChange: $,
    onFocus: j,
    placeholder: A,
    inputProps: g
  }, q, b));
  return /* @__PURE__ */ _.jsxs(Eue, T({
    className: Pe(G.root, l),
    disabled: d,
    error: f,
    fullWidth: m,
    ref: r,
    required: k,
    color: c,
    variant: U,
    ownerState: V
  }, I, {
    children: [O != null && O !== "" && /* @__PURE__ */ _.jsx(Pce, T({
      htmlFor: J,
      id: te
    }, v, {
      children: O
    })), D ? /* @__PURE__ */ _.jsx(XI, T({
      "aria-describedby": ne,
      id: J,
      labelId: te,
      value: H,
      input: K
    }, L, {
      children: i
    })) : K, y && /* @__PURE__ */ _.jsx(Mce, T({
      id: ne
    }, p, {
      children: y
    }))]
  }));
});
process.env.NODE_ENV !== "production" && (QI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: s.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: s.bool,
  /**
   * @ignore
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: s.oneOfType([s.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), s.string]),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: s.bool,
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: s.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The helper text content.
   */
  helperText: s.node,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: s.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: s.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: s.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: vn,
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: s.oneOf(["dense", "none", "normal"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: s.oneOfType([s.number, s.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: s.oneOfType([s.number, s.string]),
  /**
   * If `true`, a `textarea` element is rendered instead of an input.
   * @default false
   */
  multiline: s.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  /**
   * @ignore
   */
  onBlur: s.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: s.func,
  /**
   * @ignore
   */
  onFocus: s.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: s.string,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: s.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: s.oneOfType([s.number, s.string]),
  /**
   * Render a [`Select`](/material-ui/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   * @default false
   */
  select: s.bool,
  /**
   * Props applied to the [`Select`](/material-ui/api/select/) element.
   */
  SelectProps: s.object,
  /**
   * The size of the component.
   */
  size: s.oneOfType([s.oneOf(["medium", "small"]), s.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: s.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: s.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
const ZI = QI, $ue = ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "minDate", "maxDate", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef"], Cue = (e) => {
  var t, r, n;
  const o = wt(), a = Ya();
  return T({}, e, {
    disablePast: (t = e.disablePast) != null ? t : !1,
    disableFuture: (r = e.disableFuture) != null ? r : !1,
    format: (n = e.format) != null ? n : o.formats.keyboardDate,
    minDate: vr(o, e.minDate, a.minDate),
    maxDate: vr(o, e.maxDate, a.maxDate)
  });
}, kue = ({
  props: e,
  inputRef: t
}) => {
  const r = Cue(e), {
    value: n,
    defaultValue: o,
    format: a,
    onChange: i,
    readOnly: l,
    onError: c,
    shouldDisableDate: u,
    shouldDisableMonth: d,
    shouldDisableYear: f,
    minDate: p,
    maxDate: m,
    disableFuture: y,
    disablePast: h,
    selectedSections: v,
    onSelectedSectionsChange: g,
    unstableFieldRef: b
  } = r, x = ge(r, $ue);
  return aI({
    inputRef: t,
    forwardedProps: x,
    internalProps: {
      value: n,
      defaultValue: o,
      format: a,
      onChange: i,
      readOnly: l,
      onError: c,
      shouldDisableDate: u,
      shouldDisableMonth: d,
      shouldDisableYear: f,
      minDate: p,
      maxDate: m,
      disableFuture: y,
      disablePast: h,
      selectedSections: v,
      onSelectedSectionsChange: g,
      unstableFieldRef: b
    },
    valueManager: rs,
    fieldValueManager: QD,
    validator: Al,
    valueType: "date"
  });
}, Rue = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"], Due = ["inputRef"], Nue = ["ref", "onPaste", "inputMode", "readOnly"], qb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a;
  const i = Ae({
    props: t,
    name: "MuiDateField"
  }), {
    components: l,
    componentsProps: c,
    slots: u,
    slotProps: d,
    InputProps: f,
    inputProps: p
  } = i, m = ge(i, Rue), y = i, h = (n = (o = u == null ? void 0 : u.textField) != null ? o : l == null ? void 0 : l.TextField) != null ? n : ZI, v = It({
    elementType: h,
    externalSlotProps: (a = d == null ? void 0 : d.textField) != null ? a : c == null ? void 0 : c.textField,
    externalForwardedProps: m,
    ownerState: y
  }), {
    inputRef: g
  } = v, b = ge(v, Due);
  b.inputProps = T({}, b.inputProps, p), b.InputProps = T({}, b.InputProps, f);
  const x = kue({
    props: b,
    inputRef: g
  }), {
    ref: O,
    onPaste: w,
    inputMode: S,
    readOnly: E
  } = x, C = ge(x, Nue);
  return /* @__PURE__ */ _.jsx(h, T({
    ref: r
  }, C, {
    inputProps: T({}, C.inputProps, {
      ref: O,
      onPaste: w,
      inputMode: S,
      readOnly: E
    })
  }));
});
process.env.NODE_ENV !== "production" && (qb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: s.bool,
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: s.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: s.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: s.string,
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: s.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The helper text content.
   */
  helperText: s.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: s.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: s.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: s.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: s.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.any.isRequired
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: s.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  onBlur: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  onFocus: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: s.bool,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: s.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * The size of the component.
   */
  size: s.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  style: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: s.oneOfType([s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
function Iue(e) {
  return ze("MuiPickersMonth", e);
}
const uc = Le("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]), Mue = ["autoFocus", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "monthsPerRow"], Aue = (e) => {
  const {
    disabled: t,
    selected: r,
    classes: n
  } = e;
  return Ve({
    root: ["root"],
    monthButton: ["monthButton", t && "disabled", r && "selected"]
  }, Iue, n);
}, jue = ce("div", {
  name: "MuiPickersMonth",
  slot: "Root",
  overridesResolver: (e, t) => [t.root]
})(({
  ownerState: e
}) => ({
  flexBasis: e.monthsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), Fue = ce("button", {
  name: "MuiPickersMonth",
  slot: "MonthButton",
  overridesResolver: (e, t) => [t.monthButton, {
    [`&.${uc.disabled}`]: t.disabled
  }, {
    [`&.${uc.selected}`]: t.selected
  }]
})(({
  theme: e
}) => T({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, e.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${uc.disabled}`]: {
    color: (e.vars || e).palette.text.secondary
  },
  [`&.${uc.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  }
})), Lue = /* @__PURE__ */ P.memo(function(t) {
  const r = Ae({
    props: t,
    name: "MuiPickersMonth"
  }), {
    autoFocus: n,
    children: o,
    disabled: a,
    value: i,
    tabIndex: l,
    onClick: c,
    onKeyDown: u,
    onFocus: d,
    onBlur: f,
    "aria-current": p
    // We don't want to forward this prop to the root element
  } = r, m = ge(r, Mue), y = P.useRef(null), h = Aue(r);
  return wr(() => {
    if (n) {
      var v;
      (v = y.current) == null || v.focus();
    }
  }, [n]), /* @__PURE__ */ _.jsx(jue, T({
    className: h.root,
    ownerState: r
  }, m, {
    children: /* @__PURE__ */ _.jsx(Fue, {
      ref: y,
      disabled: a,
      type: "button",
      tabIndex: a ? -1 : l,
      "aria-current": p,
      onClick: (v) => c(v, i),
      onKeyDown: (v) => u(v, i),
      onFocus: (v) => d(v, i),
      onBlur: (v) => f(v, i),
      className: h.monthButton,
      ownerState: r,
      children: o
    })
  }));
});
function Vue(e) {
  return ze("MuiMonthCalendar", e);
}
Le("MuiMonthCalendar", ["root"]);
const zue = ["className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow"], Bue = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, Vue, t);
};
function Wue(e, t) {
  const r = wt(), n = Ya(), o = Ae({
    props: e,
    name: t
  });
  return T({
    disableFuture: !1,
    disablePast: !1
  }, o, {
    minDate: vr(r, o.minDate, n.minDate),
    maxDate: vr(r, o.maxDate, n.maxDate)
  });
}
const Uue = ce("div", {
  name: "MuiMonthCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  padding: "0 4px",
  width: 320
}), JI = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = ns(), o = xl(), a = wt(), i = Wue(t, "MuiMonthCalendar"), {
    className: l,
    value: c,
    defaultValue: u,
    disabled: d,
    disableFuture: f,
    disablePast: p,
    maxDate: m,
    minDate: y,
    onChange: h,
    shouldDisableMonth: v,
    readOnly: g,
    disableHighlightToday: b,
    autoFocus: x = !1,
    onMonthFocus: O,
    hasFocus: w,
    onFocusedViewChange: S,
    monthsPerRow: E = 3
  } = i, C = ge(i, zue), N = i, $ = Bue(N), [j, A] = Wr({
    name: "MonthCalendar",
    state: "value",
    controlled: c,
    default: u ?? null
  }), k = P.useMemo(() => a.getMonth(n), [a, n]), R = P.useMemo(() => j ?? a.startOfMonth(n), [n, a, j]), D = P.useMemo(() => j != null ? a.getMonth(j) : b ? null : a.getMonth(n), [n, j, a, b]), [L, B] = P.useState(() => D || k), [H, U] = Wr({
    name: "MonthCalendar",
    state: "hasFocus",
    controlled: w,
    default: x ?? !1
  }), I = $t((ee) => {
    U(ee), S && S(ee);
  }), V = $t((ee) => {
    const K = a.startOfMonth(p && a.isAfter(n, y) ? n : y), Q = a.startOfMonth(f && a.isBefore(n, m) ? n : m);
    return a.isBefore(ee, K) || a.isAfter(ee, Q) ? !0 : v ? v(ee) : !1;
  }), G = $t((ee, K) => {
    if (g)
      return;
    const Q = a.setMonth(R, K);
    A(Q), h == null || h(Q);
  }), q = $t((ee) => {
    V(a.setMonth(R, ee)) || (B(ee), I(!0), O && O(ee));
  });
  P.useEffect(() => {
    B((ee) => D !== null && ee !== D ? D : ee);
  }, [D]);
  const J = $t((ee, K) => {
    switch (ee.key) {
      case "ArrowUp":
        q((12 + K - 3) % 12), ee.preventDefault();
        break;
      case "ArrowDown":
        q((12 + K + 3) % 12), ee.preventDefault();
        break;
      case "ArrowLeft":
        q((12 + K + (o.direction === "ltr" ? -1 : 1)) % 12), ee.preventDefault();
        break;
      case "ArrowRight":
        q((12 + K + (o.direction === "ltr" ? 1 : -1)) % 12), ee.preventDefault();
        break;
    }
  }), ne = $t((ee, K) => {
    q(K);
  }), te = $t((ee, K) => {
    L === K && I(!1);
  });
  return /* @__PURE__ */ _.jsx(Uue, T({
    ref: r,
    className: Pe($.root, l),
    ownerState: N
  }, C, {
    children: a.getMonthArray(R).map((ee) => {
      const K = a.getMonth(ee), Q = a.format(ee, "monthShort"), ae = K === D, ie = d || V(ee);
      return /* @__PURE__ */ _.jsx(Lue, {
        selected: ae,
        value: K,
        onClick: G,
        onKeyDown: J,
        autoFocus: H && K === L,
        disabled: ie,
        tabIndex: K === L ? 0 : -1,
        onFocus: ne,
        onBlur: te,
        "aria-current": k === K ? "date" : void 0,
        monthsPerRow: E,
        children: Q
      }, Q);
    })
  }));
});
process.env.NODE_ENV !== "production" && (JI.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * className applied to the root element.
   */
  className: s.string,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true` picker is disabled
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  hasFocus: s.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   */
  onChange: s.func,
  onFocusedViewChange: s.func,
  onMonthFocus: s.func,
  /**
   * If `true` picker is readonly
   */
  readOnly: s.bool,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any
});
function Hue(e) {
  return ze("MuiPickersYear", e);
}
const dc = Le("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]), Yue = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow"], que = (e) => {
  const {
    disabled: t,
    selected: r,
    classes: n
  } = e;
  return Ve({
    root: ["root"],
    yearButton: ["yearButton", t && "disabled", r && "selected"]
  }, Hue, n);
}, Gue = ce("div", {
  name: "MuiPickersYear",
  slot: "Root",
  overridesResolver: (e, t) => [t.root]
})(({
  ownerState: e
}) => ({
  flexBasis: e.yearsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), Kue = ce("button", {
  name: "MuiPickersYear",
  slot: "YearButton",
  overridesResolver: (e, t) => [t.yearButton, {
    [`&.${dc.disabled}`]: t.disabled
  }, {
    [`&.${dc.selected}`]: t.selected
  }]
})(({
  theme: e
}) => T({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, e.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.focusOpacity})` : dt(e.palette.action.active, e.palette.action.focusOpacity)
  },
  "&:hover": {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : dt(e.palette.action.active, e.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${dc.disabled}`]: {
    color: (e.vars || e).palette.text.secondary
  },
  [`&.${dc.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText,
    backgroundColor: (e.vars || e).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (e.vars || e).palette.primary.dark
    }
  }
})), Xue = /* @__PURE__ */ P.memo(function(t) {
  const r = Ae({
    props: t,
    name: "MuiPickersYear"
  }), {
    autoFocus: n,
    className: o,
    children: a,
    disabled: i,
    value: l,
    tabIndex: c,
    onClick: u,
    onKeyDown: d,
    onFocus: f,
    onBlur: p,
    "aria-current": m
    // We don't want to forward this prop to the root element
  } = r, y = ge(r, Yue), h = P.useRef(null), v = que(r);
  return P.useEffect(() => {
    n && h.current.focus();
  }, [n]), /* @__PURE__ */ _.jsx(Gue, T({
    className: Pe(v.root, o),
    ownerState: r
  }, y, {
    children: /* @__PURE__ */ _.jsx(Kue, {
      ref: h,
      disabled: i,
      type: "button",
      tabIndex: i ? -1 : c,
      "aria-current": m,
      onClick: (g) => u(g, l),
      onKeyDown: (g) => d(g, l),
      onFocus: (g) => f(g, l),
      onBlur: (g) => p(g, l),
      className: v.yearButton,
      ownerState: r,
      children: a
    })
  }));
});
function Que(e) {
  return ze("MuiYearCalendar", e);
}
Le("MuiYearCalendar", ["root"]);
const Zue = ["autoFocus", "className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow"], Jue = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, Que, t);
};
function ede(e, t) {
  const r = wt(), n = Ya(), o = Ae({
    props: e,
    name: t
  });
  return T({
    disablePast: !1,
    disableFuture: !1
  }, o, {
    minDate: vr(r, o.minDate, n.minDate),
    maxDate: vr(r, o.maxDate, n.maxDate)
  });
}
const tde = ce("div", {
  name: "MuiYearCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  padding: "0 4px",
  width: 320,
  maxHeight: 304
}), eM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = ns(), o = xl(), a = wt(), i = ede(t, "MuiYearCalendar"), {
    autoFocus: l,
    className: c,
    value: u,
    defaultValue: d,
    disabled: f,
    disableFuture: p,
    disablePast: m,
    maxDate: y,
    minDate: h,
    onChange: v,
    readOnly: g,
    shouldDisableYear: b,
    disableHighlightToday: x,
    onYearFocus: O,
    hasFocus: w,
    onFocusedViewChange: S,
    yearsPerRow: E = 3
  } = i, C = ge(i, Zue), N = i, $ = Jue(N), [j, A] = Wr({
    name: "YearCalendar",
    state: "value",
    controlled: u,
    default: d ?? null
  }), k = P.useMemo(() => j ?? a.startOfYear(n), [n, a, j]), R = P.useMemo(() => a.getYear(n), [a, n]), D = P.useMemo(() => j != null ? a.getYear(j) : x ? null : a.getYear(n), [n, j, a, x]), [L, B] = P.useState(() => D || R), [H, U] = Wr({
    name: "YearCalendar",
    state: "hasFocus",
    controlled: w,
    default: l ?? !1
  }), I = $t((Q) => {
    U(Q), S && S(Q);
  }), V = $t((Q) => !!(m && a.isBeforeYear(Q, n) || p && a.isAfterYear(Q, n) || h && a.isBeforeYear(Q, h) || y && a.isAfterYear(Q, y) || b && b(Q))), G = $t((Q, ae) => {
    if (g)
      return;
    const ie = a.setYear(k, ae);
    A(ie), v == null || v(ie);
  }), q = $t((Q) => {
    V(a.setYear(k, Q)) || (B(Q), I(!0), O == null || O(Q));
  });
  P.useEffect(() => {
    B((Q) => D !== null && Q !== D ? D : Q);
  }, [D]);
  const J = $t((Q, ae) => {
    switch (Q.key) {
      case "ArrowUp":
        q(ae - E), Q.preventDefault();
        break;
      case "ArrowDown":
        q(ae + E), Q.preventDefault();
        break;
      case "ArrowLeft":
        q(ae + (o.direction === "ltr" ? -1 : 1)), Q.preventDefault();
        break;
      case "ArrowRight":
        q(ae + (o.direction === "ltr" ? 1 : -1)), Q.preventDefault();
        break;
    }
  }), ne = $t((Q, ae) => {
    q(ae);
  }), te = $t((Q, ae) => {
    L === ae && I(!1);
  }), ee = P.useRef(null), K = Lt(r, ee);
  return P.useEffect(() => {
    if (l || ee.current === null)
      return;
    const Q = ee.current.querySelector('[tabindex="0"]');
    if (!Q)
      return;
    const ae = Q.offsetHeight, ie = Q.offsetTop, oe = ee.current.clientHeight, se = ee.current.scrollTop, re = ie + ae;
    ae > oe || ie < se || (ee.current.scrollTop = re - oe / 2 - ae / 2);
  }, [l]), /* @__PURE__ */ _.jsx(tde, T({
    ref: K,
    className: Pe($.root, c),
    ownerState: N
  }, C, {
    children: a.getYearRange(h, y).map((Q) => {
      const ae = a.getYear(Q), ie = ae === D, oe = f || V(Q);
      return /* @__PURE__ */ _.jsx(Xue, {
        selected: ie,
        value: ae,
        onClick: G,
        onKeyDown: J,
        autoFocus: H && ae === L,
        disabled: oe,
        tabIndex: ae === L ? 0 : -1,
        onFocus: ne,
        onBlur: te,
        "aria-current": R === ae ? "date" : void 0,
        yearsPerRow: E,
        children: a.format(Q, "year")
      }, a.format(Q, "year"));
    })
  }));
});
process.env.NODE_ENV !== "production" && (eM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * className applied to the root element.
   */
  className: s.string,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true` picker is disabled
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  hasFocus: s.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   */
  onChange: s.func,
  onFocusedViewChange: s.func,
  onYearFocus: s.func,
  /**
   * If `true` picker is readonly
   */
  readOnly: s.bool,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: s.oneOf([3, 4])
});
const tM = ce("div")({
  overflow: "hidden",
  width: VN,
  maxHeight: zN,
  display: "flex",
  flexDirection: "column",
  margin: "0 auto"
}), rde = (e) => ze("MuiDateCalendar", e);
Le("MuiDateCalendar", ["root", "viewTransitionContainer"]);
const nde = ["autoFocus", "onViewChange", "value", "defaultValue", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "components", "componentsProps", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow"], ode = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  }, rde, t);
};
function ade(e, t) {
  const r = wt(), n = Ya(), o = Ae({
    props: e,
    name: t
  });
  return T({
    loading: !1,
    disablePast: !1,
    disableFuture: !1,
    openTo: "day",
    views: ["year", "day"],
    reduceAnimations: Fse,
    renderLoading: () => /* @__PURE__ */ _.jsx("span", {
      children: "..."
    })
  }, o, {
    minDate: vr(r, o.minDate, n.minDate),
    maxDate: vr(r, o.maxDate, n.maxDate)
  });
}
const ide = ce(tM, {
  name: "MuiDateCalendar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "column"
}), sde = ce(wI, {
  name: "MuiDateCalendar",
  slot: "ViewTransitionContainer",
  overridesResolver: (e, t) => t.viewTransitionContainer
})({}), rM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = wt(), o = Ri(), a = ade(t, "MuiDateCalendar"), {
    autoFocus: i,
    onViewChange: l,
    value: c,
    defaultValue: u,
    disableFuture: d,
    disablePast: f,
    defaultCalendarMonth: p,
    onChange: m,
    onYearChange: y,
    onMonthChange: h,
    reduceAnimations: v,
    shouldDisableDate: g,
    shouldDisableMonth: b,
    shouldDisableYear: x,
    view: O,
    views: w,
    openTo: S,
    className: E,
    disabled: C,
    readOnly: N,
    minDate: $,
    maxDate: j,
    disableHighlightToday: A,
    focusedView: k,
    onFocusedViewChange: R,
    showDaysOutsideCurrentMonth: D,
    fixedWeekNumber: L,
    dayOfWeekFormatter: B,
    components: H,
    componentsProps: U,
    slots: I,
    slotProps: V,
    loading: G,
    renderLoading: q,
    displayWeekNumber: J,
    yearsPerRow: ne,
    monthsPerRow: te
  } = a, ee = ge(a, nde), [K, Q] = Wr({
    name: "DateCalendar",
    state: "value",
    controlled: c,
    default: u ?? null
  }), ae = $t((Fe, Ze) => {
    Q(Fe), m == null || m(Fe, Ze);
  }), {
    view: ie,
    setView: oe,
    focusedView: se,
    setFocusedView: re,
    goToNextView: le,
    setValueAndGoToNextView: M
  } = Ab({
    view: O,
    views: w,
    openTo: S,
    onChange: ae,
    onViewChange: l,
    autoFocus: i,
    focusedView: k,
    onFocusedViewChange: R
  }), {
    calendarState: W,
    changeFocusedDay: Z,
    changeMonth: he,
    handleChangeMonth: me,
    isDateDisabled: de,
    onMonthSwitchingAnimationEnd: ue
  } = Tle({
    value: K,
    defaultCalendarMonth: p,
    reduceAnimations: v,
    onMonthChange: h,
    minDate: $,
    maxDate: j,
    shouldDisableDate: g,
    disablePast: f,
    disableFuture: d
  }), Oe = $t((Fe) => {
    const Ze = n.startOfMonth(Fe), ft = n.endOfMonth(Fe), Je = de(Fe) ? Ws({
      utils: n,
      date: Fe,
      minDate: n.isBefore($, Ze) ? Ze : $,
      maxDate: n.isAfter(j, ft) ? ft : j,
      disablePast: f,
      disableFuture: d,
      isDateDisabled: de
    }) : Fe;
    Je ? (M(Je, "finish"), h == null || h(Ze)) : (le(), he(Ze)), Z(Je, !0);
  }), Se = $t((Fe) => {
    const Ze = n.startOfYear(Fe), ft = n.endOfYear(Fe), Je = de(Fe) ? Ws({
      utils: n,
      date: Fe,
      minDate: n.isBefore($, Ze) ? Ze : $,
      maxDate: n.isAfter(j, ft) ? ft : j,
      disablePast: f,
      disableFuture: d,
      isDateDisabled: de
    }) : Fe;
    Je ? (M(Je, "finish"), y == null || y(Je)) : (le(), he(Ze)), Z(Je, !0);
  }), De = $t((Fe) => M(K && Fe ? n.mergeDateAndTime(Fe, K) : Fe, "finish"));
  P.useEffect(() => {
    K != null && n.isValid(K) && he(K);
  }, [K]);
  const nt = a, rt = ode(nt), Be = {
    disablePast: f,
    disableFuture: d,
    maxDate: j,
    minDate: $
  }, Ie = C && K || $, it = C && K || j, we = {
    disableHighlightToday: A,
    readOnly: N,
    disabled: C
  }, ye = `${o}-grid-label`, _e = se !== null, Re = P.useRef(ie);
  P.useEffect(() => {
    Re.current !== ie && (se === Re.current && re(ie, !0), Re.current = ie);
  }, [se, re, ie]);
  const je = P.useMemo(() => [K], [K]);
  return /* @__PURE__ */ _.jsxs(ide, T({
    ref: r,
    className: Pe(rt.root, E),
    ownerState: nt
  }, ee, {
    children: [/* @__PURE__ */ _.jsx(Zse, {
      views: w,
      view: ie,
      currentMonth: W.currentMonth,
      onViewChange: oe,
      onMonthChange: (Fe, Ze) => me({
        newMonth: Fe,
        direction: Ze
      }),
      minDate: Ie,
      maxDate: it,
      disabled: C,
      disablePast: f,
      disableFuture: d,
      reduceAnimations: v,
      labelId: ye,
      slots: I,
      slotProps: V
    }), /* @__PURE__ */ _.jsx(sde, {
      reduceAnimations: v,
      className: rt.viewTransitionContainer,
      transKey: ie,
      ownerState: nt,
      children: /* @__PURE__ */ _.jsxs("div", {
        children: [ie === "year" && /* @__PURE__ */ _.jsx(eM, T({}, Be, we, {
          value: K,
          onChange: Se,
          shouldDisableYear: x,
          hasFocus: _e,
          onFocusedViewChange: (Fe) => re("year", Fe),
          yearsPerRow: ne
        })), ie === "month" && /* @__PURE__ */ _.jsx(JI, T({}, Be, we, {
          hasFocus: _e,
          className: E,
          value: K,
          onChange: Oe,
          shouldDisableMonth: b,
          onFocusedViewChange: (Fe) => re("month", Fe),
          monthsPerRow: te
        })), ie === "day" && /* @__PURE__ */ _.jsx(Ple, T({}, W, Be, we, {
          onMonthSwitchingAnimationEnd: ue,
          onFocusedDayChange: Z,
          reduceAnimations: v,
          selectedDays: je,
          onSelectedDaysChange: De,
          shouldDisableDate: g,
          shouldDisableMonth: b,
          shouldDisableYear: x,
          hasFocus: _e,
          onFocusedViewChange: (Fe) => re("day", Fe),
          gridLabelId: ye,
          showDaysOutsideCurrentMonth: D,
          fixedWeekNumber: L,
          dayOfWeekFormatter: B,
          displayWeekNumber: J,
          components: H,
          componentsProps: U,
          slots: I,
          slotProps: V,
          loading: G,
          renderLoading: q
        }))]
      })
    })]
  }));
});
process.env.NODE_ENV !== "production" && (rM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  classes: s.object,
  className: s.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Controlled focused view.
   */
  focusedView: s.oneOf(["day", "month", "year"]),
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   */
  onChange: s.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "month", "year"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "month", "year"]),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: s.oneOf([3, 4])
});
const lde = (e) => e === "year" || e === "month" || e === "day", dn = ({
  view: e,
  onViewChange: t,
  views: r,
  focusedView: n,
  onFocusedViewChange: o,
  value: a,
  defaultValue: i,
  onChange: l,
  className: c,
  classes: u,
  disableFuture: d,
  disablePast: f,
  minDate: p,
  maxDate: m,
  shouldDisableDate: y,
  shouldDisableMonth: h,
  shouldDisableYear: v,
  reduceAnimations: g,
  onMonthChange: b,
  monthsPerRow: x,
  onYearChange: O,
  yearsPerRow: w,
  defaultCalendarMonth: S,
  components: E,
  componentsProps: C,
  slots: N,
  slotProps: $,
  loading: j,
  renderLoading: A,
  disableHighlightToday: k,
  readOnly: R,
  disabled: D,
  showDaysOutsideCurrentMonth: L,
  dayOfWeekFormatter: B,
  sx: H,
  autoFocus: U,
  fixedWeekNumber: I,
  displayWeekNumber: V
}) => /* @__PURE__ */ _.jsx(rM, {
  view: e,
  onViewChange: t,
  views: r.filter(lde),
  focusedView: n,
  onFocusedViewChange: o,
  value: a,
  defaultValue: i,
  onChange: l,
  className: c,
  classes: u,
  disableFuture: d,
  disablePast: f,
  minDate: p,
  maxDate: m,
  shouldDisableDate: y,
  shouldDisableMonth: h,
  shouldDisableYear: v,
  reduceAnimations: g,
  onMonthChange: b,
  monthsPerRow: x,
  onYearChange: O,
  yearsPerRow: w,
  defaultCalendarMonth: S,
  components: E,
  componentsProps: C,
  slots: N,
  slotProps: $,
  loading: j,
  renderLoading: A,
  disableHighlightToday: k,
  readOnly: R,
  disabled: D,
  showDaysOutsideCurrentMonth: L,
  dayOfWeekFormatter: B,
  sx: H,
  autoFocus: U,
  fixedWeekNumber: I,
  displayWeekNumber: V
}), nM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o;
  const a = Yr(), i = wt(), l = _N(t, "MuiDesktopDatePicker"), c = T({
    day: dn,
    month: dn,
    year: dn
  }, l.viewRenderers), u = T({}, l, {
    viewRenderers: c,
    format: xN(i, l),
    yearsPerRow: (n = l.yearsPerRow) != null ? n : 4,
    slots: T({
      openPickerIcon: $N,
      field: qb
    }, l.slots),
    slotProps: T({}, l.slotProps, {
      field: (f) => {
        var p;
        return T({}, Ma((p = l.slotProps) == null ? void 0 : p.field, f), Zp(l), {
          ref: r
        });
      },
      toolbar: T({
        hidden: !0
      }, (o = l.slotProps) == null ? void 0 : o.toolbar)
    })
  }), {
    renderPicker: d
  } = RI({
    props: u,
    valueManager: rs,
    getOpenDialogAriaText: a.openDatePickerDialogue,
    validator: Al
  });
  return d();
});
nM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    month: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: s.oneOf([3, 4])
};
const oM = ({
  props: e,
  valueManager: t,
  getOpenDialogAriaText: r,
  validator: n
}) => {
  var o, a, i;
  const {
    slots: l,
    slotProps: c,
    className: u,
    sx: d,
    format: f,
    label: p,
    inputRef: m,
    readOnly: y,
    disabled: h,
    localeText: v
  } = e, g = wt(), b = P.useRef(null), x = CI(), O = (o = c == null || (a = c.toolbar) == null ? void 0 : a.hidden) != null ? o : !1, {
    open: w,
    actions: S,
    layoutProps: E,
    renderCurrentView: C,
    fieldProps: N
  } = sI({
    props: e,
    inputRef: b,
    valueManager: t,
    validator: n,
    autoFocusView: !0,
    additionalViewProps: {},
    wrapperVariant: "mobile"
  }), $ = l.field, j = It({
    elementType: $,
    externalSlotProps: c == null ? void 0 : c.field,
    additionalProps: T({}, N, O && {
      id: x
    }, !(h || y) && {
      onClick: S.onOpen,
      onKeyDown: Qae(S.onOpen)
    }, {
      readOnly: y ?? !0,
      disabled: h,
      className: u,
      sx: d,
      format: f,
      label: p
    }),
    ownerState: e
  });
  j.inputProps = T({}, j.inputProps, {
    "aria-label": r(N.value, g)
  });
  const A = T({
    textField: l.textField
  }, j.slots), k = (i = l.layout) != null ? i : Fb, R = Mb(b, j.inputRef, m);
  let D = x;
  O && (p ? D = `${x}-label` : D = void 0);
  const L = T({}, c, {
    toolbar: T({}, c == null ? void 0 : c.toolbar, {
      titleId: x
    }),
    mobilePaper: T({
      "aria-labelledby": D
    }, c == null ? void 0 : c.mobilePaper)
  });
  return {
    renderPicker: () => /* @__PURE__ */ _.jsxs(Rl, {
      localeText: v,
      children: [/* @__PURE__ */ _.jsx($, T({}, j, {
        slots: A,
        slotProps: L,
        inputRef: R
      })), /* @__PURE__ */ _.jsx(Wae, T({}, S, {
        open: w,
        slots: l,
        slotProps: L,
        children: /* @__PURE__ */ _.jsx(k, T({}, E, L == null ? void 0 : L.layout, {
          slots: l,
          slotProps: L,
          children: C()
        }))
      }))]
    })
  };
}, aM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n;
  const o = Yr(), a = wt(), i = _N(t, "MuiMobileDatePicker"), l = T({
    day: dn,
    month: dn,
    year: dn
  }, i.viewRenderers), c = T({}, i, {
    viewRenderers: l,
    format: xN(a, i),
    slots: T({
      field: qb
    }, i.slots),
    slotProps: T({}, i.slotProps, {
      field: (d) => {
        var f;
        return T({}, Ma((f = i.slotProps) == null ? void 0 : f.field, d), Zp(i), {
          ref: r
        });
      },
      toolbar: T({
        hidden: !1
      }, (n = i.slotProps) == null ? void 0 : n.toolbar)
    })
  }), {
    renderPicker: u
  } = oM({
    props: c,
    valueManager: rs,
    getOpenDialogAriaText: o.openDatePickerDialogue,
    validator: Al
  });
  return u();
});
aM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    month: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: s.oneOf([3, 4])
};
const cde = ["desktopModeMediaQuery"], iM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDatePicker"
  }), {
    desktopModeMediaQuery: o = UN
  } = n, a = ge(n, cde);
  return HD(o, {
    defaultMatches: !0
  }) ? /* @__PURE__ */ _.jsx(nM, T({
    ref: r
  }, a)) : /* @__PURE__ */ _.jsx(aM, T({
    ref: r
  }, a));
});
process.env.NODE_ENV !== "production" && (iM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: s.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    month: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4 on desktop, 3 on mobile
   */
  yearsPerRow: s.oneOf([3, 4])
});
function ude({ control: e, name: t, PopperProps: r, ...n }) {
  const {
    field: { ref: o, ...a },
    fieldState: { error: i }
  } = So({
    name: t,
    control: e
  }), l = fr(), c = qe(), u = l.fn.variant({
    variant: "default",
    color: l.colors[l.primaryColor][l.fn.primaryShade()]
  });
  return /* @__PURE__ */ _.jsx(Rl, { dateAdapter: WD, children: /* @__PURE__ */ _.jsx(
    iM,
    {
      components: {
        OpenPickerIcon: oD
      },
      OpenPickerButtonProps: {
        sx: {
          padding: 0,
          marginLeft: "-18px",
          color: l.colors.gray[7]
        }
      },
      PopperProps: {
        anchorEl: c.current,
        sx: {
          "& .Mui-selected": {
            backgroundColor: `${u.background} !important`,
            ...l.fn.hover({
              backgroundColor: `${u.hover} !important`
            })
          }
        },
        ...r
      },
      renderInput: ({ inputProps: d, ...f }) => /* @__PURE__ */ _.jsx(
        Ip,
        {
          label: n.label,
          ref: c,
          error: !!i,
          rightSection: f.InputProps.endAdornment,
          ...d
        }
      ),
      inputRef: o,
      ...a,
      onChange: (d) => {
        a.onChange(d.toISOString().split("T")[0]);
      },
      ...n
    }
  ) });
}
const dde = ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "minDate", "maxDate", "disableFuture", "disablePast", "minTime", "maxTime", "minDateTime", "maxDateTime", "minutesStep", "disableIgnoringDatePartForTimeValidation", "shouldDisableClock", "shouldDisableTime", "selectedSections", "onSelectedSectionsChange", "ampm", "unstableFieldRef"], fde = (e) => {
  var t, r, n, o, a, i, l, c;
  const u = wt(), d = Ya(), p = ((t = e.ampm) != null ? t : u.is12HourCycleInCurrentLocale()) ? u.formats.keyboardDateTime12h : u.formats.keyboardDateTime24h;
  return T({}, e, {
    disablePast: (r = e.disablePast) != null ? r : !1,
    disableFuture: (n = e.disableFuture) != null ? n : !1,
    format: (o = e.format) != null ? o : p,
    disableIgnoringDatePartForTimeValidation: !!(e.minDateTime || e.maxDateTime),
    minDate: vr(u, (a = e.minDateTime) != null ? a : e.minDate, d.minDate),
    maxDate: vr(u, (i = e.maxDateTime) != null ? i : e.maxDate, d.maxDate),
    minTime: (l = e.minDateTime) != null ? l : e.minTime,
    maxTime: (c = e.maxDateTime) != null ? c : e.maxTime
  });
}, pde = ({
  props: e,
  inputRef: t
}) => {
  const r = fde(e), {
    value: n,
    defaultValue: o,
    format: a,
    onChange: i,
    readOnly: l,
    onError: c,
    shouldDisableDate: u,
    shouldDisableMonth: d,
    shouldDisableYear: f,
    minDate: p,
    maxDate: m,
    disableFuture: y,
    disablePast: h,
    minTime: v,
    maxTime: g,
    minutesStep: b,
    disableIgnoringDatePartForTimeValidation: x,
    shouldDisableClock: O,
    shouldDisableTime: w,
    selectedSections: S,
    onSelectedSectionsChange: E,
    ampm: C,
    unstableFieldRef: N
  } = r, $ = ge(r, dde);
  return aI({
    inputRef: t,
    forwardedProps: $,
    internalProps: {
      value: n,
      defaultValue: o,
      format: a,
      onChange: i,
      readOnly: l,
      onError: c,
      shouldDisableDate: u,
      shouldDisableMonth: d,
      shouldDisableYear: f,
      minDate: p,
      maxDate: m,
      disableFuture: y,
      disablePast: h,
      minTime: v,
      maxTime: g,
      minutesStep: b,
      shouldDisableClock: O,
      shouldDisableTime: w,
      disableIgnoringDatePartForTimeValidation: x,
      selectedSections: S,
      onSelectedSectionsChange: E,
      ampm: C,
      unstableFieldRef: N
    },
    valueManager: rs,
    fieldValueManager: QD,
    validator: Lb,
    valueType: "date-time"
  });
}, mde = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"], hde = ["inputRef"], yde = ["ref", "onPaste", "inputMode", "readOnly"], Gb = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a;
  const i = Ae({
    props: t,
    name: "MuiDateTimeField"
  }), {
    components: l,
    componentsProps: c,
    slots: u,
    slotProps: d,
    InputProps: f,
    inputProps: p
  } = i, m = ge(i, mde), y = i, h = (n = (o = u == null ? void 0 : u.textField) != null ? o : l == null ? void 0 : l.TextField) != null ? n : ZI, v = It({
    elementType: h,
    externalSlotProps: (a = d == null ? void 0 : d.textField) != null ? a : c == null ? void 0 : c.textField,
    externalForwardedProps: m,
    ownerState: y
  }), {
    inputRef: g
  } = v, b = ge(v, hde);
  b.inputProps = T({}, b.inputProps, p), b.InputProps = T({}, b.InputProps, f);
  const x = pde({
    props: b,
    inputRef: g
  }), {
    ref: O,
    onPaste: w,
    inputMode: S,
    readOnly: E
  } = x, C = ge(x, yde);
  return /* @__PURE__ */ _.jsx(h, T({
    ref: r
  }, C, {
    inputProps: T({}, C.inputProps, {
      ref: O,
      onPaste: w,
      inputMode: S,
      readOnly: E
    })
  }));
});
process.env.NODE_ENV !== "production" && (Gb.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: s.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: s.bool,
  className: s.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: s.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: s.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: s.string,
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: s.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: s.bool,
  /**
   * The helper text content.
   */
  helperText: s.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: s.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: s.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: s.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: s.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: s.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.any.isRequired
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: s.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: s.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: s.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: s.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: s.number,
  /**
   * Name attribute of the `input` element.
   */
  name: s.string,
  onBlur: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  onFocus: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: s.bool,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: s.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: s.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific time.
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * The size of the component.
   */
  size: s.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  style: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: s.oneOfType([s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: s.oneOf(["filled", "outlined", "standard"])
});
function vde(e) {
  return ze("MuiTab", e);
}
const gde = Le("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]), fa = gde, bde = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"], wde = (e) => {
  const {
    classes: t,
    textColor: r,
    fullWidth: n,
    wrapped: o,
    icon: a,
    label: i,
    selected: l,
    disabled: c
  } = e, u = {
    root: ["root", a && i && "labelIcon", `textColor${Te(r)}`, n && "fullWidth", o && "wrapped", l && "selected", c && "disabled"],
    iconWrapper: ["iconWrapper"]
  };
  return Ve(u, vde, t);
}, xde = ce(bo, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.label && r.icon && t.labelIcon, t[`textColor${Te(r.textColor)}`], r.fullWidth && t.fullWidth, r.wrapped && t.wrapped];
  }
})(({
  theme: e,
  ownerState: t
}) => T({}, e.typography.button, {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center"
}, t.label && {
  flexDirection: t.iconPosition === "top" || t.iconPosition === "bottom" ? "column" : "row"
}, {
  lineHeight: 1.25
}, t.icon && t.label && {
  minHeight: 72,
  paddingTop: 9,
  paddingBottom: 9,
  [`& > .${fa.iconWrapper}`]: T({}, t.iconPosition === "top" && {
    marginBottom: 6
  }, t.iconPosition === "bottom" && {
    marginTop: 6
  }, t.iconPosition === "start" && {
    marginRight: e.spacing(1)
  }, t.iconPosition === "end" && {
    marginLeft: e.spacing(1)
  })
}, t.textColor === "inherit" && {
  color: "inherit",
  opacity: 0.6,
  // same opacity as theme.palette.text.secondary
  [`&.${fa.selected}`]: {
    opacity: 1
  },
  [`&.${fa.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  }
}, t.textColor === "primary" && {
  color: (e.vars || e).palette.text.secondary,
  [`&.${fa.selected}`]: {
    color: (e.vars || e).palette.primary.main
  },
  [`&.${fa.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  }
}, t.textColor === "secondary" && {
  color: (e.vars || e).palette.text.secondary,
  [`&.${fa.selected}`]: {
    color: (e.vars || e).palette.secondary.main
  },
  [`&.${fa.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  }
}, t.fullWidth && {
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: 0,
  maxWidth: "none"
}, t.wrapped && {
  fontSize: e.typography.pxToRem(12)
})), sM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTab"
  }), {
    className: o,
    disabled: a = !1,
    disableFocusRipple: i = !1,
    // eslint-disable-next-line react/prop-types
    fullWidth: l,
    icon: c,
    iconPosition: u = "top",
    // eslint-disable-next-line react/prop-types
    indicator: d,
    label: f,
    onChange: p,
    onClick: m,
    onFocus: y,
    // eslint-disable-next-line react/prop-types
    selected: h,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus: v,
    // eslint-disable-next-line react/prop-types
    textColor: g = "inherit",
    value: b,
    wrapped: x = !1
  } = n, O = ge(n, bde), w = T({}, n, {
    disabled: a,
    disableFocusRipple: i,
    selected: h,
    icon: !!c,
    iconPosition: u,
    label: !!f,
    fullWidth: l,
    textColor: g,
    wrapped: x
  }), S = wde(w), E = c && f && /* @__PURE__ */ P.isValidElement(c) ? /* @__PURE__ */ P.cloneElement(c, {
    className: Pe(S.iconWrapper, c.props.className)
  }) : c, C = ($) => {
    !h && p && p($, b), m && m($);
  }, N = ($) => {
    v && !h && p && p($, b), y && y($);
  };
  return /* @__PURE__ */ _.jsxs(xde, T({
    focusRipple: !i,
    className: Pe(S.root, o),
    ref: r,
    role: "tab",
    "aria-selected": h,
    disabled: a,
    onClick: C,
    onFocus: N,
    ownerState: w,
    tabIndex: h ? 0 : -1
  }, O, {
    children: [u === "top" || u === "start" ? /* @__PURE__ */ _.jsxs(P.Fragment, {
      children: [E, f]
    }) : /* @__PURE__ */ _.jsxs(P.Fragment, {
      children: [f, E]
    }), d]
  }));
});
process.env.NODE_ENV !== "production" && (sM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: UT,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: s.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * âš ï¸ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: s.bool,
  /**
   * The icon to display.
   */
  icon: s.oneOfType([s.element, s.string]),
  /**
   * The position of the icon relative to the label.
   * @default 'top'
   */
  iconPosition: s.oneOf(["bottom", "end", "start", "top"]),
  /**
   * The label element.
   */
  label: s.node,
  /**
   * @ignore
   */
  onChange: s.func,
  /**
   * @ignore
   */
  onClick: s.func,
  /**
   * @ignore
   */
  onFocus: s.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * You can provide your own value. Otherwise, we fallback to the child position index.
   */
  value: s.any,
  /**
   * Tab labels appear in a single row.
   * They can use a second line if needed.
   * @default false
   */
  wrapped: s.bool
});
const O1 = sM;
function _de(e) {
  return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2;
}
function Ode(e, t, r, n = {}, o = () => {
}) {
  const {
    ease: a = _de,
    duration: i = 300
    // standard
  } = n;
  let l = null;
  const c = t[e];
  let u = !1;
  const d = () => {
    u = !0;
  }, f = (p) => {
    if (u) {
      o(new Error("Animation cancelled"));
      return;
    }
    l === null && (l = p);
    const m = Math.min(1, (p - l) / i);
    if (t[e] = a(m) * (r - c) + c, m >= 1) {
      requestAnimationFrame(() => {
        o(null);
      });
      return;
    }
    requestAnimationFrame(f);
  };
  return c === r ? (o(new Error("Element already at target position")), d) : (requestAnimationFrame(f), d);
}
const Pde = ["onChange"], Sde = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function lM(e) {
  const {
    onChange: t
  } = e, r = ge(e, Pde), n = P.useRef(), o = P.useRef(null), a = () => {
    n.current = o.current.offsetHeight - o.current.clientHeight;
  };
  return P.useEffect(() => {
    const i = ki(() => {
      const c = n.current;
      a(), c !== n.current && t(n.current);
    }), l = ho(o.current);
    return l.addEventListener("resize", i), () => {
      i.clear(), l.removeEventListener("resize", i);
    };
  }, [t]), P.useEffect(() => {
    a(), t(n.current);
  }, [t]), /* @__PURE__ */ _.jsx("div", T({
    style: Sde,
    ref: o
  }, r));
}
process.env.NODE_ENV !== "production" && (lM.propTypes = {
  onChange: s.func.isRequired
});
const Fv = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft"), Lv = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function Tde(e) {
  return ze("MuiTabScrollButton", e);
}
const Ede = Le("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]), $de = Ede, Cde = ["className", "slots", "slotProps", "direction", "orientation", "disabled"], kde = (e) => {
  const {
    classes: t,
    orientation: r,
    disabled: n
  } = e;
  return Ve({
    root: ["root", r, n && "disabled"]
  }, Tde, t);
}, Rde = ce(bo, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, r.orientation && t[r.orientation]];
  }
})(({
  ownerState: e
}) => T({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${$de.disabled}`]: {
    opacity: 0
  }
}, e.orientation === "vertical" && {
  width: "100%",
  height: 40,
  "& svg": {
    transform: `rotate(${e.isRtl ? -90 : 90}deg)`
  }
})), cM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o;
  const a = Ae({
    props: t,
    name: "MuiTabScrollButton"
  }), {
    className: i,
    slots: l = {},
    slotProps: c = {},
    direction: u
  } = a, d = ge(a, Cde), p = Nr().direction === "rtl", m = T({
    isRtl: p
  }, a), y = kde(m), h = (n = l.StartScrollButtonIcon) != null ? n : Fv, v = (o = l.EndScrollButtonIcon) != null ? o : Lv, g = It({
    elementType: h,
    externalSlotProps: c.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: m
  }), b = It({
    elementType: v,
    externalSlotProps: c.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState: m
  });
  return /* @__PURE__ */ _.jsx(Rde, T({
    component: "div",
    className: Pe(y.root, i),
    ref: r,
    role: null,
    ownerState: m,
    tabIndex: null
  }, d, {
    children: u === "left" ? /* @__PURE__ */ _.jsx(h, T({}, g)) : /* @__PURE__ */ _.jsx(v, T({}, b))
  }));
});
process.env.NODE_ENV !== "production" && (cM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The direction the button should indicate.
   */
  direction: s.oneOf(["left", "right"]).isRequired,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * The component orientation (layout flow direction).
   */
  orientation: s.oneOf(["horizontal", "vertical"]).isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: s.shape({
    endScrollButtonIcon: s.oneOfType([s.func, s.object]),
    startScrollButtonIcon: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: s.shape({
    EndScrollButtonIcon: s.elementType,
    StartScrollButtonIcon: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const Dde = cM;
function Nde(e) {
  return ze("MuiTabs", e);
}
const Ide = Le("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]), xu = Ide, Mde = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"], P1 = (e, t) => e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e.firstChild, S1 = (e, t) => e === t ? e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e.lastChild, fc = (e, t, r) => {
  let n = !1, o = r(e, t);
  for (; o; ) {
    if (o === e.firstChild) {
      if (n)
        return;
      n = !0;
    }
    const a = o.disabled || o.getAttribute("aria-disabled") === "true";
    if (!o.hasAttribute("tabindex") || a)
      o = r(e, o);
    else {
      o.focus();
      return;
    }
  }
}, Ade = (e) => {
  const {
    vertical: t,
    fixed: r,
    hideScrollbar: n,
    scrollableX: o,
    scrollableY: a,
    centered: i,
    scrollButtonsHideMobile: l,
    classes: c
  } = e;
  return Ve({
    root: ["root", t && "vertical"],
    scroller: ["scroller", r && "fixed", n && "hideScrollbar", o && "scrollableX", a && "scrollableY"],
    flexContainer: ["flexContainer", t && "flexContainerVertical", i && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", l && "scrollButtonsHideMobile"],
    scrollableX: [o && "scrollableX"],
    hideScrollbar: [n && "hideScrollbar"]
  }, Nde, c);
}, jde = ce("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [{
      [`& .${xu.scrollButtons}`]: t.scrollButtons
    }, {
      [`& .${xu.scrollButtons}`]: r.scrollButtonsHideMobile && t.scrollButtonsHideMobile
    }, t.root, r.vertical && t.vertical];
  }
})(({
  ownerState: e,
  theme: t
}) => T({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex"
}, e.vertical && {
  flexDirection: "column"
}, e.scrollButtonsHideMobile && {
  [`& .${xu.scrollButtons}`]: {
    [t.breakpoints.down("sm")]: {
      display: "none"
    }
  }
})), Fde = ce("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.scroller, r.fixed && t.fixed, r.hideScrollbar && t.hideScrollbar, r.scrollableX && t.scrollableX, r.scrollableY && t.scrollableY];
  }
})(({
  ownerState: e
}) => T({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap"
}, e.fixed && {
  overflowX: "hidden",
  width: "100%"
}, e.hideScrollbar && {
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}, e.scrollableX && {
  overflowX: "auto",
  overflowY: "hidden"
}, e.scrollableY && {
  overflowY: "auto",
  overflowX: "hidden"
})), Lde = ce("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.flexContainer, r.vertical && t.flexContainerVertical, r.centered && t.centered];
  }
})(({
  ownerState: e
}) => T({
  display: "flex"
}, e.vertical && {
  flexDirection: "column"
}, e.centered && {
  justifyContent: "center"
})), Vde = ce("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (e, t) => t.indicator
})(({
  ownerState: e,
  theme: t
}) => T({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: t.transitions.create()
}, e.indicatorColor === "primary" && {
  backgroundColor: (t.vars || t).palette.primary.main
}, e.indicatorColor === "secondary" && {
  backgroundColor: (t.vars || t).palette.secondary.main
}, e.vertical && {
  height: "100%",
  width: 2,
  right: 0
})), zde = ce(lM, {
  name: "MuiTabs",
  slot: "ScrollbarSize"
})({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}), T1 = {};
let E1 = !1;
const uM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTabs"
  }), o = Nr(), a = o.direction === "rtl", {
    "aria-label": i,
    "aria-labelledby": l,
    action: c,
    centered: u = !1,
    children: d,
    className: f,
    component: p = "div",
    allowScrollButtonsMobile: m = !1,
    indicatorColor: y = "primary",
    onChange: h,
    orientation: v = "horizontal",
    ScrollButtonComponent: g = Dde,
    scrollButtons: b = "auto",
    selectionFollowsFocus: x,
    slots: O = {},
    slotProps: w = {},
    TabIndicatorProps: S = {},
    TabScrollButtonProps: E = {},
    textColor: C = "primary",
    value: N,
    variant: $ = "standard",
    visibleScrollbar: j = !1
  } = n, A = ge(n, Mde), k = $ === "scrollable", R = v === "vertical", D = R ? "scrollTop" : "scrollLeft", L = R ? "top" : "left", B = R ? "bottom" : "right", H = R ? "clientHeight" : "clientWidth", U = R ? "height" : "width", I = T({}, n, {
    component: p,
    allowScrollButtonsMobile: m,
    indicatorColor: y,
    orientation: v,
    vertical: R,
    scrollButtons: b,
    textColor: C,
    variant: $,
    visibleScrollbar: j,
    fixed: !k,
    hideScrollbar: k && !j,
    scrollableX: k && !R,
    scrollableY: k && R,
    centered: u && !k,
    scrollButtonsHideMobile: !m
  }), V = Ade(I), G = It({
    elementType: O.StartScrollButtonIcon,
    externalSlotProps: w.startScrollButtonIcon,
    ownerState: I
  }), q = It({
    elementType: O.EndScrollButtonIcon,
    externalSlotProps: w.endScrollButtonIcon,
    ownerState: I
  });
  process.env.NODE_ENV !== "production" && u && k && console.error('MUI: You can not use the `centered={true}` and `variant="scrollable"` properties at the same time on a `Tabs` component.');
  const [J, ne] = P.useState(!1), [te, ee] = P.useState(T1), [K, Q] = P.useState({
    start: !1,
    end: !1
  }), [ae, ie] = P.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  }), oe = /* @__PURE__ */ new Map(), se = P.useRef(null), re = P.useRef(null), le = () => {
    const ye = se.current;
    let _e;
    if (ye) {
      const je = ye.getBoundingClientRect();
      _e = {
        clientWidth: ye.clientWidth,
        scrollLeft: ye.scrollLeft,
        scrollTop: ye.scrollTop,
        scrollLeftNormalized: V0(ye, o.direction),
        scrollWidth: ye.scrollWidth,
        top: je.top,
        bottom: je.bottom,
        left: je.left,
        right: je.right
      };
    }
    let Re;
    if (ye && N !== !1) {
      const je = re.current.children;
      if (je.length > 0) {
        const Fe = je[oe.get(N)];
        process.env.NODE_ENV !== "production" && (Fe || console.error(["MUI: The `value` provided to the Tabs component is invalid.", `None of the Tabs' children match with "${N}".`, oe.keys ? `You can provide one of the following values: ${Array.from(oe.keys()).join(", ")}.` : null].join(`
`))), Re = Fe ? Fe.getBoundingClientRect() : null, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && !E1 && Re && Re.width === 0 && Re.height === 0 && // if the whole Tabs component is hidden, don't warn
        _e.clientWidth !== 0 && (_e = null, console.error(["MUI: The `value` provided to the Tabs component is invalid.", `The Tab with this \`value\` ("${N}") is not part of the document layout.`, "Make sure the tab item is present in the document or that it's not `display: none`."].join(`
`)), E1 = !0);
      }
    }
    return {
      tabsMeta: _e,
      tabMeta: Re
    };
  }, M = $t(() => {
    const {
      tabsMeta: ye,
      tabMeta: _e
    } = le();
    let Re = 0, je;
    if (R)
      je = "top", _e && ye && (Re = _e.top - ye.top + ye.scrollTop);
    else if (je = a ? "right" : "left", _e && ye) {
      const Ze = a ? ye.scrollLeftNormalized + ye.clientWidth - ye.scrollWidth : ye.scrollLeft;
      Re = (a ? -1 : 1) * (_e[je] - ye[je] + Ze);
    }
    const Fe = {
      [je]: Re,
      // May be wrong until the font is loaded.
      [U]: _e ? _e[U] : 0
    };
    if (isNaN(te[je]) || isNaN(te[U]))
      ee(Fe);
    else {
      const Ze = Math.abs(te[je] - Fe[je]), ft = Math.abs(te[U] - Fe[U]);
      (Ze >= 1 || ft >= 1) && ee(Fe);
    }
  }), W = (ye, {
    animation: _e = !0
  } = {}) => {
    _e ? Ode(D, se.current, ye, {
      duration: o.transitions.duration.standard
    }) : se.current[D] = ye;
  }, Z = (ye) => {
    let _e = se.current[D];
    R ? _e += ye : (_e += ye * (a ? -1 : 1), _e *= a && YT() === "reverse" ? -1 : 1), W(_e);
  }, he = () => {
    const ye = se.current[H];
    let _e = 0;
    const Re = Array.from(re.current.children);
    for (let je = 0; je < Re.length; je += 1) {
      const Fe = Re[je];
      if (_e + Fe[H] > ye) {
        je === 0 && (_e = ye);
        break;
      }
      _e += Fe[H];
    }
    return _e;
  }, me = () => {
    Z(-1 * he());
  }, de = () => {
    Z(he());
  }, ue = P.useCallback((ye) => {
    ie({
      overflow: null,
      scrollbarWidth: ye
    });
  }, []), Oe = () => {
    const ye = {};
    ye.scrollbarSizeListener = k ? /* @__PURE__ */ _.jsx(zde, {
      onChange: ue,
      className: Pe(V.scrollableX, V.hideScrollbar)
    }) : null;
    const _e = K.start || K.end, Re = k && (b === "auto" && _e || b === !0);
    return ye.scrollButtonStart = Re ? /* @__PURE__ */ _.jsx(g, T({
      slots: {
        StartScrollButtonIcon: O.StartScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: G
      },
      orientation: v,
      direction: a ? "right" : "left",
      onClick: me,
      disabled: !K.start
    }, E, {
      className: Pe(V.scrollButtons, E.className)
    })) : null, ye.scrollButtonEnd = Re ? /* @__PURE__ */ _.jsx(g, T({
      slots: {
        EndScrollButtonIcon: O.EndScrollButtonIcon
      },
      slotProps: {
        endScrollButtonIcon: q
      },
      orientation: v,
      direction: a ? "left" : "right",
      onClick: de,
      disabled: !K.end
    }, E, {
      className: Pe(V.scrollButtons, E.className)
    })) : null, ye;
  }, Se = $t((ye) => {
    const {
      tabsMeta: _e,
      tabMeta: Re
    } = le();
    if (!(!Re || !_e)) {
      if (Re[L] < _e[L]) {
        const je = _e[D] + (Re[L] - _e[L]);
        W(je, {
          animation: ye
        });
      } else if (Re[B] > _e[B]) {
        const je = _e[D] + (Re[B] - _e[B]);
        W(je, {
          animation: ye
        });
      }
    }
  }), De = $t(() => {
    if (k && b !== !1) {
      const {
        scrollTop: ye,
        scrollHeight: _e,
        clientHeight: Re,
        scrollWidth: je,
        clientWidth: Fe
      } = se.current;
      let Ze, ft;
      if (R)
        Ze = ye > 1, ft = ye < _e - Re - 1;
      else {
        const Je = V0(se.current, o.direction);
        Ze = a ? Je < je - Fe - 1 : Je > 1, ft = a ? Je > 1 : Je < je - Fe - 1;
      }
      (Ze !== K.start || ft !== K.end) && Q({
        start: Ze,
        end: ft
      });
    }
  });
  P.useEffect(() => {
    const ye = ki(() => {
      se.current && (M(), De());
    }), _e = ho(se.current);
    _e.addEventListener("resize", ye);
    let Re;
    return typeof ResizeObserver < "u" && (Re = new ResizeObserver(ye), Array.from(re.current.children).forEach((je) => {
      Re.observe(je);
    })), () => {
      ye.clear(), _e.removeEventListener("resize", ye), Re && Re.disconnect();
    };
  }, [M, De]);
  const nt = P.useMemo(() => ki(() => {
    De();
  }), [De]);
  P.useEffect(() => () => {
    nt.clear();
  }, [nt]), P.useEffect(() => {
    ne(!0);
  }, []), P.useEffect(() => {
    M(), De();
  }), P.useEffect(() => {
    Se(T1 !== te);
  }, [Se, te]), P.useImperativeHandle(c, () => ({
    updateIndicator: M,
    updateScrollButtons: De
  }), [M, De]);
  const rt = /* @__PURE__ */ _.jsx(Vde, T({}, S, {
    className: Pe(V.indicator, S.className),
    ownerState: I,
    style: T({}, te, S.style)
  }));
  let Be = 0;
  const Ie = P.Children.map(d, (ye) => {
    if (!/* @__PURE__ */ P.isValidElement(ye))
      return null;
    process.env.NODE_ENV !== "production" && Ci.isFragment(ye) && console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    const _e = ye.props.value === void 0 ? Be : ye.props.value;
    oe.set(_e, Be);
    const Re = _e === N;
    return Be += 1, /* @__PURE__ */ P.cloneElement(ye, T({
      fullWidth: $ === "fullWidth",
      indicator: Re && !J && rt,
      selected: Re,
      selectionFollowsFocus: x,
      onChange: h,
      textColor: C,
      value: _e
    }, Be === 1 && N === !1 && !ye.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  }), it = (ye) => {
    const _e = re.current, Re = nr(_e).activeElement;
    if (Re.getAttribute("role") !== "tab")
      return;
    let Fe = v === "horizontal" ? "ArrowLeft" : "ArrowUp", Ze = v === "horizontal" ? "ArrowRight" : "ArrowDown";
    switch (v === "horizontal" && a && (Fe = "ArrowRight", Ze = "ArrowLeft"), ye.key) {
      case Fe:
        ye.preventDefault(), fc(_e, Re, S1);
        break;
      case Ze:
        ye.preventDefault(), fc(_e, Re, P1);
        break;
      case "Home":
        ye.preventDefault(), fc(_e, null, P1);
        break;
      case "End":
        ye.preventDefault(), fc(_e, null, S1);
        break;
    }
  }, we = Oe();
  return /* @__PURE__ */ _.jsxs(jde, T({
    className: Pe(V.root, f),
    ownerState: I,
    ref: r,
    as: p
  }, A, {
    children: [we.scrollButtonStart, we.scrollbarSizeListener, /* @__PURE__ */ _.jsxs(Fde, {
      className: V.scroller,
      ownerState: I,
      style: {
        overflow: ae.overflow,
        [R ? `margin${a ? "Left" : "Right"}` : "marginBottom"]: j ? void 0 : -ae.scrollbarWidth
      },
      ref: se,
      onScroll: nt,
      children: [/* @__PURE__ */ _.jsx(Lde, {
        "aria-label": i,
        "aria-labelledby": l,
        "aria-orientation": v === "vertical" ? "vertical" : null,
        className: V.flexContainer,
        ownerState: I,
        onKeyDown: it,
        ref: re,
        role: "tablist",
        children: Ie
      }), J && rt]
    }), we.scrollButtonEnd]
  }));
});
process.env.NODE_ENV !== "production" && (uM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when the component mounts.
   * This is useful when you want to trigger an action programmatically.
   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`
   *
   * @param {object} actions This object contains all possible actions
   * that can be triggered programmatically.
   */
  action: vn,
  /**
   * If `true`, the scroll buttons aren't forced hidden on mobile.
   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.
   * @default false
   */
  allowScrollButtonsMobile: s.bool,
  /**
   * The label for the Tabs as a string.
   */
  "aria-label": s.string,
  /**
   * An id or list of ids separated by a space that label the Tabs.
   */
  "aria-labelledby": s.string,
  /**
   * If `true`, the tabs are centered.
   * This prop is intended for large views.
   * @default false
   */
  centered: s.bool,
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * Determines the color of the indicator.
   * @default 'primary'
   */
  indicatorColor: s.oneOfType([s.oneOf(["primary", "secondary"]), s.string]),
  /**
   * Callback fired when the value changes.
   *
   * @param {React.SyntheticEvent} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {any} value We default to the index of the child (number)
   */
  onChange: s.func,
  /**
   * The component orientation (layout flow direction).
   * @default 'horizontal'
   */
  orientation: s.oneOf(["horizontal", "vertical"]),
  /**
   * The component used to render the scroll buttons.
   * @default TabScrollButton
   */
  ScrollButtonComponent: s.elementType,
  /**
   * Determine behavior of scroll buttons when tabs are set to scroll:
   *
   * - `auto` will only present them when not all the items are visible.
   * - `true` will always present them.
   * - `false` will never present them.
   *
   * By default the scroll buttons are hidden on mobile.
   * This behavior can be disabled with `allowScrollButtonsMobile`.
   * @default 'auto'
   */
  scrollButtons: s.oneOf(["auto", !1, !0]),
  /**
   * If `true` the selected tab changes on focus. Otherwise it only
   * changes on activation.
   */
  selectionFollowsFocus: s.bool,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   * @default {}
   */
  slotProps: s.shape({
    endScrollButtonIcon: s.oneOfType([s.func, s.object]),
    startScrollButtonIcon: s.oneOfType([s.func, s.object])
  }),
  /**
   * The components used for each slot inside.
   * @default {}
   */
  slots: s.shape({
    EndScrollButtonIcon: s.elementType,
    StartScrollButtonIcon: s.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Props applied to the tab indicator element.
   * @default  {}
   */
  TabIndicatorProps: s.object,
  /**
   * Props applied to the [`TabScrollButton`](/material-ui/api/tab-scroll-button/) element.
   * @default {}
   */
  TabScrollButtonProps: s.object,
  /**
   * Determines the color of the `Tab`.
   * @default 'primary'
   */
  textColor: s.oneOf(["inherit", "primary", "secondary"]),
  /**
   * The value of the currently selected `Tab`.
   * If you don't want any selected `Tab`, you can set this prop to `false`.
   */
  value: s.any,
  /**
   * Determines additional display behavior of the tabs:
   *
   *  - `scrollable` will invoke scrolling properties and allow for horizontally
   *  scrolling (or swiping) of the tab bar.
   *  -`fullWidth` will make the tabs grow to use all the available space,
   *  which should be used for small views, like on mobile.
   *  - `standard` will render the default state.
   * @default 'standard'
   */
  variant: s.oneOf(["fullWidth", "scrollable", "standard"]),
  /**
   * If `true`, the scrollbar is visible. It can be useful when displaying
   * a long vertical list of tabs.
   * @default false
   */
  visibleScrollbar: s.bool
});
const Bde = uM;
function Wde(e) {
  return ze("MuiDateTimePickerTabs", e);
}
Le("MuiDateTimePickerTabs", ["root"]);
const Ude = (e) => ["day", "month", "year"].includes(e) ? "date" : "time", Hde = (e) => e === "date" ? "day" : "hours", Yde = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"]
  }, Wde, t);
}, qde = ce(Bde, {
  name: "MuiDateTimePickerTabs",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  boxShadow: `0 -1px 0 0 inset ${(e.vars || e).palette.divider}`,
  "&:last-child": {
    boxShadow: `0 1px 0 0 inset ${(e.vars || e).palette.divider}`,
    [`& .${xu.indicator}`]: {
      bottom: "auto",
      top: 0
    }
  }
})), dM = function(t) {
  const r = Ae({
    props: t,
    name: "MuiDateTimePickerTabs"
  }), {
    dateIcon: n = /* @__PURE__ */ _.jsx(rae, {}),
    onViewChange: o,
    timeIcon: a = /* @__PURE__ */ _.jsx(nae, {}),
    view: i,
    hidden: l = typeof window > "u" || window.innerHeight < 667
  } = r, c = Yr(), u = Yde(r), d = (f, p) => {
    o(Hde(p));
  };
  return l ? null : /* @__PURE__ */ _.jsxs(qde, {
    ownerState: r,
    variant: "fullWidth",
    value: Ude(i),
    onChange: d,
    className: u.root,
    children: [/* @__PURE__ */ _.jsx(O1, {
      value: "date",
      "aria-label": c.dateTableLabel,
      icon: /* @__PURE__ */ _.jsx(P.Fragment, {
        children: n
      })
    }), /* @__PURE__ */ _.jsx(O1, {
      value: "time",
      "aria-label": c.timeTableLabel,
      icon: /* @__PURE__ */ _.jsx(P.Fragment, {
        children: a
      })
    })]
  });
};
process.env.NODE_ENV !== "production" && (dM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * Date tab icon.
   * @default DateRange
   */
  dateIcon: s.node,
  /**
   * Toggles visibility of the tabs allowing view switching.
   * @default `window.innerHeight < 667` for `DesktopDateTimePicker` and `MobileDateTimePicker`, `displayStaticWrapperAs === 'desktop'` for `StaticDateTimePicker`
   */
  hidden: s.bool,
  /**
   * Callback called when a tab is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: s.func.isRequired,
  /**
   * Time tab icon.
   * @default Time
   */
  timeIcon: s.node,
  /**
   * Currently visible picker view.
   */
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired
});
function Gde(e) {
  return ze("MuiDateTimePickerToolbar", e);
}
const hh = Le("MuiDateTimePickerToolbar", ["root", "dateContainer", "timeContainer", "timeDigitsContainer", "separator", "timeLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]), Kde = ["ampm", "ampmInClock", "value", "onChange", "view", "isLandscape", "onViewChange", "toolbarFormat", "toolbarPlaceholder", "views", "disabled", "readOnly"], Xde = (e) => {
  const {
    classes: t,
    theme: r,
    isLandscape: n
  } = e, o = {
    root: ["root"],
    dateContainer: ["dateContainer"],
    timeContainer: ["timeContainer", r.direction === "rtl" && "timeLabelReverse"],
    timeDigitsContainer: ["timeDigitsContainer", r.direction === "rtl" && "timeLabelReverse"],
    separator: ["separator"],
    ampmSelection: ["ampmSelection", n && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return Ve(o, Gde, t);
}, fM = ce(bN, {
  name: "MuiDateTimePickerToolbar",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  paddingLeft: 16,
  paddingRight: 16,
  justifyContent: "space-around",
  position: "relative",
  [`& .${ioe.penIconButton}`]: T({
    position: "absolute",
    top: 8
  }, e.direction === "rtl" ? {
    left: 8
  } : {
    right: 8
  })
}));
fM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: s.elementType,
  classes: s.object,
  className: s.string,
  isLandscape: s.bool.isRequired,
  isMobileKeyboardViewOpen: s.bool,
  landscapeDirection: s.oneOf(["column", "row"]),
  ownerState: s.object.isRequired,
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  toggleMobileKeyboardView: s.func,
  toolbarTitle: s.node,
  viewType: s.oneOf(["date", "time"])
};
const Qde = ce("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "DateContainer",
  overridesResolver: (e, t) => t.dateContainer
})({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start"
}), pM = ce("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeContainer",
  overridesResolver: (e, t) => t.timeContainer
})(({
  theme: e,
  ownerState: t
}) => {
  const r = t.isLandscape ? "column" : "row";
  return T({
    display: "flex",
    flexDirection: r
  }, e.direction === "rtl" && {
    flexDirection: `${r}-reverse`
  });
}), Zde = ce("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeDigitsContainer",
  overridesResolver: (e, t) => t.timeDigitsContainer
})(({
  theme: e
}) => T({
  display: "flex"
}, e.direction === "rtl" && {
  flexDirection: "row-reverse"
}));
pM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: s.elementType,
  ownerState: s.object.isRequired,
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
};
const $1 = ce(GN, {
  name: "MuiDateTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (e, t) => t.separator
})({
  margin: "0 4px 0 2px",
  cursor: "default"
}), Jde = ce("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (e, t) => [{
    [`.${hh.ampmLabel}`]: t.ampmLabel
  }, {
    [`&.${hh.ampmLandscape}`]: t.ampmLandscape
  }, t.ampmSelection]
})(({
  ownerState: e
}) => T({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12
}, e.isLandscape && {
  margin: "4px 0 auto",
  flexDirection: "row",
  justifyContent: "space-around",
  width: "100%"
}, {
  [`& .${hh.ampmLabel}`]: {
    fontSize: 17
  }
}));
function mM(e) {
  const t = Ae({
    props: e,
    name: "MuiDateTimePickerToolbar"
  }), {
    ampm: r,
    ampmInClock: n,
    value: o,
    onChange: a,
    view: i,
    isLandscape: l,
    onViewChange: c,
    toolbarFormat: u,
    toolbarPlaceholder: d = "â€“â€“",
    views: f,
    disabled: p,
    readOnly: m
  } = t, y = ge(t, Kde), h = t, v = wt(), {
    meridiemMode: g,
    handleMeridiemChange: b
  } = bI(o, r, a), x = !!(r && !n), O = Yr(), w = Nr(), S = Xde(T({}, h, {
    theme: w
  })), E = (N) => r ? v.format(N, "hours12h") : v.format(N, "hours24h"), C = P.useMemo(() => o ? u ? v.formatByString(o, u) : v.format(o, "shortDate") : d, [o, u, d, v]);
  return /* @__PURE__ */ _.jsxs(fM, T({
    toolbarTitle: O.dateTimePickerToolbarTitle,
    isLandscape: l,
    className: S.root
  }, y, {
    ownerState: h,
    children: [/* @__PURE__ */ _.jsxs(Qde, {
      className: S.dateContainer,
      ownerState: h,
      children: [f.includes("year") && /* @__PURE__ */ _.jsx(ua, {
        tabIndex: -1,
        variant: "subtitle1",
        onClick: () => c("year"),
        selected: i === "year",
        value: o ? v.format(o, "year") : "â€“"
      }), f.includes("day") && /* @__PURE__ */ _.jsx(ua, {
        tabIndex: -1,
        variant: "h4",
        onClick: () => c("day"),
        selected: i === "day",
        value: C
      })]
    }), /* @__PURE__ */ _.jsxs(pM, {
      className: S.timeContainer,
      ownerState: h,
      children: [/* @__PURE__ */ _.jsxs(Zde, {
        className: S.timeDigitsContainer,
        children: [f.includes("hours") && /* @__PURE__ */ _.jsx(ua, {
          variant: "h3",
          onClick: () => c("hours"),
          selected: i === "hours",
          value: o ? E(o) : "--"
        }), f.includes("minutes") && /* @__PURE__ */ _.jsxs(P.Fragment, {
          children: [/* @__PURE__ */ _.jsx($1, {
            variant: "h3",
            value: ":",
            className: S.separator,
            ownerState: h
          }), /* @__PURE__ */ _.jsx(ua, {
            variant: "h3",
            onClick: () => c("minutes"),
            selected: i === "minutes",
            value: o ? v.format(o, "minutes") : "--"
          })]
        }), f.includes("seconds") && /* @__PURE__ */ _.jsxs(P.Fragment, {
          children: [/* @__PURE__ */ _.jsx($1, {
            variant: "h3",
            value: ":",
            className: S.separator,
            ownerState: h
          }), /* @__PURE__ */ _.jsx(ua, {
            variant: "h3",
            onClick: () => c("seconds"),
            selected: i === "seconds",
            value: o ? v.format(o, "seconds") : "--"
          })]
        })]
      }), x && /* @__PURE__ */ _.jsxs(Jde, {
        className: S.ampmSelection,
        ownerState: h,
        children: [/* @__PURE__ */ _.jsx(ua, {
          disableRipple: !0,
          variant: "subtitle2",
          selected: g === "am",
          typographyClassName: S.ampmLabel,
          value: v.getMeridiemText("am"),
          onClick: m ? void 0 : () => b("am"),
          disabled: p
        }), /* @__PURE__ */ _.jsx(ua, {
          disableRipple: !0,
          variant: "subtitle2",
          selected: g === "pm",
          typographyClassName: S.ampmLabel,
          value: v.getMeridiemText("pm"),
          onClick: m ? void 0 : () => b("pm"),
          disabled: p
        })]
      })]
    })]
  }));
}
process.env.NODE_ENV !== "production" && (mM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ampm: s.bool,
  ampmInClock: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * className applied to the root component.
   */
  className: s.string,
  disabled: s.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: s.bool,
  isLandscape: s.bool.isRequired,
  onChange: s.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: s.func.isRequired,
  readOnly: s.bool,
  titleId: s.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: s.string,
  /**
   * Toolbar value placeholderâ€”it is displayed when the value is empty.
   * @default "â€“â€“"
   */
  toolbarPlaceholder: s.node,
  value: s.any,
  /**
   * Currently visible picker view.
   */
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired,
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired).isRequired
});
function hM(e, t) {
  var r, n, o, a, i, l, c, u, d, f, p;
  const m = wt(), y = Ya(), h = Ae({
    props: e,
    name: t
  }), v = (r = h.ampm) != null ? r : m.is12HourCycleInCurrentLocale(), g = P.useMemo(() => {
    var O;
    return ((O = h.localeText) == null ? void 0 : O.toolbarTitle) == null ? h.localeText : T({}, h.localeText, {
      dateTimePickerToolbarTitle: h.localeText.toolbarTitle
    });
  }, [h.localeText]), b = (n = h.slots) != null ? n : Gp(h.components), x = (o = h.slotProps) != null ? o : h.componentsProps;
  return T({}, h, tN({
    views: h.views,
    openTo: h.openTo,
    defaultViews: ["year", "day", "hours", "minutes"],
    defaultOpenTo: "day"
  }), {
    ampm: v,
    localeText: g,
    orientation: (a = h.orientation) != null ? a : "portrait",
    // TODO: Remove from public API
    disableIgnoringDatePartForTimeValidation: (i = h.disableIgnoringDatePartForTimeValidation) != null ? i : !!(h.minDateTime || h.maxDateTime),
    disableFuture: (l = h.disableFuture) != null ? l : !1,
    disablePast: (c = h.disablePast) != null ? c : !1,
    minDate: vr(m, (u = h.minDateTime) != null ? u : h.minDate, y.minDate),
    maxDate: vr(m, (d = h.maxDateTime) != null ? d : h.maxDate, y.maxDate),
    minTime: (f = h.minDateTime) != null ? f : h.minTime,
    maxTime: (p = h.maxDateTime) != null ? p : h.maxTime,
    slots: T({
      toolbar: mM,
      tabs: dM
    }, b),
    slotProps: T({}, x, {
      toolbar: T({
        ampm: v
      }, x == null ? void 0 : x.toolbar)
    })
  });
}
const yM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a, i;
  const l = Yr(), c = hM(t, "MuiDesktopDateTimePicker"), u = T({
    day: dn,
    month: dn,
    year: dn,
    hours: null,
    minutes: null,
    seconds: null
  }, c.viewRenderers), d = (n = c.ampmInClock) != null ? n : !0, f = T({}, c, {
    viewRenderers: u,
    yearsPerRow: (o = c.yearsPerRow) != null ? o : 4,
    ampmInClock: d,
    slots: T({
      field: Gb,
      openPickerIcon: $N
    }, c.slots),
    slotProps: T({}, c.slotProps, {
      field: (m) => {
        var y;
        return T({}, Ma((y = c.slotProps) == null ? void 0 : y.field, m), Zp(c), {
          ref: r,
          ampm: c.ampm
        });
      },
      toolbar: T({
        hidden: !0,
        ampmInClock: d
      }, (a = c.slotProps) == null ? void 0 : a.toolbar),
      tabs: T({
        hidden: !0
      }, (i = c.slotProps) == null ? void 0 : i.tabs)
    })
  }), {
    renderPicker: p
  } = RI({
    props: f,
    valueManager: rs,
    getOpenDialogAriaText: l.openDatePickerDialogue,
    validator: Lb
  });
  return p();
});
yM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: s.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: s.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: s.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: s.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: s.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: s.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: s.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific time.
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    hours: s.func,
    minutes: s.func,
    month: s.func,
    seconds: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: s.oneOf([3, 4])
};
function efe(e) {
  return ze("MuiTimeClock", e);
}
Le("MuiTimeClock", ["root", "arrowSwitcher"]);
const Hi = 220, Yo = 36, fl = {
  x: Hi / 2,
  y: Hi / 2
}, vM = {
  x: fl.x,
  y: 0
}, tfe = vM.x - fl.x, rfe = vM.y - fl.y, nfe = (e) => e * (180 / Math.PI), gM = (e, t, r) => {
  const n = t - fl.x, o = r - fl.y, a = Math.atan2(tfe, rfe) - Math.atan2(n, o);
  let i = nfe(a);
  i = Math.round(i / e) * e, i %= 360;
  const l = Math.floor(i / e) || 0, c = n ** 2 + o ** 2, u = Math.sqrt(c);
  return {
    value: l,
    distance: u
  };
}, ofe = (e, t, r = 1) => {
  const n = r * 6;
  let {
    value: o
  } = gM(n, e, t);
  return o = o * r % 60, o;
}, afe = (e, t, r) => {
  const {
    value: n,
    distance: o
  } = gM(30, e, t);
  let a = n || 12;
  return r ? a %= 12 : o < Hi / 2 - Yo && (a += 12, a %= 24), a;
};
function ife(e) {
  return ze("MuiClockPointer", e);
}
Le("MuiClockPointer", ["root", "thumb"]);
const sfe = ["className", "hasSelected", "isInner", "type", "viewValue"], lfe = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    thumb: ["thumb"]
  }, ife, t);
}, cfe = ce("div", {
  name: "MuiClockPointer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e,
  ownerState: t
}) => T({
  width: 2,
  backgroundColor: (e.vars || e).palette.primary.main,
  position: "absolute",
  left: "calc(50% - 1px)",
  bottom: "50%",
  transformOrigin: "center bottom 0px"
}, t.shouldAnimate && {
  transition: e.transitions.create(["transform", "height"])
})), ufe = ce("div", {
  name: "MuiClockPointer",
  slot: "Thumb",
  overridesResolver: (e, t) => t.thumb
})(({
  theme: e,
  ownerState: t
}) => T({
  width: 4,
  height: 4,
  backgroundColor: (e.vars || e).palette.primary.contrastText,
  borderRadius: "50%",
  position: "absolute",
  top: -21,
  left: `calc(50% - ${Yo / 2}px)`,
  border: `${(Yo - 4) / 2}px solid ${(e.vars || e).palette.primary.main}`,
  boxSizing: "content-box"
}, t.hasSelected && {
  backgroundColor: (e.vars || e).palette.primary.main
}));
function dfe(e) {
  const t = Ae({
    props: e,
    name: "MuiClockPointer"
  }), {
    className: r,
    isInner: n,
    type: o,
    viewValue: a
  } = t, i = ge(t, sfe), l = P.useRef(o);
  P.useEffect(() => {
    l.current = o;
  }, [o]);
  const c = T({}, t, {
    shouldAnimate: l.current !== o
  }), u = lfe(c), d = () => {
    let p = 360 / (o === "hours" ? 12 : 60) * a;
    return o === "hours" && a > 12 && (p -= 360), {
      height: Math.round((n ? 0.26 : 0.4) * Hi),
      transform: `rotateZ(${p}deg)`
    };
  };
  return /* @__PURE__ */ _.jsx(cfe, T({
    style: d(),
    className: Pe(r, u.root),
    ownerState: c
  }, i, {
    children: /* @__PURE__ */ _.jsx(ufe, {
      ownerState: c,
      className: u.thumb
    })
  }));
}
function ffe(e) {
  return ze("MuiClock", e);
}
Le("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton"]);
const pfe = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    clock: ["clock"],
    wrapper: ["wrapper"],
    squareMask: ["squareMask"],
    pin: ["pin"],
    amButton: ["amButton"],
    pmButton: ["pmButton"]
  }, ffe, t);
}, mfe = ce("div", {
  name: "MuiClock",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  margin: e.spacing(2)
})), hfe = ce("div", {
  name: "MuiClock",
  slot: "Clock",
  overridesResolver: (e, t) => t.clock
})({
  backgroundColor: "rgba(0,0,0,.07)",
  borderRadius: "50%",
  height: 220,
  width: 220,
  flexShrink: 0,
  position: "relative",
  pointerEvents: "none"
}), yfe = ce("div", {
  name: "MuiClock",
  slot: "Wrapper",
  overridesResolver: (e, t) => t.wrapper
})({
  "&:focus": {
    outline: "none"
  }
}), vfe = ce("div", {
  name: "MuiClock",
  slot: "SquareMask",
  overridesResolver: (e, t) => t.squareMask
})(({
  ownerState: e
}) => T({
  width: "100%",
  height: "100%",
  position: "absolute",
  pointerEvents: "auto",
  outline: 0,
  // Disable scroll capabilities.
  touchAction: "none",
  userSelect: "none"
}, e.disabled ? {} : {
  "@media (pointer: fine)": {
    cursor: "pointer",
    borderRadius: "50%"
  },
  "&:active": {
    cursor: "move"
  }
})), gfe = ce("div", {
  name: "MuiClock",
  slot: "Pin",
  overridesResolver: (e, t) => t.pin
})(({
  theme: e
}) => ({
  width: 6,
  height: 6,
  borderRadius: "50%",
  backgroundColor: (e.vars || e).palette.primary.main,
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)"
})), bfe = ce(co, {
  name: "MuiClock",
  slot: "AmButton",
  overridesResolver: (e, t) => t.amButton
})(({
  theme: e,
  ownerState: t
}) => T({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  left: 8
}, t.meridiemMode === "am" && {
  backgroundColor: (e.vars || e).palette.primary.main,
  color: (e.vars || e).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (e.vars || e).palette.primary.light
  }
})), wfe = ce(co, {
  name: "MuiClock",
  slot: "PmButton",
  overridesResolver: (e, t) => t.pmButton
})(({
  theme: e,
  ownerState: t
}) => T({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  right: 8
}, t.meridiemMode === "pm" && {
  backgroundColor: (e.vars || e).palette.primary.main,
  color: (e.vars || e).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (e.vars || e).palette.primary.light
  }
}));
function xfe(e) {
  const t = Ae({
    props: e,
    name: "MuiClock"
  }), {
    ampm: r,
    ampmInClock: n,
    autoFocus: o,
    children: a,
    value: i,
    handleMeridiemChange: l,
    isTimeDisabled: c,
    meridiemMode: u,
    minutesStep: d = 1,
    onChange: f,
    selectedId: p,
    type: m,
    viewValue: y,
    disabled: h,
    readOnly: v,
    className: g
  } = t, b = t, x = wt(), O = Yr(), w = P.useRef(!1), S = pfe(b), E = c(y, m), C = !r && m === "hours" && (y < 1 || y > 12), N = (U, I) => {
    h || v || c(U, m) || f(U, I);
  }, $ = (U, I) => {
    let {
      offsetX: V,
      offsetY: G
    } = U;
    if (V === void 0) {
      const J = U.target.getBoundingClientRect();
      V = U.changedTouches[0].clientX - J.left, G = U.changedTouches[0].clientY - J.top;
    }
    const q = m === "seconds" || m === "minutes" ? ofe(V, G, d) : afe(V, G, !!r);
    N(q, I);
  }, j = (U) => {
    w.current = !0, $(U, "shallow");
  }, A = (U) => {
    w.current && ($(U, "finish"), w.current = !1);
  }, k = (U) => {
    U.buttons > 0 && $(U.nativeEvent, "shallow");
  }, R = (U) => {
    w.current && (w.current = !1), $(U.nativeEvent, "finish");
  }, D = P.useMemo(() => m === "hours" ? !0 : y % 5 === 0, [m, y]), L = m === "minutes" ? d : 1, B = P.useRef(null);
  wr(() => {
    o && B.current.focus();
  }, [o]);
  const H = (U) => {
    if (!w.current)
      switch (U.key) {
        case "Home":
          N(0, "partial"), U.preventDefault();
          break;
        case "End":
          N(m === "minutes" ? 59 : 23, "partial"), U.preventDefault();
          break;
        case "ArrowUp":
          N(y + L, "partial"), U.preventDefault();
          break;
        case "ArrowDown":
          N(y - L, "partial"), U.preventDefault();
          break;
      }
  };
  return /* @__PURE__ */ _.jsxs(mfe, {
    className: Pe(g, S.root),
    children: [/* @__PURE__ */ _.jsxs(hfe, {
      className: S.clock,
      children: [/* @__PURE__ */ _.jsx(vfe, {
        onTouchMove: j,
        onTouchEnd: A,
        onMouseUp: R,
        onMouseMove: k,
        ownerState: {
          disabled: h
        },
        className: S.squareMask
      }), !E && /* @__PURE__ */ _.jsxs(P.Fragment, {
        children: [/* @__PURE__ */ _.jsx(gfe, {
          className: S.pin
        }), i != null && /* @__PURE__ */ _.jsx(dfe, {
          type: m,
          viewValue: y,
          isInner: C,
          hasSelected: D
        })]
      }), /* @__PURE__ */ _.jsx(yfe, {
        "aria-activedescendant": p,
        "aria-label": O.clockLabelText(m, i, x),
        ref: B,
        role: "listbox",
        onKeyDown: H,
        tabIndex: 0,
        className: S.wrapper,
        children: a
      })]
    }), r && n && /* @__PURE__ */ _.jsxs(P.Fragment, {
      children: [/* @__PURE__ */ _.jsx(bfe, {
        onClick: v ? void 0 : () => l("am"),
        disabled: h || u === null,
        ownerState: b,
        className: S.amButton,
        children: /* @__PURE__ */ _.jsx(Zn, {
          variant: "caption",
          children: "AM"
        })
      }), /* @__PURE__ */ _.jsx(wfe, {
        disabled: h || u === null,
        onClick: v ? void 0 : () => l("pm"),
        ownerState: b,
        className: S.pmButton,
        children: /* @__PURE__ */ _.jsx(Zn, {
          variant: "caption",
          children: "PM"
        })
      })]
    })]
  });
}
function _fe(e) {
  return ze("MuiClockNumber", e);
}
const pc = Le("MuiClockNumber", ["root", "selected", "disabled"]), Ofe = ["className", "disabled", "index", "inner", "label", "selected"], Pfe = (e) => {
  const {
    classes: t,
    selected: r,
    disabled: n
  } = e;
  return Ve({
    root: ["root", r && "selected", n && "disabled"]
  }, _fe, t);
}, Sfe = ce("span", {
  name: "MuiClockNumber",
  slot: "Root",
  overridesResolver: (e, t) => [t.root, {
    [`&.${pc.disabled}`]: t.disabled
  }, {
    [`&.${pc.selected}`]: t.selected
  }]
})(({
  theme: e,
  ownerState: t
}) => T({
  height: Yo,
  width: Yo,
  position: "absolute",
  left: `calc((100% - ${Yo}px) / 2)`,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  color: (e.vars || e).palette.text.primary,
  fontFamily: e.typography.fontFamily,
  "&:focused": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  [`&.${pc.selected}`]: {
    color: (e.vars || e).palette.primary.contrastText
  },
  [`&.${pc.disabled}`]: {
    pointerEvents: "none",
    color: (e.vars || e).palette.text.disabled
  }
}, t.inner && T({}, e.typography.body2, {
  color: (e.vars || e).palette.text.secondary
})));
function bM(e) {
  const t = Ae({
    props: e,
    name: "MuiClockNumber"
  }), {
    className: r,
    disabled: n,
    index: o,
    inner: a,
    label: i,
    selected: l
  } = t, c = ge(t, Ofe), u = t, d = Pfe(u), f = o % 12 / 12 * Math.PI * 2 - Math.PI / 2, p = (Hi - Yo - 2) / 2 * (a ? 0.65 : 1), m = Math.round(Math.cos(f) * p), y = Math.round(Math.sin(f) * p);
  return /* @__PURE__ */ _.jsx(Sfe, T({
    className: Pe(r, d.root),
    "aria-disabled": n ? !0 : void 0,
    "aria-selected": l ? !0 : void 0,
    role: "option",
    style: {
      transform: `translate(${m}px, ${y + (Hi - Yo) / 2}px`
    },
    ownerState: u
  }, c, {
    children: i
  }));
}
const Tfe = ({
  ampm: e,
  value: t,
  getClockNumberText: r,
  isDisabled: n,
  selectedId: o,
  utils: a
}) => {
  const i = t ? a.getHours(t) : null, l = [], c = e ? 1 : 0, u = e ? 12 : 23, d = (f) => i === null ? !1 : e ? f === 12 ? i === 12 || i === 0 : i === f || i - 12 === f : i === f;
  for (let f = c; f <= u; f += 1) {
    let p = f.toString();
    f === 0 && (p = "00");
    const m = !e && (f === 0 || f > 12);
    p = a.formatNumber(p);
    const y = d(f);
    l.push(/* @__PURE__ */ _.jsx(bM, {
      id: y ? o : void 0,
      index: f,
      inner: m,
      selected: y,
      disabled: n(f),
      label: p,
      "aria-label": r(p)
    }, f));
  }
  return l;
}, C1 = ({
  utils: e,
  value: t,
  isDisabled: r,
  getClockNumberText: n,
  selectedId: o
}) => {
  const a = e.formatNumber;
  return [[5, a("05")], [10, a("10")], [15, a("15")], [20, a("20")], [25, a("25")], [30, a("30")], [35, a("35")], [40, a("40")], [45, a("45")], [50, a("50")], [55, a("55")], [0, a("00")]].map(([i, l], c) => {
    const u = i === t;
    return /* @__PURE__ */ _.jsx(bM, {
      label: l,
      id: u ? o : void 0,
      index: c + 1,
      inner: !1,
      disabled: r(i),
      selected: u,
      "aria-label": n(l)
    }, i);
  });
}, Efe = ["ampm", "ampmInClock", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "showViewSwitcher", "onChange", "defaultValue", "view", "views", "openTo", "onViewChange", "className", "disabled", "readOnly"], $fe = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    arrowSwitcher: ["arrowSwitcher"]
  }, efe, t);
}, Cfe = ce(tM, {
  name: "MuiTimeClock",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "flex",
  flexDirection: "column",
  position: "relative"
}), kfe = ce(CN, {
  name: "MuiTimeClock",
  slot: "ArrowSwitcher",
  overridesResolver: (e, t) => t.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
}), wM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Yr(), o = ns(), a = wt(), i = Ae({
    props: t,
    name: "MuiTimeClock"
  }), {
    ampm: l = a.is12HourCycleInCurrentLocale(),
    ampmInClock: c = !1,
    autoFocus: u,
    components: d,
    componentsProps: f,
    slots: p,
    slotProps: m,
    value: y,
    disableIgnoringDatePartForTimeValidation: h = !1,
    maxTime: v,
    minTime: g,
    disableFuture: b,
    disablePast: x,
    minutesStep: O = 1,
    shouldDisableClock: w,
    shouldDisableTime: S,
    showViewSwitcher: E,
    onChange: C,
    defaultValue: N,
    view: $,
    views: j = ["hours", "minutes"],
    openTo: A,
    onViewChange: k,
    className: R,
    disabled: D,
    readOnly: L
  } = i, B = ge(i, Efe), H = p ?? Gp(d), U = m ?? f, [I, V] = Wr({
    name: "DateCalendar",
    state: "value",
    controlled: y,
    default: N ?? null
  }), G = gt((M, W) => {
    V(M), C == null || C(M, W);
  }), {
    view: q,
    setView: J,
    previousView: ne,
    nextView: te,
    setValueAndGoToNextView: ee
  } = Ab({
    view: $,
    views: j,
    openTo: A,
    onViewChange: k,
    onChange: G
  }), K = P.useMemo(() => I || a.setSeconds(a.setMinutes(a.setHours(o, 0), 0), 0), [I, o, a]), {
    meridiemMode: Q,
    handleMeridiemChange: ae
  } = bI(K, l, ee), ie = P.useCallback((M, W) => {
    const Z = iI(h, a), he = W === "hours" || W === "minutes" && j.includes("seconds"), me = ({
      start: ue,
      end: Oe
    }) => !(g && Z(g, Oe) || v && Z(ue, v) || b && Z(ue, o) || x && Z(o, he ? Oe : ue)), de = (ue, Oe = 1) => {
      if (ue % Oe !== 0 || w != null && w(ue, W))
        return !1;
      if (S)
        switch (W) {
          case "hours":
            return !S(a.setHours(K, ue), "hours");
          case "minutes":
            return !S(a.setMinutes(K, ue), "minutes");
          case "seconds":
            return !S(a.setSeconds(K, ue), "seconds");
          default:
            return !1;
        }
      return !0;
    };
    switch (W) {
      case "hours": {
        const ue = Av(M, Q, l), Oe = a.setHours(K, ue), Se = a.setSeconds(a.setMinutes(Oe, 0), 0), De = a.setSeconds(a.setMinutes(Oe, 59), 59);
        return !me({
          start: Se,
          end: De
        }) || !de(ue);
      }
      case "minutes": {
        const ue = a.setMinutes(K, M), Oe = a.setSeconds(ue, 0), Se = a.setSeconds(ue, 59);
        return !me({
          start: Oe,
          end: Se
        }) || !de(M, O);
      }
      case "seconds": {
        const ue = a.setSeconds(K, M);
        return !me({
          start: ue,
          end: ue
        }) || !de(M);
      }
      default:
        throw new Error("not supported");
    }
  }, [l, K, h, v, Q, g, O, w, S, a, b, x, o, j]), oe = Ri(), se = P.useMemo(() => {
    switch (q) {
      case "hours": {
        const M = (W, Z) => {
          const he = Av(W, Q, l);
          ee(a.setHours(K, he), Z);
        };
        return {
          onChange: M,
          viewValue: a.getHours(K),
          children: Tfe({
            value: I,
            utils: a,
            ampm: l,
            onChange: M,
            getClockNumberText: n.hoursClockNumberText,
            isDisabled: (W) => D || ie(W, "hours"),
            selectedId: oe
          })
        };
      }
      case "minutes": {
        const M = a.getMinutes(K), W = (Z, he) => {
          ee(a.setMinutes(K, Z), he);
        };
        return {
          viewValue: M,
          onChange: W,
          children: C1({
            utils: a,
            value: M,
            onChange: W,
            getClockNumberText: n.minutesClockNumberText,
            isDisabled: (Z) => D || ie(Z, "minutes"),
            selectedId: oe
          })
        };
      }
      case "seconds": {
        const M = a.getSeconds(K), W = (Z, he) => {
          ee(a.setSeconds(K, Z), he);
        };
        return {
          viewValue: M,
          onChange: W,
          children: C1({
            utils: a,
            value: M,
            onChange: W,
            getClockNumberText: n.secondsClockNumberText,
            isDisabled: (Z) => D || ie(Z, "seconds"),
            selectedId: oe
          })
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [q, a, I, l, n.hoursClockNumberText, n.minutesClockNumberText, n.secondsClockNumberText, Q, ee, K, ie, oe, D]), re = i, le = $fe(re);
  return /* @__PURE__ */ _.jsxs(Cfe, T({
    ref: r,
    className: Pe(le.root, R),
    ownerState: re
  }, B, {
    children: [/* @__PURE__ */ _.jsx(xfe, T({
      autoFocus: u,
      ampmInClock: c && j.includes("hours"),
      value: I,
      type: q,
      ampm: l,
      minutesStep: O,
      isTimeDisabled: ie,
      meridiemMode: Q,
      handleMeridiemChange: ae,
      selectedId: oe,
      disabled: D,
      readOnly: L
    }, se)), E && /* @__PURE__ */ _.jsx(kfe, {
      className: le.arrowSwitcher,
      slots: H,
      slotProps: U,
      onGoToPrevious: () => J(ne),
      isPreviousDisabled: !ne,
      previousLabel: n.openPreviousView,
      onGoToNext: () => J(te),
      isNextDisabled: !te,
      nextLabel: n.openNextView,
      ownerState: re
    })]
  }));
});
process.env.NODE_ENV !== "production" && (wM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: s.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default false
   */
  ampmInClock: s.bool,
  /**
   * Set to `true` if focus should be moved to clock picker.
   */
  autoFocus: s.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  className: s.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: s.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: s.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: s.number,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {TDate | null} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   */
  onChange: s.func,
  /**
   * Callback fired on view change.
   * @param {TimeView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Initially open view.
   * @default 'hours'
   */
  openTo: s.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: s.bool,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: s.func,
  /**
   * Disable specific time.
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: s.func,
  showViewSwitcher: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * Controlled open view.
   */
  view: s.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Views for calendar picker.
   * @default ['hours', 'minutes']
   */
  views: s.arrayOf(s.oneOf(["hours", "minutes", "seconds"]).isRequired)
});
const Rfe = (e) => e === "hours" || e === "minutes" || e === "seconds", yh = ({
  view: e,
  onViewChange: t,
  views: r,
  value: n,
  defaultValue: o,
  onChange: a,
  className: i,
  classes: l,
  disableFuture: c,
  disablePast: u,
  minTime: d,
  maxTime: f,
  shouldDisableTime: p,
  shouldDisableClock: m,
  minutesStep: y,
  ampm: h,
  ampmInClock: v,
  components: g,
  componentsProps: b,
  slots: x,
  slotProps: O,
  readOnly: w,
  disabled: S,
  sx: E,
  autoFocus: C,
  showViewSwitcher: N,
  disableIgnoringDatePartForTimeValidation: $
}) => /* @__PURE__ */ _.jsx(wM, {
  view: e,
  onViewChange: t,
  views: r.filter(Rfe),
  value: n,
  defaultValue: o,
  onChange: a,
  className: i,
  classes: l,
  disableFuture: c,
  disablePast: u,
  minTime: d,
  maxTime: f,
  shouldDisableTime: p,
  shouldDisableClock: m,
  minutesStep: y,
  ampm: h,
  ampmInClock: v,
  components: g,
  componentsProps: b,
  slots: x,
  slotProps: O,
  readOnly: w,
  disabled: S,
  sx: E,
  autoFocus: C,
  showViewSwitcher: N,
  disableIgnoringDatePartForTimeValidation: $
}), xM = /* @__PURE__ */ P.forwardRef(function(t, r) {
  var n, o, a;
  const i = Yr(), l = hM(t, "MuiMobileDateTimePicker"), c = T({
    day: dn,
    month: dn,
    year: dn,
    hours: yh,
    minutes: yh,
    seconds: yh
  }, l.viewRenderers), u = (n = l.ampmInClock) != null ? n : !1, d = T({}, l, {
    viewRenderers: c,
    ampmInClock: u,
    slots: T({
      field: Gb
    }, l.slots),
    slotProps: T({}, l.slotProps, {
      field: (p) => {
        var m;
        return T({}, Ma((m = l.slotProps) == null ? void 0 : m.field, p), Zp(l), {
          ref: r,
          ampm: l.ampm
        });
      },
      toolbar: T({
        hidden: !1,
        ampmInClock: u
      }, (o = l.slotProps) == null ? void 0 : o.toolbar),
      tabs: T({
        hidden: !1
      }, (a = l.slotProps) == null ? void 0 : a.tabs)
    })
  }), {
    renderPicker: f
  } = oM({
    props: d,
    valueManager: rs,
    getOpenDialogAriaText: i.openDatePickerDialogue,
    validator: Lb
  });
  return f();
});
xM.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: s.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: s.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: s.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: s.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: s.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: s.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: s.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific time.
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    hours: s.func,
    minutes: s.func,
    month: s.func,
    seconds: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: s.oneOf([3, 4])
};
const Dfe = ["desktopModeMediaQuery"], _M = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiDateTimePicker"
  }), {
    desktopModeMediaQuery: o = UN
  } = n, a = ge(n, Dfe);
  return HD(o, {
    defaultMatches: !0
  }) ? /* @__PURE__ */ _.jsx(yM, T({
    ref: r
  }, a)) : /* @__PURE__ */ _.jsx(xM, T({
    ref: r
  }, a));
});
process.env.NODE_ENV !== "production" && (_M.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: s.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: s.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: s.bool,
  /**
   * Class name applied to the root element.
   */
  className: s.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: s.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: s.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: s.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
   * @returns {string} The name to display.
   * @default (day) => day.charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: s.func,
  /**
   * Default calendar month displayed when `value={null}`.
   */
  defaultCalendarMonth: s.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: s.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: s.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: s.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: s.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: s.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: s.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: s.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: s.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: s.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: s.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: s.string,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: s.oneOfType([s.func, s.shape({
    current: s.object
  })]),
  /**
   * The label content.
   */
  label: s.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: s.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: s.object,
  /**
   * Maximal selectable date.
   */
  maxDate: s.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: s.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: s.any,
  /**
   * Minimal selectable date.
   */
  minDate: s.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: s.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: s.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: s.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: s.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: s.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: s.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: s.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: s.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: s.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: s.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: s.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: s.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: s.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: s.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: s.oneOf(["landscape", "portrait"]),
  readOnly: s.bool,
  /**
   * Disable heavy animations.
   * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
   */
  reduceAnimations: s.bool,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: s.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: s.oneOfType([s.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), s.number, s.shape({
    endIndex: s.number.isRequired,
    startIndex: s.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: s.func,
  /**
   * Disable specific date.
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: s.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: s.func,
  /**
   * Disable specific time.
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: s.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: s.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: s.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: s.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: s.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: s.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: s.shape({
    day: s.func,
    hours: s.func,
    minutes: s.func,
    month: s.func,
    seconds: s.func,
    year: s.func
  }),
  /**
   * Available views.
   */
  views: s.arrayOf(s.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4 on desktop, 3 on mobile
   */
  yearsPerRow: s.oneOf([3, 4])
});
function Nfe({ control: e, name: t, PopperProps: r, ...n }) {
  const {
    field: { ref: o, ...a },
    fieldState: { error: i }
  } = So({
    name: t,
    control: e
  }), l = fr(), c = qe(), u = l.fn.variant({
    variant: "default",
    color: l.colors[l.primaryColor][l.fn.primaryShade()]
  });
  return /* @__PURE__ */ _.jsx(Rl, { dateAdapter: WD, children: /* @__PURE__ */ _.jsx(
    _M,
    {
      components: {
        OpenPickerIcon: oD
      },
      OpenPickerButtonProps: {
        sx: {
          padding: 0,
          marginLeft: "-18px",
          color: l.colors.gray[7]
        }
      },
      PopperProps: {
        anchorEl: c.current,
        sx: {
          "& .Mui-selected": {
            backgroundColor: `${u.background} !important`,
            ...l.fn.hover({
              backgroundColor: `${u.hover} !important`
            })
          }
        },
        ...r
      },
      renderInput: ({ ref: d, inputProps: f, disabled: p, onChange: m, value: y, ...h }) => /* @__PURE__ */ _.jsx(
        Ip,
        {
          ref: c,
          label: n.label,
          error: !!i,
          rightSection: h.InputProps.endAdornment,
          ...f
        }
      ),
      inputRef: o,
      ...a,
      onChange: (d) => {
        a.onChange(d);
      },
      ...n
    }
  ) });
}
function Ife({ control: e, name: t, items: r, filter: n, ...o }) {
  var u;
  const {
    field: { ...a },
    fieldState: { error: i }
  } = So({
    name: t,
    control: e
  }), l = r.map((d) => ({ value: d.id.toString(), label: d.value }));
  let c = null;
  return n && a.value ? c = a.value.toString() : (u = a.value) != null && u.id && (c = a.value.id.toString()), /* @__PURE__ */ _.jsx(
    Ji,
    {
      data: l,
      error: i ? i.message : null,
      ...a,
      value: c,
      onChange: (d) => {
        if (n) {
          a.onChange(d);
          return;
        }
        const f = r.find((p) => p.id.toString() === d);
        a.onChange(f);
      },
      searchable: !0,
      ...o
    }
  );
}
function Mfe({ control: e, name: t, items: r, ...n }) {
  const {
    field: { ref: o, ...a },
    fieldState: { error: i }
  } = So({
    name: t,
    control: e
  }), l = r.map((u) => ({ value: u.id, label: u.value })), c = a.value.map((u) => u.id);
  return /* @__PURE__ */ _.jsx(
    Np,
    {
      ref: o,
      data: l,
      error: i ? i.message : null,
      searchable: !0,
      ...a,
      value: c,
      onChange: (u) => {
        const d = [];
        u.forEach((f) => {
          d.push(r.find((p) => p.id === f));
        }), a.onChange(d);
      },
      ...n
    }
  );
}
function Afe({ control: e, name: t, items: r, ...n }) {
  const {
    field: { ref: o, ...a },
    fieldState: { error: i }
  } = So({
    name: t,
    control: e
  });
  return /* @__PURE__ */ _.jsx(Ji, { ref: o, data: r, error: i ? i.message : null, searchable: !0, ...a, ...n });
}
function k1({ control: e, name: t, ...r }) {
  const {
    field: { ref: n, ...o },
    fieldState: { error: a }
  } = So({
    name: t,
    control: e
  }), i = o.value || "";
  return /* @__PURE__ */ _.jsx(Ip, { ref: n, ...o, error: a ? a.message : null, value: i, ...r });
}
function Kb({ name: e, control: t, schema: r, filter: n, ...o }) {
  if (!r.type)
    return null;
  switch (r.type) {
    case "Boolean":
      return /* @__PURE__ */ _.jsx(
        Afe,
        {
          name: e,
          control: t,
          items: [
            { label: "True", value: !0 },
            { label: "False", value: !1 }
          ],
          ...o
        }
      );
    case "RelatedList":
      return /* @__PURE__ */ _.jsx(Mfe, { name: e, control: t, items: r.values, ...o });
    case "Related":
      return /* @__PURE__ */ _.jsx(Ife, { name: e, control: t, items: r.values, filter: n, ...o });
    case "DateTime":
      return /* @__PURE__ */ _.jsx(
        Nfe,
        {
          control: t,
          name: e,
          mask: "__.__.____ __:__",
          format: "dd.MM.yyyy HH:mm",
          schema: r,
          PopperProps: n && { placement: "bottom-end" },
          ...o
        }
      );
    case "Date":
      return /* @__PURE__ */ _.jsx(
        ude,
        {
          control: t,
          name: e,
          mask: "__.__.____",
          format: "dd.MM.yyyy",
          schema: r,
          PopperProps: n && { placement: "bottom-end" },
          ...o
        }
      );
    case "Integer":
    case "Float":
      return /* @__PURE__ */ _.jsx(k1, { name: e, control: t, ...o });
    default:
      return /* @__PURE__ */ _.jsx(k1, { name: e, control: t, ...o });
  }
}
function jfe({ opened: e, onClose: t }) {
  const { info: r, addEntry: n } = ir(), { handleSubmit: o, reset: a, control: i } = ub({
    mode: "onChange",
    defaultValues: r.add.defaultValues,
    resolver: db(r.add.schema)
  }), l = async (c) => {
    await n(c), a(), t();
  };
  return /* @__PURE__ */ _.jsx(
    Zi,
    {
      opened: e,
      onClose: () => {
        a(), t();
      },
      title: r.add.title,
      size: "lg",
      centered: !0,
      children: /* @__PURE__ */ _.jsxs(El, { spacing: "md", children: [
        r.add.columns.map((c) => /* @__PURE__ */ _.jsx(
          Kb,
          {
            name: c.name,
            control: i,
            label: `${c.name}${c.required ? "*" : ""}`,
            description: c.description,
            schema: c
          },
          c.name
        )),
        /* @__PURE__ */ _.jsx(Rn, { position: "right", mt: "xl", children: /* @__PURE__ */ _.jsx(ji, { onClick: o(l), children: "Add" }) })
      ] })
    }
  );
}
function Ffe() {
  const [e, t] = Me(!1);
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx(Ba, { label: "Add Item", children: /* @__PURE__ */ _.jsx(
      tn,
      {
        onClick: () => {
          t(!0);
        },
        children: /* @__PURE__ */ _.jsx(aD, {})
      }
    ) }),
    /* @__PURE__ */ _.jsx(
      jfe,
      {
        opened: e,
        onClose: () => {
          t(!1);
        }
      }
    )
  ] });
}
function Lfe({ control: e, name: t, items: r, onChange: n, TextFieldProps: o, ...a }) {
  const {
    field: { ref: i, ...l },
    fieldState: { error: c }
  } = So({
    name: t,
    control: e
  });
  return /* @__PURE__ */ _.jsx(
    Ji,
    {
      ref: i,
      data: r,
      searchable: !0,
      onChange: (u, d) => {
        l.onChange(d), n && n(d.value ?? d);
      },
      ...l,
      ...a
    }
  );
}
function Vfe({ control: e, name: t, items: r, onChange: n, TextFieldProps: o, ...a }) {
  const {
    field: { ref: i, ...l },
    fieldState: { error: c }
  } = So({
    name: t,
    control: e
  });
  return /* @__PURE__ */ _.jsx(
    Ji,
    {
      ref: i,
      data: r,
      searchable: !0,
      onChange: (u, d) => {
        l.onChange(d), n && n(d.value ?? d);
      },
      ...l,
      ...a
    }
  );
}
function zfe({ control: e, name: t, ...r }) {
  const [n, o] = Me([]), {
    field: { ref: a, ...i },
    fieldState: { error: l }
  } = So({
    name: t,
    control: e
  });
  return Ue(() => {
    if (i.value) {
      const c = JSON.parse(i.value);
      o([...c]), i.onChange(c);
    } else
      i.onChange([]);
  }, []), /* @__PURE__ */ _.jsx(
    Np,
    {
      ref: a,
      data: n,
      placeholder: "Enter items",
      searchable: !0,
      creatable: !0,
      error: l ? l.message : null,
      ...i,
      value: i.value,
      getCreateLabel: (c) => `+ Add ${c}`,
      onCreate: (c) => (o((u) => [...u, c]), c),
      onChange: (c) => {
        i.onChange(c);
      }
    }
  );
}
const Bfe = il({
  filters: rb().of(
    il({
      col: Gd().required("Column is required"),
      opr: Gd().required("Operation is required"),
      value: Kg().required("Value is required")
    })
  )
});
function Wfe({ onClose: e }) {
  const { info: t, queryParams: r, setQueryParams: n } = ir(), { handleSubmit: o, control: a, setValue: i, watch: l } = ub({
    mode: "onTouched",
    defaultValues: {
      filters: []
    },
    resolver: db(Bfe)
  }), { fields: c, append: u, remove: d, update: f } = jG({ control: a, name: "filters" }), p = l("filters"), m = c.map((h, v) => ({
    ...h,
    ...p[v]
  }));
  Ue(() => {
    r.filters.length && i("filters", JSON.parse(JSON.stringify(r.filters)));
  }, [r.filters, i]);
  const y = (h) => {
    const v = JSON.parse(JSON.stringify(h.filters));
    v.forEach((g) => {
      g.opr === "in" && Array.isArray(g.value) && (g.value = JSON.stringify(g.value));
    }), n({ filters: v }), e();
  };
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    m.length ? m.map((h, v) => /* @__PURE__ */ _.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ _.jsxs(Rn, { mt: "lg", spacing: "md", noWrap: !0, children: [
        /* @__PURE__ */ _.jsx(Ke, { sx: { width: "192px" }, children: /* @__PURE__ */ _.jsx(
          Lfe,
          {
            name: `filters.${v}.col`,
            control: a,
            items: Object.keys(t.filters),
            onChange: (g) => {
              f(v, { col: g, value: "", opr: "" });
            }
          }
        ) }),
        /* @__PURE__ */ _.jsx(Ke, { sx: { width: "192px" }, children: h.col ? /* @__PURE__ */ _.jsx(
          Vfe,
          {
            name: `filters.${v}.opr`,
            control: a,
            items: t.filters[h.col].filters.map((g) => ({
              label: g.name,
              value: g.operator
            }))
          }
        ) : null }),
        /* @__PURE__ */ _.jsx(Ke, { sx: { width: "192px" }, children: h.col ? h.opr === "in" ? /* @__PURE__ */ _.jsx(zfe, { name: `filters.${v}.value`, control: a }) : /* @__PURE__ */ _.jsx(
          Kb,
          {
            name: `filters.${v}.value`,
            control: a,
            schema: t.filters[h.col].schema,
            filter: !0
          }
        ) : null }),
        /* @__PURE__ */ _.jsx(
          tn,
          {
            size: "xs",
            onClick: () => {
              d(v);
            },
            children: /* @__PURE__ */ _.jsx(iD, {})
          }
        )
      ] }),
      m.length > 1 && v < m.length - 1 ? /* @__PURE__ */ _.jsx(
        ol,
        {
          sx: (g) => ({
            color: `${g.colors[g.primaryColor][g.fn.primaryShade()]} !important`
          }),
          my: "md",
          labelPosition: "center",
          label: "AND"
        }
      ) : null
    ] }, h.id)) : /* @__PURE__ */ _.jsx(Ke, { sx: { width: "642px" }, children: /* @__PURE__ */ _.jsx($r, { sx: (h) => ({ fontStyle: "italic", padding: "7px" }), size: "sm", color: "dimmed", children: "No filters selected..." }) }),
    /* @__PURE__ */ _.jsx(ol, { my: "xl" }),
    /* @__PURE__ */ _.jsxs(Ke, { sx: { display: "flex", justifyContent: "space-between" }, children: [
      /* @__PURE__ */ _.jsx(
        ji,
        {
          variant: "subtle",
          leftIcon: /* @__PURE__ */ _.jsx(aD, {}),
          onClick: () => {
            u({ col: "", opr: "", value: "" });
          },
          children: "Add Filter"
        }
      ),
      /* @__PURE__ */ _.jsx(Rn, { spacing: "md", children: /* @__PURE__ */ _.jsx(ji, { onClick: o(y), children: "Apply" }) })
    ] })
  ] });
}
function Ufe() {
  const { queryParams: e } = ir(), [t, r] = Me(!1);
  return /* @__PURE__ */ _.jsxs(
    cn,
    {
      opened: t,
      position: "bottom-end",
      onClose: () => r(!1),
      children: [
        /* @__PURE__ */ _.jsx(cn.Target, { children: /* @__PURE__ */ _.jsx(Ba, { opened: t ? !1 : null, label: "Filter", children: /* @__PURE__ */ _.jsx(tn, { onClick: () => r(!0), children: e.filters.length ? /* @__PURE__ */ _.jsx(Vg, { styles: (n) => ({ indicator: { paddingTop: "2px" } }), label: e.filters.length, children: /* @__PURE__ */ _.jsx(eP, {}) }) : /* @__PURE__ */ _.jsx(eP, {}) }) }) }),
        /* @__PURE__ */ _.jsxs(cn.Dropdown, { children: [
          /* @__PURE__ */ _.jsx(Ke, { sx: { position: "absolute", top: 4, right: 4 }, children: /* @__PURE__ */ _.jsx(Sp, { title: "Filters", onClick: () => r(!1) }) }),
          /* @__PURE__ */ _.jsx(
            Wfe,
            {
              onClose: () => {
                r(!1);
              }
            }
          )
        ] })
      ]
    }
  );
}
const OM = Jf(({ settings: e, hideFilter: t, hideSettings: r, dense: n, dispatch: o }) => {
  const { info: a } = ir(), { classes: i } = sG({ dense: n }, { name: "DataGrid" }), l = a.permissions.includes("can_post");
  return /* @__PURE__ */ _.jsxs(Ke, { className: i.toolbarRoot, children: [
    /* @__PURE__ */ _.jsx(Ke, { children: r ? null : /* @__PURE__ */ _.jsx($G, { onSettingsChange: (c) => o({ type: "setSettings", payload: c }), settings: e }) }),
    /* @__PURE__ */ _.jsxs(Ke, { sx: { display: "flex" }, children: [
      l ? /* @__PURE__ */ _.jsx(Ffe, {}) : null,
      t ? null : /* @__PURE__ */ _.jsx(Ufe, {})
    ] })
  ] });
});
OM.displayName = "Toolbar";
/*!
 * OverlayScrollbars
 * Version: 2.2.0
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
function mt(e, t) {
  if (im(e))
    for (let r = 0; r < e.length && t(e[r], r, e) !== !1; r++)
      ;
  else
    e && mt(Object.keys(e), (r) => t(e[r], r, e));
  return e;
}
function hr(e, t) {
  const r = na(t);
  if (Nn(t) || r) {
    let o = r ? "" : {};
    if (e) {
      const a = window.getComputedStyle(e, null);
      o = r ? I1(e, a, t) : t.reduce((i, l) => (i[l] = I1(e, a, l), i), o);
    }
    return o;
  }
  e && mt(Hr(t), (o) => ipe(e, o, t[o]));
}
const Sn = (e, t) => {
  const { o: r, u: n, _: o } = e;
  let a = r, i;
  const l = (d, f) => {
    const p = a, m = d, y = f || (n ? !n(p, m) : p !== m);
    return (y || o) && (a = m, i = p), [a, y, i];
  };
  return [t ? (d) => l(t(a, i), d) : l, (d) => [a, !!d, i]];
}, jl = () => typeof window < "u", PM = jl() && Node.ELEMENT_NODE, { toString: Hfe, hasOwnProperty: vh } = Object.prototype, Eo = (e) => e === void 0, am = (e) => e === null, Yfe = (e) => Eo(e) || am(e) ? `${e}` : Hfe.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase(), qo = (e) => typeof e == "number", na = (e) => typeof e == "string", Xb = (e) => typeof e == "boolean", Dn = (e) => typeof e == "function", Nn = (e) => Array.isArray(e), pl = (e) => typeof e == "object" && !Nn(e) && !am(e), im = (e) => {
  const t = !!e && e.length, r = qo(t) && t > -1 && t % 1 == 0;
  return Nn(e) || !Dn(e) && r ? t > 0 && pl(e) ? t - 1 in e : !0 : !1;
}, Vv = (e) => {
  if (!e || !pl(e) || Yfe(e) !== "object")
    return !1;
  let t;
  const r = "constructor", n = e[r], o = n && n.prototype, a = vh.call(e, r), i = o && vh.call(o, "isPrototypeOf");
  if (n && !a && !i)
    return !1;
  for (t in e)
    ;
  return Eo(t) || vh.call(e, t);
}, Uf = (e) => {
  const t = HTMLElement;
  return e ? t ? e instanceof t : e.nodeType === PM : !1;
}, sm = (e) => {
  const t = Element;
  return e ? t ? e instanceof t : e.nodeType === PM : !1;
}, Qb = (e, t, r) => e.indexOf(t, r), Ct = (e, t, r) => (!r && !na(t) && im(t) ? Array.prototype.push.apply(e, t) : e.push(t), e), ja = (e) => {
  const t = Array.from, r = [];
  return t && e ? t(e) : (e instanceof Set ? e.forEach((n) => {
    Ct(r, n);
  }) : mt(e, (n) => {
    Ct(r, n);
  }), r);
}, Zb = (e) => !!e && e.length === 0, no = (e, t, r) => {
  mt(e, (o) => o && o.apply(void 0, t || [])), !r && (e.length = 0);
}, lm = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Hr = (e) => e ? Object.keys(e) : [], jt = (e, t, r, n, o, a, i) => {
  const l = [t, r, n, o, a, i];
  return (typeof e != "object" || am(e)) && !Dn(e) && (e = {}), mt(l, (c) => {
    mt(Hr(c), (u) => {
      const d = c[u];
      if (e === d)
        return !0;
      const f = Nn(d);
      if (d && (Vv(d) || f)) {
        const p = e[u];
        let m = p;
        f && !Nn(p) ? m = [] : !f && !Vv(p) && (m = {}), e[u] = jt(m, d);
      } else
        e[u] = d;
    });
  }), e;
}, Jb = (e) => {
  for (const t in e)
    return !1;
  return !0;
}, SM = (e, t, r, n) => {
  if (Eo(n))
    return r ? r[e] : t;
  r && (na(n) || qo(n)) && (r[e] = n);
}, mr = (e, t, r) => {
  if (Eo(r))
    return e ? e.getAttribute(t) : null;
  e && e.setAttribute(t, r);
}, Pr = (e, t) => {
  e && e.removeAttribute(t);
}, $a = (e, t, r, n) => {
  if (r) {
    const o = mr(e, t) || "", a = new Set(o.split(" "));
    a[n ? "add" : "delete"](r);
    const i = ja(a).join(" ").trim();
    mr(e, t, i);
  }
}, qfe = (e, t, r) => {
  const n = mr(e, t) || "";
  return new Set(n.split(" ")).has(r);
}, Cn = (e, t) => SM("scrollLeft", 0, e, t), po = (e, t) => SM("scrollTop", 0, e, t), zv = jl() && Element.prototype, TM = (e, t) => {
  const r = [], n = t ? sm(t) ? t : null : document;
  return n ? Ct(r, n.querySelectorAll(e)) : r;
}, Gfe = (e, t) => {
  const r = t ? sm(t) ? t : null : document;
  return r ? r.querySelector(e) : null;
}, Hf = (e, t) => sm(e) ? (zv.matches || zv.msMatchesSelector).call(e, t) : !1, e0 = (e) => e ? ja(e.childNodes) : [], wo = (e) => e ? e.parentElement : null, bi = (e, t) => {
  if (sm(e)) {
    const r = zv.closest;
    if (r)
      return r.call(e, t);
    do {
      if (Hf(e, t))
        return e;
      e = wo(e);
    } while (e);
  }
  return null;
}, Kfe = (e, t, r) => {
  const n = e && bi(e, t), o = e && Gfe(r, n), a = bi(o, t) === n;
  return n && o ? n === e || o === e || a && bi(bi(e, r), t) !== n : !1;
}, t0 = (e, t, r) => {
  if (r && e) {
    let n = t, o;
    im(r) ? (o = document.createDocumentFragment(), mt(r, (a) => {
      a === n && (n = a.previousSibling), o.appendChild(a);
    })) : o = r, t && (n ? n !== t && (n = n.nextSibling) : n = e.firstChild), e.insertBefore(o, n || null);
  }
}, nn = (e, t) => {
  t0(e, null, t);
}, Xfe = (e, t) => {
  t0(wo(e), e, t);
}, R1 = (e, t) => {
  t0(wo(e), e && e.nextSibling, t);
}, Jn = (e) => {
  if (im(e))
    mt(ja(e), (t) => Jn(t));
  else if (e) {
    const t = wo(e);
    t && t.removeChild(e);
  }
}, Ca = (e) => {
  const t = document.createElement("div");
  return e && mr(t, "class", e), t;
}, EM = (e) => {
  const t = Ca();
  return t.innerHTML = e.trim(), mt(e0(t), (r) => Jn(r));
}, Bv = (e) => e.charAt(0).toUpperCase() + e.slice(1), Qfe = () => Ca().style, Zfe = ["-webkit-", "-moz-", "-o-", "-ms-"], Jfe = ["WebKit", "Moz", "O", "MS", "webkit", "moz", "o", "ms"], gh = {}, bh = {}, epe = (e) => {
  let t = bh[e];
  if (lm(bh, e))
    return t;
  const r = Bv(e), n = Qfe();
  return mt(Zfe, (o) => {
    const a = o.replace(/-/g, "");
    return !(t = [e, o + e, a + r, Bv(a) + r].find((l) => n[l] !== void 0));
  }), bh[e] = t || "";
}, Fl = (e) => {
  if (jl()) {
    let t = gh[e] || window[e];
    return lm(gh, e) || (mt(Jfe, (r) => (t = t || window[r + Bv(e)], !t)), gh[e] = t), t;
  }
}, tpe = Fl("MutationObserver"), D1 = Fl("IntersectionObserver"), wi = Fl("ResizeObserver"), $M = Fl("cancelAnimationFrame"), CM = Fl("requestAnimationFrame"), Yf = jl() && window.setTimeout, Wv = jl() && window.clearTimeout, rpe = /[^\x20\t\r\n\f]+/g, kM = (e, t, r) => {
  const n = e && e.classList;
  let o, a = 0, i = !1;
  if (n && t && na(t)) {
    const l = t.match(rpe) || [];
    for (i = l.length > 0; o = l[a++]; )
      i = !!r(n, o) && i;
  }
  return i;
}, r0 = (e, t) => {
  kM(e, t, (r, n) => r.remove(n));
}, mo = (e, t) => (kM(e, t, (r, n) => r.add(n)), r0.bind(0, e, t)), cm = (e, t, r, n) => {
  if (e && t) {
    let o = !0;
    return mt(r, (a) => {
      const i = n ? n(e[a]) : e[a], l = n ? n(t[a]) : t[a];
      i !== l && (o = !1);
    }), o;
  }
  return !1;
}, RM = (e, t) => cm(e, t, ["w", "h"]), DM = (e, t) => cm(e, t, ["x", "y"]), npe = (e, t) => cm(e, t, ["t", "r", "b", "l"]), N1 = (e, t, r) => cm(e, t, ["width", "height"], r && ((n) => Math.round(n))), en = () => {
}, fi = (e) => {
  let t;
  const r = e ? Yf : CM, n = e ? Wv : $M;
  return [(o) => {
    n(t), t = r(o, Dn(e) ? e() : e);
  }, () => n(t)];
}, n0 = (e, t) => {
  let r, n, o, a = en;
  const { v: i, g: l, p: c } = t || {}, u = function(y) {
    a(), Wv(r), r = n = void 0, a = en, e.apply(this, y);
  }, d = (m) => c && n ? c(n, m) : m, f = () => {
    a !== en && u(d(o) || o);
  }, p = function() {
    const y = ja(arguments), h = Dn(i) ? i() : i;
    if (qo(h) && h >= 0) {
      const g = Dn(l) ? l() : l, b = qo(g) && g >= 0, x = h > 0 ? Yf : CM, O = h > 0 ? Wv : $M, S = d(y) || y, E = u.bind(0, S);
      a();
      const C = x(E, h);
      a = () => O(C), b && !r && (r = Yf(f, g)), n = o = S;
    } else
      u(y);
  };
  return p.m = f, p;
}, ope = {
  opacity: 1,
  zindex: 1
}, mc = (e, t) => {
  const r = t ? parseFloat(e) : parseInt(e, 10);
  return r === r ? r : 0;
}, ape = (e, t) => !ope[e.toLowerCase()] && qo(t) ? `${t}px` : t, I1 = (e, t, r) => t != null ? t[r] || t.getPropertyValue(r) : e.style[r], ipe = (e, t, r) => {
  try {
    const { style: n } = e;
    Eo(n[t]) ? n.setProperty(t, r) : n[t] = ape(t, r);
  } catch {
  }
}, ml = (e) => hr(e, "direction") === "rtl", M1 = (e, t, r) => {
  const n = t ? `${t}-` : "", o = r ? `-${r}` : "", a = `${n}top${o}`, i = `${n}right${o}`, l = `${n}bottom${o}`, c = `${n}left${o}`, u = hr(e, [a, i, l, c]);
  return {
    t: mc(u[a], !0),
    r: mc(u[i], !0),
    b: mc(u[l], !0),
    l: mc(u[c], !0)
  };
}, { round: A1 } = Math, o0 = {
  w: 0,
  h: 0
}, Fa = (e) => e ? {
  w: e.offsetWidth,
  h: e.offsetHeight
} : o0, _u = (e) => e ? {
  w: e.clientWidth,
  h: e.clientHeight
} : o0, qf = (e) => e ? {
  w: e.scrollWidth,
  h: e.scrollHeight
} : o0, Gf = (e) => {
  const t = parseFloat(hr(e, "height")) || 0, r = parseFloat(hr(e, "width")) || 0;
  return {
    w: r - A1(r),
    h: t - A1(t)
  };
}, Vo = (e) => e.getBoundingClientRect();
let hc;
const spe = () => {
  if (Eo(hc)) {
    hc = !1;
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get() {
          hc = !0;
        }
      }));
    } catch {
    }
  }
  return hc;
}, NM = (e) => e.split(" "), lpe = (e, t, r, n) => {
  mt(NM(t), (o) => {
    e.removeEventListener(o, r, n);
  });
}, rr = (e, t, r, n) => {
  var o;
  const a = spe(), i = (o = a && n && n.S) != null ? o : a, l = n && n.$ || !1, c = n && n.C || !1, u = [], d = a ? {
    passive: i,
    capture: l
  } : l;
  return mt(NM(t), (f) => {
    const p = c ? (m) => {
      e.removeEventListener(f, p, l), r && r(m);
    } : r;
    Ct(u, lpe.bind(null, e, f, p, l)), e.addEventListener(f, p, d);
  }), no.bind(0, u);
}, IM = (e) => e.stopPropagation(), MM = (e) => e.preventDefault(), cpe = {
  x: 0,
  y: 0
}, wh = (e) => {
  const t = e ? Vo(e) : 0;
  return t ? {
    x: t.left + window.pageYOffset,
    y: t.top + window.pageXOffset
  } : cpe;
}, j1 = (e, t) => {
  mt(Nn(t) ? t : [t], e);
}, a0 = (e) => {
  const t = /* @__PURE__ */ new Map(), r = (a, i) => {
    if (a) {
      const l = t.get(a);
      j1((c) => {
        l && l[c ? "delete" : "clear"](c);
      }, i);
    } else
      t.forEach((l) => {
        l.clear();
      }), t.clear();
  }, n = (a, i) => {
    if (na(a)) {
      const u = t.get(a) || /* @__PURE__ */ new Set();
      return t.set(a, u), j1((d) => {
        Dn(d) && u.add(d);
      }, i), r.bind(0, a, i);
    }
    Xb(i) && i && r();
    const l = Hr(a), c = [];
    return mt(l, (u) => {
      const d = a[u];
      d && Ct(c, n(u, d));
    }), no.bind(0, c);
  }, o = (a, i) => {
    const l = t.get(a);
    mt(ja(l), (c) => {
      i && !Zb(i) ? c.apply(0, i) : c();
    });
  };
  return n(e || {}), [n, r, o];
}, F1 = (e) => JSON.stringify(e, (t, r) => {
  if (Dn(r))
    throw new Error();
  return r;
}), upe = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, AM = (e, t) => {
  const r = {}, n = Hr(t).concat(Hr(e));
  return mt(n, (o) => {
    const a = e[o], i = t[o];
    if (pl(a) && pl(i))
      jt(r[o] = {}, AM(a, i)), Jb(r[o]) && delete r[o];
    else if (lm(t, o) && i !== a) {
      let l = !0;
      if (Nn(a) || Nn(i))
        try {
          F1(a) === F1(i) && (l = !1);
        } catch {
        }
      l && (r[o] = i);
    }
  }), r;
}, jM = "os-environment", FM = `${jM}-flexbox-glue`, dpe = `${FM}-max`, LM = "os-scrollbar-hidden", xh = "data-overlayscrollbars-initialize", Tn = "data-overlayscrollbars", VM = `${Tn}-overflow-x`, zM = `${Tn}-overflow-y`, Ei = "overflowVisible", fpe = "scrollbarHidden", L1 = "scrollbarPressed", Kf = "updating", Ao = "data-overlayscrollbars-viewport", _h = "arrange", BM = "scrollbarHidden", $i = Ei, Uv = "data-overlayscrollbars-padding", ppe = $i, V1 = "data-overlayscrollbars-content", i0 = "os-size-observer", mpe = `${i0}-appear`, hpe = `${i0}-listener`, ype = "os-trinsic-observer", vpe = "os-no-css-vars", gpe = "os-theme-none", Ir = "os-scrollbar", bpe = `${Ir}-rtl`, wpe = `${Ir}-horizontal`, xpe = `${Ir}-vertical`, WM = `${Ir}-track`, s0 = `${Ir}-handle`, _pe = `${Ir}-visible`, Ope = `${Ir}-cornerless`, z1 = `${Ir}-transitionless`, B1 = `${Ir}-interaction`, W1 = `${Ir}-unusable`, U1 = `${Ir}-auto-hidden`, H1 = `${Ir}-wheel`, Ppe = `${WM}-interactive`, Spe = `${s0}-interactive`, UM = {}, La = () => UM, Tpe = (e) => {
  const t = [];
  return mt(Nn(e) ? e : [e], (r) => {
    const n = Hr(r);
    mt(n, (o) => {
      Ct(t, UM[o] = r[o]);
    });
  }), t;
}, Epe = "__osOptionsValidationPlugin", $pe = "__osSizeObserverPlugin", l0 = "__osScrollbarsHidingPlugin", Cpe = "__osClickScrollPlugin";
let Oh;
const Y1 = (e, t, r, n) => {
  nn(e, t);
  const o = _u(t), a = Fa(t), i = Gf(r);
  return n && Jn(t), {
    x: a.h - o.h + i.h,
    y: a.w - o.w + i.w
  };
}, kpe = (e) => {
  let t = !1;
  const r = mo(e, LM);
  try {
    t = hr(e, epe("scrollbar-width")) === "none" || window.getComputedStyle(e, "::-webkit-scrollbar").getPropertyValue("display") === "none";
  } catch {
  }
  return r(), t;
}, Rpe = (e, t) => {
  const r = "hidden";
  hr(e, {
    overflowX: r,
    overflowY: r,
    direction: "rtl"
  }), Cn(e, 0);
  const n = wh(e), o = wh(t);
  Cn(e, -999);
  const a = wh(t);
  return {
    i: n.x === o.x,
    n: o.x !== a.x
  };
}, Dpe = (e, t) => {
  const r = mo(e, FM), n = Vo(e), o = Vo(t), a = N1(o, n, !0), i = mo(e, dpe), l = Vo(e), c = Vo(t), u = N1(c, l, !0);
  return r(), i(), a && u;
}, Npe = () => {
  const { body: e } = document, r = EM(`<div class="${jM}"><div></div></div>`)[0], n = r.firstChild, [o, , a] = a0(), [i, l] = Sn({
    o: Y1(e, r, n),
    u: DM
  }, Y1.bind(0, e, r, n, !0)), [c] = l(), u = kpe(r), d = {
    x: c.x === 0,
    y: c.y === 0
  }, f = {
    elements: {
      host: null,
      padding: !u,
      viewport: (b) => u && b === b.ownerDocument.body && b,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, p = jt({}, upe), m = jt.bind(0, {}, p), y = jt.bind(0, {}, f), h = {
    k: c,
    A: d,
    I: u,
    L: hr(r, "zIndex") === "-1",
    B: Rpe(r, n),
    V: Dpe(r, n),
    Y: o.bind(0, "z"),
    j: o.bind(0, "r"),
    N: y,
    q: (b) => jt(f, b) && y(),
    F: m,
    G: (b) => jt(p, b) && m(),
    X: jt({}, f),
    U: jt({}, p)
  }, v = window.addEventListener, g = n0((b) => a(b ? "z" : "r"), {
    v: 33,
    g: 99
  });
  if (Pr(r, "style"), Jn(r), v("resize", g.bind(0, !1)), !u && (!d.x || !d.y)) {
    let b;
    v("resize", () => {
      const x = La()[l0];
      b = b || x && x.R(), b && b(h, i, g.bind(0, !0));
    });
  }
  return h;
}, Mr = () => (Oh || (Oh = Npe()), Oh), c0 = (e, t) => Dn(t) ? t.apply(0, e) : t, Ipe = (e, t, r, n) => {
  const o = Eo(n) ? r : n;
  return c0(e, o) || t.apply(0, e);
}, HM = (e, t, r, n) => {
  const o = Eo(n) ? r : n, a = c0(e, o);
  return !!a && (Uf(a) ? a : t.apply(0, e));
}, Mpe = (e, t, r) => {
  const { nativeScrollbarsOverlaid: n, body: o } = r || {}, { A: a, I: i } = Mr(), { nativeScrollbarsOverlaid: l, body: c } = t, u = n ?? l, d = Eo(o) ? c : o, f = (a.x || a.y) && u, p = e && (am(d) ? !i : d);
  return !!f || !!p;
}, u0 = /* @__PURE__ */ new WeakMap(), Ape = (e, t) => {
  u0.set(e, t);
}, jpe = (e) => {
  u0.delete(e);
}, YM = (e) => u0.get(e), q1 = (e, t) => e ? t.split(".").reduce((r, n) => r && lm(r, n) ? r[n] : void 0, e) : void 0, Hv = (e, t, r) => (n) => [q1(e, n), r || q1(t, n) !== void 0], qM = (e) => {
  let t = e;
  return [() => t, (r) => {
    t = jt({}, t, r);
  }];
}, yc = "tabindex", vc = Ca.bind(0, ""), Ph = (e) => {
  nn(wo(e), e0(e)), Jn(e);
}, Fpe = (e) => {
  const t = Mr(), { N: r, I: n } = t, o = La()[l0], a = o && o.T, { elements: i } = r(), { host: l, padding: c, viewport: u, content: d } = i, f = Uf(e), p = f ? {} : e, { elements: m } = p, { host: y, padding: h, viewport: v, content: g } = m || {}, b = f ? e : p.target, x = Hf(b, "textarea"), O = b.ownerDocument, w = O.documentElement, S = b === O.body, E = O.defaultView, C = Ipe.bind(0, [b]), N = HM.bind(0, [b]), $ = c0.bind(0, [b]), j = C.bind(0, vc, u), A = N.bind(0, vc, d), k = j(v), R = k === b, D = R && S, L = !R && A(g), B = !R && Uf(k) && k === L, H = B && !!$(d), U = H ? j() : k, I = H ? L : A(), G = D ? w : B ? U : k, q = x ? C(vc, l, y) : b, J = D ? G : q, ne = B ? I : L, te = O.activeElement, ee = !R && E.top === E && te === b, K = {
    W: b,
    Z: J,
    J: G,
    K: !R && N(vc, c, h),
    tt: ne,
    nt: !R && !n && a && a(t),
    ot: D ? w : G,
    st: D ? O : G,
    et: E,
    ct: O,
    rt: x,
    it: S,
    lt: f,
    ut: R,
    dt: B,
    ft: (ue, Oe) => qfe(G, R ? Tn : Ao, R ? Oe : ue),
    _t: (ue, Oe, Se) => $a(G, R ? Tn : Ao, R ? Oe : ue, Se)
  }, Q = Hr(K).reduce((ue, Oe) => {
    const Se = K[Oe];
    return Ct(ue, Se && !wo(Se) ? Se : !1);
  }, []), ae = (ue) => ue ? Qb(Q, ue) > -1 : null, { W: ie, Z: oe, K: se, J: re, tt: le, nt: M } = K, W = [() => {
    Pr(oe, Tn), Pr(oe, xh), Pr(ie, xh), S && (Pr(w, Tn), Pr(w, xh));
  }], Z = x && ae(oe);
  let he = x ? ie : e0([le, re, se, oe, ie].find((ue) => ae(ue) === !1));
  const me = D ? ie : le || re;
  return [K, () => {
    mr(oe, Tn, R ? "viewport" : "host"), mr(se, Uv, ""), mr(le, V1, ""), R || mr(re, Ao, "");
    const ue = S && !R ? mo(wo(b), LM) : en;
    if (Z && (R1(ie, oe), Ct(W, () => {
      R1(oe, ie), Jn(oe);
    })), nn(me, he), nn(oe, se), nn(se || oe, !R && re), nn(re, le), Ct(W, () => {
      ue(), Pr(se, Uv), Pr(le, V1), Pr(re, VM), Pr(re, zM), Pr(re, Ao), ae(le) && Ph(le), ae(re) && Ph(re), ae(se) && Ph(se);
    }), n && !R && ($a(re, Ao, BM, !0), Ct(W, Pr.bind(0, re, Ao))), M && (Xfe(re, M), Ct(W, Jn.bind(0, M))), ee) {
      const Oe = mr(re, yc);
      mr(re, yc, "-1"), re.focus();
      const Se = () => Oe ? mr(re, yc, Oe) : Pr(re, yc), De = rr(O, "pointerdown keydown", () => {
        Se(), De();
      });
      Ct(W, [Se, De]);
    } else
      te && te.focus && te.focus();
    he = 0;
  }, no.bind(0, W)];
}, Lpe = (e, t) => {
  const { tt: r } = e, [n] = t;
  return (o) => {
    const { V: a } = Mr(), { ht: i } = n(), { vt: l } = o, c = (r || !a) && l;
    return c && hr(r, {
      height: i ? "" : "100%"
    }), {
      gt: c,
      wt: c
    };
  };
}, Vpe = (e, t) => {
  const [r, n] = t, { Z: o, K: a, J: i, ut: l } = e, [c, u] = Sn({
    u: npe,
    o: M1()
  }, M1.bind(0, o, "padding", ""));
  return (d, f, p) => {
    let [m, y] = u(p);
    const { I: h, V: v } = Mr(), { bt: g } = r(), { gt: b, wt: x, yt: O } = d, [w, S] = f("paddingAbsolute");
    (b || y || !v && x) && ([m, y] = c(p));
    const C = !l && (S || O || y);
    if (C) {
      const N = !w || !a && !h, $ = m.r + m.l, j = m.t + m.b, A = {
        marginRight: N && !g ? -$ : 0,
        marginBottom: N ? -j : 0,
        marginLeft: N && g ? -$ : 0,
        top: N ? -m.t : 0,
        right: N ? g ? -m.r : "auto" : 0,
        left: N ? g ? "auto" : -m.l : 0,
        width: N ? `calc(100% + ${$}px)` : ""
      }, k = {
        paddingTop: N ? m.t : 0,
        paddingRight: N ? m.r : 0,
        paddingBottom: N ? m.b : 0,
        paddingLeft: N ? m.l : 0
      };
      hr(a || i, A), hr(i, k), n({
        K: m,
        St: !N,
        P: a ? k : jt({}, A, k)
      });
    }
    return {
      xt: C
    };
  };
}, { max: Yv } = Math, jo = Yv.bind(0, 0), GM = "visible", G1 = "hidden", zpe = 42, gc = {
  u: RM,
  o: {
    w: 0,
    h: 0
  }
}, Bpe = {
  u: DM,
  o: {
    x: G1,
    y: G1
  }
}, Wpe = (e, t) => {
  const r = window.devicePixelRatio % 1 !== 0 ? 1 : 0, n = {
    w: jo(e.w - t.w),
    h: jo(e.h - t.h)
  };
  return {
    w: n.w > r ? n.w : 0,
    h: n.h > r ? n.h : 0
  };
}, bc = (e) => e.indexOf(GM) === 0, Upe = (e, t) => {
  const [r, n] = t, { Z: o, K: a, J: i, nt: l, ut: c, _t: u, it: d, et: f } = e, { k: p, V: m, I: y, A: h } = Mr(), v = La()[l0], g = !c && !y && (h.x || h.y), b = d && c, [x, O] = Sn(gc, Gf.bind(0, i)), [w, S] = Sn(gc, qf.bind(0, i)), [E, C] = Sn(gc), [N, $] = Sn(gc), [j] = Sn(Bpe), A = (H, U) => {
    if (hr(i, {
      height: ""
    }), U) {
      const { St: I, K: V } = r(), { $t: G, D: q } = H, J = Gf(o), ne = _u(o), te = hr(i, "boxSizing") === "content-box", ee = I || te ? V.b + V.t : 0, K = !(h.x && te);
      hr(i, {
        height: ne.h + J.h + (G.x && K ? q.x : 0) - ee
      });
    }
  }, k = (H, U) => {
    const I = !y && !H ? zpe : 0, V = (ae, ie, oe) => {
      const se = hr(i, ae), le = (U ? U[ae] : se) === "scroll";
      return [se, le, le && !y ? ie ? I : oe : 0, ie && !!I];
    }, [G, q, J, ne] = V("overflowX", h.x, p.x), [te, ee, K, Q] = V("overflowY", h.y, p.y);
    return {
      Ct: {
        x: G,
        y: te
      },
      $t: {
        x: q,
        y: ee
      },
      D: {
        x: J,
        y: K
      },
      M: {
        x: ne,
        y: Q
      }
    };
  }, R = (H, U, I, V) => {
    const G = (ee, K) => {
      const Q = bc(ee), ae = K && Q && ee.replace(`${GM}-`, "") || "";
      return [K && !Q ? ee : "", bc(ae) ? "hidden" : ae];
    }, [q, J] = G(I.x, U.x), [ne, te] = G(I.y, U.y);
    return V.overflowX = J && ne ? J : q, V.overflowY = te && q ? te : ne, k(H, V);
  }, D = (H, U, I, V) => {
    const { D: G, M: q } = H, { x: J, y: ne } = q, { x: te, y: ee } = G, { P: K } = r(), Q = U ? "marginLeft" : "marginRight", ae = U ? "paddingLeft" : "paddingRight", ie = K[Q], oe = K.marginBottom, se = K[ae], re = K.paddingBottom;
    V.width = `calc(100% + ${ee + -1 * ie}px)`, V[Q] = -ee + ie, V.marginBottom = -te + oe, I && (V[ae] = se + (ne ? ee : 0), V.paddingBottom = re + (J ? te : 0));
  }, [L, B] = v ? v.H(g, m, i, l, r, k, D) : [() => g, () => [en]];
  return (H, U, I) => {
    const { gt: V, Ot: G, wt: q, xt: J, vt: ne, yt: te } = H, { ht: ee, bt: K } = r(), [Q, ae] = U("showNativeOverlaidScrollbars"), [ie, oe] = U("overflow"), se = Q && h.x && h.y, re = !c && !m && (V || q || G || ae || ne), le = bc(ie.x), M = bc(ie.y), W = le || M;
    let Z = O(I), he = S(I), me = C(I), de = $(I), ue;
    if (ae && y && u(BM, fpe, !se), re && (ue = k(se), A(ue, ee)), V || J || q || te || ae) {
      W && u($i, Ei, !1);
      const [je, Fe] = B(se, K, ue), [Ze, ft] = Z = x(I), [Je, Ht] = he = w(I), at = _u(i);
      let Jt = Je, Yt = at;
      je(), (Ht || ft || ae) && Fe && !se && L(Fe, Je, Ze, K) && (Yt = _u(i), Jt = qf(i));
      const qt = {
        w: jo(Yv(Je.w, Jt.w) + Ze.w),
        h: jo(Yv(Je.h, Jt.h) + Ze.h)
      }, Or = {
        w: jo((b ? f.innerWidth : Yt.w + jo(at.w - Je.w)) + Ze.w),
        h: jo((b ? f.innerHeight + Ze.h : Yt.h + jo(at.h - Je.h)) + Ze.h)
      };
      de = N(Or), me = E(Wpe(qt, Or), I);
    }
    const [Oe, Se] = de, [De, nt] = me, [rt, Be] = he, [Ie, it] = Z, we = {
      x: De.w > 0,
      y: De.h > 0
    }, ye = le && M && (we.x || we.y) || le && we.x && !we.y || M && we.y && !we.x;
    if (J || te || it || Be || Se || nt || oe || ae || re) {
      const je = {
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        width: "",
        overflowY: "",
        overflowX: ""
      }, Fe = R(se, we, ie, je), Ze = L(Fe, rt, Ie, K);
      c || D(Fe, K, Ze, je), re && A(Fe, ee), c ? (mr(o, VM, je.overflowX), mr(o, zM, je.overflowY)) : hr(i, je);
    }
    $a(o, Tn, Ei, ye), $a(a, Uv, ppe, ye), c || $a(i, Ao, $i, W);
    const [_e, Re] = j(k(se).Ct);
    return n({
      Ct: _e,
      zt: {
        x: Oe.w,
        y: Oe.h
      },
      Tt: {
        x: De.w,
        y: De.h
      },
      Et: we
    }), {
      It: Re,
      At: Se,
      Lt: nt
    };
  };
}, K1 = (e, t, r) => {
  const n = {}, o = t || {}, a = Hr(e).concat(Hr(o));
  return mt(a, (i) => {
    const l = e[i], c = o[i];
    n[i] = !!(r || l || c);
  }), n;
}, Hpe = (e, t) => {
  const { W: r, J: n, _t: o, ut: a } = e, { I: i, A: l, V: c } = Mr(), u = !i && (l.x || l.y), d = [Lpe(e, t), Vpe(e, t), Upe(e, t)];
  return (f, p, m) => {
    const y = K1(jt({
      gt: !1,
      xt: !1,
      yt: !1,
      vt: !1,
      At: !1,
      Lt: !1,
      It: !1,
      Ot: !1,
      wt: !1
    }, p), {}, m), h = u || !c, v = h && Cn(n), g = h && po(n);
    o("", Kf, !0);
    let b = y;
    return mt(d, (x) => {
      b = K1(b, x(b, f, !!m) || {}, m);
    }), Cn(n, v), po(n, g), o("", Kf), a || (Cn(r, 0), po(r, 0)), b;
  };
}, Ype = (e, t, r) => {
  let n, o = !1;
  const a = () => {
    o = !0;
  }, i = (l) => {
    if (r) {
      const c = r.reduce((u, d) => {
        if (d) {
          const [f, p] = d, m = p && f && (l ? l(f) : TM(f, e));
          m && m.length && p && na(p) && Ct(u, [m, p.trim()], !0);
        }
        return u;
      }, []);
      mt(c, (u) => mt(u[0], (d) => {
        const f = u[1], p = n.get(d) || [];
        if (e.contains(d)) {
          const y = rr(d, f, (h) => {
            o ? (y(), n.delete(d)) : t(h);
          });
          n.set(d, Ct(p, y));
        } else
          no(p), n.delete(d);
      }));
    }
  };
  return r && (n = /* @__PURE__ */ new WeakMap(), i()), [a, i];
}, X1 = (e, t, r, n) => {
  let o = !1;
  const { Ht: a, Pt: i, Dt: l, Mt: c, Rt: u, kt: d } = n || {}, f = n0(() => {
    o && r(!0);
  }, {
    v: 33,
    g: 99
  }), [p, m] = Ype(e, f, l), y = a || [], h = i || [], v = y.concat(h), g = (x, O) => {
    const w = u || en, S = d || en, E = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ new Set();
    let N = !1, $ = !1;
    if (mt(x, (j) => {
      const { attributeName: A, target: k, type: R, oldValue: D, addedNodes: L, removedNodes: B } = j, H = R === "attributes", U = R === "childList", I = e === k, V = H && na(A) ? mr(k, A) : 0, G = V !== 0 && D !== V, q = Qb(h, A) > -1 && G;
      if (t && (U || !I)) {
        const J = !H, ne = H && G, te = ne && c && Hf(k, c), K = (te ? !w(k, A, D, V) : J || ne) && !S(j, !!te, e, n);
        mt(L, (Q) => E.add(Q)), mt(B, (Q) => E.add(Q)), $ = $ || K;
      }
      !t && I && G && !w(k, A, D, V) && (C.add(A), N = N || q);
    }), E.size > 0 && m((j) => ja(E).reduce((A, k) => (Ct(A, TM(j, k)), Hf(k, j) ? Ct(A, k) : A), [])), t)
      return !O && $ && r(!1), [!1];
    if (C.size > 0 || N) {
      const j = [ja(C), N];
      return !O && r.apply(0, j), j;
    }
  }, b = new tpe((x) => g(x));
  return b.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: v,
    subtree: t,
    childList: t,
    characterData: t
  }), o = !0, [() => {
    o && (p(), b.disconnect(), o = !1);
  }, () => {
    if (o) {
      f.m();
      const x = b.takeRecords();
      return !Zb(x) && g(x, !0);
    }
  }];
}, wc = 3333333, xc = (e) => e && (e.height || e.width), KM = (e, t, r) => {
  const { Bt: n = !1, Vt: o = !1 } = r || {}, a = La()[$pe], { B: i } = Mr(), c = EM(`<div class="${i0}"><div class="${hpe}"></div></div>`)[0], u = c.firstChild, d = ml.bind(0, e), [f] = Sn({
    o: void 0,
    _: !0,
    u: (h, v) => !(!h || !xc(h) && xc(v))
  }), p = (h) => {
    const v = Nn(h) && h.length > 0 && pl(h[0]), g = !v && Xb(h[0]);
    let b = !1, x = !1, O = !0;
    if (v) {
      const [w, , S] = f(h.pop().contentRect), E = xc(w), C = xc(S);
      b = !S || !E, x = !C && E, O = !b;
    } else
      g ? [, O] = h : x = h === !0;
    if (n && O) {
      const w = g ? h[0] : ml(c);
      Cn(c, w ? i.n ? -wc : i.i ? 0 : wc : wc), po(c, wc);
    }
    b || t({
      gt: !g,
      Yt: g ? h : void 0,
      Vt: !!x
    });
  }, m = [];
  let y = o ? p : !1;
  return [() => {
    no(m), Jn(c);
  }, () => {
    if (wi) {
      const h = new wi(p);
      h.observe(u), Ct(m, () => {
        h.disconnect();
      });
    } else if (a) {
      const [h, v] = a.O(u, p, o);
      y = h, Ct(m, v);
    }
    if (n) {
      const [h] = Sn({
        o: void 0
      }, d);
      Ct(m, rr(c, "scroll", (v) => {
        const g = h(), [b, x, O] = g;
        x && (r0(u, "ltr rtl"), b ? mo(u, "rtl") : mo(u, "ltr"), p([!!b, x, O])), IM(v);
      }));
    }
    y && (mo(c, mpe), Ct(m, rr(c, "animationstart", y, {
      C: !!wi
    }))), (wi || a) && nn(e, c);
  }];
}, qpe = (e) => e.h === 0 || e.isIntersecting || e.intersectionRatio > 0, Gpe = (e, t) => {
  let r;
  const n = Ca(ype), o = [], [a] = Sn({
    o: !1
  }), i = (c, u) => {
    if (c) {
      const d = a(qpe(c)), [, f] = d;
      if (f)
        return !u && t(d), [d];
    }
  }, l = (c, u) => {
    if (c && c.length > 0)
      return i(c.pop(), u);
  };
  return [() => {
    no(o), Jn(n);
  }, () => {
    if (D1)
      r = new D1((c) => l(c), {
        root: e
      }), r.observe(n), Ct(o, () => {
        r.disconnect();
      });
    else {
      const c = () => {
        const f = Fa(n);
        i(f);
      }, [u, d] = KM(n, c);
      Ct(o, u), d(), c();
    }
    nn(e, n);
  }, () => {
    if (r)
      return l(r.takeRecords(), !0);
  }];
}, Q1 = `[${Tn}]`, Kpe = `[${Ao}]`, Sh = ["tabindex"], Z1 = ["wrap", "cols", "rows"], Th = ["id", "class", "style", "open"], Xpe = (e, t, r) => {
  let n, o, a;
  const { Z: i, J: l, tt: c, rt: u, ut: d, ft: f, _t: p } = e, { V: m } = Mr(), [y] = Sn({
    u: RM,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const R = f($i, Ei), D = f(_h, ""), L = D && Cn(l), B = D && po(l);
    p($i, Ei), p(_h, ""), p("", Kf, !0);
    const H = qf(c), U = qf(l), I = Gf(l);
    return p($i, Ei, R), p(_h, "", D), p("", Kf), Cn(l, L), po(l, B), {
      w: U.w + H.w + I.w,
      h: U.h + H.h + I.h
    };
  }), h = u ? Z1 : Th.concat(Z1), v = n0(r, {
    v: () => n,
    g: () => o,
    p(R, D) {
      const [L] = R, [B] = D;
      return [Hr(L).concat(Hr(B)).reduce((H, U) => (H[U] = L[U] || B[U], H), {})];
    }
  }), g = (R) => {
    mt(R || Sh, (D) => {
      if (Qb(Sh, D) > -1) {
        const L = mr(i, D);
        na(L) ? mr(l, D, L) : Pr(l, D);
      }
    });
  }, b = (R, D) => {
    const [L, B] = R, H = {
      vt: B
    };
    return t({
      ht: L
    }), !D && r(H), H;
  }, x = ({ gt: R, Yt: D, Vt: L }) => {
    const B = !R || L ? r : v;
    let H = !1;
    if (D) {
      const [U, I] = D;
      H = I, t({
        bt: U
      });
    }
    B({
      gt: R,
      yt: H
    });
  }, O = (R, D) => {
    const [, L] = y(), B = {
      wt: L
    };
    return L && !D && (R ? r : v)(B), B;
  }, w = (R, D, L) => {
    const B = {
      Ot: D
    };
    return D ? !L && v(B) : d || g(R), B;
  }, [S, E, C] = c || !m ? Gpe(i, b) : [en, en, en], [N, $] = d ? [en, en] : KM(i, x, {
    Vt: !0,
    Bt: !0
  }), [j, A] = X1(i, !1, w, {
    Pt: Th,
    Ht: Th.concat(Sh)
  }), k = d && wi && new wi(x.bind(0, {
    gt: !0
  }));
  return k && k.observe(i), g(), [() => {
    S(), N(), a && a[0](), k && k.disconnect(), j();
  }, () => {
    $(), E();
  }, () => {
    const R = {}, D = A(), L = C(), B = a && a[1]();
    return D && jt(R, w.apply(0, Ct(D, !0))), L && jt(R, b.apply(0, Ct(L, !0))), B && jt(R, O.apply(0, Ct(B, !0))), R;
  }, (R) => {
    const [D] = R("update.ignoreMutation"), [L, B] = R("update.attributes"), [H, U] = R("update.elementEvents"), [I, V] = R("update.debounce"), G = U || B, q = (J) => Dn(D) && D(J);
    if (G && (a && (a[1](), a[0]()), a = X1(c || l, !0, O, {
      Ht: h.concat(L || []),
      Dt: H,
      Mt: Q1,
      kt: (J, ne) => {
        const { target: te, attributeName: ee } = J;
        return (!ne && ee && !d ? Kfe(te, Q1, Kpe) : !1) || !!bi(te, `.${Ir}`) || !!q(J);
      }
    })), V)
      if (v.m(), Nn(I)) {
        const J = I[0], ne = I[1];
        n = qo(J) && J, o = qo(ne) && ne;
      } else
        qo(I) ? (n = I, o = !1) : (n = !1, o = !1);
  }];
}, J1 = {
  x: 0,
  y: 0
}, Qpe = (e) => ({
  K: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  St: !1,
  P: {
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0
  },
  zt: J1,
  Tt: J1,
  Ct: {
    x: "hidden",
    y: "hidden"
  },
  Et: {
    x: !1,
    y: !1
  },
  ht: !1,
  bt: ml(e.Z)
}), Zpe = (e, t) => {
  const r = Hv(t, {}), [n, o, a] = a0(), [i, l, c] = Fpe(e), u = qM(Qpe(i)), [d, f] = u, p = Hpe(i, u), m = (x, O, w) => {
    const E = Hr(x).some((C) => x[C]) || !Jb(O) || w;
    return E && a("u", [x, O, w]), E;
  }, [y, h, v, g] = Xpe(i, f, (x) => m(p(r, x), {}, !1)), b = d.bind(0);
  return b.jt = (x) => n("u", x), b.Nt = () => {
    const { W: x, J: O } = i, w = Cn(x), S = po(x);
    h(), l(), Cn(O, w), po(O, S);
  }, b.qt = i, [(x, O) => {
    const w = Hv(t, x, O);
    return g(w), m(p(w, v(), O), x, !!O);
  }, b, () => {
    o(), y(), c();
  }];
}, { round: eT } = Math, Jpe = (e) => {
  const { width: t, height: r } = Vo(e), { w: n, h: o } = Fa(e);
  return {
    x: eT(t) / n || 1,
    y: eT(r) / o || 1
  };
}, eme = (e, t, r) => {
  const n = t.scrollbars, { button: o, isPrimary: a, pointerType: i } = e, { pointers: l } = n;
  return o === 0 && a && n[r ? "dragScroll" : "clickScroll"] && (l || []).includes(i);
}, tme = (e, t) => rr(e, "mousedown", rr.bind(0, t, "click", IM, {
  C: !0,
  $: !0
}), {
  $: !0
}), tT = "pointerup pointerleave pointercancel lostpointercapture", rme = (e, t, r, n, o, a, i) => {
  const { B: l } = Mr(), { Ft: c, Gt: u, Xt: d } = n, f = `scroll${i ? "Left" : "Top"}`, p = `client${i ? "X" : "Y"}`, m = i ? "width" : "height", y = i ? "left" : "top", h = i ? "w" : "h", v = i ? "x" : "y", g = (b, x) => (O) => {
    const { Tt: w } = a(), S = Fa(u)[h] - Fa(c)[h], C = x * O / S * w[v], $ = ml(d) && i ? l.n || l.i ? 1 : -1 : 1;
    o[f] = b + C * $;
  };
  return rr(u, "pointerdown", (b) => {
    const x = bi(b.target, `.${s0}`) === c, O = x ? c : u;
    if ($a(t, Tn, L1, !0), eme(b, e, x)) {
      const w = !x && b.shiftKey, S = () => Vo(c), E = () => Vo(u), C = (U, I) => (U || S())[y] - (I || E())[y], N = g(o[f] || 0, 1 / Jpe(o)[v]), $ = b[p], j = S(), A = E(), k = j[m], R = C(j, A) + k / 2, D = $ - A[y], L = x ? 0 : D - R, B = (U) => {
        no(H), O.releasePointerCapture(U.pointerId);
      }, H = [$a.bind(0, t, Tn, L1), rr(r, tT, B), rr(r, "selectstart", (U) => MM(U), {
        S: !1
      }), rr(u, tT, B), rr(u, "pointermove", (U) => {
        const I = U[p] - $;
        (x || w) && N(L + I);
      })];
      if (w)
        N(L);
      else if (!x) {
        const U = La()[Cpe];
        U && Ct(H, U.O(N, C, L, k, D));
      }
      O.setPointerCapture(b.pointerId);
    }
  });
}, nme = (e, t) => (r, n, o, a, i, l) => {
  const { Xt: c } = r, [u, d] = fi(333), f = !!i.scrollBy;
  let p = !0;
  return no.bind(0, [rr(c, "pointerenter", () => {
    n(B1, !0);
  }), rr(c, "pointerleave pointercancel", () => {
    n(B1);
  }), rr(c, "wheel", (m) => {
    const { deltaX: y, deltaY: h, deltaMode: v } = m;
    f && p && v === 0 && wo(c) === a && i.scrollBy({
      left: y,
      top: h,
      behavior: "smooth"
    }), p = !1, n(H1, !0), u(() => {
      p = !0, n(H1);
    }), MM(m);
  }, {
    S: !1,
    $: !0
  }), tme(c, o), rme(e, a, o, r, i, t, l), d]);
}, { min: qv, max: rT, abs: ome, round: ame } = Math, XM = (e, t, r, n) => {
  if (n) {
    const l = r ? "x" : "y", { Tt: c, zt: u } = n, d = u[l], f = c[l];
    return rT(0, qv(1, d / (d + f)));
  }
  const o = r ? "w" : "h", a = Fa(e)[o], i = Fa(t)[o];
  return rT(0, qv(1, a / i));
}, ime = (e, t, r, n, o, a) => {
  const { B: i } = Mr(), l = a ? "x" : "y", c = a ? "Left" : "Top", { Tt: u } = n, d = ame(u[l]), f = ome(r[`scroll${c}`]), p = a && o, m = i.i ? f : d - f, h = qv(1, (p ? m : f) / d), v = XM(e, t, a);
  return 1 / v * (1 - v) * h;
}, sme = (e, t, r) => {
  const { N: n, L: o } = Mr(), { scrollbars: a } = n(), { slot: i } = a, { ct: l, W: c, Z: u, J: d, lt: f, ot: p, it: m, ut: y } = t, { scrollbars: h } = f ? {} : e, { slot: v } = h || {}, g = HM([c, u, d], () => y && m ? c : u, i, v), b = (L, B, H) => {
    const U = H ? mo : r0;
    mt(L, (I) => {
      U(I.Xt, B);
    });
  }, x = (L, B) => {
    mt(L, (H) => {
      const [U, I] = B(H);
      hr(U, I);
    });
  }, O = (L, B, H) => {
    x(L, (U) => {
      const { Ft: I, Gt: V } = U;
      return [I, {
        [H ? "width" : "height"]: `${(100 * XM(I, V, H, B)).toFixed(3)}%`
      }];
    });
  }, w = (L, B, H) => {
    const U = H ? "X" : "Y";
    x(L, (I) => {
      const { Ft: V, Gt: G, Xt: q } = I, J = ime(V, G, p, B, ml(q), H);
      return [V, {
        transform: J === J ? `translate${U}(${(100 * J).toFixed(3)}%)` : ""
      }];
    });
  }, S = [], E = [], C = [], N = (L, B, H) => {
    const U = Xb(H), I = U ? H : !0, V = U ? !H : !0;
    I && b(E, L, B), V && b(C, L, B);
  }, $ = (L) => {
    O(E, L, !0), O(C, L);
  }, j = (L) => {
    w(E, L, !0), w(C, L);
  }, A = (L) => {
    const B = L ? wpe : xpe, H = L ? E : C, U = Zb(H) ? z1 : "", I = Ca(`${Ir} ${B} ${U}`), V = Ca(WM), G = Ca(s0), q = {
      Xt: I,
      Gt: V,
      Ft: G
    };
    return o || mo(I, vpe), nn(I, V), nn(V, G), Ct(H, q), Ct(S, [Jn.bind(0, I), r(q, N, l, u, p, L)]), q;
  }, k = A.bind(0, !0), R = A.bind(0, !1), D = () => {
    nn(g, E[0].Xt), nn(g, C[0].Xt), Yf(() => {
      N(z1);
    }, 300);
  };
  return k(), R(), [{
    Ut: $,
    Wt: j,
    Zt: N,
    Jt: {
      Kt: E,
      Qt: k,
      tn: x.bind(0, E)
    },
    nn: {
      Kt: C,
      Qt: R,
      tn: x.bind(0, C)
    }
  }, D, no.bind(0, S)];
}, lme = (e, t, r, n) => {
  let o, a, i, l, c, u = 0;
  const d = qM({}), [f] = d, [p, m] = fi(), [y, h] = fi(), [v, g] = fi(100), [b, x] = fi(100), [O, w] = fi(() => u), [S, E, C] = sme(e, r.qt, nme(t, r)), { Z: N, J: $, ot: j, st: A, ut: k, it: R } = r.qt, { Jt: D, nn: L, Zt: B, Ut: H, Wt: U } = S, { tn: I } = D, { tn: V } = L, G = (ee) => {
    const { Xt: K } = ee, Q = k && !R && wo(K) === $ && K;
    return [Q, {
      transform: Q ? `translate(${Cn(j)}px, ${po(j)}px)` : ""
    }];
  }, q = (ee, K) => {
    if (w(), ee)
      B(U1);
    else {
      const Q = () => B(U1, !0);
      u > 0 && !K ? O(Q) : Q();
    }
  }, J = () => {
    l = a, l && q(!0);
  }, ne = [g, w, x, h, m, C, rr(N, "pointerover", J, {
    C: !0
  }), rr(N, "pointerenter", J), rr(N, "pointerleave", () => {
    l = !1, a && q(!1);
  }), rr(N, "pointermove", () => {
    o && p(() => {
      g(), q(!0), b(() => {
        o && q(!1);
      });
    });
  }), rr(A, "scroll", (ee) => {
    y(() => {
      U(r()), i && q(!0), v(() => {
        i && !l && q(!1);
      });
    }), n(ee), k && I(G), k && V(G);
  })], te = f.bind(0);
  return te.qt = S, te.Nt = E, [(ee, K, Q) => {
    const { At: ae, Lt: ie, It: oe, yt: se } = Q, { A: re } = Mr(), le = Hv(t, ee, K), M = r(), { Tt: W, Ct: Z, bt: he } = M, [me, de] = le("showNativeOverlaidScrollbars"), [ue, Oe] = le("scrollbars.theme"), [Se, De] = le("scrollbars.visibility"), [nt, rt] = le("scrollbars.autoHide"), [Be] = le("scrollbars.autoHideDelay"), [Ie, it] = le("scrollbars.dragScroll"), [we, ye] = le("scrollbars.clickScroll"), _e = ae || ie || se, Re = oe || De, je = me && re.x && re.y, Fe = (Ze, ft) => {
      const Je = Se === "visible" || Se === "auto" && Ze === "scroll";
      return B(_pe, Je, ft), Je;
    };
    if (u = Be, de && B(gpe, je), Oe && (B(c), B(ue, !0), c = ue), rt && (o = nt === "move", a = nt === "leave", i = nt !== "never", q(!i, !0)), it && B(Spe, Ie), ye && B(Ppe, we), Re) {
      const Ze = Fe(Z.x, !0), ft = Fe(Z.y, !1);
      B(Ope, !(Ze && ft));
    }
    _e && (H(M), U(M), B(W1, !W.x, !0), B(W1, !W.y, !1), B(bpe, he && !R));
  }, te, no.bind(0, ne)];
}, QM = (e, t, r) => {
  Dn(e) && e(t || void 0, r || void 0);
}, zo = (e, t, r) => {
  const { F: n, N: o, Y: a, j: i } = Mr(), l = La(), c = Uf(e), u = c ? e : e.target, d = YM(u);
  if (t && !d) {
    let f = !1;
    const p = (k) => {
      const R = La()[Epe], D = R && R.O;
      return D ? D(k, !0) : k;
    }, m = jt({}, n(), p(t)), [y, h, v] = a0(r), [g, b, x] = Zpe(e, m), [O, w, S] = lme(e, m, b, (k) => v("scroll", [A, k])), E = (k, R) => g(k, !!R), C = E.bind(0, {}, !0), N = a(C), $ = i(C), j = (k) => {
      jpe(u), N(), $(), S(), x(), f = !0, v("destroyed", [A, !!k]), h();
    }, A = {
      options(k, R) {
        if (k) {
          const D = R ? n() : {}, L = AM(m, jt(D, p(k)));
          Jb(L) || (jt(m, L), E(L));
        }
        return jt({}, m);
      },
      on: y,
      off: (k, R) => {
        k && R && h(k, R);
      },
      state() {
        const { zt: k, Tt: R, Ct: D, Et: L, K: B, St: H, bt: U } = b();
        return jt({}, {
          overflowEdge: k,
          overflowAmount: R,
          overflowStyle: D,
          hasOverflow: L,
          padding: B,
          paddingAbsolute: H,
          directionRTL: U,
          destroyed: f
        });
      },
      elements() {
        const { W: k, Z: R, K: D, J: L, tt: B, ot: H, st: U } = b.qt, { Jt: I, nn: V } = w.qt, G = (J) => {
          const { Ft: ne, Gt: te, Xt: ee } = J;
          return {
            scrollbar: ee,
            track: te,
            handle: ne
          };
        }, q = (J) => {
          const { Kt: ne, Qt: te } = J, ee = G(ne[0]);
          return jt({}, ee, {
            clone: () => {
              const K = G(te());
              return O({}, !0, {}), K;
            }
          });
        };
        return jt({}, {
          target: k,
          host: R,
          padding: D || L,
          viewport: L,
          content: B || L,
          scrollOffsetElement: H,
          scrollEventElement: U,
          scrollbarHorizontal: q(I),
          scrollbarVertical: q(V)
        });
      },
      update: (k) => E({}, k),
      destroy: j.bind(0)
    };
    return b.jt((k, R, D) => {
      O(R, D, k);
    }), Ape(u, A), mt(Hr(l), (k) => QM(l[k], 0, A)), Mpe(b.qt.it, o().cancel, !c && e.cancel) ? (j(!0), A) : (b.Nt(), w.Nt(), v("initialized", [A]), b.jt((k, R, D) => {
      const { gt: L, yt: B, vt: H, At: U, Lt: I, It: V, wt: G, Ot: q } = k;
      v("updated", [A, {
        updateHints: {
          sizeChanged: L,
          directionChanged: B,
          heightIntrinsicChanged: H,
          overflowEdgeChanged: U,
          overflowAmountChanged: I,
          overflowStyleChanged: V,
          contentMutation: G,
          hostMutation: q
        },
        changedOptions: R,
        force: D
      }]);
    }), A.update(!0), A);
  }
  return d;
};
zo.plugin = (e) => {
  mt(Tpe(e), (t) => QM(t, zo));
};
zo.valid = (e) => {
  const t = e && e.elements, r = Dn(t) && t();
  return Vv(r) && !!YM(r.target);
};
zo.env = () => {
  const { k: e, A: t, I: r, B: n, V: o, L: a, X: i, U: l, N: c, q: u, F: d, G: f } = Mr();
  return jt({}, {
    scrollbarsSize: e,
    scrollbarsOverlaid: t,
    scrollbarsHiding: r,
    rtlScrollBehavior: n,
    flexboxGlue: o,
    cssCustomProperties: a,
    staticDefaultInitialization: i,
    staticDefaultOptions: l,
    getDefaultInitialization: c,
    setDefaultInitialization: u,
    getDefaultOptions: d,
    setDefaultOptions: f
  });
};
const cme = () => {
  if (typeof window > "u") {
    const u = () => {
    };
    return [u, u];
  }
  let e, t;
  const r = window, n = typeof r.requestIdleCallback == "function", o = r.requestAnimationFrame, a = r.cancelAnimationFrame, i = n ? r.requestIdleCallback : o, l = n ? r.cancelIdleCallback : a, c = () => {
    l(e), a(t);
  };
  return [
    (u, d) => {
      c(), e = i(
        n ? () => {
          c(), t = o(u);
        } : u,
        typeof d == "object" ? d : { timeout: 2233 }
      );
    },
    c
  ];
}, ume = (e) => {
  const { options: t, events: r, defer: n } = e || {}, [o, a] = fn(cme, []), i = qe(null), l = qe(n), c = qe(t), u = qe(r);
  return Ue(() => {
    l.current = n;
  }, [n]), Ue(() => {
    const { current: d } = i;
    c.current = t, zo.valid(d) && d.options(t || {}, !0);
  }, [t]), Ue(() => {
    const { current: d } = i;
    u.current = r, zo.valid(d) && d.on(r || {}, !0);
  }, [r]), Ue(
    () => () => {
      var d;
      a(), (d = i.current) == null || d.destroy();
    },
    []
  ), fn(
    () => [
      (d) => {
        const f = i.current;
        if (zo.valid(f))
          return;
        const p = l.current, m = c.current || {}, y = u.current || {}, h = () => i.current = zo(d, m, y);
        p ? o(h, p) : h();
      },
      () => i.current
    ],
    []
  );
}, dme = (e, t) => {
  const { element: r = "div", options: n, events: o, defer: a, children: i, ...l } = e, c = r, u = qe(null), d = qe(null), [f, p] = ume({ options: n, events: o, defer: a });
  return Ue(() => {
    const { current: m } = u, { current: y } = d;
    return m && y && f({
      target: m,
      elements: {
        viewport: y,
        content: y
      }
    }), () => {
      var h;
      return (h = p()) == null ? void 0 : h.destroy();
    };
  }, [f, r]), z2(
    t,
    () => ({
      osInstance: p,
      getElement: () => u.current
    }),
    []
  ), /* @__PURE__ */ F.createElement(c, {
    "data-overlayscrollbars-initialize": "",
    ref: u,
    ...l
  }, /* @__PURE__ */ F.createElement("div", {
    ref: d
  }, i));
}, fme = Ne(dme), ZM = Ne(
  ({ children: e, options: t, ...r }, n) => /* @__PURE__ */ _.jsx(fme, { ref: n, options: t, ...r, children: e })
);
ZM.displayName = "ScrollArea";
const pme = Qe(
  (e, { selecDataGrid: t, selectedColumn: r, rtl: n }) => ({
    fieldTitleRoot: {
      position: "sticky",
      top: 0,
      padding: "0 !important",
      zIndex: 20,
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white
    },
    fieldTitleWrapper: {
      boxSizing: "border-box",
      display: "flex",
      flexDirection: n ? "row-reverse" : "row",
      paddingLeft: e.spacing.sm,
      paddingRight: e.spacing.sm,
      paddingTop: e.spacing.xs,
      paddingBottom: e.spacing.xs,
      borderBottom: `1px solid ${e.colors.gray[4]}`,
      ...e.fn.fontStyles(),
      fontSize: e.fontSizes.sm,
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      cursor: t ? "pointer" : "default",
      color: r ? e.colors[e.primaryColor][e.fn.primaryShade()] : null,
      "&:hover": {
        color: t ? r ? e.colors.dark[4] : e.colors.gray[6] : null
      }
    },
    fieldTitleName: {
      fontWeight: 700
    },
    fieldTitleIcon: {
      display: "flex",
      alignItems: "center",
      visibility: r ? "visible" : "hidden"
    }
  })
);
function nT({
  column: e,
  label: t,
  selecDataGrid: r,
  related: n,
  rtl: o,
  classNames: a,
  styles: i
}) {
  const { queryParams: l, setQueryParams: c } = ir(), u = l.order_column === e, { classes: d } = pme({ selectedColumn: u, selecDataGrid: r, rtl: o }, { classNames: a, styles: i, name: "DataGrid" });
  return /* @__PURE__ */ _.jsx(
    "th",
    {
      className: d.fieldTitleRoot,
      onClick: r ? () => c({
        order_column: e,
        order_direction: l.order_direction === "asc" ? "desc" : "asc"
      }) : null,
      children: /* @__PURE__ */ _.jsxs(Ke, { className: d.fieldTitleWrapper, children: [
        /* @__PURE__ */ _.jsx(Ke, { className: d.fieldTitleName, children: t || e }),
        n ? /* @__PURE__ */ _.jsx(Ba, { label: "Related Field", children: /* @__PURE__ */ _.jsx(
          Vg,
          {
            label: "rel",
            styles: (f) => ({ indicator: { top: "-1px !important", right: "-2px !important", padding: "4px" } }),
            children: /* @__PURE__ */ _.jsx(Ke, { className: d.fieldTitleIcon, children: u ? l.order_direction === "asc" ? /* @__PURE__ */ _.jsx(uy, { size: 14, strokeWidth: 1.5 }) : /* @__PURE__ */ _.jsx(JO, { size: 14, strokeWidth: 1.5 }) : null })
          }
        ) }) : /* @__PURE__ */ _.jsx(Ke, { className: d.fieldTitleIcon, children: u ? l.order_direction === "asc" ? /* @__PURE__ */ _.jsx(uy, { size: 14, strokeWidth: 1.5 }) : /* @__PURE__ */ _.jsx(JO, { size: 14, strokeWidth: 1.5 }) : null })
      ] })
    }
  );
}
const JM = Jf(({ settings: e, hideActions: t }) => {
  const { data: r, info: n } = ir();
  return /* @__PURE__ */ _.jsx("thead", { style: { padding: 0 }, children: /* @__PURE__ */ _.jsxs("tr", { children: [
    t ? null : /* @__PURE__ */ _.jsx(nT, { column: "Actions", rtl: e.rtl }),
    r.list_columns.map((o, a) => {
      var i;
      return /* @__PURE__ */ _.jsx(
        nT,
        {
          column: o,
          label: r.label_columns[o],
          selecDataGrid: r.order_columns.includes(o),
          related: ((i = n.filters[o]) == null ? void 0 : i.schema.type) === "Nested",
          rtl: e.rtl
        },
        o
      );
    })
  ] }) });
});
JM.displayName = "Header";
const e2 = (e, t) => {
  const r = t.split(".").reduce((n, o) => n[o], e);
  return r ? typeof r == "boolean" ? r.toString() : Array.isArray(r) ? r.map((n) => n._name).join(", ") : typeof r == "object" ? r._name : r : null;
};
function t2(e, t) {
  return e === !0 || Array.isArray(e) ? t : Object.fromEntries(
    Object.keys(e).map((r) => [r, t2(e[r], t[r])])
  );
}
const mme = Qe((e, { selected: t, pointer: r, hover: n }) => {
  const o = e.fn.variant({
    color: e.colors[e.primaryColor][e.fn.primaryShade()],
    variant: "light"
  });
  return {
    row: {
      backgroundColor: t ? `${o.hover} !important` : void 0,
      ":hover": {
        cursor: r ? "pointer" : "default",
        backgroundColor: n ? t ? `${o.hover} !important` : `${o.background} !important` : void 0
      }
    }
  };
});
function hme({ entry: e, selected: t, hover: r, onSelect: n, setSelectedItem: o, children: a }) {
  const { classes: i } = mme({ selected: t, hover: n || r, pointer: !!n }, { name: "DataGrid" });
  return /* @__PURE__ */ _.jsx(
    "tr",
    {
      className: i.row,
      onClick: (l) => {
        n && (o(e), n(l, e));
      },
      children: a
    }
  );
}
const yme = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "search",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
var vme = yme;
const gme = /* @__PURE__ */ qi(vme), bme = /\s?<!doctype html>|(<html\b[^>]*>|<body\b[^>]*>|<x-[^>]+>)+/i, wme = new RegExp(gme.map((e) => `<${e}\\b[^>]*>`).join("|"), "i");
function xme(e) {
  return e = e.trim().slice(0, 1e3), bme.test(e) || wme.test(e);
}
var d0 = {}, f0 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(n) {
    n.Root = "root", n.Text = "text", n.Directive = "directive", n.Comment = "comment", n.Script = "script", n.Style = "style", n.Tag = "tag", n.CDATA = "cdata", n.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function r(n) {
    return n.type === t.Tag || n.type === t.Script || n.type === t.Style;
  }
  e.isTag = r, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(f0);
var lt = {}, oa = Bn && Bn.__extends || function() {
  var e = function(t, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, o) {
      n.__proto__ = o;
    } || function(n, o) {
      for (var a in o)
        Object.prototype.hasOwnProperty.call(o, a) && (n[a] = o[a]);
    }, e(t, r);
  };
  return function(t, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    e(t, r);
    function n() {
      this.constructor = t;
    }
    t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Qs = Bn && Bn.__assign || function() {
  return Qs = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Qs.apply(this, arguments);
};
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.cloneNode = lt.hasChildren = lt.isDocument = lt.isDirective = lt.isComment = lt.isText = lt.isCDATA = lt.isTag = lt.Element = lt.Document = lt.CDATA = lt.NodeWithChildren = lt.ProcessingInstruction = lt.Comment = lt.Text = lt.DataNode = lt.Node = void 0;
var Rr = f0, p0 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), m0(this, t);
    }, e;
  }()
);
lt.Node = p0;
var um = (
  /** @class */
  function(e) {
    oa(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n.data = r, n;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(r) {
        this.data = r;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(p0)
);
lt.DataNode = um;
var r2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = Rr.ElementType.Text, r;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(um)
);
lt.Text = r2;
var n2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = Rr.ElementType.Comment, r;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(um)
);
lt.Comment = n2;
var o2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t(r, n) {
      var o = e.call(this, n) || this;
      return o.name = r, o.type = Rr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(um)
);
lt.ProcessingInstruction = o2;
var dm = (
  /** @class */
  function(e) {
    oa(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n.children = r, n;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var r;
        return (r = this.children[0]) !== null && r !== void 0 ? r : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(r) {
        this.children = r;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(p0)
);
lt.NodeWithChildren = dm;
var a2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = Rr.ElementType.CDATA, r;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(dm)
);
lt.CDATA = a2;
var i2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = Rr.ElementType.Root, r;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(dm)
);
lt.Document = i2;
var s2 = (
  /** @class */
  function(e) {
    oa(t, e);
    function t(r, n, o, a) {
      o === void 0 && (o = []), a === void 0 && (a = r === "script" ? Rr.ElementType.Script : r === "style" ? Rr.ElementType.Style : Rr.ElementType.Tag);
      var i = e.call(this, o) || this;
      return i.name = r, i.attribs = n, i.type = a, i;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(r) {
        this.name = r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var r = this;
        return Object.keys(this.attribs).map(function(n) {
          var o, a;
          return {
            name: n,
            value: r.attribs[n],
            namespace: (o = r["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[n],
            prefix: (a = r["x-attribsPrefix"]) === null || a === void 0 ? void 0 : a[n]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(dm)
);
lt.Element = s2;
function l2(e) {
  return (0, Rr.isTag)(e);
}
lt.isTag = l2;
function c2(e) {
  return e.type === Rr.ElementType.CDATA;
}
lt.isCDATA = c2;
function u2(e) {
  return e.type === Rr.ElementType.Text;
}
lt.isText = u2;
function d2(e) {
  return e.type === Rr.ElementType.Comment;
}
lt.isComment = d2;
function f2(e) {
  return e.type === Rr.ElementType.Directive;
}
lt.isDirective = f2;
function p2(e) {
  return e.type === Rr.ElementType.Root;
}
lt.isDocument = p2;
function _me(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
lt.hasChildren = _me;
function m0(e, t) {
  t === void 0 && (t = !1);
  var r;
  if (u2(e))
    r = new r2(e.data);
  else if (d2(e))
    r = new n2(e.data);
  else if (l2(e)) {
    var n = t ? Eh(e.children) : [], o = new s2(e.name, Qs({}, e.attribs), n);
    n.forEach(function(c) {
      return c.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Qs({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Qs({}, e["x-attribsPrefix"])), r = o;
  } else if (c2(e)) {
    var n = t ? Eh(e.children) : [], a = new a2(n);
    n.forEach(function(u) {
      return u.parent = a;
    }), r = a;
  } else if (p2(e)) {
    var n = t ? Eh(e.children) : [], i = new i2(n);
    n.forEach(function(u) {
      return u.parent = i;
    }), e["x-mode"] && (i["x-mode"] = e["x-mode"]), r = i;
  } else if (f2(e)) {
    var l = new o2(e.name, e.data);
    e["x-name"] != null && (l["x-name"] = e["x-name"], l["x-publicId"] = e["x-publicId"], l["x-systemId"] = e["x-systemId"]), r = l;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return r.startIndex = e.startIndex, r.endIndex = e.endIndex, e.sourceCodeLocation != null && (r.sourceCodeLocation = e.sourceCodeLocation), r;
}
lt.cloneNode = m0;
function Eh(e) {
  for (var t = e.map(function(n) {
    return m0(n, !0);
  }), r = 1; r < t.length; r++)
    t[r].prev = t[r - 1], t[r - 1].next = t[r];
  return t;
}
(function(e) {
  var t = Bn && Bn.__createBinding || (Object.create ? function(l, c, u, d) {
    d === void 0 && (d = u);
    var f = Object.getOwnPropertyDescriptor(c, u);
    (!f || ("get" in f ? !c.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return c[u];
    } }), Object.defineProperty(l, d, f);
  } : function(l, c, u, d) {
    d === void 0 && (d = u), l[d] = c[u];
  }), r = Bn && Bn.__exportStar || function(l, c) {
    for (var u in l)
      u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && t(c, l, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var n = f0, o = lt;
  r(lt, e);
  var a = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, i = (
    /** @class */
    function() {
      function l(c, u, d) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (d = u, u = a), typeof c == "object" && (u = c, c = void 0), this.callback = c ?? null, this.options = u ?? a, this.elementCB = d ?? null;
      }
      return l.prototype.onparserinit = function(c) {
        this.parser = c;
      }, l.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, l.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, l.prototype.onerror = function(c) {
        this.handleCallback(c);
      }, l.prototype.onclosetag = function() {
        this.lastNode = null;
        var c = this.tagStack.pop();
        this.options.withEndIndices && (c.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(c);
      }, l.prototype.onopentag = function(c, u) {
        var d = this.options.xmlMode ? n.ElementType.Tag : void 0, f = new o.Element(c, u, void 0, d);
        this.addNode(f), this.tagStack.push(f);
      }, l.prototype.ontext = function(c) {
        var u = this.lastNode;
        if (u && u.type === n.ElementType.Text)
          u.data += c, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var d = new o.Text(c);
          this.addNode(d), this.lastNode = d;
        }
      }, l.prototype.oncomment = function(c) {
        if (this.lastNode && this.lastNode.type === n.ElementType.Comment) {
          this.lastNode.data += c;
          return;
        }
        var u = new o.Comment(c);
        this.addNode(u), this.lastNode = u;
      }, l.prototype.oncommentend = function() {
        this.lastNode = null;
      }, l.prototype.oncdatastart = function() {
        var c = new o.Text(""), u = new o.CDATA([c]);
        this.addNode(u), c.parent = u, this.lastNode = c;
      }, l.prototype.oncdataend = function() {
        this.lastNode = null;
      }, l.prototype.onprocessinginstruction = function(c, u) {
        var d = new o.ProcessingInstruction(c, u);
        this.addNode(d);
      }, l.prototype.handleCallback = function(c) {
        if (typeof this.callback == "function")
          this.callback(c, this.dom);
        else if (c)
          throw c;
      }, l.prototype.addNode = function(c) {
        var u = this.tagStack[this.tagStack.length - 1], d = u.children[u.children.length - 1];
        this.options.withStartIndices && (c.startIndex = this.parser.startIndex), this.options.withEndIndices && (c.endIndex = this.parser.endIndex), u.children.push(c), d && (c.prev = d, d.next = c), c.parent = u, this.lastNode = null;
      }, l;
    }()
  );
  e.DomHandler = i, e.default = i;
})(d0);
var oT = "html", aT = "head", _c = "body", Ome = /<([a-zA-Z]+[0-9]?)/, iT = /<head[^]*>/i, sT = /<body[^]*>/i, Xf = function() {
  throw new Error(
    "This browser does not support `document.implementation.createHTMLDocument`"
  );
}, Gv = function() {
  throw new Error(
    "This browser does not support `DOMParser.prototype.parseFromString`"
  );
}, lT = typeof window == "object" && window.DOMParser;
if (typeof lT == "function") {
  var Pme = new lT(), Sme = "text/html";
  Gv = function(e, t) {
    return t && (e = "<" + t + ">" + e + "</" + t + ">"), Pme.parseFromString(e, Sme);
  }, Xf = Gv;
}
if (typeof document == "object" && document.implementation) {
  var Oc = document.implementation.createHTMLDocument();
  Xf = function(e, t) {
    if (t) {
      var r = Oc.documentElement.querySelector(t);
      return r.innerHTML = e, Oc;
    }
    return Oc.documentElement.innerHTML = e, Oc;
  };
}
var $h = typeof document == "object" ? document.createElement("template") : {}, Kv;
$h.content && (Kv = function(e) {
  return $h.innerHTML = e, $h.content.childNodes;
});
function Tme(e) {
  var t, r = e.match(Ome);
  r && r[1] && (t = r[1].toLowerCase());
  var n, o, a;
  switch (t) {
    case oT:
      return n = Gv(e), iT.test(e) || (o = n.querySelector(aT), o && o.parentNode.removeChild(o)), sT.test(e) || (o = n.querySelector(_c), o && o.parentNode.removeChild(o)), n.querySelectorAll(oT);
    case aT:
    case _c:
      return n = Xf(e), a = n.querySelectorAll(t), sT.test(e) && iT.test(e) ? a[0].parentNode.childNodes : a;
    default:
      return Kv ? Kv(e) : (o = Xf(e, _c).querySelector(_c), o.childNodes);
  }
}
var Eme = Tme, h0 = {}, m2 = {};
m2.CASE_SENSITIVE_TAG_NAMES = [
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "linearGradient",
  "radialGradient",
  "textPath"
];
var fm = d0, $me = m2, cT = $me.CASE_SENSITIVE_TAG_NAMES, Cme = fm.Comment, kme = fm.Element, Rme = fm.ProcessingInstruction, Dme = fm.Text, h2 = {}, Ch;
for (var kh = 0, Nme = cT.length; kh < Nme; kh++)
  Ch = cT[kh], h2[Ch.toLowerCase()] = Ch;
function Ime(e) {
  return h2[e];
}
function y2(e) {
  for (var t = {}, r, n = 0, o = e.length; n < o; n++)
    r = e[n], t[r.name] = r.value;
  return t;
}
function Mme(e) {
  e = e.toLowerCase();
  var t = Ime(e);
  return t || e;
}
function v2(e, t, r) {
  t = t || null;
  for (var n = [], o, a = 0, i = e.length; a < i; a++) {
    var l = e[a], c;
    switch (l.nodeType) {
      case 1:
        o = Mme(l.nodeName), c = new kme(o, y2(l.attributes)), c.children = v2(
          // template children are on content
          o === "template" ? l.content.childNodes : l.childNodes,
          c
        );
        break;
      case 3:
        c = new Dme(l.nodeValue);
        break;
      case 8:
        c = new Cme(l.nodeValue);
        break;
      default:
        continue;
    }
    var u = n[a - 1] || null;
    u && (u.next = c), c.parent = t, c.prev = u, c.next = null, n.push(c);
  }
  return r && (c = new Rme(
    r.substring(0, r.indexOf(" ")).toLowerCase(),
    r
  ), c.next = n[0] || null, c.parent = t, n.unshift(c), n[1] && (n[1].prev = n[0])), n;
}
h0.formatAttributes = y2;
h0.formatDOM = v2;
var Ame = Eme, jme = h0, Fme = jme.formatDOM, Lme = /<(![a-zA-Z\s]+)>/;
function Vme(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (e === "")
    return [];
  var t = e.match(Lme), r;
  return t && t[1] && (r = t[1]), Fme(Ame(e), null, r);
}
var zme = Vme, bn = {}, pm = {}, Bme = 0;
pm.SAME = Bme;
var Wme = 1;
pm.CAMELCASE = Wme;
pm.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
Object.defineProperty(bn, "__esModule", { value: !0 });
function Ume(e, t) {
  return Hme(e) || Yme(e, t) || qme(e, t) || Gme();
}
function Hme(e) {
  if (Array.isArray(e))
    return e;
}
function Yme(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n = [], o = !0, a = !1, i, l;
    try {
      for (r = r.call(e); !(o = (i = r.next()).done) && (n.push(i.value), !(t && n.length === t)); o = !0)
        ;
    } catch (c) {
      a = !0, l = c;
    } finally {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a)
          throw l;
      }
    }
    return n;
  }
}
function qme(e, t) {
  if (e) {
    if (typeof e == "string")
      return uT(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set")
      return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return uT(e, t);
  }
}
function uT(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function Gme() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var g2 = 0, aa = 1, mm = 2, hm = 3, y0 = 4, b2 = 5, w2 = 6;
function Kme(e) {
  return dr.hasOwnProperty(e) ? dr[e] : null;
}
function _r(e, t, r, n, o, a, i) {
  this.acceptsBooleans = t === mm || t === hm || t === y0, this.attributeName = n, this.attributeNamespace = o, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = a, this.removeEmptyString = i;
}
var dr = {}, Xme = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Xme.forEach(function(e) {
  dr[e] = new _r(
    e,
    g2,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = Ume(e, 2), r = t[0], n = t[1];
  dr[r] = new _r(
    r,
    aa,
    !1,
    // mustUseProperty
    n,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  dr[e] = new _r(
    e,
    mm,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  dr[e] = new _r(
    e,
    mm,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach(function(e) {
  dr[e] = new _r(
    e,
    hm,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  dr[e] = new _r(
    e,
    hm,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  dr[e] = new _r(
    e,
    y0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  dr[e] = new _r(
    e,
    w2,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
["rowSpan", "start"].forEach(function(e) {
  dr[e] = new _r(
    e,
    b2,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
var v0 = /[\-\:]([a-z])/g, g0 = function(t) {
  return t[1].toUpperCase();
};
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(v0, g0);
  dr[t] = new _r(
    t,
    aa,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(v0, g0);
  dr[t] = new _r(
    t,
    aa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach(function(e) {
  var t = e.replace(v0, g0);
  dr[t] = new _r(
    t,
    aa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
  );
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  dr[e] = new _r(
    e,
    aa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
  );
});
var Qme = "xlinkHref";
dr[Qme] = new _r(
  "xlinkHref",
  aa,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
);
["src", "href", "action", "formAction"].forEach(function(e) {
  dr[e] = new _r(
    e,
    aa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
  );
});
var b0 = pm, Zme = b0.CAMELCASE, Jme = b0.SAME, dT = b0.possibleStandardNames, ehe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", the = ehe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", rhe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + the + "]*$")
), nhe = Object.keys(dT).reduce(function(e, t) {
  var r = dT[t];
  return r === Jme ? e[t] = t : r === Zme ? e[t.toLowerCase()] = t : e[t] = r, e;
}, {});
bn.BOOLEAN = hm;
bn.BOOLEANISH_STRING = mm;
bn.NUMERIC = b2;
bn.OVERLOADED_BOOLEAN = y0;
bn.POSITIVE_NUMERIC = w2;
bn.RESERVED = g2;
bn.STRING = aa;
bn.getPropertyInfo = Kme;
bn.isCustomAttribute = rhe;
bn.possibleStandardNames = nhe;
var x2 = {}, w0 = { exports: {} }, fT = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ohe = /\n/g, ahe = /^\s*/, ihe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, she = /^:\s*/, lhe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, che = /^[;\s]*/, uhe = /^\s+|\s+$/g, dhe = `
`, pT = "/", mT = "*", ba = "", fhe = "comment", phe = "declaration", mhe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var r = 1, n = 1;
  function o(y) {
    var h = y.match(ohe);
    h && (r += h.length);
    var v = y.lastIndexOf(dhe);
    n = ~v ? y.length - v : n + y.length;
  }
  function a() {
    var y = { line: r, column: n };
    return function(h) {
      return h.position = new i(y), u(), h;
    };
  }
  function i(y) {
    this.start = y, this.end = { line: r, column: n }, this.source = t.source;
  }
  i.prototype.content = e;
  function l(y) {
    var h = new Error(
      t.source + ":" + r + ":" + n + ": " + y
    );
    if (h.reason = y, h.filename = t.source, h.line = r, h.column = n, h.source = e, !t.silent)
      throw h;
  }
  function c(y) {
    var h = y.exec(e);
    if (h) {
      var v = h[0];
      return o(v), e = e.slice(v.length), h;
    }
  }
  function u() {
    c(ahe);
  }
  function d(y) {
    var h;
    for (y = y || []; h = f(); )
      h !== !1 && y.push(h);
    return y;
  }
  function f() {
    var y = a();
    if (!(pT != e.charAt(0) || mT != e.charAt(1))) {
      for (var h = 2; ba != e.charAt(h) && (mT != e.charAt(h) || pT != e.charAt(h + 1)); )
        ++h;
      if (h += 2, ba === e.charAt(h - 1))
        return l("End of comment missing");
      var v = e.slice(2, h - 2);
      return n += 2, o(v), e = e.slice(h), n += 2, y({
        type: fhe,
        comment: v
      });
    }
  }
  function p() {
    var y = a(), h = c(ihe);
    if (h) {
      if (f(), !c(she))
        return l("property missing ':'");
      var v = c(lhe), g = y({
        type: phe,
        property: hT(h[0].replace(fT, ba)),
        value: v ? hT(v[0].replace(fT, ba)) : ba
      });
      return c(che), g;
    }
  }
  function m() {
    var y = [];
    d(y);
    for (var h; h = p(); )
      h !== !1 && (y.push(h), d(y));
    return y;
  }
  return u(), m();
};
function hT(e) {
  return e ? e.replace(uhe, ba) : ba;
}
var hhe = mhe;
function _2(e, t) {
  var r = null;
  if (!e || typeof e != "string")
    return r;
  for (var n, o = hhe(e), a = typeof t == "function", i, l, c = 0, u = o.length; c < u; c++)
    n = o[c], i = n.property, l = n.value, a ? t(i, l, n) : l && (r || (r = {}), r[i] = l);
  return r;
}
w0.exports = _2;
w0.exports.default = _2;
var yhe = w0.exports, ym = {};
ym.__esModule = !0;
ym.camelCase = void 0;
var vhe = /^--[a-zA-Z0-9-]+$/, ghe = /-([a-z])/g, bhe = /^[^-]+$/, whe = /^-(webkit|moz|ms|o|khtml)-/, xhe = /^-(ms)-/, _he = function(e) {
  return !e || bhe.test(e) || vhe.test(e);
}, Ohe = function(e, t) {
  return t.toUpperCase();
}, yT = function(e, t) {
  return "".concat(t, "-");
}, Phe = function(e, t) {
  return t === void 0 && (t = {}), _he(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(xhe, yT) : e = e.replace(whe, yT), e.replace(ghe, Ohe));
};
ym.camelCase = Phe;
(function(e) {
  var t = Bn && Bn.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  };
  e.__esModule = !0;
  var r = t(yhe), n = ym;
  function o(a, i) {
    var l = {};
    return !a || typeof a != "string" || (0, r.default)(a, function(c, u) {
      c && u && (l[(0, n.camelCase)(c, i)] = u);
    }), l;
  }
  e.default = o;
})(x2);
var She = F, The = x2.default;
function Ehe(e, t) {
  if (!e || typeof e != "object")
    throw new TypeError("First argument must be an object");
  var r, n, o = typeof t == "function", a = {}, i = {};
  for (r in e) {
    if (n = e[r], o && (a = t(r, n), a && a.length === 2)) {
      i[a[0]] = a[1];
      continue;
    }
    typeof n == "string" && (i[n] = r);
  }
  return i;
}
function $he(e, t) {
  if (e.indexOf("-") === -1)
    return t && typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var Che = { reactCompat: !0 };
function khe(e, t) {
  if (e != null)
    try {
      t.style = The(e, Che);
    } catch {
      t.style = {};
    }
}
var Rhe = She.version.split(".")[0] >= 16, O2 = /* @__PURE__ */ new Set([
  "tr",
  "tbody",
  "thead",
  "tfoot",
  "colgroup",
  "table",
  "head",
  "html",
  "frameset"
]);
function Dhe(e) {
  return !O2.has(e.name);
}
var P2 = {
  PRESERVE_CUSTOM_ATTRIBUTES: Rhe,
  invertObject: Ehe,
  isCustomComponent: $he,
  setStyleProp: khe,
  canTextBeChildOfNode: Dhe,
  elementsWithNoTextChildren: O2
}, Ms = bn, vT = P2, Nhe = ["checked", "value"], Ihe = ["input", "select", "textarea"], Mhe = {
  reset: !0,
  submit: !0
}, S2 = function(t, r) {
  t = t || {};
  var n, o, a, i, l, c = {}, u = t.type && Mhe[t.type];
  for (n in t) {
    if (a = t[n], Ms.isCustomAttribute(n)) {
      c[n] = a;
      continue;
    }
    if (o = n.toLowerCase(), i = gT(o), i) {
      switch (l = Ms.getPropertyInfo(i), Nhe.indexOf(i) !== -1 && Ihe.indexOf(r) !== -1 && !u && (i = gT("default" + o)), c[i] = a, l && l.type) {
        case Ms.BOOLEAN:
          c[i] = !0;
          break;
        case Ms.OVERLOADED_BOOLEAN:
          a === "" && (c[i] = !0);
          break;
      }
      continue;
    }
    vT.PRESERVE_CUSTOM_ATTRIBUTES && (c[n] = a);
  }
  return vT.setStyleProp(t.style, c), c;
};
function gT(e) {
  return Ms.possibleStandardNames[e];
}
var Ahe = F, jhe = S2, Qf = P2, Fhe = Qf.setStyleProp, Lhe = Qf.canTextBeChildOfNode;
function T2(e, t) {
  t = t || {};
  for (var r = t.library || Ahe, n = r.cloneElement, o = r.createElement, a = r.isValidElement, i = [], l, c, u = typeof t.replace == "function", d, f, p, m = t.trim, y = 0, h = e.length; y < h; y++) {
    if (l = e[y], u && (d = t.replace(l), a(d))) {
      h > 1 && (d = n(d, {
        key: d.key || y
      })), i.push(d);
      continue;
    }
    if (l.type === "text") {
      if (c = !l.data.trim().length, c && l.parent && !Lhe(l.parent) || m && c)
        continue;
      i.push(l.data);
      continue;
    }
    switch (f = l.attribs, Vhe(l) ? Fhe(f.style, f) : f && (f = jhe(f, l.name)), p = null, l.type) {
      case "script":
      case "style":
        l.children[0] && (f.dangerouslySetInnerHTML = {
          __html: l.children[0].data
        });
        break;
      case "tag":
        l.name === "textarea" && l.children[0] ? f.defaultValue = l.children[0].data : l.children && l.children.length && (p = T2(l.children, t));
        break;
      default:
        continue;
    }
    h > 1 && (f.key = y), i.push(o(l.name, f, p));
  }
  return i.length === 1 ? i[0] : i;
}
function Vhe(e) {
  return Qf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && Qf.isCustomComponent(e.name, e.attribs);
}
var zhe = T2, vm = d0, xi = zme, Bhe = S2, E2 = zhe;
xi = /* istanbul ignore next */
typeof xi.default == "function" ? xi.default : xi;
var Whe = { lowerCaseAttributeNames: !1 };
function eo(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  return e === "" ? [] : (t = t || {}, E2(
    xi(e, t.htmlparser2 || Whe),
    t
  ));
}
eo.domToReact = E2;
eo.htmlToDOM = xi;
eo.attributesToProps = Bhe;
eo.Comment = vm.Comment;
eo.Element = vm.Element;
eo.ProcessingInstruction = vm.ProcessingInstruction;
eo.Text = vm.Text;
var Uhe = eo;
eo.default = eo;
const ia = /* @__PURE__ */ qi(Uhe);
ia.domToReact;
ia.htmlToDOM;
ia.attributesToProps;
ia.Comment;
ia.Element;
ia.ProcessingInstruction;
ia.Text;
/*! @license DOMPurify 3.0.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.1/LICENSE */
function _a(e) {
  "@babel/helpers - typeof";
  return _a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _a(e);
}
function Xv(e, t) {
  return Xv = Object.setPrototypeOf || function(n, o) {
    return n.__proto__ = o, n;
  }, Xv(e, t);
}
function Hhe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ou(e, t, r) {
  return Hhe() ? Ou = Reflect.construct : Ou = function(o, a, i) {
    var l = [null];
    l.push.apply(l, a);
    var c = Function.bind.apply(o, l), u = new c();
    return i && Xv(u, i.prototype), u;
  }, Ou.apply(null, arguments);
}
function Yhe(e, t) {
  return Ghe(e) || Xhe(e, t) || x0(e, t) || Zhe();
}
function On(e) {
  return qhe(e) || Khe(e) || x0(e) || Qhe();
}
function qhe(e) {
  if (Array.isArray(e))
    return Qv(e);
}
function Ghe(e) {
  if (Array.isArray(e))
    return e;
}
function Khe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function Xhe(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n = [], o = !0, a = !1, i, l;
    try {
      for (r = r.call(e); !(o = (i = r.next()).done) && (n.push(i.value), !(t && n.length === t)); o = !0)
        ;
    } catch (c) {
      a = !0, l = c;
    } finally {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a)
          throw l;
      }
    }
    return n;
  }
}
function x0(e, t) {
  if (e) {
    if (typeof e == "string")
      return Qv(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set")
      return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return Qv(e, t);
  }
}
function Qv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++)
    n[r] = e[r];
  return n;
}
function Qhe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Zhe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Jhe(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!r) {
    if (Array.isArray(e) || (r = x0(e)) || t && e && typeof e.length == "number") {
      r && (e = r);
      var n = 0, o = function() {
      };
      return {
        s: o,
        n: function() {
          return n >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[n++]
          };
        },
        e: function(c) {
          throw c;
        },
        f: o
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a = !0, i = !1, l;
  return {
    s: function() {
      r = r.call(e);
    },
    n: function() {
      var c = r.next();
      return a = c.done, c;
    },
    e: function(c) {
      i = !0, l = c;
    },
    f: function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (i)
          throw l;
      }
    }
  };
}
var $2 = Object.entries, bT = Object.setPrototypeOf, eye = Object.isFrozen, tye = Object.getPrototypeOf, rye = Object.getOwnPropertyDescriptor, xr = Object.freeze, In = Object.seal, nye = Object.create, C2 = typeof Reflect < "u" && Reflect, Zv = C2.apply, Jv = C2.construct;
Zv || (Zv = function(t, r, n) {
  return t.apply(r, n);
});
xr || (xr = function(t) {
  return t;
});
In || (In = function(t) {
  return t;
});
Jv || (Jv = function(t, r) {
  return Ou(t, On(r));
});
var oye = yn(Array.prototype.forEach), wT = yn(Array.prototype.pop), ks = yn(Array.prototype.push), Pu = yn(String.prototype.toLowerCase), Rh = yn(String.prototype.toString), aye = yn(String.prototype.match), xn = yn(String.prototype.replace), iye = yn(String.prototype.indexOf), sye = yn(String.prototype.trim), Ar = yn(RegExp.prototype.test), Dh = lye(TypeError);
function yn(e) {
  return function(t) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      n[o - 1] = arguments[o];
    return Zv(e, t, n);
  };
}
function lye(e) {
  return function() {
    for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
      r[n] = arguments[n];
    return Jv(e, r);
  };
}
function ot(e, t, r) {
  r = r || Pu, bT && bT(e, null);
  for (var n = t.length; n--; ) {
    var o = t[n];
    if (typeof o == "string") {
      var a = r(o);
      a !== o && (eye(t) || (t[n] = a), o = a);
    }
    e[o] = !0;
  }
  return e;
}
function li(e) {
  var t = nye(null), r = Jhe($2(e)), n;
  try {
    for (r.s(); !(n = r.n()).done; ) {
      var o = Yhe(n.value, 2), a = o[0], i = o[1];
      t[a] = i;
    }
  } catch (l) {
    r.e(l);
  } finally {
    r.f();
  }
  return t;
}
function Pc(e, t) {
  for (; e !== null; ) {
    var r = rye(e, t);
    if (r) {
      if (r.get)
        return yn(r.get);
      if (typeof r.value == "function")
        return yn(r.value);
    }
    e = tye(e);
  }
  function n(o) {
    return console.warn("fallback value for", o), null;
  }
  return n;
}
var xT = xr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Nh = xr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Ih = xr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), cye = xr(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Mh = xr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), uye = xr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), _T = xr(["#text"]), OT = xr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Ah = xr(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), PT = xr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Sc = xr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), dye = In(/\{\{[\w\W]*|[\w\W]*\}\}/gm), fye = In(/<%[\w\W]*|[\w\W]*%>/gm), pye = In(/\${[\w\W]*}/gm), mye = In(/^data-[\-\w.\u00B7-\uFFFF]/), hye = In(/^aria-[\-\w]+$/), yye = In(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), vye = In(/^(?:\w+script|data):/i), gye = In(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), bye = In(/^html$/i), wye = function() {
  return typeof window > "u" ? null : window;
}, xye = function(t, r) {
  if (_a(t) !== "object" || typeof t.createPolicy != "function")
    return null;
  var n = null, o = "data-tt-policy-suffix";
  r.currentScript && r.currentScript.hasAttribute(o) && (n = r.currentScript.getAttribute(o));
  var a = "dompurify" + (n ? "#" + n : "");
  try {
    return t.createPolicy(a, {
      createHTML: function(l) {
        return l;
      },
      createScriptURL: function(l) {
        return l;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + a + " could not be created."), null;
  }
};
function k2() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : wye(), t = function(X) {
    return k2(X);
  };
  if (t.version = "3.0.1", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return t.isSupported = !1, t;
  var r = e.document, n = e.document, o = e.DocumentFragment, a = e.HTMLTemplateElement, i = e.Node, l = e.Element, c = e.NodeFilter, u = e.NamedNodeMap, d = u === void 0 ? e.NamedNodeMap || e.MozNamedAttrMap : u, f = e.HTMLFormElement, p = e.DOMParser, m = e.trustedTypes, y = l.prototype, h = Pc(y, "cloneNode"), v = Pc(y, "nextSibling"), g = Pc(y, "childNodes"), b = Pc(y, "parentNode");
  if (typeof a == "function") {
    var x = n.createElement("template");
    x.content && x.content.ownerDocument && (n = x.content.ownerDocument);
  }
  var O = xye(m, r), w = O ? O.createHTML("") : "", S = n, E = S.implementation, C = S.createNodeIterator, N = S.createDocumentFragment, $ = S.getElementsByTagName, j = r.importNode, A = {};
  t.isSupported = typeof $2 == "function" && typeof b == "function" && E && typeof E.createHTMLDocument < "u";
  var k = dye, R = fye, D = pye, L = mye, B = hye, H = vye, U = gye, I = yye, V = null, G = ot({}, [].concat(On(xT), On(Nh), On(Ih), On(Mh), On(_T))), q = null, J = ot({}, [].concat(On(OT), On(Ah), On(PT), On(Sc))), ne = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), te = null, ee = null, K = !0, Q = !0, ae = !1, ie = !0, oe = !1, se = !1, re = !1, le = !1, M = !1, W = !1, Z = !1, he = !0, me = !1, de = "user-content-", ue = !0, Oe = !1, Se = {}, De = null, nt = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), rt = null, Be = ot({}, ["audio", "video", "img", "source", "image", "track"]), Ie = null, it = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), we = "http://www.w3.org/1998/Math/MathML", ye = "http://www.w3.org/2000/svg", _e = "http://www.w3.org/1999/xhtml", Re = _e, je = !1, Fe = null, Ze = ot({}, [we, ye, _e], Rh), ft, Je = ["application/xhtml+xml", "text/html"], Ht = "text/html", at, Jt = null, Yt = n.createElement("form"), qt = function(X) {
    return X instanceof RegExp || X instanceof Function;
  }, Or = function(X) {
    Jt && Jt === X || ((!X || _a(X) !== "object") && (X = {}), X = li(X), ft = // eslint-disable-next-line unicorn/prefer-includes
    Je.indexOf(X.PARSER_MEDIA_TYPE) === -1 ? ft = Ht : ft = X.PARSER_MEDIA_TYPE, at = ft === "application/xhtml+xml" ? Rh : Pu, V = "ALLOWED_TAGS" in X ? ot({}, X.ALLOWED_TAGS, at) : G, q = "ALLOWED_ATTR" in X ? ot({}, X.ALLOWED_ATTR, at) : J, Fe = "ALLOWED_NAMESPACES" in X ? ot({}, X.ALLOWED_NAMESPACES, Rh) : Ze, Ie = "ADD_URI_SAFE_ATTR" in X ? ot(
      li(it),
      // eslint-disable-line indent
      X.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      at
      // eslint-disable-line indent
    ) : it, rt = "ADD_DATA_URI_TAGS" in X ? ot(
      li(Be),
      // eslint-disable-line indent
      X.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      at
      // eslint-disable-line indent
    ) : Be, De = "FORBID_CONTENTS" in X ? ot({}, X.FORBID_CONTENTS, at) : nt, te = "FORBID_TAGS" in X ? ot({}, X.FORBID_TAGS, at) : {}, ee = "FORBID_ATTR" in X ? ot({}, X.FORBID_ATTR, at) : {}, Se = "USE_PROFILES" in X ? X.USE_PROFILES : !1, K = X.ALLOW_ARIA_ATTR !== !1, Q = X.ALLOW_DATA_ATTR !== !1, ae = X.ALLOW_UNKNOWN_PROTOCOLS || !1, ie = X.ALLOW_SELF_CLOSE_IN_ATTR !== !1, oe = X.SAFE_FOR_TEMPLATES || !1, se = X.WHOLE_DOCUMENT || !1, M = X.RETURN_DOM || !1, W = X.RETURN_DOM_FRAGMENT || !1, Z = X.RETURN_TRUSTED_TYPE || !1, le = X.FORCE_BODY || !1, he = X.SANITIZE_DOM !== !1, me = X.SANITIZE_NAMED_PROPS || !1, ue = X.KEEP_CONTENT !== !1, Oe = X.IN_PLACE || !1, I = X.ALLOWED_URI_REGEXP || I, Re = X.NAMESPACE || _e, ne = X.CUSTOM_ELEMENT_HANDLING || {}, X.CUSTOM_ELEMENT_HANDLING && qt(X.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ne.tagNameCheck = X.CUSTOM_ELEMENT_HANDLING.tagNameCheck), X.CUSTOM_ELEMENT_HANDLING && qt(X.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ne.attributeNameCheck = X.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), X.CUSTOM_ELEMENT_HANDLING && typeof X.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ne.allowCustomizedBuiltInElements = X.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), oe && (Q = !1), W && (M = !0), Se && (V = ot({}, On(_T)), q = [], Se.html === !0 && (ot(V, xT), ot(q, OT)), Se.svg === !0 && (ot(V, Nh), ot(q, Ah), ot(q, Sc)), Se.svgFilters === !0 && (ot(V, Ih), ot(q, Ah), ot(q, Sc)), Se.mathMl === !0 && (ot(V, Mh), ot(q, PT), ot(q, Sc))), X.ADD_TAGS && (V === G && (V = li(V)), ot(V, X.ADD_TAGS, at)), X.ADD_ATTR && (q === J && (q = li(q)), ot(q, X.ADD_ATTR, at)), X.ADD_URI_SAFE_ATTR && ot(Ie, X.ADD_URI_SAFE_ATTR, at), X.FORBID_CONTENTS && (De === nt && (De = li(De)), ot(De, X.FORBID_CONTENTS, at)), ue && (V["#text"] = !0), se && ot(V, ["html", "head", "body"]), V.table && (ot(V, ["tbody"]), delete te.tbody), xr && xr(X), Jt = X);
  }, Qt = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), Gt = ot({}, ["foreignobject", "desc", "title", "annotation-xml"]), Rt = ot({}, ["title", "style", "font", "a", "script"]), ct = ot({}, Nh);
  ot(ct, Ih), ot(ct, cye);
  var sr = ot({}, Mh);
  ot(sr, uye);
  var Gr = function(X) {
    var pe = b(X);
    (!pe || !pe.tagName) && (pe = {
      namespaceURI: Re,
      tagName: "template"
    });
    var xe = Pu(X.tagName), tt = Pu(pe.tagName);
    return Fe[X.namespaceURI] ? X.namespaceURI === ye ? pe.namespaceURI === _e ? xe === "svg" : pe.namespaceURI === we ? xe === "svg" && (tt === "annotation-xml" || Qt[tt]) : !!ct[xe] : X.namespaceURI === we ? pe.namespaceURI === _e ? xe === "math" : pe.namespaceURI === ye ? xe === "math" && Gt[tt] : !!sr[xe] : X.namespaceURI === _e ? pe.namespaceURI === ye && !Gt[tt] || pe.namespaceURI === we && !Qt[tt] ? !1 : !sr[xe] && (Rt[xe] || !ct[xe]) : !!(ft === "application/xhtml+xml" && Fe[X.namespaceURI]) : !1;
  }, Mt = function(X) {
    ks(t.removed, {
      element: X
    });
    try {
      X.parentNode.removeChild(X);
    } catch {
      X.remove();
    }
  }, er = function(X, pe) {
    try {
      ks(t.removed, {
        attribute: pe.getAttributeNode(X),
        from: pe
      });
    } catch {
      ks(t.removed, {
        attribute: null,
        from: pe
      });
    }
    if (pe.removeAttribute(X), X === "is" && !q[X])
      if (M || W)
        try {
          Mt(pe);
        } catch {
        }
      else
        try {
          pe.setAttribute(X, "");
        } catch {
        }
  }, Kr = function(X) {
    var pe, xe;
    if (le)
      X = "<remove></remove>" + X;
    else {
      var tt = aye(X, /^[\r\n\t ]+/);
      xe = tt && tt[0];
    }
    ft === "application/xhtml+xml" && Re === _e && (X = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + X + "</body></html>");
    var Dt = O ? O.createHTML(X) : X;
    if (Re === _e)
      try {
        pe = new p().parseFromString(Dt, ft);
      } catch {
      }
    if (!pe || !pe.documentElement) {
      pe = E.createDocument(Re, "template", null);
      try {
        pe.documentElement.innerHTML = je ? w : Dt;
      } catch {
      }
    }
    var ut = pe.body || pe.documentElement;
    return X && xe && ut.insertBefore(n.createTextNode(xe), ut.childNodes[0] || null), Re === _e ? $.call(pe, se ? "html" : "body")[0] : se ? pe.documentElement : ut;
  }, wn = function(X) {
    return C.call(
      X.ownerDocument || X,
      X,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT,
      null,
      !1
    );
  }, $o = function(X) {
    return X instanceof f && (typeof X.nodeName != "string" || typeof X.textContent != "string" || typeof X.removeChild != "function" || !(X.attributes instanceof d) || typeof X.removeAttribute != "function" || typeof X.setAttribute != "function" || typeof X.namespaceURI != "string" || typeof X.insertBefore != "function" || typeof X.hasChildNodes != "function");
  }, Y = function(X) {
    return _a(i) === "object" ? X instanceof i : X && _a(X) === "object" && typeof X.nodeType == "number" && typeof X.nodeName == "string";
  }, ve = function(X, pe, xe) {
    A[X] && oye(A[X], function(tt) {
      tt.call(t, pe, xe, Jt);
    });
  }, Ee = function(X) {
    var pe;
    if (ve("beforeSanitizeElements", X, null), $o(X))
      return Mt(X), !0;
    var xe = at(X.nodeName);
    if (ve("uponSanitizeElement", X, {
      tagName: xe,
      allowedTags: V
    }), X.hasChildNodes() && !Y(X.firstElementChild) && (!Y(X.content) || !Y(X.content.firstElementChild)) && Ar(/<[/\w]/g, X.innerHTML) && Ar(/<[/\w]/g, X.textContent))
      return Mt(X), !0;
    if (!V[xe] || te[xe]) {
      if (!te[xe] && be(xe) && (ne.tagNameCheck instanceof RegExp && Ar(ne.tagNameCheck, xe) || ne.tagNameCheck instanceof Function && ne.tagNameCheck(xe)))
        return !1;
      if (ue && !De[xe]) {
        var tt = b(X) || X.parentNode, Dt = g(X) || X.childNodes;
        if (Dt && tt)
          for (var ut = Dt.length, Tt = ut - 1; Tt >= 0; --Tt)
            tt.insertBefore(h(Dt[Tt], !0), v(X));
      }
      return Mt(X), !0;
    }
    return X instanceof l && !Gr(X) || (xe === "noscript" || xe === "noembed") && Ar(/<\/no(script|embed)/i, X.innerHTML) ? (Mt(X), !0) : (oe && X.nodeType === 3 && (pe = X.textContent, pe = xn(pe, k, " "), pe = xn(pe, R, " "), pe = xn(pe, D, " "), X.textContent !== pe && (ks(t.removed, {
      element: X.cloneNode()
    }), X.textContent = pe)), ve("afterSanitizeElements", X, null), !1);
  }, He = function(X, pe, xe) {
    if (he && (pe === "id" || pe === "name") && (xe in n || xe in Yt))
      return !1;
    if (!(Q && !ee[pe] && Ar(L, pe))) {
      if (!(K && Ar(B, pe))) {
        if (!q[pe] || ee[pe]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(be(X) && (ne.tagNameCheck instanceof RegExp && Ar(ne.tagNameCheck, X) || ne.tagNameCheck instanceof Function && ne.tagNameCheck(X)) && (ne.attributeNameCheck instanceof RegExp && Ar(ne.attributeNameCheck, pe) || ne.attributeNameCheck instanceof Function && ne.attributeNameCheck(pe)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            pe === "is" && ne.allowCustomizedBuiltInElements && (ne.tagNameCheck instanceof RegExp && Ar(ne.tagNameCheck, xe) || ne.tagNameCheck instanceof Function && ne.tagNameCheck(xe)))
          )
            return !1;
        } else if (!Ie[pe]) {
          if (!Ar(I, xn(xe, U, ""))) {
            if (!((pe === "src" || pe === "xlink:href" || pe === "href") && X !== "script" && iye(xe, "data:") === 0 && rt[X])) {
              if (!(ae && !Ar(H, xn(xe, U, "")))) {
                if (xe)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, be = function(X) {
    return X.indexOf("-") > 0;
  }, We = function(X) {
    var pe, xe, tt, Dt;
    ve("beforeSanitizeAttributes", X, null);
    var ut = X.attributes;
    if (ut) {
      var Tt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: q
      };
      for (Dt = ut.length; Dt--; ) {
        pe = ut[Dt];
        var lr = pe, oo = lr.name, as = lr.namespaceURI;
        if (xe = oo === "value" ? pe.value : sye(pe.value), tt = at(oo), Tt.attrName = tt, Tt.attrValue = xe, Tt.keepAttr = !0, Tt.forceKeepAttr = void 0, ve("uponSanitizeAttribute", X, Tt), xe = Tt.attrValue, !Tt.forceKeepAttr && (er(oo, X), !!Tt.keepAttr)) {
          if (!ie && Ar(/\/>/i, xe)) {
            er(oo, X);
            continue;
          }
          oe && (xe = xn(xe, k, " "), xe = xn(xe, R, " "), xe = xn(xe, D, " "));
          var Ll = at(X.nodeName);
          if (He(Ll, tt, xe)) {
            if (me && (tt === "id" || tt === "name") && (er(oo, X), xe = de + xe), O && _a(m) === "object" && typeof m.getAttributeType == "function" && !as)
              switch (m.getAttributeType(Ll, tt)) {
                case "TrustedHTML":
                  xe = O.createHTML(xe);
                  break;
                case "TrustedScriptURL":
                  xe = O.createScriptURL(xe);
                  break;
              }
            try {
              as ? X.setAttributeNS(as, oo, xe) : X.setAttribute(oo, xe), wT(t.removed);
            } catch {
            }
          }
        }
      }
      ve("afterSanitizeAttributes", X, null);
    }
  }, Ye = function fe(X) {
    var pe, xe = wn(X);
    for (ve("beforeSanitizeShadowDOM", X, null); pe = xe.nextNode(); )
      ve("uponSanitizeShadowNode", pe, null), !Ee(pe) && (pe.content instanceof o && fe(pe.content), We(pe));
    ve("afterSanitizeShadowDOM", X, null);
  };
  return t.sanitize = function(fe) {
    var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, pe, xe, tt, Dt;
    if (je = !fe, je && (fe = "<!-->"), typeof fe != "string" && !Y(fe)) {
      if (typeof fe.toString != "function")
        throw Dh("toString is not a function");
      if (fe = fe.toString(), typeof fe != "string")
        throw Dh("dirty is not a string, aborting");
    }
    if (!t.isSupported)
      return fe;
    if (re || Or(X), t.removed = [], typeof fe == "string" && (Oe = !1), Oe) {
      if (fe.nodeName) {
        var ut = at(fe.nodeName);
        if (!V[ut] || te[ut])
          throw Dh("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (fe instanceof i)
      pe = Kr("<!---->"), xe = pe.ownerDocument.importNode(fe, !0), xe.nodeType === 1 && xe.nodeName === "BODY" || xe.nodeName === "HTML" ? pe = xe : pe.appendChild(xe);
    else {
      if (!M && !oe && !se && // eslint-disable-next-line unicorn/prefer-includes
      fe.indexOf("<") === -1)
        return O && Z ? O.createHTML(fe) : fe;
      if (pe = Kr(fe), !pe)
        return M ? null : Z ? w : "";
    }
    pe && le && Mt(pe.firstChild);
    for (var Tt = wn(Oe ? fe : pe); tt = Tt.nextNode(); )
      Ee(tt) || (tt.content instanceof o && Ye(tt.content), We(tt));
    if (Oe)
      return fe;
    if (M) {
      if (W)
        for (Dt = N.call(pe.ownerDocument); pe.firstChild; )
          Dt.appendChild(pe.firstChild);
      else
        Dt = pe;
      return (q.shadowroot || q.shadowrootmod) && (Dt = j.call(r, Dt, !0)), Dt;
    }
    var lr = se ? pe.outerHTML : pe.innerHTML;
    return se && V["!doctype"] && pe.ownerDocument && pe.ownerDocument.doctype && pe.ownerDocument.doctype.name && Ar(bye, pe.ownerDocument.doctype.name) && (lr = "<!DOCTYPE " + pe.ownerDocument.doctype.name + `>
` + lr), oe && (lr = xn(lr, k, " "), lr = xn(lr, R, " "), lr = xn(lr, D, " ")), O && Z ? O.createHTML(lr) : lr;
  }, t.setConfig = function(fe) {
    Or(fe), re = !0;
  }, t.clearConfig = function() {
    Jt = null, re = !1;
  }, t.isValidAttribute = function(fe, X, pe) {
    Jt || Or({});
    var xe = at(fe), tt = at(X);
    return He(xe, tt, pe);
  }, t.addHook = function(fe, X) {
    typeof X == "function" && (A[fe] = A[fe] || [], ks(A[fe], X));
  }, t.removeHook = function(fe) {
    if (A[fe])
      return wT(A[fe]);
  }, t.removeHooks = function(fe) {
    A[fe] && (A[fe] = []);
  }, t.removeAllHooks = function() {
    A = {};
  }, t;
}
var _ye = k2();
const Oye = Qe((e, { rightBorder: t, rtl: r }) => ({
  field: {
    ...e.fn.fontStyles(),
    fontSize: e.fontSizes.sm,
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    textAlign: r ? "right" : "left",
    borderBottom: `1px solid ${e.colors.gray[4]}`
  },
  borderRight: {
    borderRight: t && `1px solid ${e.colors.gray[4]}`,
    "&:last-of-type": {
      borderRight: "none"
    }
  }
})), eg = F.memo(({ loading: e, rightBorder: t, rtl: r, children: n, ...o }) => {
  const { classes: a, cx: i } = Oye({ rightBorder: t, rtl: r });
  let l;
  return typeof n == "string" && xme(n) && (l = ia(_ye.sanitize(n))), /* @__PURE__ */ _.jsx("td", { className: i(a.field, t ? a.borderRight : null), ...o, children: /* @__PURE__ */ _.jsx(OR, { visible: e, children: l || n }) });
});
eg.displayName = "Field";
function Pye({ relatedPath: e, ...t }) {
  const { path: r } = ir(), n = Er(
    r ? r.substring(0, r.lastIndexOf("/")) : "",
    e.substring(0, e.lastIndexOf("/"))
  );
  return /* @__PURE__ */ _.jsx(iG, { path: n, relation: t, children: /* @__PURE__ */ _.jsx(L2, { hideToolbar: !0 }) });
}
const Sye = Jf(Pye);
function Tye({ item: e, info: t, loading: r, opened: n, onClose: o }) {
  return /* @__PURE__ */ _.jsxs(
    Zi,
    {
      opened: n,
      onClose: o,
      title: `${e == null ? void 0 : e.show_title} (#${e == null ? void 0 : e.id})`,
      size: "lg",
      centered: !0,
      children: [
        /* @__PURE__ */ _.jsx(zg, { visible: r }),
        !r && e ? /* @__PURE__ */ _.jsxs(Fn, { defaultValue: "details", children: [
          /* @__PURE__ */ _.jsxs(Fn.List, { children: [
            /* @__PURE__ */ _.jsx(Fn.Tab, { value: "details", children: "Details" }),
            t.relations.map((a, i) => /* @__PURE__ */ _.jsx(Fn.Tab, { value: a.name, children: a.name }, i))
          ] }),
          /* @__PURE__ */ _.jsx(Fn.Panel, { pt: "xs", value: "details", children: /* @__PURE__ */ _.jsx(ud, { p: "xs", withBorder: !0, children: /* @__PURE__ */ _.jsx(El, { spacing: "md", children: e.show_columns.map((a, i) => /* @__PURE__ */ _.jsxs(pi, { children: [
            /* @__PURE__ */ _.jsx(pi.Col, { span: 4, children: /* @__PURE__ */ _.jsx($r, { size: "md", sx: {}, children: e.label_columns[a] }) }),
            /* @__PURE__ */ _.jsx(pi.Col, { span: 1, children: /* @__PURE__ */ _.jsx($r, { size: "xs", color: "dimmed", children: ":" }) }),
            /* @__PURE__ */ _.jsx(pi.Col, { span: 4, children: /* @__PURE__ */ _.jsx($r, { size: "md", color: "dimmed", sx: {}, children: e2(e.result, a) }) })
          ] }, i)) }) }) }),
          t.relations.map((a, i) => /* @__PURE__ */ _.jsx(Fn.Panel, { pt: "xs", value: a.name, children: /* @__PURE__ */ _.jsx(ud, { withBorder: !0, children: /* @__PURE__ */ _.jsx(
            Sye,
            {
              relatedPath: a.path,
              id: e.id,
              foreign_key: a.foreign_key,
              type: a.type
            }
          ) }) }, i))
        ] }) : null
      ]
    }
  );
}
function Eye({ id: e }) {
  const { info: t, getEntry: r } = ir(), [n, o] = Me(null), [a, i] = Me(!1), [l, c] = Me(!1);
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx(Ba, { label: "Details", children: /* @__PURE__ */ _.jsx(
      tn,
      {
        size: "sm",
        onClick: async () => {
          i(!0);
          const u = await r(e);
          u && (o(u), i(!1), c(!0));
        },
        children: /* @__PURE__ */ _.jsx(xG, {})
      }
    ) }),
    /* @__PURE__ */ _.jsx(Tye, { item: n, info: t, loading: a, opened: l, onClose: () => c(!1) })
  ] });
}
function $ye({ item: e, info: t, opened: r, onClose: n }) {
  const { updateEntry: o } = ir(), { handleSubmit: a, reset: i, setValue: l, formState: c, control: u } = ub({
    mode: "onTouched",
    defaultValues: t.edit.defaultValues,
    resolver: db(t.edit.schema)
  });
  Ue(() => {
    if (e)
      for (const f of t.edit.columns)
        l(f.name, e.result[f.name]);
  }, [e, t.edit.columns, l]), c.dirtyFields;
  const d = async (f) => {
    f = t2(c.dirtyFields, f), await o(e.id, f), i(), n();
  };
  return e ? /* @__PURE__ */ _.jsx(
    Zi,
    {
      opened: r,
      onClose: () => {
        n(), i();
      },
      title: `${t.edit.title}  (#${e == null ? void 0 : e.id})`,
      size: "lg",
      centered: !0,
      children: /* @__PURE__ */ _.jsxs(El, { spacing: "md", children: [
        t.edit.columns.map((f) => /* @__PURE__ */ _.jsx(
          Kb,
          {
            name: f.name,
            control: u,
            label: `${f.label}${f.required ? "*" : ""}`,
            description: f.description,
            schema: f
          },
          f.name
        )),
        /* @__PURE__ */ _.jsx(Rn, { position: "right", mt: "xl", children: /* @__PURE__ */ _.jsx(ji, { onClick: a(d), children: "Save" }) })
      ] })
    }
  ) : null;
}
function Cye({ id: e }) {
  const { info: t, getEntry: r } = ir(), [n, o] = Me(null), [a, i] = Me(!1), [l, c] = Me(!1);
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx(Ba, { label: "Edit", children: /* @__PURE__ */ _.jsx(
      tn,
      {
        size: "sm",
        onClick: async () => {
          i(!0);
          const u = await r(e);
          u && (o(u), i(!1), c(!0));
        },
        children: /* @__PURE__ */ _.jsx(PG, {})
      }
    ) }),
    /* @__PURE__ */ _.jsx($ye, { item: n, info: t, opened: l, onClose: () => c(!1) })
  ] });
}
function kye({ opened: e, onClose: t, handleAccept: r, handleReject: n }) {
  return /* @__PURE__ */ _.jsxs(
    Zi,
    {
      opened: e,
      onClose: t,
      "aria-labelledby": "alert-dialog-title",
      "aria-describedby": "alert-dialog-description",
      title: "Item lÃ¶schen?",
      centered: !0,
      children: [
        "Sind Sie Sicher, dass Sie das Item lÃ¶schen wollen?",
        /* @__PURE__ */ _.jsxs(Rn, { position: "right", mt: "xl", children: [
          /* @__PURE__ */ _.jsx(ji, { onClick: n, variant: "default", children: "Abbrechen" }),
          /* @__PURE__ */ _.jsx(ji, { onClick: r, color: "red", children: "LÃ¶schen" })
        ] })
      ]
    }
  );
}
function Rye({ id: e }) {
  const { deleteEntry: t } = ir(), [r, n] = Me(!1), o = () => {
    n(!1);
  }, a = async () => {
    t(e), n(!1);
  };
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx(Ba, { label: "Delete", children: /* @__PURE__ */ _.jsx(
      tn,
      {
        size: "sm",
        onClick: () => {
          n(!0);
        },
        children: /* @__PURE__ */ _.jsx(iD, {})
      }
    ) }),
    /* @__PURE__ */ _.jsx(kye, { opened: r, onClose: o, handleAccept: a, handleReject: o })
  ] });
}
function Dye({ id: e, selected: t, rtl: r }) {
  const { info: n } = ir();
  return /* @__PURE__ */ _.jsxs(Rn, { sx: { gap: 4, justifyContent: r ? "flex-end" : void 0 }, spacing: 0, noWrap: !0, children: [
    n.permissions.includes("can_get") ? /* @__PURE__ */ _.jsx(Eye, { id: e }) : null,
    n.permissions.includes("can_put") ? /* @__PURE__ */ _.jsx(Cye, { id: e }) : null,
    n.permissions.includes("can_delete") ? /* @__PURE__ */ _.jsx(Rye, { id: e }) : null
  ] });
}
function Nye({
  settings: e,
  loading: t,
  onSelect: r,
  hideActions: n
}) {
  const { data: o } = ir(), [a, i] = Me(null);
  return /* @__PURE__ */ _.jsx("tbody", { children: o.result.length ? o.result.map((l, c) => {
    const u = o.ids[c];
    return /* @__PURE__ */ _.jsxs(
      hme,
      {
        entry: { ...l, id: u },
        selected: (a == null ? void 0 : a.id) === u,
        hover: e.hover,
        setSelectedItem: i,
        onSelect: r,
        children: [
          n ? null : /* @__PURE__ */ _.jsx(eg, { rtl: e.rtl, rightBorder: e.rightBorder, loading: t, children: /* @__PURE__ */ _.jsx(Dye, { id: o.ids[c], selected: (a == null ? void 0 : a.id) === u, rtl: e.rtl }) }),
          o.list_columns.map((d, f) => /* @__PURE__ */ _.jsx(eg, { rtl: e.rtl, rightBorder: e.rightBorder, loading: t, children: e2(l, d) }, f))
        ]
      },
      c
    );
  }) : /* @__PURE__ */ _.jsx("tr", { children: /* @__PURE__ */ _.jsx(
    "td",
    {
      style: { padding: "8px" },
      colSpan: n ? o.list_columns.length : o.list_columns.length + 1,
      children: /* @__PURE__ */ _.jsx($r, { sx: { fontStyle: "italic" }, size: "sm", color: "dimmed", children: "No data available..." })
    }
  ) }) });
}
function Iye({
  settings: e,
  hideActions: t,
  loading: r,
  onSelect: n
}) {
  const o = fr();
  return /* @__PURE__ */ _.jsx(
    ZM,
    {
      options: { className: o.colorScheme === "dark" ? "os-theme-light" : void 0 },
      style: { flex: 1, flexDirection: "column" },
      children: /* @__PURE__ */ _.jsxs(
        DR,
        {
          verticalSpacing: e.dense ? "xs" : "md",
          horizontalSpacing: e.dense ? "xs" : "md",
          fontSize: e.dense ? "sm" : "md",
          striped: e.striped,
          highlightOnHover: !!n,
          children: [
            /* @__PURE__ */ _.jsx(JM, { settings: e, hideActions: t }),
            /* @__PURE__ */ _.jsx(Nye, { settings: e, loading: r, onSelect: n, hideActions: t })
          ]
        }
      )
    }
  );
}
const Mye = Le("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), ST = Mye, Aye = Le("MuiListItemIcon", ["root", "alignItemsFlexStart"]), TT = Aye, jye = Le("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), ET = jye;
function Fye(e) {
  return ze("MuiMenuItem", e);
}
const Lye = Le("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), Rs = Lye, Vye = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"], zye = (e, t) => {
  const {
    ownerState: r
  } = e;
  return [t.root, r.dense && t.dense, r.divider && t.divider, !r.disableGutters && t.gutters];
}, Bye = (e) => {
  const {
    disabled: t,
    dense: r,
    divider: n,
    disableGutters: o,
    selected: a,
    classes: i
  } = e, c = Ve({
    root: ["root", r && "dense", t && "disabled", !o && "gutters", n && "divider", a && "selected"]
  }, Fye, i);
  return T({}, i, c);
}, Wye = ce(bo, {
  shouldForwardProp: (e) => to(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: zye
})(({
  theme: e,
  ownerState: t
}) => T({}, e.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !t.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, t.divider && {
  borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${Rs.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : dt(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${Rs.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : dt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${Rs.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : dt(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : dt(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${Rs.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${Rs.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${ST.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${ST.inset}`]: {
    marginLeft: 52
  },
  [`& .${ET.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${ET.inset}`]: {
    paddingLeft: 36
  },
  [`& .${TT.root}`]: {
    minWidth: 36
  }
}, !t.dense && {
  [e.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, t.dense && T({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, e.typography.body2, {
  [`& .${TT.root} svg`]: {
    fontSize: "1.25rem"
  }
}))), R2 = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: o = !1,
    component: a = "li",
    dense: i = !1,
    divider: l = !1,
    disableGutters: c = !1,
    focusVisibleClassName: u,
    role: d = "menuitem",
    tabIndex: f,
    className: p
  } = n, m = ge(n, Vye), y = P.useContext(Ea), h = P.useMemo(() => ({
    dense: i || y.dense || !1,
    disableGutters: c
  }), [y.dense, i, c]), v = P.useRef(null);
  wr(() => {
    o && (v.current ? v.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [o]);
  const g = T({}, n, {
    dense: h.dense,
    divider: l,
    disableGutters: c
  }), b = Bye(n), x = Lt(v, r);
  let O;
  return n.disabled || (O = f !== void 0 ? f : -1), /* @__PURE__ */ _.jsx(Ea.Provider, {
    value: h,
    children: /* @__PURE__ */ _.jsx(Wye, T({
      ref: x,
      role: d,
      tabIndex: O,
      component: a,
      focusVisibleClassName: Pe(b.focusVisible, u),
      className: Pe(b.root, p)
    }, m, {
      ownerState: g,
      classes: b
    }))
  });
});
process.env.NODE_ENV !== "production" && (R2.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: s.bool,
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: s.bool,
  /**
   * @ignore
   */
  disabled: s.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: s.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: s.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: s.string,
  /**
   * @ignore
   */
  role: s.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * @default 0
   */
  tabIndex: s.number
});
const Uye = R2, $T = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage"), CT = qr(/* @__PURE__ */ _.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage"), D2 = /* @__PURE__ */ P.createContext();
process.env.NODE_ENV !== "production" && (D2.displayName = "TableContext");
const Hye = D2, N2 = /* @__PURE__ */ P.createContext();
process.env.NODE_ENV !== "production" && (N2.displayName = "Tablelvl2Context");
const Yye = N2;
function qye(e) {
  return ze("MuiTableCell", e);
}
const Gye = Le("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), Kye = Gye, Xye = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"], Qye = (e) => {
  const {
    classes: t,
    variant: r,
    align: n,
    padding: o,
    size: a,
    stickyHeader: i
  } = e, l = {
    root: ["root", r, i && "stickyHeader", n !== "inherit" && `align${Te(n)}`, o !== "normal" && `padding${Te(o)}`, `size${Te(a)}`]
  };
  return Ve(l, qye, t);
}, Zye = ce("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, t[r.variant], t[`size${Te(r.size)}`], r.padding !== "normal" && t[`padding${Te(r.padding)}`], r.align !== "inherit" && t[`align${Te(r.align)}`], r.stickyHeader && t.stickyHeader];
  }
})(({
  theme: e,
  ownerState: t
}) => T({}, e.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? wE(dt(e.palette.divider, 1), 0.88) : bE(dt(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, t.variant === "head" && {
  color: (e.vars || e).palette.text.primary,
  lineHeight: e.typography.pxToRem(24),
  fontWeight: e.typography.fontWeightMedium
}, t.variant === "body" && {
  color: (e.vars || e).palette.text.primary
}, t.variant === "footer" && {
  color: (e.vars || e).palette.text.secondary,
  lineHeight: e.typography.pxToRem(21),
  fontSize: e.typography.pxToRem(12)
}, t.size === "small" && {
  padding: "6px 16px",
  [`&.${Kye.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, t.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, t.padding === "none" && {
  padding: 0
}, t.align === "left" && {
  textAlign: "left"
}, t.align === "center" && {
  textAlign: "center"
}, t.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, t.align === "justify" && {
  textAlign: "justify"
}, t.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (e.vars || e).palette.background.default
})), I2 = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTableCell"
  }), {
    align: o = "inherit",
    className: a,
    component: i,
    padding: l,
    scope: c,
    size: u,
    sortDirection: d,
    variant: f
  } = n, p = ge(n, Xye), m = P.useContext(Hye), y = P.useContext(Yye), h = y && y.variant === "head";
  let v;
  i ? v = i : v = h ? "th" : "td";
  let g = c;
  v === "td" ? g = void 0 : !g && h && (g = "col");
  const b = f || y && y.variant, x = T({}, n, {
    align: o,
    component: v,
    padding: l || (m && m.padding ? m.padding : "normal"),
    size: u || (m && m.size ? m.size : "medium"),
    sortDirection: d,
    stickyHeader: b === "head" && m && m.stickyHeader,
    variant: b
  }), O = Qye(x);
  let w = null;
  return d && (w = d === "asc" ? "ascending" : "descending"), /* @__PURE__ */ _.jsx(Zye, T({
    as: v,
    ref: r,
    className: Pe(O.root, a),
    "aria-sort": w,
    scope: g,
    ownerState: x
  }, p));
});
process.env.NODE_ENV !== "production" && (I2.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the table cell content.
   *
   * Monetary or generally number fields **should be right aligned** as that allows
   * you to add them up quickly in your head without having to worry about decimals.
   * @default 'inherit'
   */
  align: s.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * Sets the padding applied to the cell.
   * The prop defaults to the value (`'default'`) inherited from the parent Table component.
   */
  padding: s.oneOf(["checkbox", "none", "normal"]),
  /**
   * Set scope attribute.
   */
  scope: s.string,
  /**
   * Specify the size of the cell.
   * The prop defaults to the value (`'medium'`) inherited from the parent Table component.
   */
  size: s.oneOfType([s.oneOf(["medium", "small"]), s.string]),
  /**
   * Set aria-sort direction.
   */
  sortDirection: s.oneOf(["asc", "desc", !1]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * Specify the cell type.
   * The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components.
   */
  variant: s.oneOfType([s.oneOf(["body", "footer", "head"]), s.string])
});
const tg = I2;
function Jye(e) {
  return ze("MuiToolbar", e);
}
Le("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const eve = ["className", "component", "disableGutters", "variant"], tve = (e) => {
  const {
    classes: t,
    disableGutters: r,
    variant: n
  } = e;
  return Ve({
    root: ["root", !r && "gutters", n]
  }, Jye, t);
}, rve = ce("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: r
    } = e;
    return [t.root, !r.disableGutters && t.gutters, t[r.variant]];
  }
})(({
  theme: e,
  ownerState: t
}) => T({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !t.disableGutters && {
  paddingLeft: e.spacing(2),
  paddingRight: e.spacing(2),
  [e.breakpoints.up("sm")]: {
    paddingLeft: e.spacing(3),
    paddingRight: e.spacing(3)
  }
}, t.variant === "dense" && {
  minHeight: 48
}), ({
  theme: e,
  ownerState: t
}) => t.variant === "regular" && e.mixins.toolbar), M2 = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiToolbar"
  }), {
    className: o,
    component: a = "div",
    disableGutters: i = !1,
    variant: l = "regular"
  } = n, c = ge(n, eve), u = T({}, n, {
    component: a,
    disableGutters: i,
    variant: l
  }), d = tve(u);
  return /* @__PURE__ */ _.jsx(rve, T({
    as: a,
    className: Pe(d.root, o),
    ref: r,
    ownerState: u
  }, c));
});
process.env.NODE_ENV !== "production" && (M2.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The Toolbar children, usually a mixture of `IconButton`, `Button` and `Typography`.
   * The Toolbar is a flex container, allowing flex item properites to be used to lay out the children.
   */
  children: s.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * If `true`, disables gutter padding.
   * @default false
   */
  disableGutters: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object]),
  /**
   * The variant to use.
   * @default 'regular'
   */
  variant: s.oneOfType([s.oneOf(["dense", "regular"]), s.string])
});
const nve = M2;
var kT, RT, DT, NT, IT, MT, AT, jT;
const ove = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"], A2 = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const {
    backIconButtonProps: n,
    count: o,
    getItemAriaLabel: a,
    nextIconButtonProps: i,
    onPageChange: l,
    page: c,
    rowsPerPage: u,
    showFirstButton: d,
    showLastButton: f
  } = t, p = ge(t, ove), m = Nr(), y = (b) => {
    l(b, 0);
  }, h = (b) => {
    l(b, c - 1);
  }, v = (b) => {
    l(b, c + 1);
  }, g = (b) => {
    l(b, Math.max(0, Math.ceil(o / u) - 1));
  };
  return /* @__PURE__ */ _.jsxs("div", T({
    ref: r
  }, p, {
    children: [d && /* @__PURE__ */ _.jsx(co, {
      onClick: y,
      disabled: c === 0,
      "aria-label": a("first", c),
      title: a("first", c),
      children: m.direction === "rtl" ? kT || (kT = /* @__PURE__ */ _.jsx(CT, {})) : RT || (RT = /* @__PURE__ */ _.jsx($T, {}))
    }), /* @__PURE__ */ _.jsx(co, T({
      onClick: h,
      disabled: c === 0,
      color: "inherit",
      "aria-label": a("previous", c),
      title: a("previous", c)
    }, n, {
      children: m.direction === "rtl" ? DT || (DT = /* @__PURE__ */ _.jsx(Lv, {})) : NT || (NT = /* @__PURE__ */ _.jsx(Fv, {}))
    })), /* @__PURE__ */ _.jsx(co, T({
      onClick: v,
      disabled: o !== -1 ? c >= Math.ceil(o / u) - 1 : !1,
      color: "inherit",
      "aria-label": a("next", c),
      title: a("next", c)
    }, i, {
      children: m.direction === "rtl" ? IT || (IT = /* @__PURE__ */ _.jsx(Fv, {})) : MT || (MT = /* @__PURE__ */ _.jsx(Lv, {}))
    })), f && /* @__PURE__ */ _.jsx(co, {
      onClick: g,
      disabled: c >= Math.ceil(o / u) - 1,
      "aria-label": a("last", c),
      title: a("last", c),
      children: m.direction === "rtl" ? AT || (AT = /* @__PURE__ */ _.jsx($T, {})) : jT || (jT = /* @__PURE__ */ _.jsx(CT, {}))
    })]
  }));
});
process.env.NODE_ENV !== "production" && (A2.propTypes = {
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  backIconButtonProps: s.object,
  /**
   * The total number of rows.
   */
  count: s.number.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   *
   * @param {string} type The link or button type to format ('page' | 'first' | 'last' | 'next' | 'previous'). Defaults to 'page'.
   * @param {number} page The page number to format.
   * @returns {string}
   */
  getItemAriaLabel: s.func.isRequired,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: s.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {object} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: s.func.isRequired,
  /**
   * The zero-based index of the current page.
   */
  page: s.number.isRequired,
  /**
   * The number of rows per page.
   */
  rowsPerPage: s.number.isRequired,
  /**
   * If `true`, show the first-page button.
   */
  showFirstButton: s.bool.isRequired,
  /**
   * If `true`, show the last-page button.
   */
  showLastButton: s.bool.isRequired
});
const ave = A2;
function ive(e) {
  return ze("MuiTablePagination", e);
}
const sve = Le("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]), Zs = sve;
var FT;
const lve = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"], cve = ce(tg, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})(({
  theme: e
}) => ({
  overflow: "auto",
  color: (e.vars || e).palette.text.primary,
  fontSize: e.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
})), uve = ce(nve, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (e, t) => T({
    [`& .${Zs.actions}`]: t.actions
  }, t.toolbar)
})(({
  theme: e
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${e.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [e.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${Zs.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
})), dve = ce("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (e, t) => t.spacer
})({
  flex: "1 1 100%"
}), fve = ce("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (e, t) => t.selectLabel
})(({
  theme: e
}) => T({}, e.typography.body2, {
  flexShrink: 0
})), pve = ce(XI, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (e, t) => T({
    [`& .${Zs.selectIcon}`]: t.selectIcon,
    [`& .${Zs.select}`]: t.select
  }, t.input, t.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${Zs.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
}), mve = ce(Uye, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (e, t) => t.menuItem
})({}), hve = ce("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (e, t) => t.displayedRows
})(({
  theme: e
}) => T({}, e.typography.body2, {
  flexShrink: 0
}));
function yve({
  from: e,
  to: t,
  count: r
}) {
  return `${e}â€“${t} of ${r !== -1 ? r : `more than ${t}`}`;
}
function vve(e) {
  return `Go to ${e} page`;
}
const gve = (e) => {
  const {
    classes: t
  } = e;
  return Ve({
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  }, ive, t);
}, j2 = /* @__PURE__ */ P.forwardRef(function(t, r) {
  const n = Ae({
    props: t,
    name: "MuiTablePagination"
  }), {
    ActionsComponent: o = ave,
    backIconButtonProps: a,
    className: i,
    colSpan: l,
    component: c = tg,
    count: u,
    getItemAriaLabel: d = vve,
    labelDisplayedRows: f = yve,
    labelRowsPerPage: p = "Rows per page:",
    nextIconButtonProps: m,
    onPageChange: y,
    onRowsPerPageChange: h,
    page: v,
    rowsPerPage: g,
    rowsPerPageOptions: b = [10, 25, 50, 100],
    SelectProps: x = {},
    showFirstButton: O = !1,
    showLastButton: w = !1
  } = n, S = ge(n, lve), E = n, C = gve(E), N = x.native ? "option" : mve;
  let $;
  (c === tg || c === "td") && ($ = l || 1e3);
  const j = Ri(x.id), A = Ri(x.labelId), k = () => u === -1 ? (v + 1) * g : g === -1 ? u : Math.min(u, (v + 1) * g);
  return /* @__PURE__ */ _.jsx(cve, T({
    colSpan: $,
    ref: r,
    as: c,
    ownerState: E,
    className: Pe(C.root, i)
  }, S, {
    children: /* @__PURE__ */ _.jsxs(uve, {
      className: C.toolbar,
      children: [/* @__PURE__ */ _.jsx(dve, {
        className: C.spacer
      }), b.length > 1 && /* @__PURE__ */ _.jsx(fve, {
        className: C.selectLabel,
        id: A,
        children: p
      }), b.length > 1 && /* @__PURE__ */ _.jsx(pve, T({
        variant: "standard"
      }, !x.variant && {
        input: FT || (FT = /* @__PURE__ */ _.jsx(om, {}))
      }, {
        value: g,
        onChange: h,
        id: j,
        labelId: A
      }, x, {
        classes: T({}, x.classes, {
          // TODO v5 remove `classes.input`
          root: Pe(C.input, C.selectRoot, (x.classes || {}).root),
          select: Pe(C.select, (x.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: Pe(C.selectIcon, (x.classes || {}).icon)
        }),
        children: b.map((R) => /* @__PURE__ */ et(N, T({}, !Ia(N) && {
          ownerState: E
        }, {
          className: C.menuItem,
          key: R.label ? R.label : R,
          value: R.value ? R.value : R
        }), R.label ? R.label : R))
      })), /* @__PURE__ */ _.jsx(hve, {
        className: C.displayedRows,
        children: f({
          from: u === 0 ? 0 : v * g + 1,
          to: k(),
          count: u === -1 ? -1 : u,
          page: v
        })
      }), /* @__PURE__ */ _.jsx(o, {
        className: C.actions,
        backIconButtonProps: a,
        count: u,
        nextIconButtonProps: m,
        onPageChange: y,
        page: v,
        rowsPerPage: g,
        showFirstButton: O,
        showLastButton: w,
        getItemAriaLabel: d
      })]
    })
  }));
});
process.env.NODE_ENV !== "production" && (j2.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The component used for displaying the actions.
   * Either a string to use a HTML element or a component.
   * @default TablePaginationActions
   */
  ActionsComponent: s.elementType,
  /**
   * Props applied to the back arrow [`IconButton`](/material-ui/api/icon-button/) component.
   */
  backIconButtonProps: s.object,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: s.object,
  /**
   * @ignore
   */
  className: s.string,
  /**
   * @ignore
   */
  colSpan: s.number,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: s.elementType,
  /**
   * The total number of rows.
   *
   * To enable server side pagination for an unknown number of items, provide -1.
   */
  count: js.isRequired,
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current page.
   * This is important for screen reader users.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @param {string} type The link or button type to format ('first' | 'last' | 'next' | 'previous').
   * @returns {string}
   * @default function defaultGetAriaLabel(type) {
   *   return `Go to ${type} page`;
   * }
   */
  getItemAriaLabel: s.func,
  /**
   * Customize the displayed rows label. Invoked with a `{ from, to, count, page }`
   * object.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default function defaultLabelDisplayedRows({ from, to, count }) {
   *   return `${from}â€“${to} of ${count !== -1 ? count : `more than ${to}`}`;
   * }
   */
  labelDisplayedRows: s.func,
  /**
   * Customize the rows per page label.
   *
   * For localization purposes, you can use the provided [translations](/material-ui/guides/localization/).
   * @default 'Rows per page:'
   */
  labelRowsPerPage: s.node,
  /**
   * Props applied to the next arrow [`IconButton`](/material-ui/api/icon-button/) element.
   */
  nextIconButtonProps: s.object,
  /**
   * Callback fired when the page is changed.
   *
   * @param {React.MouseEvent<HTMLButtonElement> | null} event The event source of the callback.
   * @param {number} page The page selected.
   */
  onPageChange: s.func.isRequired,
  /**
   * Callback fired when the number of rows per page is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   */
  onRowsPerPageChange: s.func,
  /**
   * The zero-based index of the current page.
   */
  page: xo(js.isRequired, (e) => {
    const {
      count: t,
      page: r,
      rowsPerPage: n
    } = e;
    if (t === -1)
      return null;
    const o = Math.max(0, Math.ceil(t / n) - 1);
    return r < 0 || r > o ? new Error(`MUI: The page prop of a TablePagination is out of range (0 to ${o}, but page is ${r}).`) : null;
  }),
  /**
   * The number of rows per page.
   *
   * Set -1 to display all the rows.
   */
  rowsPerPage: js.isRequired,
  /**
   * Customizes the options of the rows per page select field. If less than two options are
   * available, no select field will be displayed.
   * Use -1 for the value with a custom label to show all the rows.
   * @default [10, 25, 50, 100]
   */
  rowsPerPageOptions: s.arrayOf(s.oneOfType([s.number, s.shape({
    label: s.string.isRequired,
    value: s.number.isRequired
  })]).isRequired),
  /**
   * Props applied to the rows per page [`Select`](/material-ui/api/select/) element.
   * @default {}
   */
  SelectProps: s.object,
  /**
   * If `true`, show the first-page button.
   * @default false
   */
  showFirstButton: s.bool,
  /**
   * If `true`, show the last-page button.
   * @default false
   */
  showLastButton: s.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: s.oneOfType([s.arrayOf(s.oneOfType([s.func, s.object, s.bool])), s.func, s.object])
});
const bve = j2;
function wve(e) {
  const { count: t, page: r, rowsPerPage: n, onPageChange: o } = e, a = (u) => {
    o(u, 0);
  }, i = (u) => {
    o(u, r - 1);
  }, l = (u) => {
    o(u, r + 1);
  }, c = (u) => {
    o(u, Math.max(0, Math.ceil(t / n) - 1));
  };
  return /* @__PURE__ */ _.jsxs(Rn, { ml: "sm", noWrap: !0, children: [
    /* @__PURE__ */ _.jsx(tn, { onClick: a, disabled: r === 0, "aria-label": "first page", children: /* @__PURE__ */ _.jsx(yG, {}) }),
    /* @__PURE__ */ _.jsx(tn, { onClick: i, disabled: r === 0, "aria-label": "previous page", children: /* @__PURE__ */ _.jsx(gG, {}) }),
    /* @__PURE__ */ _.jsx(
      tn,
      {
        onClick: l,
        disabled: r >= Math.ceil(t / n) - 1,
        "aria-label": "next page",
        children: /* @__PURE__ */ _.jsx(bG, {})
      }
    ),
    /* @__PURE__ */ _.jsx(
      tn,
      {
        onClick: c,
        disabled: r >= Math.ceil(t / n) - 1,
        "aria-label": "last page",
        children: /* @__PURE__ */ _.jsx(vG, {})
      }
    )
  ] });
}
const F2 = Jf(({ ...e }) => {
  const { data: t, queryParams: r, setQueryParams: n } = ir(), o = [10, 25, 50], a = r.page_size, [i, l] = Me(r.page), c = fn(
    () => ki((f) => {
      n({ page: f });
    }, 550),
    [n]
  );
  Ue(() => {
    l(r.page);
  }, [r.page]);
  const u = (f, p) => {
    l(p), c(p);
  }, d = (f) => {
    n({ page_size: parseInt(f.target.value, 10) });
  };
  return /* @__PURE__ */ _.jsx(
    Ke,
    {
      sx: (f) => ({
        flex: "0 1 0",
        height: 54,
        border: "none",
        borderTopWidth: "1px",
        borderTopStyle: "solid",
        borderColor: f.colors.gray[4]
      }),
      children: /* @__PURE__ */ _.jsx(
        bve,
        {
          sx: {
            color: "inherit",
            "& .MuiSvgIcon-root": {
              color: "inherit"
            }
          },
          rowsPerPageOptions: o,
          component: "div",
          count: t.count,
          rowsPerPage: a,
          page: i,
          onPageChange: u,
          onRowsPerPageChange: d,
          ActionsComponent: wve,
          ...e
        }
      )
    }
  );
});
F2.displayName = "Pagination";
function xve() {
  const { error: e } = ir(), [t, r] = Me(!1);
  return Ue(() => {
    e && r(!0);
  }, [e]), /* @__PURE__ */ _.jsx(
    Zi,
    {
      opened: t,
      onClose: () => r(!1),
      title: /* @__PURE__ */ _.jsxs(Rn, { children: [
        /* @__PURE__ */ _.jsx(mG, { size: 16, color: "red" }),
        /* @__PURE__ */ _.jsx($r, { children: e ? e.originalError.message : "Error" })
      ] }),
      centered: !0,
      children: e ? /* @__PURE__ */ _.jsx($r, { children: e.message }) : null
    }
  );
}
const Dve = {
  root: "Root element",
  toolbar: "Main control",
  body: "Track element, contains all other elements",
  pagination: "Filled part of the track",
  header: "DataGrid header, contains titles"
}, _ve = Qe(() => ({
  root: {},
  toolbar: {
    display: "flex",
    boxSizing: "border-box"
  },
  body: {
    flex: 1,
    width: "100vw",
    boxSizing: "border-box"
  },
  pagination: {
    flex: 1,
    width: "100vw",
    boxSizing: "border-box"
  }
})), Ove = {
  settings: {
    rtl: !1,
    dense: !1,
    striped: !1,
    rightBorder: !1,
    hover: !1
  }
};
function Pve(e, t) {
  switch (t.type) {
    case "setSettings":
      return { ...e, settings: t.payload };
    default:
      throw new Error();
  }
}
const L2 = Ne((e, t) => {
  const { path: r, data: n, loading: o, info: a, setQueryParams: i } = ir(), {
    hideToolbar: l = !1,
    hideFilter: c = !1,
    hideSettings: u = !1,
    hideActions: d = !1,
    settings: f = null,
    sx: p = null,
    onSelectEntry: m = null,
    fetchOnMount: y = !0,
    styles: h
  } = e, v = `${r}-datagrid`, { classes: g, cx: b, theme: x } = _ve(), [O, w] = hl(Pve, {
    ...Ove,
    settings: JSON.parse(localStorage.getItem(v)) || {
      rtl: (f == null ? void 0 : f.rtl) ?? !1,
      dense: (f == null ? void 0 : f.dense) ?? !1,
      striped: (f == null ? void 0 : f.striped) ?? !1,
      rightBorder: (f == null ? void 0 : f.rightBorder) ?? !1,
      hover: (f == null ? void 0 : f.hover) ?? !1
    }
  });
  return Ue(() => {
    !n && y && i({});
  }, [n]), Ue(() => {
    O.settings && localStorage.setItem(v, JSON.stringify(O.settings));
  }, [O.settings]), /* @__PURE__ */ _.jsxs(
    ud,
    {
      ref: t,
      className: g.root,
      sx: { position: "relative", height: "100%", display: "flex", flexDirection: "column", ...p },
      children: [
        /* @__PURE__ */ _.jsx(
          zg,
          {
            loaderProps: { size: "sm", variant: "dots" },
            overlayOpacity: 0.1,
            overlayColor: "#c5c5c5",
            visible: o
          }
        ),
        a && n && !o && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
          l ? null : /* @__PURE__ */ _.jsx(
            OM,
            {
              settings: O.settings,
              dispatch: w,
              hideFilter: c,
              hideSettings: u,
              dense: O.settings.dense
            }
          ),
          /* @__PURE__ */ _.jsx(Iye, { settings: O.settings, hideActions: d, loading: o, onSelect: m }),
          /* @__PURE__ */ _.jsx(F2, {})
        ] }),
        /* @__PURE__ */ _.jsx(xve, {})
      ]
    }
  );
});
L2.displayName = "DataGrid";
function Nve({ name: e, ...t }) {
  const { info: r, queryParams: n, setQueryParams: o } = ir(), [a, i] = Me(), [l, c] = Me();
  return Ue(() => {
    if (r) {
      const u = r.quickfilters.find((d) => d.name === e);
      i(u);
    }
  }, [r]), Ue(() => {
    var u;
    if (n) {
      const d = (u = n == null ? void 0 : n.filters) == null ? void 0 : u.find(
        (f) => f.col === a.column && f.opr === "in"
      );
      c(d);
    }
  }, [n]), a ? /* @__PURE__ */ _.jsx(
    vd.Group,
    {
      value: l && typeof l.value == "string" ? JSON.parse(l.value) : [],
      label: a.label,
      onChange: (u) => {
        var f;
        const d = (f = n.filters) == null ? void 0 : f.filter((p) => p !== l);
        o({
          ...n,
          filters: [...d, { col: a.column, opr: "in", value: JSON.stringify(u) }]
        });
      },
      ...t,
      children: a.options.map((u) => /* @__PURE__ */ _.jsx(vd, { value: u.value, label: u.label }, u.value))
    }
  ) : null;
}
function Ive({ name: e, ...t }) {
  const { info: r, queryParams: n, setQueryParams: o } = ir(), [a, i] = Me(), [l, c] = Me();
  return Ue(() => {
    if (r) {
      const u = r.quickfilters.find((d) => d.name === e);
      i(u);
    }
  }, [r]), Ue(() => {
    var u;
    if (n) {
      const d = (u = n == null ? void 0 : n.filters) == null ? void 0 : u.find(
        (f) => f.col === a.column && f.opr === "in"
      );
      c(d);
    }
  }, [n]), a ? /* @__PURE__ */ _.jsx(
    Np,
    {
      value: l && typeof l.value == "string" ? JSON.parse(l.value) : [],
      label: a.label,
      onChange: (u) => {
        var f;
        const d = (f = n.filters) == null ? void 0 : f.filter((p) => p !== l);
        o({
          ...n,
          filters: [...d, { col: a.column, opr: "in", value: JSON.stringify(u) }]
        });
      },
      ...t,
      data: a.options
    }
  ) : null;
}
function Mve({ name: e, ...t }) {
  const { info: r, queryParams: n, setQueryParams: o } = ir(), [a, i] = Me(), [l, c] = Me();
  return Ue(() => {
    if (r) {
      const u = r.quickfilters.find((d) => d.name === e);
      i(u);
    }
  }, [r]), Ue(() => {
    var u;
    if (n) {
      const d = (u = n == null ? void 0 : n.filters) == null ? void 0 : u.find(
        (f) => f.col === a.column && f.opr === "eq"
      );
      c(d);
    }
  }, [n]), a ? /* @__PURE__ */ _.jsx(
    Ji,
    {
      value: l && typeof l.value == "string" ? l.value : [],
      label: a.label,
      onChange: (u) => {
        var f;
        const d = (f = n.filters) == null ? void 0 : f.filter((p) => p !== l);
        o({
          ...n,
          filters: [...d, { col: a.column, opr: "eq", value: u }]
        });
      },
      ...t,
      data: a.options
    }
  ) : null;
}
const Sve = Qe((e) => ({
  user: {
    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
    padding: `${e.spacing.xs}px ${e.spacing.sm}px`,
    borderRadius: e.radius.sm,
    transition: "background-color 100ms ease",
    "&:hover": {
      backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[1]
    }
  },
  userActive: {
    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[1]
  }
}));
function Ave({ basePath: e = "/security", Target: t, children: r }) {
  const n = U2(), { user: o, signout: a } = nq(), { classes: i, cx: l } = Sve(), [c, u] = Me(!1), f = [
    { path: e + "/users", label: "Users", name: "UsersApi", Icon: EG },
    { path: e + "/roles", label: "Roles", name: "RolesApi", Icon: _G },
    { path: e + "/permissions", label: "Base Permissions", name: "PermissionsApi", Icon: tP },
    { path: e + "/permissionviews", label: "Permission on Views", name: "PermissionViewApi", Icon: tP },
    { path: e + "/viewsmenus", label: "Views/Menus", name: "ViewsMenusApi", Icon: hG }
  ].filter((p) => o.permissions.includes(p.name));
  return /* @__PURE__ */ _.jsxs(
    Bt,
    {
      width: 260,
      position: "bottom-end",
      transition: "pop-top-right",
      opened: c,
      onClose: () => u(!1),
      onOpen: () => u(!0),
      children: [
        /* @__PURE__ */ _.jsx(Bt.Target, { children: t || /* @__PURE__ */ _.jsx(Op, { className: l(i.user, { [i.userActive]: c }), children: /* @__PURE__ */ _.jsxs(Rn, { sx: { flexWrap: "nowrap" }, spacing: 7, children: [
          /* @__PURE__ */ _.jsx($r, { weight: 500, size: "sm", sx: { lineHeight: 1, whiteSpace: "nowrap" }, mr: 3, children: `${o.first_name} ${o.last_name}` }),
          /* @__PURE__ */ _.jsx(uy, { size: 12 })
        ] }) }) }),
        /* @__PURE__ */ _.jsxs(Bt.Dropdown, { children: [
          f.length ? /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
            /* @__PURE__ */ _.jsx(Bt.Label, { children: "Security" }),
            f.map((p, m) => /* @__PURE__ */ _.jsx(Bt.Item, { icon: /* @__PURE__ */ _.jsx(p.Icon, { size: 16 }), onClick: () => n(p.path), children: p.label }, m)),
            /* @__PURE__ */ _.jsx(Bt.Divider, {})
          ] }) : null,
          r,
          /* @__PURE__ */ _.jsx(Bt.Item, { icon: /* @__PURE__ */ _.jsx(OG, { size: 14 }), onClick: a, children: "Logout" })
        ] })
      ]
    }
  );
}
export {
  Nve as CheckboxGroup,
  L2 as DataGrid,
  Dve as DataGridStyles,
  Ive as MultiSelect,
  iG as SeidrApiProvider,
  Rve as SeidrProvider,
  Mve as Select,
  Ave as UserMenu,
  ir as useApi,
  nq as useSeidrAuth,
  oq as useSeidrInfo,
  kve as useSeidrTheme
};
